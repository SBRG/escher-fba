{"version":3,"sources":["..\\63277e3f81178526c235.worker.js","..\\webpack\\bootstrap 63277e3f81178526c235","..\\node_modules\\webpack\\buildin\\global.js","..\\node_modules\\@just-boris\\preact-scripts\\node_modules\\babel-runtime\\regenerator\\index.js","COBRA.js","COBRA.worker.js","..\\node_modules\\glpk.js\\dist\\glpk.js","..\\node_modules\\regenerator-runtime\\runtime-module.js","..\\node_modules\\regenerator-runtime\\runtime.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","g","this","Function","eval","e","window","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","modelFromWorkerData","data","model","Model","reactions","metabolites","genes","id","notes","description","__WEBPACK_IMPORTED_MODULE_0_glpk_js__","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","nRows","nCols","ia","ja","ar","metLookup","lp","forEach","metabolite","rowInd","matInd","reaction","colInd","lower_bound","upper_bound","objective_coefficient","met_id","problem","buildGlpkProblem","smcp","presolve","returnCode","f","x","console","log","Solution","objectiveValue","fluxes","_asyncToGenerator","fn","gen","apply","arguments","Promise","resolve","reject","step","arg","info","error","done","then","err","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default","__WEBPACK_IMPORTED_MODULE_1__COBRA_js__","_this","onmessage","_ref","a","mark","_callee","message","solution","wrap","_context","prev","next","optimize","sent","postMessage","stop","_x","xassert","test","Error","xerror","xcopyObj","dest","src","prop","xcopyArr","destFrom","srcFrom","count","xfillArr","xfillObjArr","xtime","Date","getTime","xdifftime","to","from","xqsort","base","idx","num","compar","tmp","Array","sort","get_env_ptr","global_env","isspace","indexOf","iscntrl","code","charCodeAt","isalpha","isalnum","isdigit","strchr","str","tolower","toLowerCase","sprintf","regex","format","pad","len","chr","leftJustify","padding","join","justify","prefix","minWidth","zeroPad","customPadChar","diff","slice","formatBaseX","precision","number","2","8","16","toString","formatString","doFormat","substring","valueIndex","flags","_","type","method","textTransform","positivePrefix","prefixBaseX","flagsl","j","charAt","isFinite","undefined","String","fromCharCode","toUpperCase","Math","round","abs","replace","create_prob","magic","GLP_PROB_MAGIC","parms","tree","obj","dir","GLP_MIN","c0","m_max","n_max","nnz","row","col","r_tree","c_tree","valid","head","Int32Array","bfcp","bfd","pbs_stat","dbs_stat","GLP_UNDEF","obj_val","it_cnt","some","ipt_stat","ipt_obj","mip_stat","mip_obj","delete_prob","copy_bfcp","parm","glp_get_bfcp","bfd_set_parm","_glp_analyze_row","P","ind","val","rhs","eps","callback","t","k","piv","dx","y","dy","dz","ret","GLP_FEAS","stat","GLP_BS","prim","GLP_LO","GLP_UP","glp_dual_rtest","dual","glp_ios_pool_size","reason","GLP_ICUTGEN","local","size","glp_ios_add_row","klass","ios_add_row","glp_ios_can_branch","mip","non_int","glp_ios_heur_sol","orig_m","kind","GLP_IV","floor","coef","GLP_MAX","msg_lev","GLP_MSG_ON","xprintf","mipx","aij","ptr","r_next","avl_create_tree","fcmp","root","height","avl_insert_node","q","r","flag","left","rank","right","link","up","bal","rotate_subtree","avl_set_node_link","node","avl_find_node","avl_get_node_link","bfd_create_it","GLP_BF_FT","fhv","lpf","lu_size","piv_tol","piv_lim","suhl","eps_tol","max_gro","nfs_max","upd_tol","nrs_max","rs_size","upd_lim","upd_cnt","bfd_factorize","bh","luf","nov","M_MAX","fhv_create_it","GLP_BF_BG","GLP_BF_GR","lpf_create_it","new_sva","hh_max","v_size","fhv_factorize","FHV_ESING","BFD_ESING","FHV_ECOND","BFD_ECOND","lpf_factorize","scf","t_opt","SCF_TBG","SCF_TGR","LPF_ESING","LPF_ECOND","bfd_ftran","fhv_ftran","lpf_ftran","bfd_btran","fhv_btran","lpf_btran","bfd_update_it","fhv_update_it","FHV_ECHECK","BFD_ECHECK","FHV_ELIMIT","BFD_ELIMIT","FHV_EROOM","BFD_EROOM","lpf_update_it","LPF_ELIMIT","bfd_get_count","check_parm","func","luf_create_it","hh_nfs","hh_ind","hh_ptr","hh_len","p0_row","p0_col","cc_ind","cc_val","nnz_h","Float64Array","luf_factorize","LUF_ESING","LUF_ECOND","pp_row","pp_col","fhv_h_solve","tr","beg","end","temp","nfs","sv_ind","sv_val","luf_f_solve","luf_v_solve","i_beg","i_end","i_ptr","j_beg","j_end","j_ptr","k1","k2","p_beg","p_end","p_ptr","vr_ptr","vr_len","vr_cap","vr_piv","vc_ptr","vc_len","vc_cap","qq_row","qq_col","work","nnz_v","luf_enlarge_row","sv_size","luf_enlarge_col","sv_end","sv_beg","luf_defrag_sva","glp_adv_basis","triang","mat","rn","cn","ndx","rs_len","rs_head","rs_prev","rs_next","cs_head","cs_prev","cs_next","ii","jj","rn_inv","cn_inv","diag","doit","typx","LPX_FX","lpx_get_mat_col","lll","lpx_get_num_rows","lpx_get_num_cols","lpx_get_mat_row","lpx_get_col_bnds","lpx_get_row_bnds","glp_std_basis","lb","ub","LPX_FR","tagx","LPX_NF","LPX_LO","LPX_NL","LPX_UP","LPX_NU","LPX_DB","LPX_NS","lpx_get_int_parm","LPX_K_MSGLEV","LPX_BS","lpx_set_row_stat","lpx_set_col_stat","new_node","parent","get_slot","slot","level","b_ptr","s_ptr","r_ptr","solved","lp_obj","DBL_MAX","bound","br_var","br_val","ii_cnt","ii_sum","changed","cb_size","tail","a_cnt","n_cnt","t_cnt","avail","nslots","save","ios_create_tree","orig_type","Int8Array","orig_lb","orig_ub","orig_stat","orig_prim","orig_dual","orig_obj","root_m","root_type","root_lb","root_ub","root_stat","curr","pred_m","pred_max","pred_type","pred_lb","pred_ub","pred_stat","ios_create_pool","mir_gen","clq_gen","pcost","iwrk","dwrk","tm_beg","tm_lag","sol_cnt","reopt","reinv","br_sel","child","next_p","ios_revive_node","b","new_size","glp_set_row_bnds","glp_set_col_bnds","glp_set_row_stat","glp_set_col_stat","glp_add_rows","glp_set_row_name","origin","glp_set_mat_row","glp_set_rii","rii","ios_freeze_node","glp_get_row_name","glp_get_mat_row","nrs","glp_del_rows","ios_clone_node","nnn","ref","ios_delete_node","ios_delete_tree","ios_delete_pool","ios_eval_degrad","kase","alfa","beta","gamma","delta","dn","glp_get_status","GLP_OPT","glp_bf_exists","lpx_eval_tab_row","lpx_dual_ratio_test","GLP_NL","GLP_NU","GLP_NF","ceil","ios_round_bound","nn","h","GLP_FX","INT_MAX","gcdn","ios_is_hopeful","tol_obj","ios_best_node","best","ios_solve_node","SMCP","GLP_MSG_OFF","GLP_MSG_ERR","GLP_MSG_ALL","GLP_MSG_DBG","meth","GLP_DUALP","out_dly","obj_ul","obj_ll","glp_simplex","pool","ord","cut","ios_clear_pool","ios_preprocess_node","max_pass","prepare_row_info","u","j_min","j_max","f_min","f_max","row_implied_bounds","col_implied_bounds","L","U","ilb","iub","ll","uu","check_row_bounds","L_","Lx","U_","Ux","LL","UU","check_col_bounds","lj","uj","t1","t2","check_efficiency","eff","glp_get_row_lb","glp_get_row_ub","glp_get_col_lb","glp_get_col_ub","list","pass","GLP_CV","c_next","glp_get_row_stat","GLP_FR","GLP_DB","ios_driver","T","show_progress","bingo","best_mip","best_bound","rho","rel_gap","ios_relative_gap","Number","toFixed","is_branch_hopeful","display_cut_info","gmi","mir","cov","clq","app","GLP_RF_CUT","GLP_RF_GMI","GLP_RF_MIR","GLP_RF_COV","GLP_RF_CLQ","curr_p","p_stat","d_stat","pred_p","ttt","label","go_to","cb_func","GLP_ISELECT","cb_info","GLP_ESTOP","ios_choose_node","gmi_cuts","GLP_ON","mir_cuts","ios_mir_init","cov_cuts","clq_cuts","ios_clq_init","out_frq","mip_gap","GLP_EMIPGAP","tm_lim","GLP_ETMLIM","GLP_IPREPRO","pp_tech","GLP_PP_NONE","GLP_PP_ROOT","GLP_PP_ALL","GLP_EOBJLL","GLP_EOBJUL","GLP_EFAIL","GLP_NOFEAS","GLP_INFEAS","GLP_IROWGEN","glp_factorize","temp1","temp2","tol_int","GLP_IBINGO","dj","fixed","GLP_IHEUR","fp_heur","ios_feas_pump","max_cuts","added_cuts","ios_gmi_gen","ios_mir_gen","ios_cov_gen","ios_clq_gen","ios_process_cuts","cnt","ios_pcost_update","GLP_IBRANCH","ios_choose_var","dn_type","up_type","dn_bad","up_bad","new_ub","new_lb","dn_bnd","up_bnd","clone","dn_lp","up_lp","GLP_NO_BRNCH","GLP_DN_BRNCH","GLP_UP_BRNCH","next_node","ios_create_vec","v","pos","ios_check_vec","ios_get_vj","ios_set_vj","ios_clear_vec","ios_clean_vec","ios_copy_vec","ios_linear_comb","xj","yj","var_","nv","worka","phi","frac","v1","v2","ksi","phi1","glp_eval_tab_row","GLP_NS","_MIR_DEBUG","skip","isint","vlb","vub","agg_row","MAXAGGR","agg_vec","subst","mod_vec","cut_vec","a1","a2","cmir_sep","alpha","cmir_cmp","cmir_ineq","cset","aa","bb","fail","r_best","vset","d_try","check_agg_row","big","agg_rhs","check_cut_row","cut_rhs","kk","MIR_N","agg_cnt","DBL_EPSILON","d1","d2","MIR_L","MIR_U","mod_rhs","nint","kappa","d_max","lpx_cover_cut","cover2","try_","rmax","MAXTRY","cover3","cover4","nb","newlen","lpx_get_col_type","lpx_get_col_lb","lpx_get_col_kind","LPX_IV","lpx_get_col_ub","ind_k","val_k","lpx_get_col_prim","lpx_eval_row","sum","prob","lpx_get_status","LPX_OPT","lpx_get_row_type","lpx_get_row_ub","lpx_get_row_lb","lpx_create_cog","get_row_lb","get_row_ub","get_col_lb","get_col_ub","is_binary","eval_lf_min","eval_lf_max","probing","lf_min","lf_max","set","vert","orig","cog","ne","CHAR_BIT","lpx_add_cog_edge","lpx_clique_cut","is_edge","dsa","is_edge1","is_edge2","sub","ct","table","weight","l_weight","curr_weight","left_weight","p1","p2","newtable","record","rec_level","rec","clique","wt","card","w","sol","vec","_n","_a","max_wt","max_nwt","wth","used","nwt","timer","br_tech","GLP_BR_FFV","branch_first","GLP_BR_LFV","branch_last","GLP_BR_MFV","branch_mostf","GLP_BR_DTH","branch_drtom","GLP_BR_PCH","ios_pcost_branch","glp_get_col_prim","most","dk","delta_j","delta_k","delta_z","dz_dn","dz_up","dd_dn","dd_up","degrad","glp_get_col_kind","glp_get_row_dual","glp_get_col_stat","glp_get_col_dual","lpx_get_obj_val","ios_pcost_init","csa","dn_cnt","dn_sum","up_cnt","up_sum","psi","eval_degrad","bnd","glp_create_prob","glp_copy_prob","GLP_DUAL","it_lim","GLP_EITLIM","glp_get_prim_stat","glp_get_dual_stat","eval_psi","brnch","jjj","sel","dmax","ni","new_x","nfail","npass","stalling","dist","tol","rand","GLP_OFF","rng_create_rand","rng_uniform","vx","vy","glp_transform_row","dy_","dz_","sqrt","deg","info1","info2","sa","sb","bt_tech","GLP_BT_DFS","GLP_BT_BFS","GLP_BT_BLB","GLP_BT_BPH","gcd","round2n","pow","str2num","isNaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","str2int","jday","ya","dd","jdate","_GLPLPF_DEBUG","m0_max","m0","B","R_ptr","R_len","S_ptr","S_len","P_row","P_col","Q_row","Q_col","v_ptr","v_ind","v_val","work1","work2","scf_create_it","scf_reset_it","r_prod","rt_prod","s_prod","st_prod","check_error","tmax","fg","scf_solve_it","enlarge_sva","z","vw","scf_update_exp","SCF_ESING","SCF_ELIMIT","glp_get_num_rows","glp_get_num_cols","glp_get_row_type","glp_get_col_type","glp_get_mat_col","status","LPX_FEAS","LPX_INFEAS","LPX_NOFEAS","GLP_UNBND","LPX_UNBND","LPX_UNDEF","glp_get_obj_val","how","LPX_CV","reset_parms","cps","scale","price","relax","tol_bnd","tol_dj","tol_piv","branch","btrack","mps_info","mps_obj","mps_orig","mps_wide","mps_free","mps_skip","lpt_orig","presol","binarize","use_cuts","access_parms","LPX_K_SCALE","LPX_K_DUAL","LPX_K_PRICE","LPX_K_ROUND","LPX_K_ITLIM","LPX_K_ITCNT","LPX_K_OUTFRQ","LPX_K_BRANCH","LPX_K_BTRACK","LPX_K_MPSINFO","LPX_K_MPSOBJ","LPX_K_MPSORIG","LPX_K_MPSWIDE","LPX_K_MPSFREE","LPX_K_MPSSKIP","LPX_K_LPTORIG","LPX_K_PRESOL","LPX_K_BINARIZE","LPX_K_USECUTS","LPX_K_BFTYPE","lpx_get_real_parm","LPX_K_RELAX","LPX_K_TOLBND","LPX_K_TOLDJ","LPX_K_TOLPIV","LPX_K_OBJLL","LPX_K_OBJUL","LPX_K_TMLIM","LPX_K_OUTDLY","LPX_K_TOLINT","LPX_K_TOLOBJ","LPX_K_MIPGAP","fr_ptr","fr_len","fc_ptr","fc_len","sv_head","sv_tail","sv_prev","sv_next","vr_max","nnz_a","nnz_f","max_a","big_v","cap","cur","reallocate","initialize","aj","find_pivot","ncand","next_j","min_p","min_q","min_len","cost","eliminate","fill","q_beg","q_end","q_ptr","fip","vpq","build_v_cols","build_f_rows","N_MAX","_p","_q","xk","mpl_internal_create_operands","index","par","con","loop","mpl_internal_enter_context","mpl","image","token","T_EOF","T_STRING","c_ptr","CONTEXT_SIZE","context","mpl_internal_print_context","line","trim","mpl_internal_get_char","MPL_EOF","column","mpl_internal_read_char","mpl_internal_warning","mpl_internal_error","mpl_internal_append_char","imlen","mpl_internal_get_token","sptp","scanDecimal","eat","triple","quote","b_token","b_imlen","b_image","b_value","f_scan","f_token","f_imlen","f_image","f_value","flag_d","T_NUMBER","substr","f_dots","T_ASTERISK","T_POWER","T_SLASH","T_LT","T_LE","T_NE","T_INPUT","T_EQ","T_GT","T_GE","T_APPEND","T_NOT","T_CONCAT","T_AND","T_BAR","T_OR","T_COMMA","T_COLON","T_ASSIGN","T_SEMICOLON","T_LEFT","T_RIGHT","T_LBRACKET","T_RBRACKET","T_LBRACE","T_RBRACE","T_TILDE","T_SYMBOL","T_POINT","T_DOTS","T_MINUS","T_PLUS","T_NAME","T_BY","T_CROSS","T_DIFF","T_DIV","T_ELSE","T_IF","T_IN","T_INFINITY","T_INTER","T_LESS","T_MOD","T_SPTP","T_SYMDIFF","T_THEN","T_UNION","T_WITHIN","flag_x","mpl_internal_unget_token","mpl_internal_is_keyword","keyword","mpl_internal_is_reserved","mpl_internal_make_code","op","dim","domain","block","vflag","O_NUMBER","O_STRING","O_INDEX","O_MEMNUM","O_MEMSYM","O_MEMSET","O_MEMVAR","suff","O_MEMCON","O_TUPLE","O_MAKE","O_SLICE","O_IRAND224","O_UNIFORM01","O_NORMAL01","O_GMTIME","O_CVTNUM","O_CVTSYM","O_CVTLOG","O_CVTTUP","O_CVTLFM","O_PLUS","O_MINUS","O_NOT","O_ABS","O_CEIL","O_FLOOR","O_EXP","O_LOG","O_LOG10","O_SQRT","O_SIN","O_COS","O_ATAN","O_ROUND","O_TRUNC","O_CARD","O_LENGTH","O_ADD","O_SUB","O_LESS","O_MUL","O_DIV","O_IDIV","O_MOD","O_POWER","O_ATAN2","O_ROUND2","O_TRUNC2","O_UNIFORM","O_NORMAL","O_CONCAT","O_LT","O_LE","O_EQ","O_GE","O_GT","O_NE","O_AND","O_OR","O_UNION","O_DIFF","O_SYMDIFF","O_INTER","O_CROSS","O_IN","O_NOTIN","O_WITHIN","O_NOTWITHIN","O_SUBSTR","O_STR2TIME","O_TIME2STR","O_DOTS","O_FORK","O_SUBSTR3","O_MIN","O_MAX","O_SUM","O_PROD","O_MINIMUM","O_MAXIMUM","O_FORALL","O_EXISTS","O_SETOF","O_BUILD","mpl_internal_make_unary","mpl_internal_make_binary","mpl_internal_make_ternary","mpl_internal_numeric_literal","A_NUMERIC","mpl_internal_string_literal","A_SYMBOLIC","mpl_internal_expand_arg_list","mpl_internal_arg_list_len","mpl_internal_subscript_list","mpl_internal_expression_5","mpl_internal_object_reference","A_INDEX","A_SET","dimen","A_PARAMETER","A_VARIABLE","A_CONSTRAINT","flag_s","DOT_VAL","DOT_NONE","DOT_LB","DOT_UB","DOT_STATUS","DOT_DUAL","A_ELEMSET","A_FORMULA","mpl_internal_numeric_argument","mpl_internal_symbolic_argument","mpl_internal_elemset_argument","mpl_internal_expression_9","mpl_internal_function_reference","mpl_internal_append_block","mpl_internal_append_slot","mpl_internal_expression_list","expr","mpl_internal_expression_13","max_dim","next_token","A_TUPLE","mpl_internal_literal_set","mpl_internal_indexing_expression","A_LOGICAL","mpl_internal_close_scope","mpl_internal_link_up","mpl_internal_iterated_expression","opstr","mpl_internal_expression_3","mpl_internal_expression_12","mpl_internal_domain_arity","arity","mpl_internal_set_expression","mpl_internal_branched_expression","mpl_internal_primary_expression","mpl_internal_error_preceding","mpl_internal_error_following","mpl_internal_error_dimension","dim1","dim2","mpl_internal_expression_0","mpl_internal_expression_1","mpl_internal_expression_2","mpl_internal_expression_4","mpl_internal_expression_6","mpl_internal_expression_7","mpl_internal_expression_8","mpl_internal_expression_10","mpl_internal_expression_11","mpl_internal_set_statement","err1","err2","err3","gadget","dimen_used","alias","within","assign","option","array","as_within","fff","mpl_internal_parameter_statement","process_binary","binary_used","A_BINARY","integer_used","symbolic_used","cond","in_","defval","A_INTEGER","as_binary","as_in","mpl_internal_variable_statement","lbnd","ubnd","mpl_internal_constraint_statement","first","second","third","mpl_internal_objective_statement","A_MINIMIZE","A_MAXIMIZE","mpl_internal_table_statement","last_arg","last_fld","fld","last_in","last_out","out","nflds","tab","A_OUTPUT","A_INPUT","mpl_internal_solve_statement","mpl_internal_check_statement","chk","mpl_internal_display_statement","entry","A_EXPRESSION","last_entry","dpy","mpl_internal_printf_statement","prt","fmt","fname","mpl_internal_for_statement","stmt","last_stmt","fur","mpl_internal_simple_statement","mpl_internal_end_statement","mpl_internal_is_literal","spec","A_TABLE","A_SOLVE","slv","A_CHECK","A_DISPLAY","A_PRINTF","A_FOR","mpl_internal_model_section","mpl_internal_expand_slice","sym","mpl_internal_slice_dimen","mpl_internal_slice_arity","mpl_internal_fake_slice","mpl_internal_delete_slice","mpl_internal_is_number","mpl_internal_is_symbol","literal","mpl_internal_read_number","mpl_internal_read_symbol","mpl_internal_create_symbol_num","mpl_internal_create_symbol_str","mpl_internal_read_slice","close","mpl_internal_select_set","mpl_internal_simple_format","memb","tuple","with_","lack","mpl_internal_format_symbol","mpl_internal_copy_symbol","mpl_internal_expand_tuple","mpl_internal_check_then_add","mpl_internal_matrix_format","which","mpl_internal_set_data","mpl_internal_tuple_dimen","mpl_internal_find_member","mpl_internal_format_tuple","mpl_internal_add_member","mpl_internal_create_elemset","is_tr","mpl_internal_select_parameter","mpl_internal_set_default","altval","mpl_internal_read_value","mpl_internal_plain_format","mpl_internal_tabular_format","mpl_internal_tabbing_format","last_name","mpl_internal_copy_tuple","mpl_internal_parameter_data","mpl_internal_data_section","mpl_internal_fp_add","mpl_internal_fp_sub","mpl_internal_fp_less","mpl_internal_fp_mul","mpl_internal_fp_div","DBL_MIN","mpl_internal_fp_idiv","mpl_internal_fp_mod","mpl_internal_fp_power","mpl_internal_fp_exp","exp","mpl_internal_fp_log","mpl_internal_fp_log10","LN10","mpl_internal_fp_sqrt","mpl_internal_fp_sin","sin","mpl_internal_fp_cos","cos","mpl_internal_fp_atan","atan","mpl_internal_fp_atan2","atan2","mpl_internal_fp_round","ten_to_n","DBL_DIG","mpl_internal_fp_trunc","mpl_internal_fp_irand224","rng_unif_rand","mpl_internal_fp_uniform01","rng_next_rand","mpl_internal_fp_uniform","mpl_internal_fp_normal01","r2","mpl_internal_fp_normal","mu","sigma","mpl_internal_compare_strings","str1","str2","copy","mpl_internal_compare_symbols","sym1","sym2","safe_append","buf","quoted","mpl_internal_concat_symbols","mpl_internal_compare_tuples","tuple1","tuple2","item1","item2","mpl_internal_build_subtuple","mpl_internal_create_array","A_NONE","mpl_internal_find_tuple","mpl_internal_add_tuple","none","mpl_internal_copy_elemset","mpl_internal_arelset_size","t0","tf","dt","mpl_internal_arelset_member","mpl_internal_create_arelset","mpl_internal_set_union","X","Y","mpl_internal_set_diff","Z","mpl_internal_set_symdiff","mpl_internal_set_inter","mpl_internal_set_cross","memx","memy","mpl_internal_constant_term","form","mpl_internal_single_variable","mpl_internal_copy_formula","mpl_internal_linear_comb","fx","fy","term","mpl_internal_remove_constant","mpl_internal_reduce_terms","next_term","mpl_internal_delete_value","bit","A_ELEMVAR","A_ELEMCON","a_list","mpl_internal_compare_member_tuples","key1","key2","mpl_internal_assign_dummy_index","leaf","mpl_internal_update_dummy_indices","backup","mpl_internal_enter_domain_block","mpl_internal_is_member","mpl_internal_eval_domain_func","my_info","mpl_internal_eval_symbolic","failure","mpl_internal_eval_logical","mpl_internal_eval_within_domain","mpl_internal_loop_domain_func","mpl_internal_eval_numeric","looping","mpl_internal_eval_elemset","found","mpl_internal_loop_within_domain","mpl_internal_out_of_domain","mpl_internal_get_domain_tuple","mpl_internal_check_elem_set","refer","eqno","mpl_internal_take_member_set","add","mpl_internal_eval_set_func","mpl_internal_saturate_set","elem","mpl_internal_eval_whole_set","mpl_internal_eval_member_set","mpl_internal_whole_set_func","mpl_internal_check_value_num","dummy","mpl_internal_take_member_num","mpl_internal_eval_num_func","mpl_internal_eval_member_num","mpl_internal_check_value_sym","mpl_internal_take_member_sym","mpl_internal_eval_sym_func","mpl_internal_eval_member_sym","mpl_internal_whole_par_func","mpl_internal_eval_whole_par","mpl_internal_take_member_var","mpl_internal_eval_var_func","mpl_internal_eval_member_var","mpl_internal_take_member_con","mpl_internal_eval_formula","mpl_internal_eval_con_func","mpl_internal_eval_member_con","mpl_internal_whole_con_func","mpl_internal_eval_whole_con","mpl_internal_iter_num_func","mpl_internal_fn_gmtime","mpl_internal_fn_str2time","mpl_internal_fn_time2str","mpl_internal_iter_log_func","mpl_internal_eval_tuple","mpl_internal_iter_set_func","mpl_internal_null_func","that","in1","in2","mpl_internal_iter_form_func","mpl_internal_write_func","dca","mpl_tab_drv_write","mpl_internal_execute_table","na","nf","mpl_tab_drv_open","tup","mpl_tab_drv_read","mpl_tab_drv_flush","mpl_internal_check_func","mpl_internal_execute_check","mpl_internal_display_set","mpl_internal_write_text","mpl_internal_display_par","mpl_internal_display_var","mpl_internal_display_con","mpl_internal_display_memb","mpl_internal_display_code","mpl_internal_display_func","flag_p","mpl_internal_execute_display","mpl_internal_print_char","prt_fp","mpl_internal_write_char","mpl_internal_print_text","OUTBUF_SIZE","mpl_internal_printf_func","int_max","mpl_internal_execute_printf","prt_file","mpl_internal_for_func","mpl_internal_execute_statement","mpl_internal_execute_for","mpl_internal_alloc_content","mpl_internal_generate_model","mpl_internal_build_problem","mpl_internal_postsolve_model","mpl_internal_open_input","in_fp","in_file","mpl_internal_close_input","mpl_internal_open_output","out_fp","out_file","out_buffer","mpl_internal_flush_output","msg","phase","mod_file","now","mpl_internal_mulstr","mpl_internal_error1","year","month","day","hh","mm","ss","zone","mpl_internal_moon","mpl_internal_error2","mpl_internal_weekday","mpl_internal_firstday","mpl_internal_week","iso","sun","mon","mode","Driver","MPL_DRIVERS","tablecb","CSVDriver","what","field","CSV_EOF","CSV_EOR","CSV_NUM","CSV_STR","mpl_tab_num_args","mpl_tab_get_arg","cursor","nskip","readField","mpl_tab_num_flds","mpl_tab_get_name","JSONDriver","JSON","parse","meta","names","push","npp_error","npp_create_wksp","npp","orig_dir","orig_n","orig_nnz","nrows","ncols","r_head","r_tail","c_head","c_tail","top","row_ref","col_ref","scaling","t_stat","i_stat","r_stat","r_pi","c_stat","c_value","npp_insert_row","where","npp_remove_row","npp_activate_row","npp_deactivate_row","npp_insert_col","npp_remove_col","npp_activate_col","npp_deactivate_col","npp_add_row","npp_add_col","is_int","npp_add_aij","r_prev","c_prev","npp_push_tse","tse","npp_erase_row","npp_del_row","npp_del_col","npp_load_prob","GLP_SOL","GLP_IPT","GLP_MIP","rrr","aaa","ccc","sjj","npp_build_prob","glp_erase_prob","glp_set_prob_name","glp_set_obj_name","glp_set_obj_dir","glp_set_obj_coef","glp_add_cols","glp_set_col_name","glp_set_col_kind","glp_set_mat_col","npp_postprocess","dval","pval","npp_unload_sol","npp_free_row","npp_lbnd_col","npp_fixed_col","npp_make_equality","npp_make_fixed","lfe","lambda","npp_empty_row","npp_empty_col","lo","npp_implied_value","npp_eq_singlet","apq","npp_implied_lower","npp_implied_upper","npp_ineq_singlet","lb_changed","ub_changed","nl","nu","npp_implied_slack","npp_implied_free","pi","npp_forcing_row","at","apj","npp_analyze_row","npp_inactive_bound","npp_implied_bounds","apk","npp_binarize_prob","bin","nfails","nvars","nbins","copy_form","hidden_packing","ej","ek","neg","npp_hidden_packing","GLP_DEBUG","hidden_covering","npp_hidden_covering","reduce_ineq_coef","inf_t","new_a","npp_reduce_ineq_coef","npp_clean_prob","next_row","next_col","npp_process_row","hard","fixup","next_aij","GLP_ENOPFS","npp_improve_bounds","npp_process_col","slack","GLP_ENODFS","npp_process_prob","processing","npp_simplex","npp_integer","prev_row","mod_diff","flip_cycle","A","fptr","rng_init_rand","seed","rng_unif_01","_GLPSCF_DEBUG","f_loc","u_loc","bg_transform","un","kj","n1","nj","SCF_EPS","givens","gr_transform","ukj","unj","fkj","fnj","transform","estimate_rank","inc","idy","ij","solve","tsolve","spx_primal","inv_col","A_ptr","A_ind","A_val","error_ftran","refine_ftran","error_btran","refine_btran","alloc_N","N_ptr","N_len","N_ind","N_val","add_N_col","build_N","get_xN","xN","eval_beta","eval_pi","cB","eval_cost","eval_cbar","cbar","work3","chuzc","chuzr","rtol","teta","bbar","tcol_ind","tcol_vec","tcol_num","set_orig_obj","zeta","check_stab","eval_obj","display","it_dpy","store_sol","ray","bind","binv_st","bbar_st","cbar_st","rigorous","refsp","trow_ind","trow_vec","work4","loc","cmax","it_beg","refct","pricing","GLP_PT_STD","GLP_PT_PSE","tcol_nnz","tcol_max","dq","r_test","GLP_RT_STD","GLP_RT_HAR","trow_nnz","piv1","piv2","new_dq","gamma_q","delta_q","pivot","spx_dual","eval_bbar","eval_trow1","eval_trow2","AT_ptr","AT_ind","AT_val","trow_num","check_feas","set_orig_bnds","chrome_workaround_1","chrome_workaround_2","ri","dens","trow_max","gamma_p","eta_p","MAX_VALUE","MIN_VALUE","XEOF","glp_version","GLP_MAJOR_VERSION","GLP_MINOR_VERSION","m_new","GLP_RF_LAZY","ncs","n_new","glp_sort_matrix","glp_set_bfcp","glp_get_obj_name","glp_get_obj_dir","glp_get_col_name","glp_create_index","glp_find_row","glp_find_col","glp_delete_index","glp_set_sjj","glp_get_rii","glp_get_sjj","glp_unscale_prob","solve_lp","GLP_EBADB","GLP_ESING","GLP_ECOND","GLP_PRIMAL","GLP_EBOUND","p_infeas","d_infeas","post","env","term_out","glp_scale_prob","GLP_SF_AUTO","options","glp_get_row_prim","GLP_BV","glp_get_num_int","glp_get_num_bin","glp_intopt","solve_mip","GLP_EROOT","IOCP","GLP_SF_GM","GLP_SF_EQ","GLP_SF_2N","GLP_SF_SKIP","glp_mip_row_val","glp_mip_col_val","b_col","glp_get_bhead","glp_get_row_bind","glp_get_col_bind","glp_ftran","glp_btran","iii","vvv","glp_eval_tab_col","aB","glp_prim_rtest","glp_mpl_read_model","store","value1","var1","value2","var2","xx","coef1","lim_coef","coef2","clen","cpiv","rlen","rpiv","cind","rind","rval","cval","mpl_initialize","tran","mpl_read_model","glp_mpl_read_data","mpl_read_data","mpl_generate","mpl_get_prob_name","mpl_get_num_rows","mpl_get_row_name","mpl_get_row_bnds","MPL_FR","MPL_LO","MPL_UP","MPL_DB","MPL_FX","mpl_get_row_c0","mpl_get_num_cols","mpl_get_col_name","mpl_get_col_kind","MPL_NUM","MPL_INT","MPL_BIN","mpl_get_col_bnds","mpl_get_mat_row","mpl_get_row_kind","MPL_MIN","MPL_MAX","mpl_has_solve_stmt","glp_ipt_row_prim","glp_ipt_row_dual","mpl_put_row_soln","glp_ipt_col_prim","glp_ipt_col_dual","mpl_put_col_soln","mpl_postsolve","CHAR_SET","glp_read_lp","warning","read_char","add_char","the_same","s1","s2","scan_token","T_MINIMIZE","T_MAXIMIZE","T_SUBJECT_TO","T_BOUNDS","T_GENERAL","T_INTEGER","T_BINARY","T_END","NaN","find_col","parse_linear_form","set_lower_bound","set_upper_bound","lb_flag","binary","check_name","adjust_name","row_name","fake","col_name","best_bnd","gap","LPX_E_OK","LPX_E_FAULT","LPX_E_TMLIM","LPX_E_SING","LPX_E_NOPFS","LPX_E_NODFS","LPX_E_MIPGAP","LPX_C_COVER","LPX_C_CLIQUE","LPX_C_GOMORY","LPX_C_MIR","mpl_tab_get_type","mpl_tab_get_num","mpl_tab_get_str","mpl_tab_set_num","mpl_tab_set_str","sym_buf","tup_buf","mpl_buf","skip_data","mpl_tab_drv_register","driver","readChar","min_row_aij","scaled","min_aij","max_row_aij","max_aij","min_col_aij","max_col_aij","min_mat_aij","max_mat_aij","eq_scaling","gm_scaling","max_row_ratio","ratio","max_col_ratio","gm_iterate","it_max","tau","r_old","global","self","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","AsyncIterator","invoke","result","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","process","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","_sent","dispatchException","abrupt","GenStateSuspendedYield","iterator","return","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","values","iterable","iteratorMethod","iteratorSymbol","Op","$Symbol","Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","Gp","constructor","displayName","isGeneratorFunction","genFun","ctor","setPrototypeOf","__proto__","awrap","async","iter","keys","reverse","pop","skipTempReset","rootEntry","rootRecord","exception","handle","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield"],"mappings":"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","file":"63277e3f81178526c235.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/escher-fba/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(5);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export Model */\n/* unused harmony export Solution */\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = modelFromWorkerData;\n/* unused harmony export solutionFromWorkerData */\n/* unused harmony export modelFromJsonData */\n/* unused harmony export modelFromJson */\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_glpk_js__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_glpk_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_glpk_js__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\nvar Model = function () {\n  function Model() {\n    _classCallCheck(this, Model);\n  }\n\n  _createClass(Model, [{\n    key: 'buildGlpkProblem',\n\n    // constructor (data) {\n    //   this.reactions = data.reactions.map(x => ({...x}))\n    //   this.metabolites = data.metabolites.map(x => ({...x}))\n    //   this.genes = data.genes.map(x => ({...x}))\n    //   this.id = data.id\n    //   this.notes = data.notes // TODO is this an object? if so clone\n    //   this.description = data.description\n    // }\n\n    value: function buildGlpkProblem() {\n      /** Build a GLPK LP for the model */\n\n      var nRows = this.metabolites.length;\n      var nCols = this.reactions.length;\n      var ia = [];\n      var ja = [];\n      var ar = [];\n      var metLookup = {};\n\n      // initialize LP objective\n      var lp = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_create_prob\"])();\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_prob_name\"])(lp, 'knockout FBA');\n      // maximize\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_obj_dir\"])(lp, __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"GLP_MAX\"]);\n      // set up rows and columns\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_add_rows\"])(lp, nRows);\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_add_cols\"])(lp, nCols);\n\n      // metabolites\n      this.metabolites.forEach(function (metabolite, i) {\n        var rowInd = i + 1;\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_row_name\"])(lp, rowInd, metabolite.id);\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_row_bnds\"])(lp, rowInd, __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"GLP_FX\"], 0.0, 0.0);\n        // remember the indices of the metabolites\n        metLookup[metabolite.id] = rowInd;\n      });\n\n      // reactions\n      var matInd = 1;\n      this.reactions.forEach(function (reaction, i) {\n        var colInd = i + 1;\n\n        __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_col_name\"])(lp, colInd, reaction.id);\n        if (reaction.lower_bound === reaction.upper_bound) {\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_col_bnds\"])(lp, colInd, __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"GLP_FX\"], reaction.lower_bound, reaction.upper_bound);\n        } else {\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_col_bnds\"])(lp, colInd, __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"GLP_DB\"], reaction.lower_bound, reaction.upper_bound);\n        }\n\n        // object_coefficient is optional for reaction in COBRA JSON\n        if ('objective_coefficient' in reaction) {\n          __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_set_obj_coef\"])(lp, colInd, reaction.objective_coefficient);\n        }\n\n        // S matrix values\n        for (var met_id in reaction.metabolites) {\n          ia[matInd] = metLookup[met_id];\n          ja[matInd] = colInd;\n          ar[matInd] = reaction.metabolites[met_id];\n          matInd++;\n        }\n      });\n      // Load the S matrix\n      __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_load_matrix\"])(lp, ia.length - 1, ia, ja, ar);\n\n      return lp;\n    }\n  }, {\n    key: 'optimize',\n    value: function optimize() {\n      var problem = this.buildGlpkProblem();\n      var smcp = new __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"SMCP\"]({ presolve: __WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"GLP_ON\"] });\n      var returnCode = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_simplex\"])(problem, smcp);\n      var f = null;\n      var x = null;\n      if (returnCode === 0) {\n        // get the objective\n        f = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_get_obj_val\"])(problem);\n        // get the primal\n        x = {};\n        for (var i = 1; i <= __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_get_num_cols\"])(problem); i++) {\n          x[__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_get_col_name\"])(problem, i)] = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_glpk_js__[\"glp_get_col_prim\"])(problem, i);\n        }\n      } else {\n        console.log('Invalid Solution');\n      }\n\n      return new Solution(f, x);\n    }\n  }]);\n\n  return Model;\n}();\n\nvar Solution = function Solution(objectiveValue, fluxes) {\n  _classCallCheck(this, Solution);\n\n  this.objectiveValue = objectiveValue;\n  this.fluxes = fluxes;\n};\n\nfunction modelFromWorkerData(data) {\n  var model = new Model();\n  model.reactions = data.reactions;\n  model.metabolites = data.metabolites;\n  model.genes = data.genes;\n  model.id = data.id;\n  model.notes = data.notes;\n  model.description = data.description;\n  return model;\n  //  Change when model structure changes significantly from original model JSON. Outputs JSON model data.\n}\n\nfunction solutionFromWorkerData(_ref) {\n  var objectiveValue = _ref.objectiveValue,\n      fluxes = _ref.fluxes;\n\n  return new Solution(objectiveValue, fluxes);\n}\n\n/**\r\n *\r\n * @param {*} data\r\n */\nfunction modelFromJsonData(data) {\n  var model = new Model();\n  if (data !== null) {\n    model.reactions = data.reactions.map(function (x) {\n      return Object.assign({}, x);\n    });\n    model.metabolites = data.metabolites.map(function (x) {\n      return Object.assign({}, x);\n    });\n    model.genes = data.genes.map(function (x) {\n      return Object.assign({}, x);\n    });\n    model.id = data.id;\n    model.notes = data.notes; // TODO is this an object? if so clone\n    model.description = data.description;\n  } else {\n    model = null;\n  }\n  return model;\n}\n\nfunction modelFromJson(jsonString) {\n  return modelFromJsonData(JSON.parse(jsonString));\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__COBRA_js__ = __webpack_require__(2);\n\n\nvar _this = this;\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);var value = info.value;\n        } catch (error) {\n          reject(error);return;\n        }if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }return step(\"next\");\n    });\n  };\n}\n\n/* eslint-disable no-undef */\n\nonmessage = function () {\n  var _ref = _asyncToGenerator(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.mark(function _callee(message) {\n    var model, solution;\n    return __WEBPACK_IMPORTED_MODULE_0_babel_runtime_regenerator___default.a.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            model = __WEBPACK_IMPORTED_MODULE_1__COBRA_js__[\"a\" /* modelFromWorkerData */](message.data);\n            _context.next = 3;\n            return model.optimize();\n\n          case 3:\n            solution = _context.sent;\n\n            postMessage(solution);\n\n          case 5:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, _this);\n  }));\n\n  return function onmessage(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n/*! glpk.js - v4.49.0\r\n* https://github.com/hgourvest/glpk.js\r\n* Copyright (c) 2013 Henri Gourvest; Licensed GPLv2 */\r\n(function(exports) {\r\nfunction xassert(test){\r\n    if (!test){\r\n        throw new Error('assert');\r\n    }\r\n}\r\n\r\n\r\n\r\nvar\r\n    /** @const */GLP_DEBUG = false,\r\n    /** @const */DBL_MAX = Number.MAX_VALUE,\r\n    /** @const */DBL_MIN = Number.MIN_VALUE,\r\n    /** @const */DBL_DIG = 16,\r\n    /** @const */INT_MAX = 0x7FFFFFFF,\r\n    /** @const */DBL_EPSILON = 0.22204460492503131E-15,\r\n    /** @const */CHAR_BIT = 1;\r\n\r\nvar\r\n/** CAUTION: DO NOT CHANGE THE LIMITS BELOW */\r\n/** @const */  M_MAX = 100000000, /* = 100*10^6 */\r\n/* maximal number of rows in the problem object */\r\n\r\n/** @const */    N_MAX = 100000000, /* = 100*10^6 */\r\n/* maximal number of columns in the problem object */\r\n\r\n/** @const */    NNZ_MAX = 500000000; /* = 500*10^6 */\r\n/* maximal number of constraint coefficients in the problem object */\r\n\r\n/** @const */\r\nvar XEOF = -1;\r\n\r\nfunction xerror(message){\r\n    throw new Error(message);\r\n}\r\n\r\nvar xprintf = function(data){\r\n\r\n};\r\n\r\nexports[\"glp_get_print_func\"] = function(){return xprintf};\r\nexports[\"glp_set_print_func\"] = function(value){xprintf = value};\r\n\r\nfunction xcopyObj(dest, src){\r\n    for (var prop in src){dest[prop] = src[prop];}\r\n}\r\n\r\nfunction xcopyArr(dest, destFrom, src, srcFrom, count){\r\n    for (; count > 0; destFrom++, srcFrom++, count--){dest[destFrom] = src[srcFrom];}\r\n}\r\n\r\nfunction xfillArr(dest, destFrom, value, count){\r\n    for (; count > 0; destFrom++, count--){dest[destFrom] = value;}\r\n}\r\n\r\nfunction xfillObjArr(dest, destFrom, count){\r\n    for (; count > 0; destFrom++, count--){dest[destFrom] = {}}\r\n}\r\n\r\nfunction xtime(){\r\n    var d = new Date();\r\n    return d.getTime();\r\n}\r\n\r\nfunction xdifftime(to, from){\r\n    return (to - from) / 1000;\r\n}\r\n\r\nfunction xqsort(base, idx, num, compar){\r\n    var tmp = new Array(num);\r\n    xcopyArr(tmp, 0, base, idx, num);\r\n    tmp.sort(compar);\r\n    xcopyArr(base, idx, tmp, 0, num);\r\n}\r\n\r\nvar\r\n    global_env = {};\r\n\r\nfunction get_env_ptr(){\r\n    return global_env;\r\n}\r\n\r\nvar glp_version = exports[\"glp_version\"] = function(){\r\n    return GLP_MAJOR_VERSION + \".\" + GLP_MINOR_VERSION;\r\n};\r\n\r\nfunction isspace(c){\r\n    return (\" \\t\\n\\v\\f\\r\".indexOf(c) >= 0)\r\n}\r\n\r\nfunction iscntrl(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return ((code >= 0x00 && code <= 0x1f) || code == 0x7f)\r\n}\r\n\r\nfunction isalpha(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x41 && code <= 0x5A)|| (code >= 0x61 && code <= 0x7A)\r\n}\r\n\r\nfunction isalnum(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x41 && code <= 0x5A)|| (code >= 0x61 && code <= 0x7A) || (code >= 0x30 && code <= 0x39)\r\n}\r\n\r\nfunction isdigit(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x30 && code <= 0x39)\r\n}\r\n\r\nfunction strchr(str, c){\r\n    return str.indexOf(c)\r\n}\r\n\r\nfunction tolower(c){\r\n    return c.toLowerCase();\r\n}\r\n\r\n\r\nfunction sprintf () {\r\n    // http://kevin.vanzonneveld.net\r\n    // +   original by: Ash Searle (http://hexmen.com/blog/)\r\n    // + namespaced by: Michael White (http://getsprink.com)\r\n    // +    tweaked by: Jack\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +      input by: Paulo Freitas\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +      input by: Brett Zamir (http://brett-zamir.me)\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +   improved by: Dj\r\n    // +   improved by: Allidylls\r\n    // *     example 1: sprintf(\"%01.2f\", 123.1);\r\n    // *     returns 1: 123.10\r\n    // *     example 2: sprintf(\"[%10s]\", 'monkey');\r\n    // *     returns 2: '[    monkey]'\r\n    // *     example 3: sprintf(\"[%'#10s]\", 'monkey');\r\n    // *     returns 3: '[####monkey]'\r\n    // *     example 4: sprintf(\"%d\", 123456789012345);\r\n    // *     returns 4: '123456789012345'\r\n    var regex = /%%|%(\\d+\\$)?([-+\\'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g;\r\n    var a = arguments,\r\n        i = 0,\r\n        format = a[i++];\r\n\r\n    // pad()\r\n    var pad = function (str, len, chr, leftJustify) {\r\n        if (!chr) {\r\n            chr = ' ';\r\n        }\r\n        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\r\n        return leftJustify ? str + padding : padding + str;\r\n    };\r\n\r\n    // justify()\r\n    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {\r\n        var diff = minWidth - value.length;\r\n        if (diff > 0) {\r\n            if (leftJustify || !zeroPad) {\r\n                value = pad(value, minWidth, customPadChar, leftJustify);\r\n            } else {\r\n                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n\r\n    // formatBaseX()\r\n    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\r\n        // Note: casts negative numbers to positive ones\r\n        var number = value >>> 0;\r\n        prefix = prefix && number && {\r\n            '2': '0b',\r\n            '8': '0',\r\n            '16': '0x'\r\n        }[base] || '';\r\n        value = prefix + pad(number.toString(base), precision || 0, '0', false);\r\n        return justify(value, prefix, leftJustify, minWidth, zeroPad);\r\n    };\r\n\r\n    // formatString()\r\n    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {\r\n        if (precision != null) {\r\n            value = value.slice(0, precision);\r\n        }\r\n        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);\r\n    };\r\n\r\n    // doFormat()\r\n    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {\r\n        var number;\r\n        var prefix;\r\n        var method;\r\n        var textTransform;\r\n        var value;\r\n\r\n        if (substring == '%%') {\r\n            return '%';\r\n        }\r\n\r\n        // parse flags\r\n        var leftJustify = false,\r\n            positivePrefix = '',\r\n            zeroPad = false,\r\n            prefixBaseX = false,\r\n            customPadChar = ' ';\r\n        var flagsl = flags.length;\r\n        for (var j = 0; flags && j < flagsl; j++) {\r\n            switch (flags.charAt(j)) {\r\n                case ' ':\r\n                    positivePrefix = ' ';\r\n                    break;\r\n                case '+':\r\n                    positivePrefix = '+';\r\n                    break;\r\n                case '-':\r\n                    leftJustify = true;\r\n                    break;\r\n                case \"'\":\r\n                    customPadChar = flags.charAt(j + 1);\r\n                    break;\r\n                case '0':\r\n                    zeroPad = true;\r\n                    break;\r\n                case '#':\r\n                    prefixBaseX = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // parameters may be null, undefined, empty-string or real valued\r\n        // we want to ignore null, undefined and empty-string values\r\n        if (!minWidth) {\r\n            minWidth = 0;\r\n        } else if (minWidth == '*') {\r\n            minWidth = +a[i++];\r\n        } else if (minWidth.charAt(0) == '*') {\r\n            minWidth = +a[minWidth.slice(1, -1)];\r\n        } else {\r\n            minWidth = +minWidth;\r\n        }\r\n\r\n        // Note: undocumented perl feature:\r\n        if (minWidth < 0) {\r\n            minWidth = -minWidth;\r\n            leftJustify = true;\r\n        }\r\n\r\n        if (!isFinite(minWidth)) {\r\n            throw new Error('sprintf: (minimum-)width must be finite');\r\n        }\r\n\r\n        if (!precision) {\r\n            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;\r\n        } else if (precision == '*') {\r\n            precision = +a[i++];\r\n        } else if (precision.charAt(0) == '*') {\r\n            precision = +a[precision.slice(1, -1)];\r\n        } else {\r\n            precision = +precision;\r\n        }\r\n\r\n        // grab value using valueIndex if required?\r\n        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\r\n\r\n        switch (type) {\r\n            case 's':\r\n                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);\r\n            case 'c':\r\n                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\r\n            case 'b':\r\n                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'o':\r\n                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'x':\r\n                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'X':\r\n                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\r\n            case 'u':\r\n                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'i':\r\n            case 'd':\r\n                number = +value || 0;\r\n                number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate\r\n                prefix = number < 0 ? '-' : positivePrefix;\r\n                value = prefix + pad(String(Math.abs(number)), precision, '0', false);\r\n                return justify(value, prefix, leftJustify, minWidth, zeroPad);\r\n            case 'e':\r\n            case 'E':\r\n            case 'f': // Should handle locales (as per setlocale)\r\n            case 'F':\r\n            case 'g':\r\n            case 'G':\r\n                number = +value;\r\n                prefix = number < 0 ? '-' : positivePrefix;\r\n                method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\r\n                textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\r\n                value = prefix + Math.abs(number)[method](precision);\r\n                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\r\n            default:\r\n                return substring;\r\n        }\r\n    };\r\n\r\n    return format.replace(regex, doFormat);\r\n}\r\n\r\n\r\n/* glpapi.h */\r\n\r\nvar\r\n    /** @const */ GLP_PROB_MAGIC = 0xD7D9D6C2;\r\n\r\nfunction create_prob(lp){\r\n    lp.magic = GLP_PROB_MAGIC;\r\n    //lp.pool = dmp_create_pool();\r\n    lp.parms = null;\r\n    lp.tree = null;\r\n    /* LP/MIP data */\r\n    lp.name = null;\r\n    lp.obj = null;\r\n    lp.dir = GLP_MIN;\r\n    lp.c0 = 0.0;\r\n    lp.m_max = 100;\r\n    lp.n_max = 200;\r\n    lp.m = lp.n = 0;\r\n    lp.nnz = 0;\r\n    lp.row = new Array(1+lp.m_max);\r\n    lp.col = new Array(1+lp.n_max);\r\n    lp.r_tree = {};\r\n    lp.c_tree = {};\r\n    /* basis factorization */\r\n    lp.valid = 0;\r\n    lp.head = new Int32Array(1+lp.m_max);\r\n    lp.bfcp = null;\r\n    lp.bfd = null;\r\n    /* basic solution (LP) */\r\n    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n    lp.obj_val = 0.0;\r\n    lp.it_cnt = 0;\r\n    lp.some = 0;\r\n    /* interior-point solution (LP) */\r\n    lp.ipt_stat = GLP_UNDEF;\r\n    lp.ipt_obj = 0.0;\r\n    /* integer solution (MIP) */\r\n    lp.mip_stat = GLP_UNDEF;\r\n    lp.mip_obj = 0.0;\r\n}\r\n\r\nvar glp_create_prob = exports[\"glp_create_prob\"] = function(){\r\n    var lp = {};\r\n    create_prob(lp);\r\n    return lp;\r\n};\r\n\r\nvar glp_set_prob_name = exports[\"glp_set_prob_name\"] = function(lp, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_prob_name: operation not allowed\");\r\n    lp.name = name;\r\n};\r\n\r\nvar glp_set_obj_name = exports[\"glp_set_obj_name\"] = function(lp, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_name: operation not allowed\");\r\n    lp.obj = name;\r\n};\r\n\r\nvar glp_set_obj_dir = exports[\"glp_set_obj_dir\"] = function(lp, dir){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_dir: operation not allowed\");\r\n    if (!(dir == GLP_MIN || dir == GLP_MAX))\r\n        xerror(\"glp_set_obj_dir: dir = \" + dir  + \"; invalid direction flag\");\r\n    lp.dir = dir;\r\n};\r\n\r\nvar glp_add_rows = exports[\"glp_add_rows\"] = function (lp, nrs){\r\n    var tree = lp.tree;\r\n    var row;\r\n    /* determine new number of rows */\r\n    if (nrs < 1)\r\n        xerror(\"glp_add_rows: nrs = \" + nrs + \"; invalid number of rows\");\r\n    if (nrs > M_MAX - lp.m)\r\n        xerror(\"glp_add_rows: nrs = \" + nrs + \"; too many rows\");\r\n    var m_new = lp.m + nrs;\r\n    /* increase the room, if necessary */\r\n    if (lp.m_max < m_new){\r\n        while (lp.m_max < m_new){\r\n            lp.m_max += lp.m_max;\r\n            xassert(lp.m_max > 0);\r\n        }\r\n        lp.row.length = 1+lp.m_max;\r\n\r\n        /* do not forget about the basis header */\r\n        lp.head = new Int32Array(1+lp.m_max);\r\n    }\r\n    /* add new rows to the end of the row list */\r\n    for (var i = lp.m+1; i <= m_new; i++)\r\n    {  /* create row descriptor */\r\n        lp.row[i] = row = {};\r\n        row.i = i;\r\n        row.name = null;\r\n        row.node = null;\r\n        row.level = 0;\r\n        row.origin = 0;\r\n        row.klass = 0;\r\n        if (tree != null)\r\n        {  switch (tree.reason)\r\n        {  case 0:\r\n                break;\r\n            case GLP_IROWGEN:\r\n                xassert(tree.curr != null);\r\n                row.level = tree.curr.level;\r\n                row.origin = GLP_RF_LAZY;\r\n                break;\r\n            case GLP_ICUTGEN:\r\n                xassert(tree.curr != null);\r\n                row.level = tree.curr.level;\r\n                row.origin = GLP_RF_CUT;\r\n                break;\r\n            default:\r\n                xassert(tree != tree);\r\n        }\r\n        }\r\n        row.type = GLP_FR;\r\n        row.lb = row.ub = 0.0;\r\n        row.ptr = null;\r\n        row.rii = 1.0;\r\n        row.stat = GLP_BS;\r\n        row.bind = 0;\r\n        row.prim = row.dual = 0.0;\r\n        row.pval = row.dval = 0.0;\r\n        row.mipx = 0.0;\r\n    }\r\n    /* set new number of rows */\r\n    lp.m = m_new;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n    if (tree != null && tree.reason != 0) tree.reopt = 1;\r\n    /* return the ordinal number of the first row added */\r\n    return m_new - nrs + 1;\r\n};\r\n\r\nvar glp_add_cols = exports[\"glp_add_cols\"] = function(lp, ncs){\r\n    var tree = lp.tree;\r\n    var col;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_add_cols: operation not allowed\");\r\n    /* determine new number of columns */\r\n    if (ncs < 1)\r\n        xerror(\"glp_add_cols: ncs = \" + ncs + \"; invalid number of columns\");\r\n    if (ncs > N_MAX - lp.n)\r\n        xerror(\"glp_add_cols: ncs = \" + ncs + \"; too many columns\");\r\n    var n_new = lp.n + ncs;\r\n    /* increase the room, if necessary */\r\n    if (lp.n_max < n_new)\r\n    {\r\n        while (lp.n_max < n_new)\r\n        {  lp.n_max += lp.n_max;\r\n            xassert(lp.n_max > 0);\r\n        }\r\n        lp.col.length = 1+lp.n_max;\r\n    }\r\n    /* add new columns to the end of the column list */\r\n    for (var j = lp.n+1; j <= n_new; j++)\r\n    {  /* create column descriptor */\r\n        lp.col[j] = col = {};\r\n        col.j = j;\r\n        col.name = null;\r\n        col.node = null;\r\n        col.kind = GLP_CV;\r\n        col.type = GLP_FX;\r\n        col.lb = col.ub = 0.0;\r\n        col.coef = 0.0;\r\n        col.ptr = null;\r\n        col.sjj = 1.0;\r\n        col.stat = GLP_NS;\r\n        col.bind = 0; /* the basis may remain valid */\r\n        col.prim = col.dual = 0.0;\r\n        col.pval = col.dval = 0.0;\r\n        col.mipx = 0.0;\r\n    }\r\n    /* set new number of columns */\r\n    lp.n = n_new;\r\n    /* return the ordinal number of the first column added */\r\n    return n_new - ncs + 1;\r\n};\r\n\r\nvar glp_set_row_name = exports[\"glp_set_row_name\"] = function(lp, i, name)\r\n{\r\n    var tree = lp.tree;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_name: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    if (tree != null && tree.reason != 0){\r\n        xassert(tree.curr != null);\r\n        xassert(row.level == tree.curr.level);\r\n    }\r\n    if (row.name != null){\r\n        delete(lp.r_tree[row.name]);\r\n        row.name = null;\r\n    }\r\n    if (name != null){\r\n        row.name = name;\r\n        lp.r_tree[row.name] = row;\r\n    }\r\n};\r\n\r\nvar glp_set_col_name = exports[\"glp_set_col_name\"] = function(lp, j, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_col_name: operation not allowed\");\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_name: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n\r\n    if (col.name != null){\r\n        delete(lp.c_tree[col.name]);\r\n        col.name = null;\r\n    }\r\n\r\n    if (name != null){\r\n        col.name = name;\r\n        lp.c_tree[col.name] = col;\r\n    }\r\n};\r\n\r\nvar glp_set_row_bnds = exports[\"glp_set_row_bnds\"] = function(lp, i, type, lb, ub){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_bnds: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    row.type = type;\r\n    switch (type){\r\n        case GLP_FR:\r\n            row.lb = row.ub = 0.0;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NF;\r\n            break;\r\n        case GLP_LO:\r\n            row.lb = lb; row.ub = 0.0;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NL;\r\n            break;\r\n        case GLP_UP:\r\n            row.lb = 0.0; row.ub = ub;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NU;\r\n            break;\r\n        case GLP_DB:\r\n            row.lb = lb; row.ub = ub;\r\n            if (!(row.stat == GLP_BS ||\r\n                row.stat == GLP_NL || row.stat == GLP_NU))\r\n                row.stat = (Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU);\r\n            break;\r\n        case GLP_FX:\r\n            row.lb = row.ub = lb;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NS;\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_row_bnds: i = \" + i + \"; type = \" + type + \"; invalid row type\");\r\n    }\r\n};\r\n\r\nvar glp_set_col_bnds = exports[\"glp_set_col_bnds\"] = function(lp, j, type, lb, ub){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_bnds: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n    col.type = type;\r\n    switch (type){\r\n        case GLP_FR:\r\n            col.lb = col.ub = 0.0;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NF;\r\n            break;\r\n        case GLP_LO:\r\n            col.lb = lb; col.ub = 0.0;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NL;\r\n            break;\r\n        case GLP_UP:\r\n            col.lb = 0.0; col.ub = ub;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NU;\r\n            break;\r\n        case GLP_DB:\r\n            col.lb = lb; col.ub = ub;\r\n            if (!(col.stat == GLP_BS ||\r\n                col.stat == GLP_NL || col.stat == GLP_NU))\r\n                col.stat = (Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU);\r\n            break;\r\n        case GLP_FX:\r\n            col.lb = col.ub = lb;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NS;\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_col_bnds: j = \" + j + \"; type = \" + type + \"; invalid column type\");\r\n    }\r\n};\r\n\r\nvar glp_set_obj_coef = exports[\"glp_set_obj_coef\"] = function(lp, j, coef){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_coef: operation not allowed\");\r\n    if (!(0 <= j && j <= lp.n))\r\n        xerror(\"glp_set_obj_coef: j = \" + j + \"; column number out of range\");\r\n    if (j == 0)\r\n        lp.c0 = coef;\r\n    else\r\n        lp.col[j].coef = coef;\r\n};\r\n\r\nvar glp_set_mat_row = exports[\"glp_set_mat_row\"] = function(lp, i, len, ind, val){\r\n    var tree = lp.tree;\r\n    var col, aij, next, j, k;\r\n    /* obtain pointer to i-th row */\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    if (tree != null && tree.reason != 0){\r\n        xassert(tree.curr != null);\r\n        xassert(row.level == tree.curr.level);\r\n    }\r\n    /* remove all existing elements from i-th row */\r\n    while (row.ptr != null){\r\n        /* take next element in the row */\r\n        aij = row.ptr;\r\n        /* remove the element from the row list */\r\n        row.ptr = aij.r_next;\r\n        /* obtain pointer to corresponding column */\r\n        col = aij.col;\r\n        /* remove the element from the column list */\r\n        if (aij.c_prev == null)\r\n            col.ptr = aij.c_next;\r\n        else\r\n            aij.c_prev.c_next = aij.c_next;\r\n        if (aij.c_next != null)\r\n            aij.c_next.c_prev = aij.c_prev;\r\n        /* return the element to the memory pool */\r\n        lp.nnz--;\r\n        /* if the corresponding column is basic, invalidate the basis\r\n         factorization */\r\n        if (col.stat == GLP_BS) lp.valid = 0;\r\n    }\r\n    /* store new contents of i-th row */\r\n    if (!(0 <= len && len <= lp.n))\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; len = \" + len + \"; invalid row length \");\r\n    if (len > NNZ_MAX - lp.nnz)\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; len = \" + len + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= len; k++){\r\n        /* take number j of corresponding column */\r\n        j = ind[k];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_set_mat_row: i = \" + i + \"; ind[\" + k + \"] = \" + j + \"; column index out of range\");\r\n        col = lp.col[j];\r\n        /* if there is element with the same column index, it can only\r\n         be found in the beginning of j-th column list */\r\n        if (col.ptr != null && col.ptr.row.i == i)\r\n            xerror(\"glp_set_mat_row: i = \" + i + \"; ind[\" + k + \"] = \" + j + \"; duplicate column indices not allowed\");\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = val[k];\r\n        /* add the new element to the beginning of i-th row and j-th\r\n         column lists */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        aij.c_prev = null;\r\n        aij.c_next = col.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n        row.ptr = col.ptr = aij;\r\n        /* if the corresponding column is basic, invalidate the basis\r\n         factorization */\r\n        if (col.stat == GLP_BS && aij.val != 0.0) lp.valid = 0;\r\n    }\r\n    /* remove zero elements from i-th row */\r\n    for (aij = row.ptr; aij != null; aij = next)\r\n    {  next = aij.r_next;\r\n        if (aij.val == 0.0)\r\n        {  /* remove the element from the row list */\r\n            if (aij.r_prev == null)\r\n                row.ptr = next;\r\n            else\r\n                aij.r_prev.r_next = next;\r\n            if (next != null)\r\n                next.r_prev = aij.r_prev;\r\n            /* remove the element from the column list */\r\n            xassert(aij.c_prev == null);\r\n            aij.col.ptr = aij.c_next;\r\n            if (aij.c_next != null) aij.c_next.c_prev = null;\r\n            /* return the element to the memory pool */\r\n            lp.nnz--;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_set_mat_col = exports[\"glp_set_mat_col\"] = function(lp, j, len, ind, val){\r\n    var tree = lp.tree;\r\n    var row, aij, next;\r\n    var i, k;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_mat_col: operation not allowed\");\r\n    /* obtain pointer to j-th column */\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n    /* remove all existing elements from j-th column */\r\n    while (col.ptr != null)\r\n    {  /* take next element in the column */\r\n        aij = col.ptr;\r\n        /* remove the element from the column list */\r\n        col.ptr = aij.c_next;\r\n        /* obtain pointer to corresponding row */\r\n        row = aij.row;\r\n        /* remove the element from the row list */\r\n        if (aij.r_prev == null)\r\n            row.ptr = aij.r_next;\r\n        else\r\n            aij.r_prev.r_next = aij.r_next;\r\n        if (aij.r_next != null)\r\n            aij.r_next.r_prev = aij.r_prev;\r\n        /* return the element to the memory pool */\r\n        lp.nnz--;\r\n    }\r\n    /* store new contents of j-th column */\r\n    if (!(0 <= len && len <= lp.m))\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; len = \" + len + \"; invalid column length\");\r\n    if (len > NNZ_MAX - lp.nnz)\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; len = \" + len + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= len; k++){\r\n        /* take number i of corresponding row */\r\n        i = ind[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_set_mat_col: j = \" + j + \"; ind[\" + k + \"] = \" + i + \"; row index out of range\");\r\n        row = lp.row[i];\r\n        /* if there is element with the same row index, it can only be\r\n         found in the beginning of i-th row list */\r\n        if (row.ptr != null && row.ptr.col.j == j)\r\n            xerror(\"glp_set_mat_col: j = \" + j + \"; ind[\" + k + \"] = \" + i + \"; duplicate row indices not allowed\");\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = val[k];\r\n        /* add the new element to the beginning of i-th row and j-th\r\n         column lists */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        aij.c_prev = null;\r\n        aij.c_next = col.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n        row.ptr = col.ptr = aij;\r\n    }\r\n    /* remove zero elements from j-th column */\r\n    for (aij = col.ptr; aij != null; aij = next)\r\n    {  next = aij.c_next;\r\n        if (aij.val == 0.0)\r\n        {  /* remove the element from the row list */\r\n            xassert(aij.r_prev == null);\r\n            aij.row.ptr = aij.r_next;\r\n            if (aij.r_next != null) aij.r_next.r_prev = null;\r\n            /* remove the element from the column list */\r\n            if (aij.c_prev == null)\r\n                col.ptr = next;\r\n            else\r\n                aij.c_prev.c_next = next;\r\n            if (next != null)\r\n                next.c_prev = aij.c_prev;\r\n            /* return the element to the memory pool */\r\n            lp.nnz--;\r\n        }\r\n    }\r\n    /* if j-th column is basic, invalidate the basis factorization */\r\n    if (col.stat == GLP_BS) lp.valid = 0;\r\n};\r\n\r\nvar glp_load_matrix = exports[\"glp_load_matrix\"] = function(lp, ne, ia, ja, ar){\r\n    var tree = lp.tree;\r\n    var row, col, aij, next;\r\n    var i, j, k;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_load_matrix: operation not allowed\");\r\n    /* clear the constraint matrix */\r\n    for (i = 1; i <= lp.m; i++){\r\n        row = lp.row[i];\r\n        while (row.ptr != null){\r\n            aij = row.ptr;\r\n            row.ptr = aij.r_next;\r\n            lp.nnz--;\r\n        }\r\n    }\r\n    xassert(lp.nnz == 0);\r\n    for (j = 1; j <= lp.n; j++) lp.col[j].ptr = null;\r\n    /* load the new contents of the constraint matrix and build its\r\n     row lists */\r\n    if (ne < 0)\r\n        xerror(\"glp_load_matrix: ne = \" + ne + \"; invalid number of constraint coefficients\");\r\n    if (ne > NNZ_MAX)\r\n        xerror(\"glp_load_matrix: ne = \" + ne + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= ne; k++){\r\n        /* take indices of new element */\r\n        i = ia[k]; j = ja[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_load_matrix: ia[\" + k + \"] = \" + i + \"; row index out of range\");\r\n        row = lp.row[i];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_load_matrix: ja[\" + k + \"] = \" + j + \"; column index out of range\");\r\n        col = lp.col[j];\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = ar[k];\r\n        /* add the new element to the beginning of i-th row list */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        row.ptr = aij;\r\n    }\r\n    xassert(lp.nnz == ne);\r\n    /* build column lists of the constraint matrix and check elements\r\n     with identical indices */\r\n    for (i = 1; i <= lp.m; i++){\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n            /* obtain pointer to corresponding column */\r\n            col = aij.col;\r\n            /* if there is element with identical indices, it can only\r\n             be found in the beginning of j-th column list */\r\n            if (col.ptr != null && col.ptr.row.i == i){\r\n                for (k = 1; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == col.j) break;\r\n                xerror(\"glp_load_mat: ia[\" + k + \"] = \" + i + \"; ja[\" + k + \"] = \" + col.j + \"; duplicate indices not allowed\");\r\n            }\r\n            /* add the element to the beginning of j-th column list */\r\n            aij.c_prev = null;\r\n            aij.c_next = col.ptr;\r\n            if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n            col.ptr = aij;\r\n        }\r\n    }\r\n    /* remove zero elements from the constraint matrix */\r\n    for (i = 1; i <= lp.m; i++)\r\n    {  row = lp.row[i];\r\n        for (aij = row.ptr; aij != null; aij = next)\r\n        {  next = aij.r_next;\r\n            if (aij.val == 0.0)\r\n            {  /* remove the element from the row list */\r\n                if (aij.r_prev == null)\r\n                    row.ptr = next;\r\n                else\r\n                    aij.r_prev.r_next = next;\r\n                if (next != null)\r\n                    next.r_prev = aij.r_prev;\r\n                /* remove the element from the column list */\r\n                if (aij.c_prev == null)\r\n                    aij.col.ptr = aij.c_next;\r\n                else\r\n                    aij.c_prev.c_next = aij.c_next;\r\n                if (aij.c_next != null)\r\n                    aij.c_next.c_prev = aij.c_prev;\r\n                /* return the element to the memory pool */\r\n                lp.nnz--;\r\n            }\r\n        }\r\n    }\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n};\r\n\r\nvar glp_check_dup = exports[\"glp_check_dup\"] = function(m, n, ne, ia, ja){\r\n    var i, j, k, ptr, next, ret;\r\n    var flag;\r\n    if (m < 0)\r\n        xerror(\"glp_check_dup: m = %d; invalid parameter\");\r\n    if (n < 0)\r\n        xerror(\"glp_check_dup: n = %d; invalid parameter\");\r\n    if (ne < 0)\r\n        xerror(\"glp_check_dup: ne = %d; invalid parameter\");\r\n    if (ne > 0 && ia == null)\r\n        xerror(\"glp_check_dup: ia = \" + ia + \"; invalid parameter\");\r\n    if (ne > 0 && ja == null)\r\n        xerror(\"glp_check_dup: ja = \" + ja + \"; invalid parameter\");\r\n    for (k = 1; k <= ne; k++){\r\n        i = ia[k]; j = ja[k];\r\n        if (!(1 <= i && i <= m && 1 <= j && j <= n)){\r\n            ret = -k;\r\n            return ret;\r\n        }\r\n    }\r\n    if (m == 0 || n == 0)\r\n    {  ret = 0;\r\n        return ret;\r\n    }\r\n    /* allocate working arrays */\r\n    ptr = new Int32Array(1+m);\r\n    next = new Int32Array(1+ne);\r\n    flag = new Int8Array(1+n);\r\n    /* build row lists */\r\n    for (k = 1; k <= ne; k++){\r\n        i = ia[k];\r\n        next[k] = ptr[i];\r\n        ptr[i] = k;\r\n    }\r\n    /* check for duplicate elements */\r\n    for (i = 1; i <= m; i++){\r\n        for (k = ptr[i]; k != 0; k = next[k]){\r\n            j = ja[k];\r\n            if (flag[j]){\r\n                /* find first element (i,j) */\r\n                for (k = 1; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == j) break;\r\n                xassert(k <= ne);\r\n                /* find next (duplicate) element (i,j) */\r\n                for (k++; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == j) break;\r\n                xassert(k <= ne);\r\n                ret = +k;\r\n                return ret;\r\n            }\r\n            flag[j] = 1;\r\n        }\r\n        /* clear column flags */\r\n        for (k = ptr[i]; k != 0; k = next[k])\r\n            flag[ja[k]] = 0;\r\n    }\r\n    /* no duplicate element found */\r\n    ret = 0;\r\n    return ret;\r\n};\r\n\r\nvar glp_sort_matrix = exports[\"glp_sort_matrix\"] = function(P){\r\n    var aij;\r\n    var i, j;\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_sort_matrix: P = \" + P + \"; invalid problem object\");\r\n    /* rebuild row linked lists */\r\n    for (i = P.m; i >= 1; i--)\r\n        P.row[i].ptr = null;\r\n    for (j = P.n; j >= 1; j--){\r\n        for (aij = P.col[j].ptr; aij != null; aij = aij.c_next){\r\n            i = aij.row.i;\r\n            aij.r_prev = null;\r\n            aij.r_next = P.row[i].ptr;\r\n            if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n            P.row[i].ptr = aij;\r\n        }\r\n    }\r\n    /* rebuild column linked lists */\r\n    for (j = P.n; j >= 1; j--)\r\n        P.col[j].ptr = null;\r\n    for (i = P.m; i >= 1; i--){\r\n        for (aij = P.row[i].ptr; aij != null; aij = aij.r_next){\r\n            j = aij.col.j;\r\n            aij.c_prev = null;\r\n            aij.c_next = P.col[j].ptr;\r\n            if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n            P.col[j].ptr = aij;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_del_rows = exports[\"glp_del_rows\"] = function(lp, nrs, num){\r\n    var tree = lp.tree;\r\n    var row;\r\n    var i, k, m_new;\r\n    /* mark rows to be deleted */\r\n    if (!(1 <= nrs && nrs <= lp.m))\r\n        xerror(\"glp_del_rows: nrs = \" + nrs + \"; invalid number of rows\");\r\n    for (k = 1; k <= nrs; k++){\r\n        /* take the number of row to be deleted */\r\n        i = num[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        row = lp.row[i];\r\n        if (tree != null && tree.reason != 0){\r\n            if (!(tree.reason == GLP_IROWGEN || tree.reason == GLP_ICUTGEN))\r\n                xerror(\"glp_del_rows: operation not allowed\");\r\n            xassert(tree.curr != null);\r\n            if (row.level != tree.curr.level)\r\n                xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; invalid attempt to delete row created not in current subproblem\");\r\n            if (row.stat != GLP_BS)\r\n                xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; invalid attempt to delete active row (constraint)\");\r\n            tree.reinv = 1;\r\n        }\r\n        /* check that the row is not marked yet */\r\n        if (row.i == 0)\r\n            xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; duplicate row numbers not allowed\");\r\n        /* erase symbolic name assigned to the row */\r\n        glp_set_row_name(lp, i, null);\r\n        xassert(row.node == null);\r\n        /* erase corresponding row of the constraint matrix */\r\n        glp_set_mat_row(lp, i, 0, null, null);\r\n        xassert(row.ptr == null);\r\n        /* mark the row to be deleted */\r\n        row.i = 0;\r\n    }\r\n    /* delete all marked rows from the row list */\r\n    m_new = 0;\r\n    for (i = 1; i <= lp.m; i++){\r\n        /* obtain pointer to i-th row */\r\n        row = lp.row[i];\r\n        /* check if the row is marked */\r\n        if (row.i != 0){\r\n            /* it is not marked; keep it */\r\n            row.i = ++m_new;\r\n            lp.row[row.i] = row;\r\n        }\r\n    }\r\n    /* set new number of rows */\r\n    lp.m = m_new;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n};\r\n\r\nvar glp_del_cols = exports[\"glp_del_cols\"] = function(lp, ncs, num){\r\n    var tree = lp.tree;\r\n    var col;\r\n    var j, k, n_new;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_del_cols: operation not allowed\");\r\n    /* mark columns to be deleted */\r\n    if (!(1 <= ncs && ncs <= lp.n))\r\n        xerror(\"glp_del_cols: ncs = \" + ncs + \"; invalid number of columns\");\r\n    for (k = 1; k <= ncs; k++){\r\n        /* take the number of column to be deleted */\r\n        j = num[k];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_del_cols: num[\" + k + \"] = \" + j + \"; column number out of range\");\r\n        col = lp.col[j];\r\n        /* check that the column is not marked yet */\r\n        if (col.j == 0)\r\n            xerror(\"glp_del_cols: num[\" + k + \"] = \" + j + \"; duplicate column numbers not allowed\");\r\n        /* erase symbolic name assigned to the column */\r\n        glp_set_col_name(lp, j, null);\r\n        xassert(col.node == null);\r\n        /* erase corresponding column of the constraint matrix */\r\n        glp_set_mat_col(lp, j, 0, null, null);\r\n        xassert(col.ptr == null);\r\n        /* mark the column to be deleted */\r\n        col.j = 0;\r\n        /* if it is basic, invalidate the basis factorization */\r\n        if (col.stat == GLP_BS) lp.valid = 0;\r\n    }\r\n    /* delete all marked columns from the column list */\r\n    n_new = 0;\r\n    for (j = 1; j <= lp.n; j++)\r\n    {  /* obtain pointer to j-th column */\r\n        col = lp.col[j];\r\n        /* check if the column is marked */\r\n        if (col.j != 0){\r\n            /* it is not marked; keep it */\r\n            col.j = ++n_new;\r\n            lp.col[col.j] = col;\r\n        }\r\n    }\r\n    /* set new number of columns */\r\n    lp.n = n_new;\r\n    /* if the basis header is still valid, adjust it */\r\n    if (lp.valid){\r\n        var m = lp.m;\r\n        var head = lp.head;\r\n        for (j = 1; j <= n_new; j++){\r\n            k = lp.col[j].bind;\r\n            if (k != 0){\r\n                xassert(1 <= k && k <= m);\r\n                head[k] = m + j;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_copy_prob = exports[\"glp_copy_prob\"] = function(dest, prob, names){\r\n    var tree = dest.tree;\r\n    var bfcp = {};\r\n    var i, j, len, ind;\r\n    var val;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_copy_prob: operation not allowed\");\r\n    if (dest == prob)\r\n        xerror(\"glp_copy_prob: copying problem object to itself not allowed\");\r\n    if (!(names == GLP_ON || names == GLP_OFF))\r\n        xerror(\"glp_copy_prob: names = \" + names + \"; invalid parameter\");\r\n    glp_erase_prob(dest);\r\n    if (names && prob.name != null)\r\n        glp_set_prob_name(dest, prob.name);\r\n    if (names && prob.obj != null)\r\n        glp_set_obj_name(dest, prob.obj);\r\n    dest.dir = prob.dir;\r\n    dest.c0 = prob.c0;\r\n    if (prob.m > 0)\r\n        glp_add_rows(dest, prob.m);\r\n    if (prob.n > 0)\r\n        glp_add_cols(dest, prob.n);\r\n    glp_get_bfcp(prob, bfcp);\r\n    glp_set_bfcp(dest, bfcp);\r\n    dest.pbs_stat = prob.pbs_stat;\r\n    dest.dbs_stat = prob.dbs_stat;\r\n    dest.obj_val = prob.obj_val;\r\n    dest.some = prob.some;\r\n    dest.ipt_stat = prob.ipt_stat;\r\n    dest.ipt_obj = prob.ipt_obj;\r\n    dest.mip_stat = prob.mip_stat;\r\n    dest.mip_obj = prob.mip_obj;\r\n    var to, from;\r\n    for (i = 1; i <= prob.m; i++){\r\n        to = dest.row[i];\r\n        from = prob.row[i];\r\n        if (names && from.name != null)\r\n            glp_set_row_name(dest, i, from.name);\r\n        to.type = from.type;\r\n        to.lb = from.lb;\r\n        to.ub = from.ub;\r\n        to.rii = from.rii;\r\n        to.stat = from.stat;\r\n        to.prim = from.prim;\r\n        to.dual = from.dual;\r\n        to.pval = from.pval;\r\n        to.dval = from.dval;\r\n        to.mipx = from.mipx;\r\n    }\r\n    ind = new Int32Array(1+prob.m);\r\n    val = new Float64Array(1+prob.m);\r\n    for (j = 1; j <= prob.n; j++){\r\n        to = dest.col[j];\r\n        from = prob.col[j];\r\n        if (names && from.name != null)\r\n            glp_set_col_name(dest, j, from.name);\r\n        to.kind = from.kind;\r\n        to.type = from.type;\r\n        to.lb = from.lb;\r\n        to.ub = from.ub;\r\n        to.coef = from.coef;\r\n        len = glp_get_mat_col(prob, j, ind, val);\r\n        glp_set_mat_col(dest, j, len, ind, val);\r\n        to.sjj = from.sjj;\r\n        to.stat = from.stat;\r\n        to.prim = from.prim;\r\n        to.dual = from.dual;\r\n        to.pval = from.pval;\r\n        to.dval = from.dval;\r\n        to.mipx = from.mipx;\r\n    }\r\n};\r\n\r\nvar glp_erase_prob = exports[\"glp_erase_prob\"] = function(lp){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_erase_prob: operation not allowed\");\r\n    delete_prob(lp);\r\n    create_prob(lp);\r\n};\r\n\r\nfunction delete_prob(lp){\r\n    lp.magic = 0x3F3F3F3F;\r\n    lp.parms = null;\r\n    xassert(lp.tree == null);\r\n    lp.row = null;\r\n    lp.col = null;\r\n    lp.r_tree = null;\r\n    lp.c_tree = null;\r\n    lp.head = null;\r\n    lp.bfcp = null;\r\n    lp.bfd = null;\r\n}\r\n\r\nvar glp_get_prob_name = exports[\"glp_get_prob_name\"] = function(lp){\r\n    return lp.name;\r\n};\r\n\r\nvar glp_get_obj_name = exports[\"glp_get_obj_name\"] = function(lp){\r\n    return lp.obj;\r\n};\r\n\r\nvar glp_get_obj_dir = exports[\"glp_get_obj_dir\"] = function(lp){\r\n    return lp.dir;\r\n};\r\n\r\nvar glp_get_num_rows = exports[\"glp_get_num_rows\"] = function(lp){\r\n    return lp.m;\r\n};\r\n\r\nvar glp_get_num_cols = exports[\"glp_get_num_cols\"] = function(lp){\r\n    return lp.n;\r\n};\r\n\r\nvar glp_get_row_name = exports[\"glp_get_row_name\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_name: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].name;\r\n};\r\n\r\nvar glp_get_col_name = exports[\"glp_get_col_name\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_name: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].name;\r\n};\r\n\r\nvar glp_get_row_type = exports[\"glp_get_row_type\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_type: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].type;\r\n};\r\n\r\nvar glp_get_row_lb = exports[\"glp_get_row_lb\"] = function(lp, i){\r\n    var lb;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_lb: i = \" + i + \"; row number out of range\");\r\n    switch (lp.row[i].type){\r\n        case GLP_FR:\r\n        case GLP_UP:\r\n            lb = -DBL_MAX; break;\r\n        case GLP_LO:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            lb = lp.row[i].lb; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return lb;\r\n};\r\n\r\nvar glp_get_row_ub = exports[\"glp_get_row_ub\"] = function(lp, i){\r\n    var ub;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_ub: i = \" + i + \"; row number out of range\");\r\n    switch (lp.row[i].type){\r\n        case GLP_FR:\r\n        case GLP_LO:\r\n            ub = +DBL_MAX; break;\r\n        case GLP_UP:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            ub = lp.row[i].ub; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return ub;\r\n};\r\n\r\nvar glp_get_col_type = exports[\"glp_get_col_type\"] = function(lp, j)\r\n{     if (!(1 <= j && j <= lp.n))\r\n    xerror(\"glp_get_col_type: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].type;\r\n};\r\n\r\nvar glp_get_col_lb = exports[\"glp_get_col_lb\"] = function(lp, j){\r\n    var lb;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_lb: j = \" + j + \"; column number out of range\");\r\n    switch (lp.col[j].type){\r\n        case GLP_FR:\r\n        case GLP_UP:\r\n            lb = -DBL_MAX; break;\r\n        case GLP_LO:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            lb = lp.col[j].lb; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return lb;\r\n};\r\n\r\nvar glp_get_col_ub = exports[\"glp_get_col_ub\"] = function(lp, j){\r\n    var ub;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_ub: j = \" + j + \"; column number out of range\");\r\n    switch (lp.col[j].type){\r\n        case GLP_FR:\r\n        case GLP_LO:\r\n            ub = +DBL_MAX; break;\r\n        case GLP_UP:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            ub = lp.col[j].ub; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return ub;\r\n};\r\n\r\nvar glp_get_obj_coef = exports[\"glp_get_obj_coef\"] = function(lp, j){\r\n    if (!(0 <= j && j <= lp.n))\r\n        xerror(\"glp_get_obj_coef: j = \" + j + \"; column number out of range\");\r\n    return j == 0 ? lp.c0 : lp.col[j].coef;\r\n};\r\n\r\nvar glp_get_num_nz = exports[\"glp_get_num_nz\"] = function (lp){\r\n    return lp.nnz;\r\n};\r\n\r\nvar glp_get_mat_row = exports[\"glp_get_mat_row\"] = function(lp, i, ind, val){\r\n    var aij;\r\n    var len;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_mat_row: i = \" + i + \"; row number out of range\");\r\n    len = 0;\r\n    for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n        len++;\r\n        if (ind != null) ind[len] = aij.col.j;\r\n        if (val != null) val[len] = aij.val;\r\n    }\r\n    xassert(len <= lp.n);\r\n    return len;\r\n};\r\n\r\nvar glp_get_mat_col = exports[\"glp_get_mat_col\"] = function(lp, j, ind, val){\r\n    var aij;\r\n    var len;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_mat_col: j = \" + j + \"; column number out of range\");\r\n    len = 0;\r\n    for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next){\r\n        len++;\r\n        if (ind != null) ind[len] = aij.row.i;\r\n        if (val != null) val[len] = aij.val;\r\n    }\r\n    xassert(len <= lp.m);\r\n    return len;\r\n};\r\n\r\nvar glp_create_index = exports[\"glp_create_index\"] = function(lp){\r\n    var row;\r\n    var col;\r\n    var i, j;\r\n    /* create row name index */\r\n    if (lp.r_tree == null){\r\n        lp.r_tree = {};\r\n        for (i = 1; i <= lp.m; i++){\r\n            row = lp.row[i];\r\n            if (row.name != null){\r\n                lp.r_tree[row.name] = row;\r\n            }\r\n        }\r\n    }\r\n    /* create column name index */\r\n    if (lp.c_tree == null)\r\n    {  lp.c_tree = {};\r\n        for (j = 1; j <= lp.n; j++){\r\n            col = lp.col[j];\r\n            if (col.name != null){\r\n                lp.c_tree[col.name] = col;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_find_row = exports[\"glp_find_row\"] = function(lp, name){\r\n    var i = 0;\r\n    if (lp.r_tree == null)\r\n        xerror(\"glp_find_row: row name index does not exist\");\r\n    var row = lp.r_tree[name];\r\n    if (row) i = row.i;\r\n    return i;\r\n};\r\n\r\nvar glp_find_col = exports[\"glp_find_col\"] = function(lp, name){\r\n    var j = 0;\r\n    if (lp.c_tree == null)\r\n        xerror(\"glp_find_col: column name index does not exist\");\r\n    var col = lp.c_tree[name];\r\n    if (col) j = col.j;\r\n    return j;\r\n};\r\n\r\nvar glp_delete_index = exports[\"glp_delete_index\"] = function(lp){\r\n    lp.r_tree = null;\r\n    lp.r_tree = null;\r\n};\r\n\r\nvar glp_set_rii = exports[\"glp_set_rii\"] = function(lp, i, rii){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_rii: i = \" + i + \"; row number out of range\");\r\n    if (rii <= 0.0)\r\n        xerror(\"glp_set_rii: i = \" + i + \"; rii = \" + rii + \"; invalid scale factor\");\r\n    if (lp.valid && lp.row[i].rii != rii){\r\n        for (var aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n            if (aij.col.stat == GLP_BS){\r\n                /* invalidate the basis factorization */\r\n                lp.valid = 0;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    lp.row[i].rii = rii;\r\n};\r\n\r\nvar glp_set_sjj = exports[\"glp_set_sjj\"] = function(lp, j, sjj){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_sjj: j = \" + j + \"; column number out of range\");\r\n    if (sjj <= 0.0)\r\n        xerror(\"glp_set_sjj: j = \" + j + \"; sjj = \" + sjj + \"; invalid scale factor\");\r\n    if (lp.valid && lp.col[j].sjj != sjj && lp.col[j].stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    lp.col[j].sjj = sjj;\r\n};\r\n\r\nvar glp_get_rii = exports[\"glp_get_rii\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_rii: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].rii;\r\n};\r\n\r\nvar glp_get_sjj = exports[\"glp_get_sjj\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_sjj: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].sjj;\r\n};\r\n\r\nvar glp_unscale_prob = exports[\"glp_unscale_prob\"] = function(lp){\r\n    var m = glp_get_num_rows(lp);\r\n    var n = glp_get_num_cols(lp);\r\n    var i, j;\r\n    for (i = 1; i <= m; i++) glp_set_rii(lp, i, 1.0);\r\n    for (j = 1; j <= n; j++) glp_set_sjj(lp, j, 1.0);\r\n};\r\n\r\nvar glp_set_row_stat = exports[\"glp_set_row_stat\"] = function(lp, i, stat){\r\n    var row;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_stat: i = \" + i + \"; row number out of range\");\r\n    if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))\r\n        xerror(\"glp_set_row_stat: i = \" + i + \"; stat = \" + stat + \"; invalid status\");\r\n    row = lp.row[i];\r\n    if (stat != GLP_BS){\r\n        switch (row.type){\r\n            case GLP_FR: stat = GLP_NF; break;\r\n            case GLP_LO: stat = GLP_NL; break;\r\n            case GLP_UP: stat = GLP_NU; break;\r\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\r\n            case GLP_FX: stat = GLP_NS; break;\r\n            default: xassert(row != row);\r\n        }\r\n    }\r\n    if (row.stat == GLP_BS && stat != GLP_BS || row.stat != GLP_BS && stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    row.stat = stat;\r\n};\r\n\r\nvar glp_set_col_stat = exports[\"glp_set_col_stat\"] = function(lp, j, stat){\r\n    var col;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_stat: j = \" + j + \"; column number out of range\");\r\n    if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))\r\n        xerror(\"glp_set_col_stat: j = \" + j + \"; stat = \" + stat + \"; invalid status\");\r\n    col = lp.col[j];\r\n    if (stat != GLP_BS){\r\n        switch (col.type){\r\n            case GLP_FR: stat = GLP_NF; break;\r\n            case GLP_LO: stat = GLP_NL; break;\r\n            case GLP_UP: stat = GLP_NU; break;\r\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\r\n            case GLP_FX: stat = GLP_NS; break;\r\n            default: xassert(col != col);\r\n        }\r\n    }\r\n    if (col.stat == GLP_BS && stat != GLP_BS || col.stat != GLP_BS && stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    col.stat = stat;\r\n};\r\n\r\nvar glp_std_basis = exports[\"glp_std_basis\"] = function(lp){\r\n    var i, j;\r\n    /* make all auxiliary variables basic */\r\n    for (i = 1; i <= lp.m; i++)\r\n        glp_set_row_stat(lp, i, GLP_BS);\r\n    /* make all structural variables non-basic */\r\n    for (j = 1; j <= lp.n; j++){\r\n        var col = lp.col[j];\r\n        if (col.type == GLP_DB && Math.abs(col.lb) > Math.abs(col.ub))\r\n            glp_set_col_stat(lp, j, GLP_NU);\r\n        else\r\n            glp_set_col_stat(lp, j, GLP_NL);\r\n    }\r\n};\r\n\r\nvar glp_simplex = exports[\"glp_simplex\"] = function(P, parm){\r\n\r\n    function solve_lp(P, parm){\r\n        /* solve LP directly without using the preprocessor */\r\n        var ret;\r\n        if (!glp_bf_exists(P)){\r\n            ret = glp_factorize(P);\r\n            if (ret == 0){\r\n\r\n            }\r\n            else if (ret == GLP_EBADB){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is invalid\");\r\n            }\r\n            else if (ret == GLP_ESING){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is singular\");\r\n            }\r\n            else if (ret == GLP_ECOND){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is ill-conditioned\");\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n            if (ret != 0) return ret;\r\n        }\r\n        if (parm.meth == GLP_PRIMAL)\r\n            ret = spx_primal(P, parm);\r\n        else if (parm.meth == GLP_DUALP)\r\n        {  ret = spx_dual(P, parm);\r\n            if (ret == GLP_EFAIL && P.valid)\r\n                ret = spx_primal(P, parm);\r\n        }\r\n        else if (parm.meth == GLP_DUAL)\r\n            ret = spx_dual(P, parm);\r\n        else\r\n            xassert(parm != parm);\r\n        return ret;\r\n    }\r\n\r\n    function preprocess_and_solve_lp(P, parm){\r\n        /* solve LP using the preprocessor */\r\n        var npp;\r\n        var lp = null;\r\n        var bfcp = {};\r\n        var ret;\r\n\r\n\r\n        function post(){\r\n            /* postprocess solution from the transformed LP */\r\n            npp_postprocess(npp, lp);\r\n            /* the transformed LP is no longer needed */\r\n            lp = null;\r\n            /* store solution to the original problem */\r\n            npp_unload_sol(npp, P);\r\n            /* the original LP has been successfully solved */\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n\r\n\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Preprocessing...\");\r\n        /* create preprocessor workspace */\r\n        npp = npp_create_wksp();\r\n        /* load original problem into the preprocessor workspace */\r\n        npp_load_prob(npp, P, GLP_OFF, GLP_SOL, GLP_OFF);\r\n        /* process LP prior to applying primal/dual simplex method */\r\n        ret = npp_simplex(npp, parm);\r\n        if (ret == 0)\r\n        {\r\n\r\n        }\r\n        else if (ret == GLP_ENOPFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\");\r\n        }\r\n        else if (ret == GLP_ENODFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* build transformed LP */\r\n        lp = glp_create_prob();\r\n        npp_build_prob(npp, lp);\r\n        /* if the transformed LP is empty, it has empty solution, which\r\n         is optimal */\r\n        if (lp.m == 0 && lp.n == 0)\r\n        {  lp.pbs_stat = lp.dbs_stat = GLP_FEAS;\r\n            lp.obj_val = lp.c0;\r\n            if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0)\r\n            {  xprintf(P.it_cnt + \": obj = \" + lp.obj_val + \"  infeas = 0.0\");\r\n            }\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OPTIMAL SOLUTION FOUND BY LP PREPROCESSOR\");\r\n            return post();\r\n        }\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n        {  xprintf(lp.m + \" row\" + (lp.m == 1 ? \"\" : \"s\") + \", \" + lp.n + \" column\" + (lp.n == 1 ? \"\" : \"s\") + \", \"\r\n            + lp.nnz + \" non-zero\" + (lp.nnz == 1 ? \"\" : \"s\") + \"\");\r\n        }\r\n        /* inherit basis factorization control parameters */\r\n        glp_get_bfcp(P, bfcp);\r\n        glp_set_bfcp(lp, bfcp);\r\n        /* scale the transformed problem */\r\n\r\n        {   var env = get_env_ptr();\r\n            var term_out = env.term_out;\r\n            if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n                env.term_out = GLP_OFF;\r\n            else\r\n                env.term_out = GLP_ON;\r\n            glp_scale_prob(lp, GLP_SF_AUTO);\r\n            env.term_out = term_out;\r\n        }\r\n        /* build advanced initial basis */\r\n        {   env = get_env_ptr();\r\n            term_out = env.term_out;\r\n            if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n                env.term_out = GLP_OFF;\r\n            else\r\n                env.term_out = GLP_ON;\r\n            glp_adv_basis(lp, 0);\r\n            env.term_out = term_out;\r\n        }\r\n        /* solve the transformed LP */\r\n        lp.it_cnt = P.it_cnt;\r\n        ret = solve_lp(lp, parm);\r\n        P.it_cnt = lp.it_cnt;\r\n        /* only optimal solution can be postprocessed */\r\n        if (!(ret == 0 && lp.pbs_stat == GLP_FEAS && lp.dbs_stat == GLP_FEAS)){\r\n            if (parm.msg_lev >= GLP_MSG_ERR)\r\n                xprintf(\"glp_simplex: unable to recover undefined or non-optimal solution\");\r\n            if (ret == 0){\r\n                if (lp.pbs_stat == GLP_NOFEAS)\r\n                    ret = GLP_ENOPFS;\r\n                else if (lp.dbs_stat == GLP_NOFEAS)\r\n                    ret = GLP_ENODFS;\r\n                else\r\n                    xassert(lp != lp);\r\n            }\r\n            return ret;\r\n        }\r\n        return post();\r\n    }\r\n\r\n    function trivial_lp(P, parm){\r\n        /* solve trivial LP which has empty constraint matrix */\r\n        var row, col;\r\n        var i, j;\r\n        var p_infeas, d_infeas, zeta;\r\n        P.valid = 0;\r\n        P.pbs_stat = P.dbs_stat = GLP_FEAS;\r\n        P.obj_val = P.c0;\r\n        P.some = 0;\r\n        p_infeas = d_infeas = 0.0;\r\n        /* make all auxiliary variables basic */\r\n        for (i = 1; i <= P.m; i++){\r\n            row = P.row[i];\r\n            row.stat = GLP_BS;\r\n            row.prim = row.dual = 0.0;\r\n            /* check primal feasibility */\r\n            if (row.type == GLP_LO || row.type == GLP_DB || row.type == GLP_FX){\r\n                /* row has lower bound */\r\n                if (row.lb > + parm.tol_bnd){\r\n                    P.pbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth != GLP_PRIMAL)\r\n                        P.some = i;\r\n                }\r\n                if (p_infeas < + row.lb)\r\n                    p_infeas = + row.lb;\r\n            }\r\n            if (row.type == GLP_UP || row.type == GLP_DB || row.type == GLP_FX){\r\n                /* row has upper bound */\r\n                if (row.ub < - parm.tol_bnd){\r\n                    P.pbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth != GLP_PRIMAL)\r\n                        P.some = i;\r\n                }\r\n                if (p_infeas < - row.ub)\r\n                    p_infeas = - row.ub;\r\n            }\r\n        }\r\n        /* determine scale factor for the objective row */\r\n        zeta = 1.0;\r\n        for (j = 1; j <= P.n; j++)\r\n        {  col = P.col[j];\r\n            if (zeta < Math.abs(col.coef)) zeta = Math.abs(col.coef);\r\n        }\r\n        zeta = (P.dir == GLP_MIN ? +1.0 : -1.0) / zeta;\r\n        /* make all structural variables non-basic */\r\n\r\n        function lo(){col.stat = GLP_NL; col.prim = col.lb}\r\n        function up(){col.stat = GLP_NU; col.prim = col.ub}\r\n\r\n        for (j = 1; j <= P.n; j++)\r\n        {  col = P.col[j];\r\n            if (col.type == GLP_FR){\r\n                col.stat = GLP_NF; col.prim = 0.0;\r\n            }\r\n            else if (col.type == GLP_LO)\r\n                lo();\r\n            else if (col.type == GLP_UP)\r\n                up();\r\n            else if (col.type == GLP_DB)\r\n            {  if (zeta * col.coef > 0.0)\r\n                lo();\r\n            else if (zeta * col.coef < 0.0)\r\n                up();\r\n            else if (Math.abs(col.lb) <= Math.abs(col.ub))\r\n                lo();\r\n            else\r\n                up();\r\n            }\r\n            else if (col.type == GLP_FX){\r\n                col.stat = GLP_NS; col.prim = col.lb;\r\n            }\r\n            col.dual = col.coef;\r\n            P.obj_val += col.coef * col.prim;\r\n            /* check dual feasibility */\r\n            if (col.type == GLP_FR || col.type == GLP_LO){\r\n                /* column has no upper bound */\r\n                if (zeta * col.dual < - parm.tol_dj){\r\n                    P.dbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth == GLP_PRIMAL)\r\n                        P.some = P.m + j;\r\n                }\r\n                if (d_infeas < - zeta * col.dual)\r\n                    d_infeas = - zeta * col.dual;\r\n            }\r\n            if (col.type == GLP_FR || col.type == GLP_UP)\r\n            {  /* column has no lower bound */\r\n                if (zeta * col.dual > + parm.tol_dj)\r\n                {  P.dbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth == GLP_PRIMAL)\r\n                        P.some = P.m + j;\r\n                }\r\n                if (d_infeas < + zeta * col.dual)\r\n                    d_infeas = + zeta * col.dual;\r\n            }\r\n        }\r\n        /* simulate the simplex solver output */\r\n        if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0){\r\n            xprintf(\"~\" + P.it_cnt + \": obj = \" + P.obj_val + \"  infeas = \" + (parm.meth == GLP_PRIMAL ? p_infeas : d_infeas) + \"\");\r\n        }\r\n        if (parm.msg_lev >= GLP_MSG_ALL && parm.out_dly == 0){\r\n            if (P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS)\r\n                xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n            else if (P.pbs_stat == GLP_NOFEAS)\r\n                xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n            else if (parm.meth == GLP_PRIMAL)\r\n                xprintf(\"PROBLEM HAS UNBOUNDED SOLUTION\");\r\n            else\r\n                xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n    }\r\n\r\n    /* solve LP problem with the simplex method */\r\n    var i, j, ret;\r\n    /* check problem object */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_simplex: P = \" + P + \"; invalid problem object\");\r\n    if (P.tree != null && P.tree.reason != 0)\r\n        xerror(\"glp_simplex: operation not allowed\");\r\n    /* check control parameters */\r\n    if (parm == null){\r\n        parm = new SMCP();\r\n    }\r\n    if (!(parm.msg_lev == GLP_MSG_OFF ||\r\n        parm.msg_lev == GLP_MSG_ERR ||\r\n        parm.msg_lev == GLP_MSG_ON  ||\r\n        parm.msg_lev == GLP_MSG_ALL ||\r\n        parm.msg_lev == GLP_MSG_DBG))\r\n        xerror(\"glp_simplex: msg_lev = \" + parm.msg_lev + \"; invalid parameter\");\r\n    if (!(parm.meth == GLP_PRIMAL ||\r\n        parm.meth == GLP_DUALP  ||\r\n        parm.meth == GLP_DUAL))\r\n        xerror(\"glp_simplex: meth = \" + parm.meth + \"; invalid parameter\");\r\n    if (!(parm.pricing == GLP_PT_STD || parm.pricing == GLP_PT_PSE))\r\n        xerror(\"glp_simplex: pricing = \" + parm.pricing + \"; invalid parameter\");\r\n    if (!(parm.r_test == GLP_RT_STD || parm.r_test == GLP_RT_HAR))\r\n        xerror(\"glp_simplex: r_test = \" + parm.r_test + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_bnd && parm.tol_bnd < 1.0))\r\n        xerror(\"glp_simplex: tol_bnd = \" + parm.tol_bnd + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_dj && parm.tol_dj < 1.0))\r\n        xerror(\"glp_simplex: tol_dj = \" + parm.tol_dj + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_piv && parm.tol_piv < 1.0))\r\n        xerror(\"glp_simplex: tol_piv = \" + parm.tol_piv + \"; invalid parameter\");\r\n    if (parm.it_lim < 0)\r\n        xerror(\"glp_simplex: it_lim = \" + parm.it_lim + \"; invalid parameter\");\r\n    if (parm.tm_lim < 0)\r\n        xerror(\"glp_simplex: tm_lim = \" + parm.tm_lim + \"; invalid parameter\");\r\n    if (parm.out_frq < 1)\r\n        xerror(\"glp_simplex: out_frq = \" + parm.out_frq + \"; invalid parameter\");\r\n    if (parm.out_dly < 0)\r\n        xerror(\"glp_simplex: out_dly = \" + parm.out_dly + \"; invalid parameter\");\r\n    if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))\r\n        xerror(\"glp_simplex: presolve = \" + parm.presolve + \"; invalid parameter\");\r\n    /* basic solution is currently undefined */\r\n    P.pbs_stat = P.dbs_stat = GLP_UNDEF;\r\n    P.obj_val = 0.0;\r\n    P.some = 0;\r\n    /* check bounds of double-bounded variables */\r\n    for (i = 1; i <= P.m; i++)\r\n    {  var row = P.row[i];\r\n        if (row.type == GLP_DB && row.lb >= row.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_simplex: row \" + i + \": lb = \" + row.lb + \", ub = \" + row.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  var col = P.col[j];\r\n        if (col.type == GLP_DB && col.lb >= col.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_simplex: column \" +  j + \": lb = \" + col.lb + \", ub = \" + col.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    /* solve LP problem */\r\n    if (parm.msg_lev >= GLP_MSG_ALL)\r\n    {   xprintf(\"GLPK Simplex Optimizer, v\" + glp_version() + \"\");\r\n        xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" +\r\n            P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\") + \"\");\r\n    }\r\n    if (P.nnz == 0){\r\n        trivial_lp(P, parm);\r\n        ret = 0;\r\n    }\r\n    else if (!parm.presolve)\r\n        ret = solve_lp(P, parm);\r\n    else\r\n        ret = preprocess_and_solve_lp(P, parm);\r\n    /* return to the application program */\r\n    return ret;\r\n};\r\n\r\n/***********************************************************************\r\n *  NAME\r\n *\r\n *  glp_init_smcp - initialize simplex method control parameters\r\n *\r\n *  SYNOPSIS\r\n *\r\n *  void glp_init_smcp(glp_smcp *parm);\r\n *\r\n *  DESCRIPTION\r\n *\r\n *  The routine glp_init_smcp initializes control parameters, which are\r\n *  used by the simplex solver, with default values.\r\n *\r\n *  Default values of the control parameters are stored in a glp_smcp\r\n *  structure, which the parameter parm points to. */\r\n\r\nvar SMCP = exports[\"SMCP\"] = /**@constructor*/ function(options){\r\n    options = options || {};\r\n    this.msg_lev = options[\"msg_lev\"] || GLP_MSG_ALL;\r\n    this.meth = options[\"meth\"] || GLP_PRIMAL;\r\n    this.pricing = options[\"pricing\"] || GLP_PT_PSE;\r\n    this.r_test = options[\"r_test\"] || GLP_RT_HAR;\r\n    this.tol_bnd = options[\"tol_bnd\"] || 1e-7;\r\n    this.tol_dj = options[\"tol_dj\"] || 1e-7;\r\n    this.tol_piv = options[\"tol_piv\"] || 1e-10;\r\n    this.obj_ll = options[\"obj_ll\"] || -DBL_MAX;\r\n    this.obj_ul = options[\"obj_ul\"] || +DBL_MAX;\r\n    this.it_lim = options[\"it_lim\"] || INT_MAX;\r\n    this.tm_lim = options[\"tm_lim\"] || INT_MAX;\r\n    this.out_frq = options[\"out_frq\"] || 500;\r\n    this.out_dly = options[\"out_dly\"] || 0;\r\n    this.presolve = options[\"presolve\"] || GLP_OFF;\r\n};\r\n\r\n/***********************************************************************\r\n *  NAME\r\n *\r\n *  glp_get_status - retrieve generic status of basic solution\r\n *\r\n *  SYNOPSIS\r\n *\r\n *  int glp_get_status(glp_prob *lp);\r\n *\r\n *  RETURNS\r\n *\r\n *  The routine glp_get_status reports the generic status of the basic\r\n *  solution for the specified problem object as follows:\r\n *\r\n *  GLP_OPT    - solution is optimal;\r\n *  GLP_FEAS   - solution is feasible;\r\n *  GLP_INFEAS - solution is infeasible;\r\n *  GLP_NOFEAS - problem has no feasible solution;\r\n *  GLP_UNBND  - problem has unbounded solution;\r\n *  GLP_UNDEF  - solution is undefined. */\r\n\r\nvar glp_get_status = exports[\"glp_get_status\"] = function(lp){\r\n    var status;\r\n    status = glp_get_prim_stat(lp);\r\n    switch (status)\r\n    {  case GLP_FEAS:\r\n        switch (glp_get_dual_stat(lp))\r\n        {  case GLP_FEAS:\r\n            status = GLP_OPT;\r\n            break;\r\n            case GLP_NOFEAS:\r\n                status = GLP_UNBND;\r\n                break;\r\n            case GLP_UNDEF:\r\n            case GLP_INFEAS:\r\n                //status = status;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        break;\r\n        case GLP_UNDEF:\r\n        case GLP_INFEAS:\r\n        case GLP_NOFEAS:\r\n            //status = status;\r\n            break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return status;\r\n};\r\n\r\nvar glp_get_prim_stat = exports[\"glp_get_prim_stat\"] = function(lp){\r\n    return lp.pbs_stat;\r\n};\r\n\r\nvar glp_get_dual_stat = exports[\"glp_get_dual_stat\"] = function(lp){\r\n    return lp.dbs_stat;\r\n};\r\n\r\nvar glp_get_obj_val = exports[\"glp_get_obj_val\"] = function(lp){\r\n    return lp.obj_val;\r\n};\r\n\r\nvar glp_get_row_stat = exports[\"glp_get_row_stat\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_stat: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].stat;\r\n};\r\n\r\nvar glp_get_row_prim = exports[\"glp_get_row_prim\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_prim: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].prim;\r\n};\r\n\r\nvar glp_get_row_dual = exports[\"glp_get_row_dual\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_dual: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].dual;\r\n};\r\n\r\nvar glp_get_col_stat = exports[\"glp_get_col_stat\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_stat: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].stat;\r\n};\r\n\r\nvar glp_get_col_prim = exports[\"glp_get_col_prim\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_prim: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].prim;\r\n};\r\n\r\nvar glp_get_col_dual = exports[\"glp_get_col_dual\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_dual: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].dual;\r\n};\r\n\r\nvar glp_get_unbnd_ray = exports[\"glp_get_unbnd_ray\"] = function(lp){\r\n    var k = lp.some;\r\n    xassert(k >= 0);\r\n    if (k > lp.m + lp.n) k = 0;\r\n    return k;\r\n};\r\n\r\nvar glp_set_col_kind = exports[\"glp_set_col_kind\"] = function(mip, j, kind){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_set_col_kind: j = \" + j + \"; column number out of range\");\r\n    var col = mip.col[j];\r\n    switch (kind)\r\n    {  case GLP_CV:\r\n        col.kind = GLP_CV;\r\n        break;\r\n        case GLP_IV:\r\n            col.kind = GLP_IV;\r\n            break;\r\n        case GLP_BV:\r\n            col.kind = GLP_IV;\r\n            if (!(col.type == GLP_DB && col.lb == 0.0 && col.ub ==\r\n                1.0)) glp_set_col_bnds(mip, j, GLP_DB, 0.0, 1.0);\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_col_kind: j = \" + j + \"; kind = \" + kind + \"; invalid column kind\");\r\n    }\r\n};\r\n\r\nvar glp_get_col_kind = exports[\"glp_get_col_kind\"] = function(mip, j){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_get_col_kind: j = \" + j + \"; column number out of range\");\r\n    var col = mip.col[j];\r\n    var kind = col.kind;\r\n    switch (kind)\r\n    {  case GLP_CV:\r\n        break;\r\n        case GLP_IV:\r\n            if (col.type == GLP_DB && col.lb == 0.0 && col.ub == 1.0)\r\n                kind = GLP_BV;\r\n            break;\r\n        default:\r\n            xassert(kind != kind);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar glp_get_num_int = exports[\"glp_get_num_int\"] = function(mip){\r\n    var col;\r\n    var count = 0;\r\n    for (var j = 1; j <= mip.n; j++)\r\n    {  col = mip.col[j];\r\n        if (col.kind == GLP_IV) count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nvar glp_get_num_bin = exports[\"glp_get_num_bin\"] = function(mip){\r\n    var col;\r\n    var count = 0;\r\n    for (var j = 1; j <= mip.n; j++)\r\n    {  col = mip.col[j];\r\n        if (col.kind == GLP_IV && col.type == GLP_DB && col.lb ==\r\n            0.0 && col.ub == 1.0) count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nvar glp_intopt = exports[\"glp_intopt\"] = function(P, parm){\r\n    function solve_mip(P, parm){\r\n        /* solve MIP directly without using the preprocessor */\r\n        var T;\r\n        var ret;\r\n        /* optimal basis to LP relaxation must be provided */\r\n        if (glp_get_status(P) != GLP_OPT)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: optimal basis to initial LP relaxation not provided\");\r\n            ret = GLP_EROOT;\r\n            return ret;\r\n        }\r\n        /* it seems all is ok */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Integer optimization begins...\");\r\n        /* create the branch-and-bound tree */\r\n        T = ios_create_tree(P, parm);\r\n        /* solve the problem instance */\r\n        ret = ios_driver(T);\r\n        /* delete the branch-and-bound tree */\r\n        ios_delete_tree(T);\r\n        /* analyze exit code reported by the mip driver */\r\n        if (ret == 0)\r\n        {  if (P.mip_stat == GLP_FEAS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"INTEGER OPTIMAL SOLUTION FOUND\");\r\n            P.mip_stat = GLP_OPT;\r\n        }\r\n        else\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\");\r\n            P.mip_stat = GLP_NOFEAS;\r\n        }\r\n        }\r\n        else if (ret == GLP_EMIPGAP)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINATED\");\r\n        }\r\n        else if (ret == GLP_ETMLIM)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n        }\r\n        else if (ret == GLP_EFAIL)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: cannot solve current LP relaxation\");\r\n        }\r\n        else if (ret == GLP_ESTOP)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"SEARCH TERMINATED BY APPLICATION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        return ret;\r\n    }\r\n\r\n    function preprocess_and_solve_mip(P, parm){\r\n        /* solve MIP using the preprocessor */\r\n        var env = get_env_ptr();\r\n        var term_out = env.term_out;\r\n        var npp;\r\n        var mip = null;\r\n        var bfcp = {};\r\n        var ret;\r\n\r\n        function post(){\r\n            npp_postprocess(npp, mip);\r\n            /* the transformed MIP is no longer needed */\r\n            mip = null;\r\n            /* store solution to the original problem */\r\n            npp_unload_sol(npp, P);\r\n            return ret;\r\n        }\r\n\r\n\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Preprocessing...\");\r\n        /* create preprocessor workspace */\r\n        npp = npp_create_wksp();\r\n        /* load original problem into the preprocessor workspace */\r\n        npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);\r\n        /* process MIP prior to applying the branch-and-bound method */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        ret = npp_integer(npp, parm);\r\n        env.term_out = term_out;\r\n        if (ret == 0)\r\n        {\r\n\r\n        }\r\n        else if (ret == GLP_ENOPFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\");\r\n        }\r\n        else if (ret == GLP_ENODFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* build transformed MIP */\r\n        mip = glp_create_prob();\r\n        npp_build_prob(npp, mip);\r\n        /* if the transformed MIP is empty, it has empty solution, which\r\n         is optimal */\r\n        if (mip.m == 0 && mip.n == 0)\r\n        {  mip.mip_stat = GLP_OPT;\r\n            mip.mip_obj = mip.c0;\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n            {  xprintf(\"Objective value = \" + mip.mip_obj + \"\");\r\n                xprintf(\"INTEGER OPTIMAL SOLUTION FOUND BY MIP PREPROCESSOR\");\r\n            }\r\n            return post();\r\n        }\r\n        /* display some statistics */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n        {   var ni = glp_get_num_int(mip);\r\n            var nb = glp_get_num_bin(mip);\r\n            var s;\r\n            xprintf(mip.m + \" row\" + (mip.m == 1 ? \"\" : \"s\") + \", \" + mip.n + \" column\" + (mip.n == 1 ? \"\" : \"s\") +\r\n                \", \" + mip.nnz + \" non-zero\" + (mip.nnz == 1 ? \"\" : \"s\") + \"\");\r\n            if (nb == 0)\r\n                s = \"none of\";\r\n            else if (ni == 1 && nb == 1)\r\n                s = \"\";\r\n            else if (nb == 1)\r\n                s = \"one of\";\r\n            else if (nb == ni)\r\n                s = \"all of\";\r\n            else\r\n                s = nb + \" of\";\r\n            xprintf(ni + \" integer variable\" + (ni == 1 ? \"\" : \"s\") + \", \" + s + \" which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n        }\r\n        /* inherit basis factorization control parameters */\r\n        glp_get_bfcp(P, bfcp);\r\n        glp_set_bfcp(mip, bfcp);\r\n        /* scale the transformed problem */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        glp_scale_prob(mip,\r\n            GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP);\r\n        env.term_out = term_out;\r\n        /* build advanced initial basis */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        glp_adv_basis(mip, 0);\r\n        env.term_out = term_out;\r\n        /* solve initial LP relaxation */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Solving LP relaxation...\");\r\n        var smcp = new SMCP();\r\n        //glp_init_smcp(smcp);\r\n\r\n        smcp.msg_lev = parm.msg_lev;\r\n        mip.it_cnt = P.it_cnt;\r\n        ret = glp_simplex(mip, smcp);\r\n        P.it_cnt = mip.it_cnt;\r\n        if (ret != 0)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: cannot solve LP relaxation\");\r\n            ret = GLP_EFAIL;\r\n            return ret;\r\n        }\r\n        /* check status of the basic solution */\r\n        ret = glp_get_status(mip);\r\n        if (ret == GLP_OPT)\r\n            ret = 0;\r\n        else if (ret == GLP_NOFEAS)\r\n            ret = GLP_ENOPFS;\r\n        else if (ret == GLP_UNBND)\r\n            ret = GLP_ENODFS;\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* solve the transformed MIP */\r\n        mip.it_cnt = P.it_cnt;\r\n        ret = solve_mip(mip, parm);\r\n        P.it_cnt = mip.it_cnt;\r\n        /* only integer feasible solution can be postprocessed */\r\n        if (!(mip.mip_stat == GLP_OPT || mip.mip_stat == GLP_FEAS))\r\n        {  P.mip_stat = mip.mip_stat;\r\n            return ret;\r\n        }\r\n        return post();\r\n    }\r\n\r\n    /* solve MIP problem with the branch-and-bound method */\r\n    var i, j, ret, col;\r\n    /* check problem object */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_intopt: P = \" + P + \"; invalid problem object\");\r\n    if (P.tree != null)\r\n        xerror(\"glp_intopt: operation not allowed\");\r\n    /* check control parameters */\r\n    if (parm == null){\r\n        parm = new IOCP();\r\n        //glp_init_iocp(parm);\r\n    }\r\n    if (!(parm.msg_lev == GLP_MSG_OFF ||\r\n        parm.msg_lev == GLP_MSG_ERR ||\r\n        parm.msg_lev == GLP_MSG_ON  ||\r\n        parm.msg_lev == GLP_MSG_ALL ||\r\n        parm.msg_lev == GLP_MSG_DBG))\r\n        xerror(\"glp_intopt: msg_lev = \" + parm.msg_lev + \"; invalid parameter\");\r\n    if (!(parm.br_tech == GLP_BR_FFV ||\r\n        parm.br_tech == GLP_BR_LFV ||\r\n        parm.br_tech == GLP_BR_MFV ||\r\n        parm.br_tech == GLP_BR_DTH ||\r\n        parm.br_tech == GLP_BR_PCH))\r\n        xerror(\"glp_intopt: br_tech = \" + parm.br_tech + \"; invalid parameter\");\r\n    if (!(parm.bt_tech == GLP_BT_DFS ||\r\n        parm.bt_tech == GLP_BT_BFS ||\r\n        parm.bt_tech == GLP_BT_BLB ||\r\n        parm.bt_tech == GLP_BT_BPH))\r\n        xerror(\"glp_intopt: bt_tech = \" + parm.bt_tech + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_int && parm.tol_int < 1.0))\r\n        xerror(\"glp_intopt: tol_int = \" + parm.tol_int + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_obj && parm.tol_obj < 1.0))\r\n        xerror(\"glp_intopt: tol_obj = \" + parm.tol_obj + \"; invalid parameter\");\r\n    if (parm.tm_lim < 0)\r\n        xerror(\"glp_intopt: tm_lim = \" + parm.tm_lim + \"; invalid parameter\");\r\n    if (parm.out_frq < 0)\r\n        xerror(\"glp_intopt: out_frq = \" + parm.out_frq + \"; invalid parameter\");\r\n    if (parm.out_dly < 0)\r\n        xerror(\"glp_intopt: out_dly = \" + parm.out_dly + \"; invalid parameter\");\r\n    if (!(0 <= parm.cb_size && parm.cb_size <= 256))\r\n        xerror(\"glp_intopt: cb_size = \" + parm.cb_size + \"; invalid parameter\");\r\n    if (!(parm.pp_tech == GLP_PP_NONE ||\r\n        parm.pp_tech == GLP_PP_ROOT ||\r\n        parm.pp_tech == GLP_PP_ALL))\r\n        xerror(\"glp_intopt: pp_tech = \" + parm.pp_tech + \"; invalid parameter\");\r\n    if (parm.mip_gap < 0.0)\r\n        xerror(\"glp_intopt: mip_gap = \" + parm.mip_gap + \"; invalid parameter\");\r\n    if (!(parm.mir_cuts == GLP_ON || parm.mir_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: mir_cuts = \" + parm.mir_cuts + \"; invalid parameter\");\r\n    if (!(parm.gmi_cuts == GLP_ON || parm.gmi_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: gmi_cuts = \" + parm.gmi_cuts + \"; invalid parameter\");\r\n    if (!(parm.cov_cuts == GLP_ON || parm.cov_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: cov_cuts = \" + parm.cov_cuts + \"; invalid parameter\");\r\n    if (!(parm.clq_cuts == GLP_ON || parm.clq_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: clq_cuts = \" + parm.clq_cuts + \"; invalid parameter\");\r\n    if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))\r\n        xerror(\"glp_intopt: presolve = \" + parm.presolve + \"; invalid parameter\");\r\n    if (!(parm.binarize == GLP_ON || parm.binarize == GLP_OFF))\r\n        xerror(\"glp_intopt: binarize = \" + parm.binarize + \"; invalid parameter\");\r\n    if (!(parm.fp_heur == GLP_ON || parm.fp_heur == GLP_OFF))\r\n        xerror(\"glp_intopt: fp_heur = \" + parm.fp_heur + \"; invalid parameter\");\r\n    /* integer solution is currently undefined */\r\n    P.mip_stat = GLP_UNDEF;\r\n    P.mip_obj = 0.0;\r\n    /* check bounds of double-bounded variables */\r\n    for (i = 1; i <= P.m; i++)\r\n    {   var row = P.row[i];\r\n        if (row.type == GLP_DB && row.lb >= row.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: row \" + i + \": lb = \" + row.lb + \", ub = \" + row.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {   col = P.col[j];\r\n        if (col.type == GLP_DB && col.lb >= col.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: column \" + j + \": lb = \" + col.lb + \", ub = \" + col.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    /* bounds of all integer variables must be integral */\r\n    for (j = 1; j <= P.n; j++)\r\n    {   col = P.col[j];\r\n        if (col.kind != GLP_IV) continue;\r\n        if (col.type == GLP_LO || col.type == GLP_DB)\r\n        {  if (col.lb != Math.floor(col.lb))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer lower bound \" + col.lb + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n        if (col.type == GLP_UP || col.type == GLP_DB)\r\n        {  if (col.ub != Math.floor(col.ub))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer upper bound \" + col.ub + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n        if (col.type == GLP_FX)\r\n        {  if (col.lb != Math.floor(col.lb))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer fixed value \" + col.lb + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n    }\r\n    /* solve MIP problem */\r\n    if (parm.msg_lev >= GLP_MSG_ALL)\r\n    {   var ni = glp_get_num_int(P);\r\n        var nb = glp_get_num_bin(P);\r\n        var s;\r\n        xprintf(\"GLPK Integer Optimizer, v\" + glp_version() + \"\");\r\n        xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" + P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\") + \"\");\r\n        if (nb == 0)\r\n            s = \"none of\";\r\n        else if (ni == 1 && nb == 1)\r\n            s = \"\";\r\n        else if (nb == 1)\r\n            s = \"one of\";\r\n        else if (nb == ni)\r\n            s = \"all of\";\r\n        else\r\n            s = nb + \" of\";\r\n        xprintf(ni + \" integer variable\" + (ni == 1 ? \"\" : \"s\") + \", \" + s + \" which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n    }\r\n    if (!parm.presolve)\r\n        ret = solve_mip(P, parm);\r\n    else\r\n        ret = preprocess_and_solve_mip(P, parm);\r\n    /* return to the application program */\r\n    return ret;\r\n};\r\n\r\nvar IOCP = exports[\"IOCP\"] = /**@constructor*/ function(options){\r\n    options = options || {};\r\n    this.msg_lev = options[\"msg_lev\"] ||  GLP_MSG_ALL;\r\n    this.br_tech = options[\"br_tech\"] || GLP_BR_DTH;\r\n    this.bt_tech = options[\"bt_tech\"] || GLP_BT_BLB;\r\n    this.tol_int = options[\"tol_int\"] || 1e-5;\r\n    this.tol_obj = options[\"tol_obj\"] || 1e-7;\r\n    this.tm_lim = options[\"tm_lim\"] || INT_MAX;\r\n    this.out_frq = options[\"out_frq\"] || 5000;\r\n    this.out_dly = options[\"out_dly\"] || 10000;\r\n    this.cb_func = options[\"cb_func\"] || null;\r\n    this.cb_info = options[\"cb_info\"] || null;\r\n    this.cb_size = options[\"cb_size\"] || 0;\r\n    this.pp_tech = options[\"pp_tech\"] || GLP_PP_ALL;\r\n    this.mip_gap = options[\"mip_gap\"] || 0.0;\r\n    this.mir_cuts = options[\"mir_cuts\"] || GLP_OFF;\r\n    this.gmi_cuts = options[\"gmi_cuts\"] || GLP_OFF;\r\n    this.cov_cuts = options[\"cov_cuts\"] || GLP_OFF;\r\n    this.clq_cuts = options[\"clq_cuts\"] || GLP_OFF;\r\n    this.presolve = options[\"presolve\"] || GLP_OFF;\r\n    this.binarize = options[\"binarize\"] || GLP_OFF;\r\n    this.fp_heur = options[\"fp_heur\"] || GLP_OFF;\r\n};\r\n\r\n/*\r\nvar glp_init_iocp = exports[\"glp_init_iocp\"] = function(parm){\r\n    parm.msg_lev = GLP_MSG_ALL;\r\n    parm.br_tech = GLP_BR_DTH;\r\n    parm.bt_tech = GLP_BT_BLB;\r\n    parm.tol_int = 1e-5;\r\n    parm.tol_obj = 1e-7;\r\n    parm.tm_lim = INT_MAX;\r\n    parm.out_frq = 5000;\r\n    parm.out_dly = 10000;\r\n    parm.cb_func = null;\r\n    parm.cb_info = null;\r\n    parm.cb_size = 0;\r\n    parm.pp_tech = GLP_PP_ALL;\r\n    parm.mip_gap = 0.0;\r\n    parm.mir_cuts = GLP_OFF;\r\n    parm.gmi_cuts = GLP_OFF;\r\n    parm.cov_cuts = GLP_OFF;\r\n    parm.clq_cuts = GLP_OFF;\r\n    parm.presolve = GLP_OFF;\r\n    parm.binarize = GLP_OFF;\r\n    parm.fp_heur = GLP_OFF;\r\n};\r\n*/\r\n\r\nvar glp_mip_status = exports[\"glp_mip_status\"] = function(mip){\r\n    return mip.mip_stat;\r\n};\r\n\r\nvar glp_mip_obj_val = exports[\"glp_mip_obj_val\"] = function(mip){\r\n    return mip.mip_obj;\r\n};\r\n\r\nvar glp_mip_row_val = exports[\"glp_mip_row_val\"] = function(mip, i){\r\n    if (!(1 <= i && i <= mip.m))\r\n        xerror(\"glp_mip_row_val: i = \" + i + \"; row number out of range\");\r\n    return mip.row[i].mipx;\r\n};\r\n\r\nvar glp_mip_col_val = exports[\"glp_mip_col_val\"] = function(mip, j){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_mip_col_val: j = \" + j + \"; column number out of range\");\r\n    return mip.col[j].mipx;\r\n};\r\n\r\nfunction glp_check_kkt(P, sol, cond, callback){\r\n    /* check feasibility and optimality conditions */\r\n    var m = P.m;\r\n    var n = P.n;\r\n    var row, col, aij;\r\n    var i, j, ae_ind, re_ind;\r\n    var e, sp, sn, t, ae_max, re_max;\r\n    if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\r\n        xerror(\"glp_check_kkt: sol = \" + sol + \"; invalid solution indicator\");\r\n    if (!(cond == GLP_KKT_PE || cond == GLP_KKT_PB ||\r\n        cond == GLP_KKT_DE || cond == GLP_KKT_DB ||\r\n        cond == GLP_KKT_CS))\r\n        xerror(\"glp_check_kkt: cond = \" + cond + \"; invalid condition indicator \");\r\n    ae_max = re_max = 0.0;\r\n    ae_ind = re_ind = 0;\r\n    if (cond == GLP_KKT_PE)\r\n    {  /* xR - A * xS = 0 */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            sp = sn = 0.0;\r\n            /* t := xR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = row.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = row.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            if (t >= 0.0) sp += t; else sn -= t;\r\n            for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            {  col = aij.col;\r\n                /* t := - a[i,j] * xS[j] */\r\n                if (sol == GLP_SOL)\r\n                    t = - aij.val * col.prim;\r\n                else if (sol == GLP_IPT)\r\n                    t = - aij.val * col.pval;\r\n                else if (sol == GLP_MIP)\r\n                    t = - aij.val * col.mipx;\r\n                else\r\n                    xassert(sol != sol);\r\n                if (t >= 0.0) sp += t; else sn -= t;\r\n            }\r\n            /* absolute error */\r\n            e = Math.abs(sp - sn);\r\n            if (ae_max < e){\r\n                ae_max = e;\r\n                ae_ind = i;\r\n            }\r\n            /* relative error */\r\n            e /= (1.0 + sp + sn);\r\n            if (re_max < e){\r\n                re_max = e;\r\n                re_ind = i;\r\n            }\r\n\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_PB)\r\n    {  /* lR <= xR <= uR */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            /* t := xR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = row.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = row.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            /* check lower bound */\r\n            if (row.type == GLP_LO || row.type == GLP_DB ||\r\n                row.type == GLP_FX)\r\n            {  if (t < row.lb)\r\n            {  /* absolute error */\r\n                e = row.lb - t;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = i;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(row.lb));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = i;\r\n                }\r\n            }\r\n            }\r\n            /* check upper bound */\r\n            if (row.type == GLP_UP || row.type == GLP_DB ||\r\n                row.type == GLP_FX)\r\n            {  if (t > row.ub)\r\n            {  /* absolute error */\r\n                e = t - row.ub;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = i;\r\n                }\r\n\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(row.ub));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = i;\r\n                }\r\n            }\r\n            }\r\n        }\r\n        /* lS <= xS <= uS */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            /* t := xS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = col.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = col.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            /* check lower bound */\r\n            if (col.type == GLP_LO || col.type == GLP_DB ||\r\n                col.type == GLP_FX)\r\n            {  if (t < col.lb)\r\n            {  /* absolute error */\r\n                e = col.lb - t;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = m+j;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(col.lb));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n            /* check upper bound */\r\n            if (col.type == GLP_UP || col.type == GLP_DB ||\r\n                col.type == GLP_FX)\r\n            {  if (t > col.ub)\r\n            {  /* absolute error */\r\n                e = t - col.ub;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = m+j;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(col.ub));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_DE)\r\n    {  /* A' * (lambdaR - cR) + (lambdaS - cS) = 0 */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            sp = sn = 0.0;\r\n            /* t := lambdaS[j] - cS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.dual - col.coef;\r\n            else if (sol == GLP_IPT)\r\n                t = col.dval - col.coef;\r\n            else\r\n                xassert(sol != sol);\r\n            if (t >= 0.0) sp += t; else sn -= t;\r\n            for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            {  row = aij.row;\r\n                /* t := a[i,j] * (lambdaR[i] - cR[i]) */\r\n                if (sol == GLP_SOL)\r\n                    t = aij.val * row.dual;\r\n                else if (sol == GLP_IPT)\r\n                    t = aij.val * row.dval;\r\n                else\r\n                    xassert(sol != sol);\r\n                if (t >= 0.0) sp += t; else sn -= t;\r\n            }\r\n            /* absolute error */\r\n            e = Math.abs(sp - sn);\r\n            if (ae_max < e){\r\n                ae_max = e;\r\n                ae_ind = m+j;\r\n            }\r\n            /* relative error */\r\n            e /= (1.0 + sp + sn);\r\n            if (re_max < e){\r\n                re_max = e;\r\n                re_ind = m+j;\r\n            }\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_DB)\r\n    {  /* check lambdaR */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            /* t := lambdaR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.dual;\r\n            else if (sol == GLP_IPT)\r\n                t = row.dval;\r\n            else\r\n                xassert(sol != sol);\r\n            /* correct sign */\r\n            if (P.dir == GLP_MIN)\r\n                t = + t;\r\n            else if (P.dir == GLP_MAX)\r\n                t = - t;\r\n            else\r\n                xassert(P != P);\r\n            /* check for positivity */\r\n            if (row.stat == GLP_NF || row.stat == GLP_NL)\r\n            {  if (t < 0.0)\r\n            {  e = - t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = i;\r\n                }\r\n            }\r\n            }\r\n            /* check for negativity */\r\n            if (row.stat == GLP_NF || row.stat == GLP_NU)\r\n            {  if (t > 0.0)\r\n            {  e = + t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = i;\r\n                }\r\n            }\r\n            }\r\n        }\r\n        /* check lambdaS */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            /* t := lambdaS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.dual;\r\n            else if (sol == GLP_IPT)\r\n                t = col.dval;\r\n            else\r\n                xassert(sol != sol);\r\n            /* correct sign */\r\n            if (P.dir == GLP_MIN)\r\n                t = + t;\r\n            else if (P.dir == GLP_MAX)\r\n                t = - t;\r\n            else\r\n                xassert(P != P);\r\n            /* check for positivity */\r\n            if (col.stat == GLP_NF || col.stat == GLP_NL)\r\n            {  if (t < 0.0)\r\n            {  e = - t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n            /* check for negativity */\r\n            if (col.stat == GLP_NF || col.stat == GLP_NU)\r\n            {  if (t > 0.0)\r\n            {  e = + t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n        }\r\n    }\r\n    else\r\n        xassert(cond != cond);\r\n\r\n    callback(ae_max, ae_ind, re_max, re_ind);\r\n}\r\n\r\nvar glp_bf_exists = exports[\"glp_bf_exists\"] = function(lp){\r\n    return (lp.m == 0 || lp.valid);\r\n};\r\n\r\nvar glp_factorize = exports[\"glp_factorize\"] = function(lp){\r\n\r\n    function b_col(lp, j, ind, val){\r\n        var m = lp.m;\r\n        var aij;\r\n        var k, len;\r\n        xassert(1 <= j && j <= m);\r\n        /* determine the ordinal number of basic auxiliary or structural\r\n         variable x[k] corresponding to basic variable xB[j] */\r\n        k = lp.head[j];\r\n        /* build j-th column of the basic matrix, which is k-th column of\r\n         the scaled augmented matrix (I | -R*A*S) */\r\n        if (k <= m)\r\n        {  /* x[k] is auxiliary variable */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* x[k] is structural variable */\r\n            len = 0;\r\n            for (aij = lp.col[k-m].ptr; aij != null; aij = aij.c_next)\r\n            {  len++;\r\n                ind[len] = aij.row.i;\r\n                val[len] = - aij.row.rii * aij.val * aij.col.sjj;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var head = lp.head;\r\n    var j, k, stat, ret;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n    /* build the basis header */\r\n    j = 0;\r\n    for (k = 1; k <= m+n; k++)\r\n    {  if (k <= m)\r\n    {  stat = row[k].stat;\r\n        row[k].bind = 0;\r\n    }\r\n    else\r\n    {  stat = col[k-m].stat;\r\n        col[k-m].bind = 0;\r\n    }\r\n        if (stat == GLP_BS)\r\n        {  j++;\r\n            if (j > m)\r\n            {  /* too many basic variables */\r\n                ret = GLP_EBADB;\r\n                return ret;\r\n            }\r\n            head[j] = k;\r\n            if (k <= m)\r\n                row[k].bind = j;\r\n            else\r\n                col[k-m].bind = j;\r\n        }\r\n    }\r\n    if (j < m)\r\n    {  /* too few basic variables */\r\n        ret = GLP_EBADB;\r\n        return ret;\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    if (m > 0)\r\n    {  if (lp.bfd == null)\r\n    {  lp.bfd = bfd_create_it();\r\n        copy_bfcp(lp);\r\n    }\r\n        switch (bfd_factorize(lp.bfd, m, lp.head, b_col, lp))\r\n        {  case 0:\r\n            /* ok */\r\n            break;\r\n            case BFD_ESING:\r\n                /* singular matrix */\r\n                ret = GLP_ESING;\r\n                return ret;\r\n            case BFD_ECOND:\r\n                /* ill-conditioned matrix */\r\n                ret = GLP_ECOND;\r\n                return ret;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        lp.valid = 1;\r\n    }\r\n    /* factorization successful */\r\n    ret = 0;\r\n    /* bring the return code to the calling program */\r\n    return ret;\r\n};\r\n\r\nvar glp_bf_updated = exports[\"glp_bf_updated\"] = function(lp){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_bf_update: basis factorization does not exist\");\r\n    return (lp.m == 0 ? 0 : bfd_get_count(lp.bfd));\r\n};\r\n\r\nvar glp_get_bfcp = exports[\"glp_get_bfcp\"] = function(lp, parm){\r\n    var bfcp = lp.bfcp;\r\n    if (bfcp == null)\r\n    {  parm.type = GLP_BF_FT;\r\n        parm.lu_size = 0;\r\n        parm.piv_tol = 0.10;\r\n        parm.piv_lim = 4;\r\n        parm.suhl = GLP_ON;\r\n        parm.eps_tol = 1e-15;\r\n        parm.max_gro = 1e+10;\r\n        parm.nfs_max = 100;\r\n        parm.upd_tol = 1e-6;\r\n        parm.nrs_max = 100;\r\n        parm.rs_size = 0;\r\n    }\r\n    else\r\n        xcopyObj(parm, bfcp);\r\n};\r\n\r\nfunction copy_bfcp(lp){\r\n    var parm = {};\r\n    glp_get_bfcp(lp, parm);\r\n    bfd_set_parm(lp.bfd, parm);\r\n}\r\n\r\nvar glp_set_bfcp = exports[\"glp_set_bfcp\"] = function(lp, parm){\r\n    var bfcp = lp.bfcp;\r\n    if (parm == null)\r\n    {  /* reset to default values */\r\n        if (bfcp != null)\r\n            lp.bfcp = null;\r\n    }\r\n    else\r\n    {  /* set to specified values */\r\n        if (bfcp == null)\r\n            bfcp = lp.bfcp = {};\r\n        xcopyObj(bfcp, parm);\r\n        if (!(bfcp.type == GLP_BF_FT || bfcp.type == GLP_BF_BG ||\r\n            bfcp.type == GLP_BF_GR))\r\n            xerror(\"glp_set_bfcp: type = \" + bfcp.type + \"; invalid parameter\");\r\n        if (bfcp.lu_size < 0)\r\n            xerror(\"glp_set_bfcp: lu_size = \" + bfcp.lu_size + \"; invalid parameter\");\r\n        if (!(0.0 < bfcp.piv_tol && bfcp.piv_tol < 1.0))\r\n            xerror(\"glp_set_bfcp: piv_tol = \" + bfcp.piv_tol + \"; invalid parameter\");\r\n        if (bfcp.piv_lim < 1)\r\n            xerror(\"glp_set_bfcp: piv_lim = \" + bfcp.piv_lim + \"; invalid parameter\");\r\n        if (!(bfcp.suhl == GLP_ON || bfcp.suhl == GLP_OFF))\r\n            xerror(\"glp_set_bfcp: suhl = \" + bfcp.suhl + \"; invalid parameter\");\r\n        if (!(0.0 <= bfcp.eps_tol && bfcp.eps_tol <= 1e-6))\r\n            xerror(\"glp_set_bfcp: eps_tol = \" + bfcp.eps_tol + \"; invalid parameter\");\r\n        if (bfcp.max_gro < 1.0)\r\n            xerror(\"glp_set_bfcp: max_gro = \" + bfcp.max_gro + \"; invalid parameter\");\r\n        if (!(1 <= bfcp.nfs_max && bfcp.nfs_max <= 32767))\r\n            xerror(\"glp_set_bfcp: nfs_max = \" + bfcp.nfs_max + \"; invalid parameter\");\r\n        if (!(0.0 < bfcp.upd_tol && bfcp.upd_tol < 1.0))\r\n            xerror(\"glp_set_bfcp: upd_tol = \" + bfcp.upd_tol + \"; invalid parameter\");\r\n        if (!(1 <= bfcp.nrs_max && bfcp.nrs_max <= 32767))\r\n            xerror(\"glp_set_bfcp: nrs_max = \" + bfcp.nrs_max + \"; invalid parameter\");\r\n        if (bfcp.rs_size < 0)\r\n            xerror(\"glp_set_bfcp: rs_size = \" + bfcp.nrs_max + \"; invalid parameter\");\r\n        if (bfcp.rs_size == 0)\r\n            bfcp.rs_size = 20 * bfcp.nrs_max;\r\n    }\r\n    if (lp.bfd != null) copy_bfcp(lp);\r\n};\r\n\r\nvar glp_get_bhead = exports[\"glp_get_bhead\"] = function(lp, k){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_bhead: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= lp.m))\r\n        xerror(\"glp_get_bhead: k = \" + k + \"; index out of range\");\r\n    return lp.head[k];\r\n};\r\n\r\nvar glp_get_row_bind = exports[\"glp_get_row_bind\"] = function(lp, i){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_row_bind: basis factorization does not exist\");\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_bind: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].bind;\r\n};\r\n\r\nvar glp_get_col_bind = exports[\"glp_get_col_bind\"] = function(lp, j){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_col_bind: basis factorization does not exist\");\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_bind: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].bind;\r\n};\r\n\r\nvar glp_ftran = exports[\"glp_ftran\"] = function(lp, x){\r\n    var m = lp.m;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var i, k;\r\n    /* B*x = b ===> (R*B*SB)*(inv(SB)*x) = R*b ===>\r\n     B\"*x\" = b\", where b\" = R*b, x = SB*x\" */\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_ftran: basis factorization does not exist\");\r\n    /* b\" := R*b */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] *= row[i].rii;\r\n    /* x\" := inv(B\")*b\" */\r\n    if (m > 0) bfd_ftran(lp.bfd, x);\r\n    /* x := SB*x\" */\r\n    for (i = 1; i <= m; i++)\r\n    {  k = lp.head[i];\r\n        if (k <= m)\r\n            x[i] /= row[k].rii;\r\n        else\r\n            x[i] *= col[k-m].sjj;\r\n    }\r\n};\r\n\r\nvar glp_btran = exports[\"glp_btran\"] = function(lp, x){\r\n    var m = lp.m;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var i, k;\r\n    /* B'*x = b ===> (SB*B'*R)*(inv(R)*x) = SB*b ===>\r\n     (B\")'*x\" = b\", where b\" = SB*b, x = R*x\" */\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_btran: basis factorization does not exist\");\r\n    /* b\" := SB*b */\r\n    for (i = 1; i <= m; i++)\r\n    {  k = lp.head[i];\r\n        if (k <= m)\r\n            x[i] /= row[k].rii;\r\n        else\r\n            x[i] *= col[k-m].sjj;\r\n    }\r\n    /* x\" := inv[(B\")']*b\" */\r\n    if (m > 0) bfd_btran(lp.bfd, x);\r\n    /* x := R*x\" */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] *= row[i].rii;\r\n};\r\n\r\nvar glp_warm_up = exports[\"glp_warm_up\"] = function(P){\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, type, stat, ret;\r\n    var eps, temp, work;\r\n    /* invalidate basic solution */\r\n    P.pbs_stat = P.dbs_stat = GLP_UNDEF;\r\n    P.obj_val = 0.0;\r\n    P.some = 0;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        row.prim = row.dual = 0.0;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        col.prim = col.dual = 0.0;\r\n    }\r\n    /* compute the basis factorization, if necessary */\r\n    if (!glp_bf_exists(P))\r\n    {  ret = glp_factorize(P);\r\n        if (ret != 0) return ret;\r\n    }\r\n    /* allocate working array */\r\n    work = new Float64Array(1+P.m);\r\n    /* determine and store values of non-basic variables, compute\r\n     vector (- N * xN) */\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat == GLP_BS)\r\n            continue;\r\n        else if (row.stat == GLP_NL)\r\n            row.prim = row.lb;\r\n        else if (row.stat == GLP_NU)\r\n            row.prim = row.ub;\r\n        else if (row.stat == GLP_NF)\r\n            row.prim = 0.0;\r\n        else if (row.stat == GLP_NS)\r\n            row.prim = row.lb;\r\n        else\r\n            xassert(row != row);\r\n        /* N[j] is i-th column of matrix (I|-A) */\r\n        work[i] -= row.prim;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n            continue;\r\n        else if (col.stat == GLP_NL)\r\n            col.prim = col.lb;\r\n        else if (col.stat == GLP_NU)\r\n            col.prim = col.ub;\r\n        else if (col.stat == GLP_NF)\r\n            col.prim = 0.0;\r\n        else if (col.stat == GLP_NS)\r\n            col.prim = col.lb;\r\n        else\r\n            xassert(col != col);\r\n        /* N[j] is (m+j)-th column of matrix (I|-A) */\r\n        if (col.prim != 0.0)\r\n        {  for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            work[aij.row.i] += aij.val * col.prim;\r\n        }\r\n    }\r\n    /* compute vector of basic variables xB = - inv(B) * N * xN */\r\n    glp_ftran(P, work);\r\n    /* store values of basic variables, check primal feasibility */\r\n    P.pbs_stat = GLP_FEAS;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat != GLP_BS)\r\n            continue;\r\n        row.prim = work[row.bind];\r\n        type = row.type;\r\n        if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(row.lb);\r\n            if (row.prim < row.lb - eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n        if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(row.ub);\r\n            if (row.prim > row.ub + eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat != GLP_BS)\r\n            continue;\r\n        col.prim = work[col.bind];\r\n        type = col.type;\r\n        if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(col.lb);\r\n            if (col.prim < col.lb - eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n        if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(col.ub);\r\n            if (col.prim > col.ub + eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n    }\r\n    /* compute value of the objective function */\r\n    P.obj_val = P.c0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        P.obj_val += col.coef * col.prim;\r\n    }\r\n    /* build vector cB of objective coefficients at basic variables */\r\n    for (i = 1; i <= P.m; i++)\r\n        work[i] = 0.0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n            work[col.bind] = col.coef;\r\n    }\r\n    /* compute vector of simplex multipliers pi = inv(B') * cB */\r\n    glp_btran(P, work);\r\n    /* compute and store reduced costs of non-basic variables d[j] =\r\n     c[j] - N'[j] * pi, check dual feasibility */\r\n    P.dbs_stat = GLP_FEAS;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat == GLP_BS)\r\n        {  row.dual = 0.0;\r\n            continue;\r\n        }\r\n        /* N[j] is i-th column of matrix (I|-A) */\r\n        row.dual = - work[i];\r\n        stat = row.stat;\r\n        temp = (P.dir == GLP_MIN ? + row.dual : - row.dual);\r\n        if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\r\n            (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\r\n            P.dbs_stat = GLP_INFEAS;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n        {  col.dual = 0.0;\r\n            continue;\r\n        }\r\n        /* N[j] is (m+j)-th column of matrix (I|-A) */\r\n        col.dual = col.coef;\r\n        for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            col.dual += aij.val * work[aij.row.i];\r\n        stat = col.stat;\r\n        temp = (P.dir == GLP_MIN ? + col.dual : - col.dual);\r\n        if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\r\n            (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\r\n            P.dbs_stat = GLP_INFEAS;\r\n    }\r\n    /* free working array */\r\n    return 0;\r\n};\r\n\r\nvar glp_eval_tab_row = exports[\"glp_eval_tab_row\"] = function(lp, k, ind, val){\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var i, t, len, lll, iii;\r\n    var alfa, rho, vvv;\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_eval_tab_row: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_eval_tab_row: k = \" + k + \"; variable number out of range\");\r\n    /* determine xB[i] which corresponds to x[k] */\r\n    if (k <= m)\r\n        i = glp_get_row_bind(lp, k);\r\n    else\r\n        i = glp_get_col_bind(lp, k-m);\r\n    if (i == 0)\r\n        xerror(\"glp_eval_tab_row: k = \" + k + \"; variable must be basic\");\r\n    xassert(1 <= i && i <= m);\r\n    /* allocate working arrays */\r\n    rho = new Float64Array(1+m);\r\n    iii = new Int32Array(1+m);\r\n    vvv = new Float64Array(1+m);\r\n    /* compute i-th row of the inverse; see (8) */\r\n    rho[i] = 1.0;\r\n    glp_btran(lp, rho);\r\n    /* compute i-th row of the simplex table */\r\n    len = 0;\r\n    for (k = 1; k <= m+n; k++)\r\n    {  if (k <= m)\r\n    {  /* x[k] is auxiliary variable, so N[k] is a unity column */\r\n        if (glp_get_row_stat(lp, k) == GLP_BS) continue;\r\n        /* compute alfa[i,j]; see (9) */\r\n        alfa = - rho[k];\r\n    }\r\n    else\r\n    {  /* x[k] is structural variable, so N[k] is a column of the\r\n     original constraint matrix A with negative sign */\r\n        if (glp_get_col_stat(lp, k-m) == GLP_BS) continue;\r\n        /* compute alfa[i,j]; see (9) */\r\n        lll = glp_get_mat_col(lp, k-m, iii, vvv);\r\n        alfa = 0.0;\r\n        for (t = 1; t <= lll; t++) alfa += rho[iii[t]] * vvv[t];\r\n    }\r\n        /* store alfa[i,j] */\r\n        if (alfa != 0.0) {\r\n            len++;\r\n            ind[len] = k;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    xassert(len <= n);\r\n    /* return to the calling program */\r\n    return len;\r\n};\r\n\r\nvar glp_eval_tab_col = exports[\"glp_eval_tab_col\"] = function(lp, k, ind, val){\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var t, len, stat;\r\n    var col;\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_eval_tab_col: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_eval_tab_col: k = \" + k + \"; variable number out of range\");\r\n    if (k <= m)\r\n        stat = glp_get_row_stat(lp, k);\r\n    else\r\n        stat = glp_get_col_stat(lp, k-m);\r\n    if (stat == GLP_BS)\r\n        xerror(\"glp_eval_tab_col: k = \" + k + \"; variable must be non-basic\");\r\n    /* obtain column N[k] with negative sign */\r\n    col = new Float64Array(1+m);\r\n    if (k <= m)\r\n    {  /* x[k] is auxiliary variable, so N[k] is a unity column */\r\n        col[k] = -1.0;\r\n    }\r\n    else\r\n    {  /* x[k] is structural variable, so N[k] is a column of the\r\n     original constraint matrix A with negative sign */\r\n        len = glp_get_mat_col(lp, k-m, ind, val);\r\n        for (t = 1; t <= len; t++) col[ind[t]] = val[t];\r\n    }\r\n    /* compute column of the simplex table, which corresponds to the\r\n     specified non-basic variable x[k] */\r\n    glp_ftran(lp, col);\r\n    len = 0;\r\n    for (t = 1; t <= m; t++)\r\n    {  if (col[t] != 0.0)\r\n    {  len++;\r\n        ind[len] = glp_get_bhead(lp, t);\r\n        val[len] = col[t];\r\n    }\r\n    }\r\n    /* return to the calling program */\r\n    return len;\r\n};\r\n\r\nvar glp_transform_row = exports[\"glp_transform_row\"] = function(P, len, ind, val){\r\n    var i, j, k, m, n, t, lll, iii;\r\n    var alfa, a, aB, rho, vvv;\r\n    if (!glp_bf_exists(P))\r\n        xerror(\"glp_transform_row: basis factorization does not exist \");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* unpack the row to be transformed to the array a */\r\n    a = new Float64Array(1+n);\r\n    if (!(0 <= len && len <= n))\r\n        xerror(\"glp_transform_row: len = \" + len + \"; invalid row length\");\r\n    for (t = 1; t <= len; t++)\r\n    {  j = ind[t];\r\n        if (!(1 <= j && j <= n))\r\n            xerror(\"glp_transform_row: ind[\" + t + \"] = \" + j + \"; column index out of range\");\r\n        if (val[t] == 0.0)\r\n            xerror(\"glp_transform_row: val[\" + t + \"] = 0; zero coefficient not allowed\");\r\n        if (a[j] != 0.0)\r\n            xerror(\"glp_transform_row: ind[\" + t + \"] = \" + j + \"; duplicate column indices not allowed\");\r\n        a[j] = val[t];\r\n    }\r\n    /* construct the vector aB */\r\n    aB = new Float64Array(1+m);\r\n    for (i = 1; i <= m; i++)\r\n    {  k = glp_get_bhead(P, i);\r\n        /* xB[i] is k-th original variable */\r\n        xassert(1 <= k && k <= m+n);\r\n        aB[i] = (k <= m ? 0.0 : a[k-m]);\r\n    }\r\n    /* solve the system B'*rho = aB to compute the vector rho */\r\n    rho = aB; glp_btran(P, rho);\r\n    /* compute coefficients at non-basic auxiliary variables */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (glp_get_row_stat(P, i) != GLP_BS)\r\n    {  alfa = - rho[i];\r\n        if (alfa != 0.0)\r\n        {  len++;\r\n            ind[len] = i;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    }\r\n    /* compute coefficients at non-basic structural variables */\r\n    iii = new Int32Array(1+m);\r\n    vvv = new Float64Array(1+m);\r\n    for (j = 1; j <= n; j++)\r\n    {  if (glp_get_col_stat(P, j) != GLP_BS)\r\n    {  alfa = a[j];\r\n        lll = glp_get_mat_col(P, j, iii, vvv);\r\n        for (t = 1; t <= lll; t++) alfa += vvv[t] * rho[iii[t]];\r\n        if (alfa != 0.0)\r\n        {  len++;\r\n            ind[len] = m+j;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    }\r\n    xassert(len <= n);\r\n    return len;\r\n};\r\n\r\nvar glp_transform_col = exports[\"glp_transform_col\"] = function(P, len, ind, val){\r\n    var i, m, t;\r\n    var a, alfa;\r\n    if (!glp_bf_exists(P))\r\n        xerror(\"glp_transform_col: basis factorization does not exist \");\r\n    m = glp_get_num_rows(P);\r\n    /* unpack the column to be transformed to the array a */\r\n    a = new Float64Array(1+m);\r\n    if (!(0 <= len && len <= m))\r\n        xerror(\"glp_transform_col: len = \" + len + \"; invalid column length\");\r\n    for (t = 1; t <= len; t++)\r\n    {  i = ind[t];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"glp_transform_col: ind[\" + t + \"] = \" + i + \"; row index out of range\");\r\n        if (val[t] == 0.0)\r\n            xerror(\"glp_transform_col: val[\" + t + \"] = 0; zero coefficient not allowed\");\r\n        if (a[i] != 0.0)\r\n            xerror(\"glp_transform_col: ind[\" + t + \"] = \" + i + \"; duplicate row indices not allowed\");\r\n        a[i] = val[t];\r\n    }\r\n    /* solve the system B*a = alfa to compute the vector alfa */\r\n    alfa = a; glp_ftran(P, alfa);\r\n    /* store resultant coefficients */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (alfa[i] != 0.0)\r\n    {  len++;\r\n        ind[len] = glp_get_bhead(P, i);\r\n        val[len] = alfa[i];\r\n    }\r\n    }\r\n    return len;\r\n};\r\n\r\nvar glp_prim_rtest = exports[\"glp_prim_rtest\"] = function(P, len, ind, val, dir, eps){\r\n    var k, m, n, piv, t, type, stat;\r\n    var alfa, big, beta, lb, ub, temp, teta;\r\n    if (glp_get_prim_stat(P) != GLP_FEAS)\r\n        xerror(\"glp_prim_rtest: basic solution is not primal feasible \");\r\n    if (!(dir == +1 || dir == -1))\r\n        xerror(\"glp_prim_rtest: dir = \" + dir + \"; invalid parameter\");\r\n    if (!(0.0 < eps && eps < 1.0))\r\n        xerror(\"glp_prim_rtest: eps = \" + eps + \"; invalid parameter\");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* initial settings */\r\n    piv = 0; teta = DBL_MAX; big = 0.0;\r\n    /* walk through the entries of the specified column */\r\n    for (t = 1; t <= len; t++)\r\n    {  /* get the ordinal number of basic variable */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= m+n))\r\n            xerror(\"glp_prim_rtest: ind[\" + t + \"] = \" + k + \"; variable number out of range\");\r\n        /* determine type, bounds, status and primal value of basic\r\n         variable xB[i] = x[k] in the current basic solution */\r\n        if (k <= m)\r\n        {  type = glp_get_row_type(P, k);\r\n            lb = glp_get_row_lb(P, k);\r\n            ub = glp_get_row_ub(P, k);\r\n            stat = glp_get_row_stat(P, k);\r\n            beta = glp_get_row_prim(P, k);\r\n        }\r\n        else\r\n        {  type = glp_get_col_type(P, k-m);\r\n            lb = glp_get_col_lb(P, k-m);\r\n            ub = glp_get_col_ub(P, k-m);\r\n            stat = glp_get_col_stat(P, k-m);\r\n            beta = glp_get_col_prim(P, k-m);\r\n        }\r\n        if (stat != GLP_BS)\r\n            xerror(\"glp_prim_rtest: ind[\" + t + \"] = \" + k + \"; non-basic variable not allowed\");\r\n        /* determine influence coefficient at basic variable xB[i]\r\n         in the explicitly specified column and turn to the case of\r\n         increasing the variable x in order to simplify the program\r\n         logic */\r\n        alfa = (dir > 0 ? + val[t] : - val[t]);\r\n        /* analyze main cases */\r\n        if (type == GLP_FR)\r\n        {  /* xB[i] is free variable */\r\n            continue;\r\n        }\r\n        else if (type == GLP_LO)\r\n        {  /* xB[i] has an lower bound */\r\n            if (alfa > - eps) continue;\r\n            temp = (lb - beta) / alfa;\r\n        }\r\n        else if (type == GLP_UP)\r\n        {  /* xB[i] has an upper bound */\r\n            if (alfa < + eps) continue;\r\n            temp = (ub - beta) / alfa;\r\n        }\r\n        else if (type == GLP_DB)\r\n        {  /* xB[i] has both lower and upper bounds */\r\n            if (alfa < 0.0)\r\n            {  /* xB[i] has an lower bound */\r\n                if (alfa > - eps) continue;\r\n                temp = (lb - beta) / alfa;\r\n            } else {\r\n                /* xB[i] has an upper bound */\r\n                if (alfa < + eps) continue;\r\n                temp = (ub - beta) / alfa;\r\n            }\r\n        }\r\n        else if (type == GLP_FX)\r\n        {  /* xB[i] is fixed variable */\r\n            if (- eps < alfa && alfa < + eps) continue;\r\n            temp = 0.0;\r\n        }\r\n        else\r\n            xassert(type != type);\r\n        /* if the value of the variable xB[i] violates its lower or\r\n         upper bound (slightly, because the current basis is assumed\r\n         to be primal feasible), temp is negative; we can think this\r\n         happens due to round-off errors and the value is exactly on\r\n         the bound; this allows replacing temp by zero */\r\n        if (temp < 0.0) temp = 0.0;\r\n        /* apply the minimal ratio test */\r\n        if (teta > temp || teta == temp && big < Math.abs(alfa)){\r\n            piv = t;\r\n            teta = temp;\r\n            big = Math.abs(alfa);\r\n        }\r\n\r\n    }\r\n    /* return index of the pivot element chosen */\r\n    return piv;\r\n};\r\n\r\nvar glp_dual_rtest = exports[\"glp_dual_rtest\"] = function(P, len, ind, val, dir, eps){\r\n    var k, m, n, piv, t, stat;\r\n    var alfa, big, cost, obj, temp, teta;\r\n    if (glp_get_dual_stat(P) != GLP_FEAS)\r\n        xerror(\"glp_dual_rtest: basic solution is not dual feasible\");\r\n    if (!(dir == +1 || dir == -1))\r\n        xerror(\"glp_dual_rtest: dir = \" + dir + \"; invalid parameter\");\r\n    if (!(0.0 < eps && eps < 1.0))\r\n        xerror(\"glp_dual_rtest: eps = \" + eps + \"; invalid parameter\");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* take into account optimization direction */\r\n    obj = (glp_get_obj_dir(P) == GLP_MIN ? +1.0 : -1.0);\r\n    /* initial settings */\r\n    piv = 0; teta = DBL_MAX; big = 0.0;\r\n    /* walk through the entries of the specified row */\r\n    for (t = 1; t <= len; t++)\r\n    {  /* get ordinal number of non-basic variable */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= m+n))\r\n            xerror(\"glp_dual_rtest: ind[\" + t + \"] = \" + k + \"; variable number out of range\");\r\n        /* determine status and reduced cost of non-basic variable\r\n         x[k] = xN[j] in the current basic solution */\r\n        if (k <= m)\r\n        {  stat = glp_get_row_stat(P, k);\r\n            cost = glp_get_row_dual(P, k);\r\n        }\r\n        else\r\n        {  stat = glp_get_col_stat(P, k-m);\r\n            cost = glp_get_col_dual(P, k-m);\r\n        }\r\n        if (stat == GLP_BS)\r\n            xerror(\"glp_dual_rtest: ind[\" + t + \"] = \" + k + \"; basic variable not allowed\");\r\n        /* determine influence coefficient at non-basic variable xN[j]\r\n         in the explicitly specified row and turn to the case of\r\n         increasing the variable x in order to simplify the program\r\n         logic */\r\n        alfa = (dir > 0 ? + val[t] : - val[t]);\r\n        /* analyze main cases */\r\n        if (stat == GLP_NL)\r\n        {  /* xN[j] is on its lower bound */\r\n            if (alfa < + eps) continue;\r\n            temp = (obj * cost) / alfa;\r\n        }\r\n        else if (stat == GLP_NU)\r\n        {  /* xN[j] is on its upper bound */\r\n            if (alfa > - eps) continue;\r\n            temp = (obj * cost) / alfa;\r\n        }\r\n        else if (stat == GLP_NF)\r\n        {  /* xN[j] is non-basic free variable */\r\n            if (- eps < alfa && alfa < + eps) continue;\r\n            temp = 0.0;\r\n        }\r\n        else if (stat == GLP_NS)\r\n        {  /* xN[j] is non-basic fixed variable */\r\n            continue;\r\n        }\r\n        else\r\n            xassert(stat != stat);\r\n        /* if the reduced cost of the variable xN[j] violates its zero\r\n         bound (slightly, because the current basis is assumed to be\r\n         dual feasible), temp is negative; we can think this happens\r\n         due to round-off errors and the reduced cost is exact zero;\r\n         this allows replacing temp by zero */\r\n        if (temp < 0.0) temp = 0.0;\r\n        /* apply the minimal ratio test */\r\n        if (teta > temp || teta == temp && big < Math.abs(alfa)){\r\n            piv = t;\r\n            teta = temp;\r\n            big = Math.abs(alfa);\r\n        }\r\n    }\r\n    /* return index of the pivot element chosen */\r\n    return piv;\r\n};\r\n\r\nfunction _glp_analyze_row(P, len, ind, val, type, rhs, eps, callback){\r\n    var t, k, dir, piv, ret = 0;\r\n    var x, dx, y, dy, dz;\r\n    if (P.pbs_stat == GLP_UNDEF)\r\n        xerror(\"glp_analyze_row: primal basic solution components are undefined\");\r\n    if (P.dbs_stat != GLP_FEAS)\r\n        xerror(\"glp_analyze_row: basic solution is not dual feasible\");\r\n    /* compute the row value y = sum alfa[j] * xN[j] in the current\r\n     basis */\r\n    if (!(0 <= len && len <= P.n))\r\n        xerror(\"glp_analyze_row: len = \" + len + \"; invalid row length\");\r\n    y = 0.0;\r\n    for (t = 1; t <= len; t++)\r\n    {  /* determine value of x[k] = xN[j] in the current basis */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= P.m+P.n))\r\n            xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; row/column index out of range\");\r\n        if (k <= P.m)\r\n        {  /* x[k] is auxiliary variable */\r\n            if (P.row[k].stat == GLP_BS)\r\n                xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; basic auxiliary variable is not allowed\");\r\n            x = P.row[k].prim;\r\n        }\r\n        else\r\n        {  /* x[k] is structural variable */\r\n            if (P.col[k-P.m].stat == GLP_BS)\r\n                xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; basic structural variable is not allowed\");\r\n            x = P.col[k-P.m].prim;\r\n        }\r\n        y += val[t] * x;\r\n    }\r\n    /* check if the row is primal infeasible in the current basis,\r\n     i.e. the constraint is violated at the current point */\r\n    if (type == GLP_LO)\r\n    {  if (y >= rhs)\r\n    {  /* the constraint is not violated */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n        /* in the adjacent basis y goes to its lower bound */\r\n        dir = +1;\r\n    }\r\n    else if (type == GLP_UP)\r\n    {  if (y <= rhs)\r\n    {  /* the constraint is not violated */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n        /* in the adjacent basis y goes to its upper bound */\r\n        dir = -1;\r\n    }\r\n    else\r\n        xerror(\"glp_analyze_row: type = \" + type + \"; invalid parameter\");\r\n    /* compute dy = y.new - y.old */\r\n    dy = rhs - y;\r\n    /* perform dual ratio test to determine which non-basic variable\r\n     should enter the adjacent basis to keep it dual feasible */\r\n    piv = glp_dual_rtest(P, len, ind, val, dir, eps);\r\n    if (piv == 0)\r\n    {  /* no dual feasible adjacent basis exists */\r\n        ret = 2;\r\n        return ret;\r\n    }\r\n    /* non-basic variable x[k] = xN[j] should enter the basis */\r\n    k = ind[piv];\r\n    xassert(1 <= k && k <= P.m+P.n);\r\n    /* determine its value in the current basis */\r\n    if (k <= P.m)\r\n        x = P.row[k].prim;\r\n    else\r\n        x = P.col[k-P.m].prim;\r\n    /* compute dx = x.new - x.old = dy / alfa[j] */\r\n    xassert(val[piv] != 0.0);\r\n    dx = dy / val[piv];\r\n    /* compute dz = z.new - z.old = d[j] * dx, where d[j] is reduced\r\n     cost of xN[j] in the current basis */\r\n    if (k <= P.m)\r\n        dz = P.row[k].dual * dx;\r\n    else\r\n        dz = P.col[k-P.m].dual * dx;\r\n    /* store the analysis results */\r\n\r\n    callback(piv, x, dx, y, dy, dz);\r\n    return ret;\r\n}\r\n\r\nvar glp_analyze_bound = exports[\"glp_analyze_bound\"] = function(P, k, callback){\r\n    var row;\r\n    var col;\r\n    var  m, n, stat, kase, p, len, piv, ind;\r\n    var  x, new_x, ll, uu, xx, delta, val;\r\n    var value1, var1, value2, var2;\r\n    value1 = var1 = value2 = var2 = null;\r\n\r\n    function store(){\r\n        /* store analysis results */\r\n        if (kase < 0)\r\n        {  value1 = new_x;\r\n            var1 = p;\r\n        }\r\n        else\r\n        {  value2 = new_x;\r\n            var2 = p;\r\n        }\r\n    }\r\n\r\n    /* sanity checks */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_analyze_bound: P = \" + P + \"; invalid problem object\");\r\n    m = P.m; n = P.n;\r\n    if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))\r\n        xerror(\"glp_analyze_bound: optimal basic solution required\");\r\n    if (!(m == 0 || P.valid))\r\n        xerror(\"glp_analyze_bound: basis factorization required\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_analyze_bound: k = \" + k + \"; variable number out of range\");\r\n    /* retrieve information about the specified non-basic variable\r\n     x[k] whose active bound is to be analyzed */\r\n    if (k <= m)\r\n    {  row = P.row[k];\r\n        stat = row.stat;\r\n        x = row.prim;\r\n    }\r\n    else\r\n    {  col = P.col[k-m];\r\n        stat = col.stat;\r\n        x = col.prim;\r\n    }\r\n    if (stat == GLP_BS)\r\n        xerror(\"glp_analyze_bound: k = \" + k + \"; basic variable not allowed \");\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+m);\r\n    val = new Float64Array(1+m);\r\n    /* compute column of the simplex table corresponding to the\r\n     non-basic variable x[k] */\r\n    len = glp_eval_tab_col(P, k, ind, val);\r\n    xassert(0 <= len && len <= m);\r\n    /* perform analysis */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* kase < 0 means active bound of x[k] is decreasing;\r\n     kase > 0 means active bound of x[k] is increasing */\r\n        /* use the primal ratio test to determine some basic variable\r\n         x[p] which reaches its bound first */\r\n        piv = glp_prim_rtest(P, len, ind, val, kase, 1e-9);\r\n        if (piv == 0)\r\n        {  /* nothing limits changing the active bound of x[k] */\r\n            p = 0;\r\n            new_x = (kase < 0 ? -DBL_MAX : +DBL_MAX);\r\n            store();\r\n            continue;\r\n        }\r\n        /* basic variable x[p] limits changing the active bound of\r\n         x[k]; determine its value in the current basis */\r\n        xassert(1 <= piv && piv <= len);\r\n        p = ind[piv];\r\n        if (p <= m)\r\n        {  row = P.row[p];\r\n            ll = glp_get_row_lb(P, row.i);\r\n            uu = glp_get_row_ub(P, row.i);\r\n            stat = row.stat;\r\n            xx = row.prim;\r\n        }\r\n        else\r\n        {  col = P.col[p-m];\r\n            ll = glp_get_col_lb(P, col.j);\r\n            uu = glp_get_col_ub(P, col.j);\r\n            stat = col.stat;\r\n            xx = col.prim;\r\n        }\r\n        xassert(stat == GLP_BS);\r\n        /* determine delta x[p] = bound of x[p] - value of x[p] */\r\n        if (kase < 0 && val[piv] > 0.0 ||\r\n            kase > 0 && val[piv] < 0.0)\r\n        {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\r\n            xassert(ll != -DBL_MAX);\r\n            delta = ll - xx;\r\n        }\r\n        else\r\n        {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\r\n            xassert(uu != +DBL_MAX);\r\n            delta = uu - xx;\r\n        }\r\n        /* delta x[p] = alfa[p,k] * delta x[k], so new x[k] = x[k] +\r\n         delta x[k] = x[k] + delta x[p] / alfa[p,k] is the value of\r\n         x[k] in the adjacent basis */\r\n        xassert(val[piv] != 0.0);\r\n        new_x = x + delta / val[piv];\r\n        store();\r\n    }\r\n    callback(value1, var1, value2, var2)\r\n};\r\n\r\nvar glp_analyze_coef = exports[\"glp_analyze_coef\"] = function(P, k, callback){\r\n    var row, col;\r\n    var m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv, cind, rind;\r\n    var lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx, rval, cval;\r\n    var coef1 = null, var1 = null, value1 = null, coef2 = null, var2 = null, value2 = null;\r\n\r\n    function store(){\r\n        /* store analysis results */\r\n        if (kase < 0)\r\n        {   coef1 = lim_coef;\r\n            var1 = q;\r\n            value1 = new_x;\r\n        }\r\n        else\r\n        {   coef2 = lim_coef;\r\n            var2 = q;\r\n            value2 = new_x;\r\n        }\r\n    }\r\n\r\n    /* sanity checks */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_analyze_coef: P = \" + P + \"; invalid problem object\");\r\n    m = P.m;\r\n    n = P.n;\r\n    if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))\r\n        xerror(\"glp_analyze_coef: optimal basic solution required\");\r\n    if (!(m == 0 || P.valid))\r\n        xerror(\"glp_analyze_coef: basis factorization required\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_analyze_coef: k = \" + k + \"; variable number out of range\");\r\n    /* retrieve information about the specified basic variable x[k]\r\n     whose objective coefficient c[k] is to be analyzed */\r\n    if (k <= m)\r\n    {  row = P.row[k];\r\n        type = row.type;\r\n        lb = row.lb;\r\n        ub = row.ub;\r\n        coef = 0.0;\r\n        stat = row.stat;\r\n        x = row.prim;\r\n    }\r\n    else\r\n    {  col = P.col[k-m];\r\n        type = col.type;\r\n        lb = col.lb;\r\n        ub = col.ub;\r\n        coef = col.coef;\r\n        stat = col.stat;\r\n        x = col.prim;\r\n    }\r\n    if (stat != GLP_BS)\r\n        xerror(\"glp_analyze_coef: k = \" + k + \"; non-basic variable not allowed\");\r\n    /* allocate working arrays */\r\n    cind = new Int32Array(1+m);\r\n    cval = new Float64Array(1+m);\r\n    rind = new Int32Array(1+n);\r\n    rval = new Float64Array(1+n);\r\n    /* compute row of the simplex table corresponding to the basic\r\n     variable x[k] */\r\n    rlen = glp_eval_tab_row(P, k, rind, rval);\r\n    xassert(0 <= rlen && rlen <= n);\r\n    /* perform analysis */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* kase < 0 means objective coefficient c[k] is decreasing;\r\n     kase > 0 means objective coefficient c[k] is increasing */\r\n        /* note that decreasing c[k] is equivalent to increasing dual\r\n         variable lambda[k] and vice versa; we need to correctly set\r\n         the dir flag as required by the routine glp_dual_rtest */\r\n        if (P.dir == GLP_MIN)\r\n            dir = - kase;\r\n        else if (P.dir == GLP_MAX)\r\n            dir = + kase;\r\n        else\r\n            xassert(P != P);\r\n        /* use the dual ratio test to determine non-basic variable\r\n         x[q] whose reduced cost d[q] reaches zero bound first */\r\n        rpiv = glp_dual_rtest(P, rlen, rind, rval, dir, 1e-9);\r\n        if (rpiv == 0)\r\n        {  /* nothing limits changing c[k] */\r\n            lim_coef = (kase < 0 ? -DBL_MAX : +DBL_MAX);\r\n            q = 0;\r\n            /* x[k] keeps its current value */\r\n            new_x = x;\r\n            store();\r\n            continue;\r\n        }\r\n        /* non-basic variable x[q] limits changing coefficient c[k];\r\n         determine its status and reduced cost d[k] in the current\r\n         basis */\r\n        xassert(1 <= rpiv && rpiv <= rlen);\r\n        q = rind[rpiv];\r\n        xassert(1 <= q && q <= m+n);\r\n        if (q <= m)\r\n        {  row = P.row[q];\r\n            stat = row.stat;\r\n            d = row.dual;\r\n        }\r\n        else\r\n        {  col = P.col[q-m];\r\n            stat = col.stat;\r\n            d = col.dual;\r\n        }\r\n        /* note that delta d[q] = new d[q] - d[q] = - d[q], because\r\n         new d[q] = 0; delta d[q] = alfa[k,q] * delta c[k], so\r\n         delta c[k] = delta d[q] / alfa[k,q] = - d[q] / alfa[k,q] */\r\n        xassert(rval[rpiv] != 0.0);\r\n        delta = - d / rval[rpiv];\r\n        /* compute new c[k] = c[k] + delta c[k], which is the limiting\r\n         value of the objective coefficient c[k] */\r\n        lim_coef = coef + delta;\r\n        /* let c[k] continue decreasing/increasing that makes d[q]\r\n         dual infeasible and forces x[q] to enter the basis;\r\n         to perform the primal ratio test we need to know in which\r\n         direction x[q] changes on entering the basis; we determine\r\n         that analyzing the sign of delta d[q] (see above), since\r\n         d[q] may be close to zero having wrong sign */\r\n        /* let, for simplicity, the problem is minimization */\r\n        if (kase < 0 && rval[rpiv] > 0.0 ||\r\n            kase > 0 && rval[rpiv] < 0.0)\r\n        {  /* delta d[q] < 0, so d[q] being non-negative will become\r\n         negative, so x[q] will increase */\r\n            dir = +1;\r\n        }\r\n        else\r\n        {  /* delta d[q] > 0, so d[q] being non-positive will become\r\n         positive, so x[q] will decrease */\r\n            dir = -1;\r\n        }\r\n        /* if the problem is maximization, correct the direction */\r\n        if (P.dir == GLP_MAX) dir = - dir;\r\n        /* check that we didn't make a silly mistake */\r\n        if (dir > 0)\r\n            xassert(stat == GLP_NL || stat == GLP_NF);\r\n        else\r\n            xassert(stat == GLP_NU || stat == GLP_NF);\r\n        /* compute column of the simplex table corresponding to the\r\n         non-basic variable x[q] */\r\n        clen = glp_eval_tab_col(P, q, cind, cval);\r\n        /* make x[k] temporarily free (unbounded) */\r\n        if (k <= m)\r\n        {  row = P.row[k];\r\n            row.type = GLP_FR;\r\n            row.lb = row.ub = 0.0;\r\n        }\r\n        else\r\n        {  col = P.col[k-m];\r\n            col.type = GLP_FR;\r\n            col.lb = col.ub = 0.0;\r\n        }\r\n        /* use the primal ratio test to determine some basic variable\r\n         which leaves the basis */\r\n        cpiv = glp_prim_rtest(P, clen, cind, cval, dir, 1e-9);\r\n        /* restore original bounds of the basic variable x[k] */\r\n        if (k <= m)\r\n        {  row = P.row[k];\r\n            row.type = type;\r\n            row.lb = lb;\r\n            row.ub = ub;\r\n        }\r\n        else\r\n        {  col = P.col[k-m];\r\n            col.type = type;\r\n            col.lb = lb;\r\n            col.ub = ub;\r\n        }\r\n        if (cpiv == 0)\r\n        {  /* non-basic variable x[q] can change unlimitedly */\r\n            if (dir < 0 && rval[rpiv] > 0.0 ||\r\n                dir > 0 && rval[rpiv] < 0.0)\r\n            {  /* delta x[k] = alfa[k,q] * delta x[q] < 0 */\r\n                new_x = -DBL_MAX;\r\n            }\r\n            else\r\n            {  /* delta x[k] = alfa[k,q] * delta x[q] > 0 */\r\n                new_x = +DBL_MAX;\r\n            }\r\n            store();\r\n            continue;\r\n        }\r\n        /* some basic variable x[p] limits changing non-basic variable\r\n         x[q] in the adjacent basis */\r\n        xassert(1 <= cpiv && cpiv <= clen);\r\n        p = cind[cpiv];\r\n        xassert(1 <= p && p <= m+n);\r\n        xassert(p != k);\r\n        if (p <= m)\r\n        {  row = P.row[p];\r\n            xassert(row.stat == GLP_BS);\r\n            ll = glp_get_row_lb(P, row.i);\r\n            uu = glp_get_row_ub(P, row.i);\r\n            xx = row.prim;\r\n        }\r\n        else\r\n        {  col = P.col[p-m];\r\n            xassert(col.stat == GLP_BS);\r\n            ll = glp_get_col_lb(P, col.j);\r\n            uu = glp_get_col_ub(P, col.j);\r\n            xx = col.prim;\r\n        }\r\n        /* determine delta x[p] = new x[p] - x[p] */\r\n        if (dir < 0 && cval[cpiv] > 0.0 ||\r\n            dir > 0 && cval[cpiv] < 0.0)\r\n        {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\r\n            xassert(ll != -DBL_MAX);\r\n            delta = ll - xx;\r\n        }\r\n        else\r\n        {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\r\n            xassert(uu != +DBL_MAX);\r\n            delta = uu - xx;\r\n        }\r\n        /* compute new x[k] = x[k] + alfa[k,q] * delta x[q], where\r\n         delta x[q] = delta x[p] / alfa[p,q] */\r\n        xassert(cval[cpiv] != 0.0);\r\n        new_x = x + (rval[rpiv] / cval[cpiv]) * delta;\r\n        store();\r\n    }\r\n    callback(coef1, var1, value1, coef2, var2, value2)\r\n};\r\n\r\nvar glp_ios_reason = exports[\"glp_ios_reason\"] = function(tree){\r\n    return tree.reason;\r\n};\r\n\r\nvar glp_ios_get_prob = exports[\"glp_ios_get_prob\"] = function(tree){\r\n    return tree.mip;\r\n};\r\n\r\nfunction glp_ios_tree_size(tree, callback){\r\n    callback(tree.a_cnt, tree.n_cnt, tree.t_cnt);\r\n}\r\n\r\nfunction glp_ios_curr_node(tree){\r\n    /* obtain pointer to the current subproblem */\r\n    var node = tree.curr;\r\n    /* return its reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_next_node(tree, p){\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_next_node: p = \" + p + \"; invalid subproblem reference number\");\r\n    }\r\n\r\n    var node;\r\n    if (p == 0)\r\n    {  /* obtain pointer to the first active subproblem */\r\n        node = tree.head;\r\n    }\r\n    else\r\n    {  /* obtain pointer to the specified subproblem */\r\n        if (!(1 <= p && p <= tree.nslots))\r\n            doError();\r\n        node = tree.slot[p].node;\r\n        if (node == null) doError();\r\n        /* the specified subproblem must be active */\r\n        if (node.count != 0)\r\n            xerror(\"glp_ios_next_node: p = \" + p + \"; subproblem not in the active list\");\r\n        /* obtain pointer to the next active subproblem */\r\n        node = node.next;\r\n    }\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_prev_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_prev_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    if (p == 0)\r\n    {  /* obtain pointer to the last active subproblem */\r\n        node = tree.tail;\r\n    }\r\n    else\r\n    {  /* obtain pointer to the specified subproblem */\r\n        if (!(1 <= p && p <= tree.nslots))\r\n            doError();\r\n        node = tree.slot[p].node;\r\n        if (node == null) doError();\r\n        /* the specified subproblem must be active */\r\n        if (node.count != 0)\r\n            xerror(\"glp_ios_prev_node: p = \" + p + \"; subproblem not in the active list\");\r\n        /* obtain pointer to the previous active subproblem */\r\n        node = node.prev;\r\n    }\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_up_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_up_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* obtain pointer to the parent subproblem */\r\n    node = node.up;\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_node_level(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_level: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return the node level */\r\n    return node.level;\r\n}\r\n\r\nfunction glp_ios_node_bound(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_bound: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return the node local bound */\r\n    return node.bound;\r\n}\r\n\r\nfunction glp_ios_best_node(tree){\r\n    return ios_best_node(tree);\r\n}\r\n\r\nfunction glp_ios_mip_gap(tree){\r\n    return ios_relative_gap(tree);\r\n}\r\n\r\nfunction glp_ios_node_data(tree, p)\r\n{\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_level: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return pointer to the application-specific data */\r\n    return node.data;\r\n}\r\n\r\nfunction glp_ios_row_attr(tree, i, attr){\r\n    var row;\r\n    if (!(1 <= i && i <= tree.mip.m))\r\n        xerror(\"glp_ios_row_attr: i = \" + i + \"; row number out of range\");\r\n    row = tree.mip.row[i];\r\n    attr.level = row.level;\r\n    attr.origin = row.origin;\r\n    attr.klass = row.klass;\r\n}\r\n\r\nfunction glp_ios_pool_size(tree){\r\n    /* determine current size of the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_pool_size: operation not allowed\");\r\n    xassert(tree.local != null);\r\n    return tree.local.size;\r\n}\r\n\r\nfunction glp_ios_add_row(tree, name, klass, flags, len, ind, val, type, rhs){\r\n    /* add row (constraint) to the cut pool */\r\n    var num;\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_add_row: operation not allowed\");\r\n    xassert(tree.local != null);\r\n    num = ios_add_row(tree, tree.local, name, klass, flags, len,\r\n        ind, val, type, rhs);\r\n    return num;\r\n}\r\n\r\nfunction glp_ios_del_row(tree, i){\r\n    /* remove row (constraint) from the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_del_row: operation not allowed\");\r\n    ios_del_row(tree.local, i);\r\n}\r\n\r\nfunction glp_ios_clear_pool(tree){\r\n    /* remove all rows (constraints) from the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_clear_pool: operation not allowed\");\r\n    ios_clear_pool(tree.local);\r\n}\r\n\r\nfunction glp_ios_can_branch(tree, j){\r\n    if (!(1 <= j && j <= tree.mip.n))\r\n        xerror(\"glp_ios_can_branch: j = \" + j + \"; column number out of range\");\r\n    return tree.non_int[j];\r\n}\r\n\r\nfunction glp_ios_branch_upon(tree, j, sel){\r\n    if (!(1 <= j && j <= tree.mip.n))\r\n        xerror(\"glp_ios_branch_upon: j = \" + j + \"; column number out of range\");\r\n    if (!(sel == GLP_DN_BRNCH || sel == GLP_UP_BRNCH || sel == GLP_NO_BRNCH))\r\n        xerror(\"glp_ios_branch_upon: sel = \" + sel + \": invalid branch selection flag\");\r\n    if (!(tree.non_int[j]))\r\n        xerror(\"glp_ios_branch_upon: j = \" + j + \"; variable cannot be used to branch upon\");\r\n    if (tree.br_var != 0)\r\n        xerror(\"glp_ios_branch_upon: branching variable already chosen\");\r\n    tree.br_var = j;\r\n    tree.br_sel = sel;\r\n}\r\n\r\nfunction glp_ios_select_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_select_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* the specified subproblem must be active */\r\n    if (node.count != 0)\r\n        xerror(\"glp_ios_select_node: p = \" + p + \"; subproblem not in the active list\");\r\n    /* no subproblem must be selected yet */\r\n    if (tree.next_p != 0)\r\n        xerror(\"glp_ios_select_node: subproblem already selected\");\r\n    /* select the specified subproblem to continue the search */\r\n    tree.next_p = p;\r\n}\r\n\r\nfunction glp_ios_heur_sol(tree, x){\r\n    var mip = tree.mip;\r\n    var m = tree.orig_m;\r\n    var n = tree.n;\r\n    var i, j;\r\n    var obj;\r\n    xassert(mip.m >= m);\r\n    xassert(mip.n == n);\r\n    /* check values of integer variables and compute value of the\r\n     objective function */\r\n    obj = mip.c0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        if (col.kind == GLP_IV)\r\n        {  /* provided value must be integral */\r\n            if (x[j] != Math.floor(x[j])) return 1;\r\n        }\r\n        obj += col.coef * x[j];\r\n    }\r\n    /* check if the provided solution is better than the best known\r\n     integer feasible solution */\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  switch (mip.dir)\r\n    {  case GLP_MIN:\r\n            if (obj >= tree.mip.mip_obj) return 1;\r\n            break;\r\n        case GLP_MAX:\r\n            if (obj <= tree.mip.mip_obj) return 1;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    /* it is better; store it in the problem object */\r\n    if (tree.parm.msg_lev >= GLP_MSG_ON)\r\n        xprintf(\"Solution found by heuristic: \" + obj + \"\");\r\n    mip.mip_stat = GLP_FEAS;\r\n    mip.mip_obj = obj;\r\n    for (j = 1; j <= n; j++)\r\n        mip.col[j].mipx = x[j];\r\n    for (i = 1; i <= m; i++)\r\n    {  var row = mip.row[i];\r\n        var aij;\r\n        row.mipx = 0.0;\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            row.mipx += aij.val * aij.col.mipx;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction glp_ios_terminate(tree){\r\n    if (tree.parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"The search is prematurely terminated due to application request\");\r\n    tree.stop = 1;\r\n}\r\n\r\n/* glpapi14.c (processing models in GNU MathProg language) */\r\n\r\nvar glp_mpl_alloc_wksp = exports[\"glp_mpl_alloc_wksp\"] = function(){\r\n    /* allocate the MathProg translator workspace */\r\n    return mpl_initialize();\r\n};\r\n\r\nvar _glp_mpl_init_rand = exports[\"_glp_mpl_init_rand\"] = function (tran, seed){\r\n    if (tran.phase != 0)\r\n    xerror(\"glp_mpl_init_rand: invalid call sequence\\n\");\r\n    rng_init_rand(tran.rand, seed);\r\n};\r\n\r\nvar glp_mpl_read_model = exports[\"glp_mpl_read_model\"] = function(tran, name, callback, skip){\r\n    /* read and translate model section */\r\n    var ret;\r\n    if (tran.phase != 0)\r\n        xerror(\"glp_mpl_read_model: invalid call sequence\");\r\n    ret = mpl_read_model(tran, name, callback, skip);\r\n    if (ret == 1 || ret == 2)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_read_model_from_string = exports[\"glp_mpl_read_model_from_string\"] = function(tran, name, str, skip){\r\n    var pos = 0;\r\n    return glp_mpl_read_model(tran, name,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        },\r\n        skip\r\n    )\r\n};\r\n\r\nvar glp_mpl_read_data = exports[\"glp_mpl_read_data\"] = function(tran, name, callback){\r\n    /* read and translate data section */\r\n    var ret;\r\n    if (!(tran.phase == 1 || tran.phase == 2))\r\n        xerror(\"glp_mpl_read_data: invalid call sequence\");\r\n    ret = mpl_read_data(tran, name, callback);\r\n    if (ret == 2)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_read_data_from_string = exports[\"glp_mpl_read_data_from_string\"] = function(tran, name, str){\r\n    var pos = 0;\r\n    return glp_mpl_read_data(tran, name,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        }\r\n    )\r\n};\r\n\r\nvar glp_mpl_generate = exports[\"glp_mpl_generate\"] = function(tran, name, callback, tablecb){\r\n    /* generate the model */\r\n    var ret;\r\n    if (!(tran.phase == 1 || tran.phase == 2))\r\n        xerror(\"glp_mpl_generate: invalid call sequence\\n\");\r\n    ret = mpl_generate(tran, name, callback, tablecb);\r\n    if (ret == 3)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_build_prob = exports[\"glp_mpl_build_prob\"] = function(tran, prob){\r\n    /* build LP/MIP problem instance from the model */\r\n    var m, n, i, j, t, kind, type, len, ind;\r\n    var lb, ub, val;\r\n    if (tran.phase != 3)\r\n        xerror(\"glp_mpl_build_prob: invalid call sequence\\n\");\r\n    /* erase the problem object */\r\n    glp_erase_prob(prob);\r\n    /* set problem name */\r\n    glp_set_prob_name(prob, mpl_get_prob_name(tran));\r\n    /* build rows (constraints) */\r\n    m = mpl_get_num_rows(tran);\r\n    if (m > 0)\r\n        glp_add_rows(prob, m);\r\n    for (i = 1; i <= m; i++)\r\n    {  /* set row name */\r\n        glp_set_row_name(prob, i, mpl_get_row_name(tran, i));\r\n        /* set row bounds */\r\n        type = mpl_get_row_bnds(tran, i, function(l,u){lb=l; ub=u});\r\n        switch (type)\r\n        {  case MPL_FR: type = GLP_FR; break;\r\n            case MPL_LO: type = GLP_LO; break;\r\n            case MPL_UP: type = GLP_UP; break;\r\n            case MPL_DB: type = GLP_DB; break;\r\n            case MPL_FX: type = GLP_FX; break;\r\n            default: xassert(type != type);\r\n        }\r\n        if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1.0 + Math.abs(lb)))\r\n        {  type = GLP_FX;\r\n            if (Math.abs(lb) <= Math.abs(ub)) ub = lb; else lb = ub;\r\n        }\r\n        glp_set_row_bnds(prob, i, type, lb, ub);\r\n        /* warn about non-zero constant term */\r\n        if (mpl_get_row_c0(tran, i) != 0.0)\r\n            xprintf(\"glp_mpl_build_prob: row \" + mpl_get_row_name(tran, i) + \"; constant term \" + mpl_get_row_c0(tran, i) + \" ignored\");\r\n    }\r\n    /* build columns (variables) */\r\n    n = mpl_get_num_cols(tran);\r\n    if (n > 0)\r\n        glp_add_cols(prob, n);\r\n    for (j = 1; j <= n; j++)\r\n    {  /* set column name */\r\n        glp_set_col_name(prob, j, mpl_get_col_name(tran, j));\r\n        /* set column kind */\r\n        kind = mpl_get_col_kind(tran, j);\r\n        switch (kind)\r\n        {  case MPL_NUM:\r\n            break;\r\n            case MPL_INT:\r\n            case MPL_BIN:\r\n                glp_set_col_kind(prob, j, GLP_IV);\r\n                break;\r\n            default:\r\n                xassert(kind != kind);\r\n        }\r\n        /* set column bounds */\r\n        type = mpl_get_col_bnds(tran, j, function(l,u){lb=l; ub=u});\r\n        switch (type)\r\n        {  case MPL_FR: type = GLP_FR; break;\r\n            case MPL_LO: type = GLP_LO; break;\r\n            case MPL_UP: type = GLP_UP; break;\r\n            case MPL_DB: type = GLP_DB; break;\r\n            case MPL_FX: type = GLP_FX; break;\r\n            default: xassert(type != type);\r\n        }\r\n        if (kind == MPL_BIN)\r\n        {  if (type == GLP_FR || type == GLP_UP || lb < 0.0) lb = 0.0;\r\n            if (type == GLP_FR || type == GLP_LO || ub > 1.0) ub = 1.0;\r\n            type = GLP_DB;\r\n        }\r\n        if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1.0 + Math.abs(lb)))\r\n        {  type = GLP_FX;\r\n            if (Math.abs(lb) <= Math.abs(ub)) ub = lb; else lb = ub;\r\n        }\r\n        glp_set_col_bnds(prob, j, type, lb, ub);\r\n    }\r\n    /* load the constraint matrix */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  len = mpl_get_mat_row(tran, i, ind, val);\r\n        glp_set_mat_row(prob, i, len, ind, val);\r\n    }\r\n    /* build objective function (the first objective is used) */\r\n    for (i = 1; i <= m; i++)\r\n    {  kind = mpl_get_row_kind(tran, i);\r\n        if (kind == MPL_MIN || kind == MPL_MAX)\r\n        {  /* set objective name */\r\n            glp_set_obj_name(prob, mpl_get_row_name(tran, i));\r\n            /* set optimization direction */\r\n            glp_set_obj_dir(prob, kind == MPL_MIN ? GLP_MIN : GLP_MAX);\r\n            /* set constant term */\r\n            glp_set_obj_coef(prob, 0, mpl_get_row_c0(tran, i));\r\n            /* set objective coefficients */\r\n            len = mpl_get_mat_row(tran, i, ind, val);\r\n            for (t = 1; t <= len; t++)\r\n                glp_set_obj_coef(prob, ind[t], val[t]);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_mpl_postsolve = exports[\"glp_mpl_postsolve\"] = function(tran, prob, sol){\r\n    /* postsolve the model */\r\n    var i, j, m, n, stat, ret;\r\n    var prim, dual;\r\n    if (!(tran.phase == 3 && !tran.flag_p))\r\n        xerror(\"glp_mpl_postsolve: invalid call sequence\");\r\n    if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\r\n        xerror(\"glp_mpl_postsolve: sol = \" + sol + \"; invalid parameter\");\r\n    m = mpl_get_num_rows(tran);\r\n    n = mpl_get_num_cols(tran);\r\n    if (!(m == glp_get_num_rows(prob) &&\r\n        n == glp_get_num_cols(prob)))\r\n        xerror(\"glp_mpl_postsolve: wrong problem object\\n\");\r\n    if (!mpl_has_solve_stmt(tran))\r\n      return 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (sol == GLP_SOL)\r\n    {  stat = glp_get_row_stat(prob, i);\r\n        prim = glp_get_row_prim(prob, i);\r\n        dual = glp_get_row_dual(prob, i);\r\n    }\r\n    else if (sol == GLP_IPT)\r\n    {  stat = 0;\r\n        prim = glp_ipt_row_prim(prob, i);\r\n        dual = glp_ipt_row_dual(prob, i);\r\n    }\r\n    else if (sol == GLP_MIP)\r\n    {  stat = 0;\r\n        prim = glp_mip_row_val(prob, i);\r\n        dual = 0.0;\r\n    }\r\n    else\r\n        xassert(sol != sol);\r\n        if (Math.abs(prim) < 1e-9) prim = 0.0;\r\n        if (Math.abs(dual) < 1e-9) dual = 0.0;\r\n        mpl_put_row_soln(tran, i, stat, prim, dual);\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  if (sol == GLP_SOL)\r\n    {  stat = glp_get_col_stat(prob, j);\r\n        prim = glp_get_col_prim(prob, j);\r\n        dual = glp_get_col_dual(prob, j);\r\n    }\r\n    else if (sol == GLP_IPT)\r\n    {  stat = 0;\r\n        prim = glp_ipt_col_prim(prob, j);\r\n        dual = glp_ipt_col_dual(prob, j);\r\n    }\r\n    else if (sol == GLP_MIP)\r\n    {  stat = 0;\r\n        prim = glp_mip_col_val(prob, j);\r\n        dual = 0.0;\r\n    }\r\n    else\r\n        xassert(sol != sol);\r\n        if (Math.abs(prim) < 1e-9) prim = 0.0;\r\n        if (Math.abs(dual) < 1e-9) dual = 0.0;\r\n        mpl_put_col_soln(tran, j, stat, prim, dual);\r\n    }\r\n    ret = mpl_postsolve(tran);\r\n    if (ret == 3)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    return ret;\r\n};\r\n\r\nfunction avl_create_tree(fcmp, info)\r\n{     /* create AVL tree */\r\n    var tree = {};\r\n    //tree.pool = dmp_create_pool();\r\n    tree.root = null;\r\n    tree.fcmp = fcmp;\r\n    tree.info = info;\r\n    tree.size = 0;\r\n    tree.height = 0;\r\n    return tree;\r\n}\r\n\r\nfunction avl_strcmp(info, key1, key2)\r\n{   /* compare character string keys */\r\n    if (key1 == key2)\r\n        return 0;\r\n    else if (key1 > key2)\r\n        return 1;\r\n    else\r\n        return -1;\r\n}\r\n\r\nfunction avl_insert_node(tree, key)\r\n{   /* insert new node into AVL tree */\r\n    var p, q, r, flag;\r\n    /* find an appropriate point for insertion */\r\n    p = null; q = tree.root;\r\n    while (q != null)\r\n    {  p = q;\r\n        if (tree.fcmp(tree.info, key, p.key) <= 0)\r\n        {  flag = 0;\r\n            q = p.left;\r\n            p.rank++;\r\n        }\r\n        else\r\n        {  flag = 1;\r\n            q = p.right;\r\n        }\r\n    }\r\n    /* create new node and insert it into the tree */\r\n    r = {};\r\n    r.key = key; r.type = 0; r.link = null;\r\n    r.rank = 1; r.up = p;\r\n    r.flag = (p == null ? 0 : flag);\r\n    r.bal = 0; r.left = null; r.right = null;\r\n    tree.size++;\r\n    if (p == null)\r\n        tree.root = r;\r\n    else\r\n    if (flag == 0) p.left = r; else p.right = r;\r\n    /* go upstairs to the root and correct all subtrees affected by\r\n     insertion */\r\n    while (p != null)\r\n    {  if (flag == 0)\r\n    {  /* the height of the left subtree of [p] is increased */\r\n        if (p.bal > 0)\r\n        {  p.bal = 0;\r\n            break;\r\n        }\r\n        if (p.bal < 0)\r\n        {  rotate_subtree(tree, p);\r\n            break;\r\n        }\r\n        p.bal = -1; flag = p.flag; p = p.up;\r\n    }\r\n    else\r\n    {  /* the height of the right subtree of [p] is increased */\r\n        if (p.bal < 0)\r\n        {  p.bal = 0;\r\n            break;\r\n        }\r\n        if (p.bal > 0)\r\n        {  rotate_subtree(tree, p);\r\n            break;\r\n        }\r\n        p.bal = +1; flag = p.flag; p = p.up;\r\n    }\r\n    }\r\n    /* if the root has been reached, the height of the entire tree is\r\n     increased */\r\n    if (p == null) tree.height++;\r\n    return r;\r\n}\r\n\r\nfunction avl_set_node_type(node, type)\r\n{     /* assign the type field of specified node */\r\n    node.type = type;\r\n}\r\n\r\nfunction avl_set_node_link(node, link)\r\n{     /* assign the link field of specified node */\r\n    node.link = link;\r\n}\r\n\r\nfunction avl_find_node(tree, key)\r\n{     /* find node in AVL tree */\r\n    var p, c;\r\n    p = tree.root;\r\n    while (p != null)\r\n    {  c = tree.fcmp(tree.info, key, p.key);\r\n        if (c == 0) break;\r\n        p = (c < 0 ? p.left : p.right);\r\n    }\r\n    return p;\r\n}\r\n\r\nfunction avl_get_node_type(node)\r\n{     /* retrieve the type field of specified node */\r\n    return node.type;\r\n}\r\n\r\nfunction avl_get_node_link(node)\r\n{     /* retrieve the link field of specified node */\r\n    return node.link;\r\n}\r\n\r\nfunction find_next_node(tree, node)\r\n{   /* find next node in AVL tree */\r\n    var p, q;\r\n    if (tree.root == null) return null;\r\n    p = node;\r\n    q = (p == null ? tree.root : p.right);\r\n    if (q == null)\r\n    {  /* go upstairs from the left subtree */\r\n        for (;;)\r\n        {  q = p.up;\r\n            if (q == null) break;\r\n            if (p.flag == 0) break;\r\n            p = q;\r\n        }\r\n    }\r\n    else\r\n    {  /* go downstairs into the right subtree */\r\n        for (;;)\r\n        {  p = q.left;\r\n            if (p == null) break;\r\n            q = p;\r\n        }\r\n    }\r\n    return q;\r\n}\r\n\r\nfunction avl_delete_node(tree, node)\r\n{   /* delete specified node from AVL tree */\r\n    var f, p, q, r, s, x, y, flag;\r\n    p = node;\r\n    /* if both subtrees of the specified node are non-empty, the node\r\n     should be interchanged with the next one, at least one subtree\r\n     of which is always empty */\r\n    if (p.left != null && p.right != null){\r\n        f = p.up; q = p.left;\r\n        r = find_next_node(tree, p); s = r.right;\r\n        if (p.right == r)\r\n        {  if (f == null)\r\n            tree.root = r;\r\n        else\r\n        if (p.flag == 0) f.left = r; else f.right = r;\r\n            r.rank = p.rank; r.up = f;\r\n            r.flag = p.flag; r.bal = p.bal;\r\n            r.left = q; r.right = p;\r\n            q.up = r;\r\n            p.rank = 1; p.up = r; p.flag = 1;\r\n            p.bal = (s == null ? 0 : +1);\r\n            p.left = null; p.right = s;\r\n            if (s != null) s.up = p;\r\n        }\r\n        else\r\n        {  x = p.right; y = r.up;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            r.rank = p.rank; r.up = f;\r\n            r.flag = p.flag; r.bal = p.bal;\r\n            r.left = q; r.right = x;\r\n            q.up = r; x.up = r; y.left = p;\r\n            p.rank = 1; p.up = y; p.flag = 0;\r\n            p.bal = (s == null ? 0 : +1);\r\n            p.left = null; p.right = s;\r\n            if (s != null) s.up = p;\r\n        }\r\n    }\r\n    /* now the specified node [p] has at least one empty subtree;\r\n     go upstairs to the root and adjust the rank field of all nodes\r\n     affected by deletion */\r\n        q = p; f = q.up;\r\n    while (f != null)\r\n    {  if (q.flag == 0) f.rank--;\r\n        q = f; f = q.up;\r\n    }\r\n    /* delete the specified node from the tree */\r\n    f = p.up; flag = p.flag;\r\n    q = p.left != null ? p.left : p.right;\r\n    if (f == null)\r\n        tree.root = q;\r\n    else\r\n    if (flag == 0) f.left = q; else f.right = q;\r\n    if (q != null){q.up = f; q.flag = flag}\r\n    tree.size--;\r\n    /* go upstairs to the root and correct all subtrees affected by\r\n     deletion */\r\n    while (f != null)\r\n    {  if (flag == 0)\r\n    {  /* the height of the left subtree of [f] is decreased */\r\n        if (f.bal == 0)\r\n        {  f.bal = +1;\r\n            break;\r\n        }\r\n        if (f.bal < 0)\r\n            f.bal = 0;\r\n        else\r\n        {  f = rotate_subtree(tree, f);\r\n            if (f.bal < 0) break;\r\n        }\r\n        flag = f.flag; f = f.up;\r\n    }\r\n    else\r\n    {  /* the height of the right subtree of [f] is decreased */\r\n        if (f.bal == 0)\r\n        {  f.bal = -1;\r\n            break;\r\n        }\r\n        if (f.bal > 0)\r\n            f.bal = 0;\r\n        else\r\n        {  f = rotate_subtree(tree, f);\r\n            if (f.bal > 0) break;\r\n        }\r\n        flag = f.flag; f = f.up;\r\n    }\r\n    }\r\n    /* if the root has been reached, the height of the entire tree is\r\n     decreased */\r\n    if (f == null) tree.height--;\r\n}\r\n\r\nfunction rotate_subtree(tree, node)\r\n{     /* restore balance of AVL subtree */\r\n    var f, p, q, r, x, y;\r\n    xassert(node != null);\r\n    p = node;\r\n    if (p.bal < 0)\r\n    {  /* perform negative (left) rotation */\r\n        f = p.up; q = p.left; r = q.right;\r\n        if (q.bal <= 0)\r\n        {  /* perform single negative rotation */\r\n            if (f == null)\r\n                tree.root = q;\r\n            else\r\n            if (p.flag == 0) f.left = q; else f.right = q;\r\n            p.rank -= q.rank;\r\n            q.up = f; q.flag = p.flag; q.bal++; q.right = p;\r\n            p.up = q; p.flag = 1;\r\n            p.bal = -q.bal; p.left = r;\r\n            if (r != null){r.up = p; r.flag = 0}\r\n            node = q;\r\n        }\r\n        else\r\n        {  /* perform double negative rotation */\r\n            x = r.left; y = r.right;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            p.rank -= (q.rank + r.rank);\r\n            r.rank += q.rank;\r\n            p.bal = (r.bal >= 0 ? 0 : +1);\r\n            q.bal = (r.bal <= 0 ? 0 : -1);\r\n            r.up = f; r.flag = p.flag; r.bal = 0;\r\n            r.left = q; r.right = p;\r\n            p.up = r; p.flag = 1; p.left = y;\r\n            q.up = r; q.flag = 0; q.right = x;\r\n            if (x != null){x.up = q; x.flag = 1}\r\n            if (y != null){y.up = p; y.flag = 0}\r\n            node = r;\r\n        }\r\n    }\r\n    else\r\n    {  /* perform positive (right) rotation */\r\n        f = p.up; q = p.right; r = q.left;\r\n        if (q.bal >= 0)\r\n        {  /* perform single positive rotation */\r\n            if (f == null)\r\n                tree.root = q;\r\n            else\r\n            if (p.flag == 0) f.left = q; else f.right = q;\r\n            q.rank += p.rank;\r\n            q.up = f; q.flag = p.flag; q.bal--; q.left = p;\r\n            p.up = q; p.flag = 0;\r\n            p.bal = -q.bal; p.right = r;\r\n            if (r != null){r.up = p; r.flag = 1}\r\n            node = q;\r\n        }\r\n        else\r\n        {  /* perform double positive rotation */\r\n            x = r.left; y = r.right;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            q.rank -= r.rank;\r\n            r.rank += p.rank;\r\n            p.bal = (r.bal <= 0 ? 0 : -1);\r\n            q.bal = (r.bal >= 0 ? 0 : +1);\r\n            r.up = f; r.flag = p.flag; r.bal = 0;\r\n            r.left = p; r.right = q;\r\n            p.up = r; p.flag = 0; p.right = x;\r\n            q.up = r; q.flag = 1; q.left = y;\r\n            if (x != null){x.up = p; x.flag = 1}\r\n            if (y != null){y.up = q; y.flag = 0}\r\n            node = r;\r\n        }\r\n    }\r\n    return node;\r\n}\r\n/* return codes: */\r\nvar\r\n    BFD_ESING   = 1,  /* singular matrix */\r\n    BFD_ECOND   = 2,  /* ill-conditioned matrix */\r\n    BFD_ECHECK  = 3,  /* insufficient accuracy */\r\n    BFD_ELIMIT  = 4,  /* update limit reached */\r\n    BFD_EROOM   = 5;  /* SVA overflow */\r\n\r\nfunction bfd_create_it(){\r\n    var bfd = {};\r\n    bfd.valid = 0;\r\n    bfd.type = GLP_BF_FT;\r\n    bfd.fhv = null;\r\n    bfd.lpf = null;\r\n    bfd.lu_size = 0;\r\n    bfd.piv_tol = 0.10;\r\n    bfd.piv_lim = 4;\r\n    bfd.suhl = 1;\r\n    bfd.eps_tol = 1e-15;\r\n    bfd.max_gro = 1e+10;\r\n    bfd.nfs_max = 100;\r\n    bfd.upd_tol = 1e-6;\r\n    bfd.nrs_max = 100;\r\n    bfd.rs_size = 1000;\r\n    bfd.upd_lim = -1;\r\n    bfd.upd_cnt = 0;\r\n    return bfd;\r\n}\r\n\r\nfunction bfd_set_parm(bfd, parm){\r\n    /* change LP basis factorization control parameters */\r\n    xassert(bfd != null);\r\n    bfd.type = parm.type;\r\n    bfd.lu_size = parm.lu_size;\r\n    bfd.piv_tol = parm.piv_tol;\r\n    bfd.piv_lim = parm.piv_lim;\r\n    bfd.suhl = parm.suhl;\r\n    bfd.eps_tol = parm.eps_tol;\r\n    bfd.max_gro = parm.max_gro;\r\n    bfd.nfs_max = parm.nfs_max;\r\n    bfd.upd_tol = parm.upd_tol;\r\n    bfd.nrs_max = parm.nrs_max;\r\n    bfd.rs_size = parm.rs_size;\r\n}\r\n\r\nfunction bfd_factorize(bfd, m, bh, col, info){\r\n    var luf;\r\n    var nov, ret;\r\n    xassert(bfd != null);\r\n    xassert(1 <= m && m <= M_MAX);\r\n    /* invalidate the factorization */\r\n    bfd.valid = 0;\r\n    /* create the factorization, if necessary */\r\n    nov = 0;\r\n    switch (bfd.type)\r\n    {  case GLP_BF_FT:\r\n        bfd.lpf = null;\r\n        if (bfd.fhv == null){\r\n            bfd.fhv = fhv_create_it(); nov = 1;\r\n        }\r\n        break;\r\n        case GLP_BF_BG:\r\n        case GLP_BF_GR:\r\n            bfd.fhv = null;\r\n            if (bfd.lpf == null){\r\n                bfd.lpf = lpf_create_it(); nov = 1;\r\n            }\r\n            break;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    /* set control parameters specific to LUF */\r\n    if (bfd.fhv != null)\r\n        luf = bfd.fhv.luf;\r\n    else if (bfd.lpf != null)\r\n        luf = bfd.lpf.luf;\r\n    else\r\n        xassert(bfd != bfd);\r\n    if (nov) luf.new_sva = bfd.lu_size;\r\n    luf.piv_tol = bfd.piv_tol;\r\n    luf.piv_lim = bfd.piv_lim;\r\n    luf.suhl = bfd.suhl;\r\n    luf.eps_tol = bfd.eps_tol;\r\n    luf.max_gro = bfd.max_gro;\r\n    /* set control parameters specific to FHV */\r\n    if (bfd.fhv != null)\r\n    {  if (nov) bfd.fhv.hh_max = bfd.nfs_max;\r\n        bfd.fhv.upd_tol = bfd.upd_tol;\r\n    }\r\n    /* set control parameters specific to LPF */\r\n    if (bfd.lpf != null)\r\n    {  if (nov) bfd.lpf.n_max = bfd.nrs_max;\r\n        if (nov) bfd.lpf.v_size = bfd.rs_size;\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    if (bfd.fhv != null)\r\n    {  switch (fhv_factorize(bfd.fhv, m, col, info))\r\n    {  case 0:\r\n            break;\r\n        case FHV_ESING:\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case FHV_ECOND:\r\n            ret = BFD_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else if (bfd.lpf != null)\r\n    {  switch (lpf_factorize(bfd.lpf, m, bh, col, info))\r\n    {  case 0:\r\n            /* set the Schur complement update type */\r\n            switch (bfd.type)\r\n            {  case GLP_BF_BG:\r\n                /* Bartels-Golub update */\r\n                bfd.lpf.scf.t_opt = SCF_TBG;\r\n                break;\r\n                case GLP_BF_GR:\r\n                    /* Givens rotation update */\r\n                    bfd.lpf.scf.t_opt = SCF_TGR;\r\n                    break;\r\n                default:\r\n                    xassert(bfd != bfd);\r\n            }\r\n            break;\r\n        case LPF_ESING:\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case LPF_ECOND:\r\n            ret = BFD_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else\r\n        xassert(bfd != bfd);\r\n    /* the basis matrix has been successfully factorized */\r\n    bfd.valid = 1;\r\n    bfd.upd_cnt = 0;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction bfd_ftran(bfd, x){\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    if (bfd.fhv != null)\r\n        fhv_ftran(bfd.fhv, x);\r\n    else if (bfd.lpf != null)\r\n        lpf_ftran(bfd.lpf, x);\r\n    else\r\n        xassert(bfd != bfd);\r\n}\r\n\r\nfunction bfd_btran(bfd, x){\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    if (bfd.fhv != null)\r\n        fhv_btran(bfd.fhv, x);\r\n    else if (bfd.lpf != null)\r\n        lpf_btran(bfd.lpf, x);\r\n    else\r\n        xassert(bfd != bfd);\r\n}\r\n\r\nfunction bfd_update_it(bfd, j, bh, len, ind, idx, val){\r\n    var ret;\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    /* try to update the factorization */\r\n    if (bfd.fhv != null)\r\n    {  switch (fhv_update_it(bfd.fhv, j, len, ind, idx, val))\r\n    {  case 0:\r\n            break;\r\n        case FHV_ESING:\r\n            bfd.valid = 0;\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case FHV_ECHECK:\r\n            bfd.valid = 0;\r\n            ret = BFD_ECHECK;\r\n            return ret;\r\n        case FHV_ELIMIT:\r\n            bfd.valid = 0;\r\n            ret = BFD_ELIMIT;\r\n            return ret;\r\n        case FHV_EROOM:\r\n            bfd.valid = 0;\r\n            ret = BFD_EROOM;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else if (bfd.lpf != null)\r\n    {  switch (lpf_update_it(bfd.lpf, j, bh, len, ind, idx, val))\r\n    {  case 0:\r\n            break;\r\n        case LPF_ESING:\r\n            bfd.valid = 0;\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case LPF_ELIMIT:\r\n            bfd.valid = 0;\r\n            ret = BFD_ELIMIT;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else\r\n        xassert(bfd != bfd);\r\n    /* the factorization has been successfully updated */\r\n    /* increase the update count */\r\n    bfd.upd_cnt++;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction bfd_get_count(bfd){\r\n    /* determine factorization update count */\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    return bfd.upd_cnt;\r\n}\r\n\r\nfunction check_parm(func, parm){\r\n    /* check control parameters */\r\n    xassert(func != null);\r\n    xassert(parm != null);\r\n}\r\n\r\nvar CHAR_SET = \"!\\\"#$%&()/,.;?@_`'{}|~\";\r\n/* characters, which may appear in symbolic names */\r\n\r\nvar glp_read_lp = exports[\"glp_read_lp\"] = function(P, parm, callback){\r\n    var\r\n        T_EOF        = 0x00,  /* end of file */\r\n        T_MINIMIZE   = 0x01,  /* keyword 'minimize' */\r\n        T_MAXIMIZE   = 0x02,  /* keyword 'maximize' */\r\n        T_SUBJECT_TO = 0x03,  /* keyword 'subject to' */\r\n        T_BOUNDS     = 0x04,  /* keyword 'bounds' */\r\n        T_GENERAL    = 0x05,  /* keyword 'general' */\r\n        T_INTEGER    = 0x06,  /* keyword 'integer' */\r\n        T_BINARY     = 0x07,  /* keyword 'binary' */\r\n        T_END        = 0x08,  /* keyword 'end' */\r\n        T_NAME       = 0x09,  /* symbolic name */\r\n        T_NUMBER     = 0x0A,  /* numeric constant */\r\n        T_PLUS       = 0x0B,  /* delimiter '+' */\r\n        T_MINUS      = 0x0C,  /* delimiter '-' */\r\n        T_COLON      = 0x0D,  /* delimiter ':' */\r\n        T_LE         = 0x0E,  /* delimiter '<=' */\r\n        T_GE         = 0x0F,  /* delimiter '>=' */\r\n        T_EQ         = 0x10;  /* delimiter '=' */\r\n\r\n    function error(csa, fmt){\r\n        /* print error message and terminate processing */\r\n        throw new Error(csa.count + \": \" + fmt);\r\n    }\r\n\r\n    function warning(csa, fmt)\r\n    {     /* print warning message and continue processing */\r\n        xprintf(csa.count + \": warning: \" + fmt);\r\n    }\r\n\r\n    function read_char(csa){\r\n        /* read next character from input file */\r\n        var c;\r\n        xassert(csa.c != XEOF);\r\n        if (csa.c == '\\n') csa.count++;\r\n        c = csa.callback();\r\n        if (c < 0)\r\n        {\r\n            if (csa.c == '\\n')\r\n            {  csa.count--;\r\n                c = XEOF;\r\n            }\r\n            else\r\n            {  warning(csa, \"missing final end of line\");\r\n                c = '\\n';\r\n            }\r\n        }\r\n        else if (c == '\\n'){\r\n\r\n        }\r\n        else if (isspace(c))\r\n            c = ' ';\r\n        else if (iscntrl(c))\r\n            error(csa, \"invalid control character \" + c.charCodeAt(0));\r\n        csa.c = c;\r\n    }\r\n\r\n    function add_char(csa){\r\n        /* append current character to current token */\r\n        csa.image += csa.c;\r\n        read_char(csa);\r\n    }\r\n\r\n    function the_same(s1, s2)\r\n    {\r\n        /* compare two character strings ignoring case sensitivity */\r\n        return (s1.toLowerCase() == s2.toLowerCase())?1:0;\r\n    }\r\n\r\n    function scan_token(csa){\r\n        /* scan next token */\r\n        var flag;\r\n        csa.token = -1;\r\n        csa.image = \"\";\r\n        csa.value = 0.0;\r\n\r\n\r\n        function name(){  /* symbolic name */\r\n            csa.token = T_NAME;\r\n            while (isalnum(csa.c) || strchr(CHAR_SET, csa.c) >= 0)\r\n                add_char(csa);\r\n            if (flag)\r\n            {  /* check for keyword */\r\n                if (the_same(csa.image, \"minimize\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"minimum\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"min\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"maximize\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"maximum\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"max\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"subject\"))\r\n                {  if (csa.c == ' ')\r\n                {  read_char(csa);\r\n                    if (tolower(csa.c) == 't')\r\n                    {  csa.token = T_SUBJECT_TO;\r\n                        csa.image += ' ';\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'o')\r\n                            error(csa, \"keyword `subject to' incomplete\");\r\n                        add_char(csa);\r\n                        if (isalpha(csa.c))\r\n                            error(csa, \"keyword `\" + csa.image + csa.c + \"...' not recognized\");\r\n                    }\r\n                }\r\n                }\r\n                else if (the_same(csa.image, \"such\"))\r\n                {  if (csa.c == ' ')\r\n                {  read_char(csa);\r\n                    if (tolower(csa.c) == 't')\r\n                    {  csa.token = T_SUBJECT_TO;\r\n                        csa.image += ' ';\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'h')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'a')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 't')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (isalpha(csa.c))\r\n                            error(csa, \"keyword `\" + csa.image + csa.c + \"...' not recognized\");\r\n                    }\r\n                }\r\n                }\r\n                else if (the_same(csa.image, \"st\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"s.t.\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"st.\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"bounds\"))\r\n                    csa.token = T_BOUNDS;\r\n                else if (the_same(csa.image, \"bound\"))\r\n                    csa.token = T_BOUNDS;\r\n                else if (the_same(csa.image, \"general\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"generals\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"gen\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"integer\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"integers\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"int\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"binary\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"binaries\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"bin\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"end\"))\r\n                    csa.token = T_END;\r\n            }\r\n        }\r\n\r\n        while (true){\r\n            flag = 0;\r\n            /* skip non-significant characters */\r\n            while (csa.c == ' ') read_char(csa);\r\n            /* recognize and scan current token */\r\n            if (csa.c == XEOF)\r\n                csa.token = T_EOF;\r\n            else if (csa.c == '\\n')\r\n            {  read_char(csa);\r\n                /* if the next character is letter, it may begin a keyword */\r\n                if (isalpha(csa.c))\r\n                {  flag = 1;\r\n                    name();\r\n                } else\r\n                    continue;\r\n            }\r\n            else if (csa.c == '\\\\')\r\n            {  /* comment; ignore everything until end-of-line */\r\n                while (csa.c != '\\n') read_char(csa);\r\n                continue;\r\n            }\r\n            else if (isalpha(csa.c) || csa.c != '.' && strchr(CHAR_SET, csa.c) >= 0){\r\n                name();\r\n\r\n            }\r\n            else if (isdigit(csa.c) || csa.c == '.')\r\n            {  /* numeric constant */\r\n                csa.token = T_NUMBER;\r\n                /* scan integer part */\r\n                while (isdigit(csa.c)) add_char(csa);\r\n                /* scan optional fractional part (it is mandatory, if there is\r\n                 no integer part) */\r\n                if (csa.c == '.')\r\n                {  add_char(csa);\r\n                    if (csa.image.length == 1 && !isdigit(csa.c))\r\n                        error(csa, \"invalid use of decimal point\");\r\n                    while (isdigit(csa.c)) add_char(csa);\r\n                }\r\n                /* scan optional decimal exponent */\r\n                if (csa.c == 'e' || csa.c == 'E')\r\n                {  add_char(csa);\r\n                    if (csa.c == '+' || csa.c == '-') add_char(csa);\r\n                    if (!isdigit(csa.c))\r\n                        error(csa, \"numeric constant `\" + csa.image + \"' incomplete\");\r\n                    while (isdigit(csa.c)) add_char(csa);\r\n                }\r\n                /* convert the numeric constant to floating-point */\r\n                csa.value = Number(csa.image);\r\n                if (csa.value == Number.NaN)\r\n                    error(csa, \"numeric constant `\" + csa.image + \"' out of range\");\r\n            }\r\n            else if (csa.c == '+'){\r\n                csa.token = T_PLUS; add_char(csa);\r\n            }\r\n            else if (csa.c == '-'){\r\n                csa.token = T_MINUS; add_char(csa);\r\n            }\r\n            else if (csa.c == ':'){\r\n                csa.token = T_COLON; add_char(csa);\r\n            }\r\n            else if (csa.c == '<')\r\n            {  csa.token = T_LE; add_char(csa);\r\n                if (csa.c == '=') add_char(csa);\r\n            }\r\n            else if (csa.c == '>')\r\n            {  csa.token = T_GE; add_char(csa);\r\n                if (csa.c == '=') add_char(csa);\r\n            }\r\n            else if (csa.c == '=')\r\n            {  csa.token = T_EQ; add_char(csa);\r\n                if (csa.c == '<'){\r\n                    csa.token = T_LE; add_char(csa);\r\n                }\r\n                else if (csa.c == '>'){\r\n                    csa.token = T_GE; add_char(csa);\r\n                }\r\n            }\r\n            else\r\n                error(csa, \"character `\" + csa.c + \"' not recognized\");\r\n            break\r\n        }\r\n\r\n        /* skip non-significant characters */\r\n        while (csa.c == ' ') read_char(csa);\r\n    }\r\n\r\n    function find_col(csa, name){\r\n        /* find column by its symbolic name */\r\n        var j = glp_find_col(csa.P, name);\r\n        if (j == 0)\r\n        {  /* not found; create new column */\r\n            j = glp_add_cols(csa.P, 1);\r\n            glp_set_col_name(csa.P, j, name);\r\n            /* enlarge working arrays, if necessary */\r\n            if (csa.n_max < j)\r\n            {  var n_max = csa.n_max;\r\n                var ind = csa.ind;\r\n                var val = csa.val;\r\n                var flag = csa.flag;\r\n                var lb = csa.lb;\r\n                var ub = csa.ub;\r\n                csa.n_max += csa.n_max;\r\n                csa.ind = new Int32Array(1+csa.n_max);\r\n                xcopyArr(csa.ind, 1, ind, 1, n_max);\r\n                csa.val = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.val, 1, val, 1, n_max);\r\n                csa.flag = new Int8Array(1+csa.n_max);\r\n                xfillArr(csa.flag, 1, 0, csa.n_max);\r\n                xcopyArr(csa.flag, 1, flag, 1, n_max);\r\n                csa.lb = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.lb, 1, lb, 1, n_max);\r\n                csa.ub = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.ub, 1, ub, 1, n_max);\r\n            }\r\n            csa.lb[j] = +DBL_MAX; csa.ub[j] = -DBL_MAX;\r\n        }\r\n        return j;\r\n    }\r\n\r\n    function parse_linear_form(csa){\r\n        var j, k, len = 0, newlen;\r\n        var s, coef;\r\n\r\n        while(true){\r\n            /* parse an optional sign */\r\n            if (csa.token == T_PLUS){\r\n                s = +1.0; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_MINUS){\r\n                s = -1.0; scan_token(csa);\r\n            }\r\n            else\r\n                s = +1.0;\r\n            /* parse an optional coefficient */\r\n            if (csa.token == T_NUMBER){\r\n                coef = csa.value; scan_token(csa);\r\n            }\r\n            else\r\n                coef = 1.0;\r\n            /* parse a variable name */\r\n            if (csa.token != T_NAME)\r\n                error(csa, \"missing variable name\");\r\n            /* find the corresponding column */\r\n            j = find_col(csa, csa.image);\r\n            /* check if the variable is already used in the linear form */\r\n            if (csa.flag[j])\r\n                error(csa, \"multiple use of variable `\" + csa.image + \"' not allowed\");\r\n            /* add new term to the linear form */\r\n            len++; csa.ind[len] = j; csa.val[len] = s * coef;\r\n            /* and mark that the variable is used in the linear form */\r\n            csa.flag[j] = 1;\r\n            scan_token(csa);\r\n            /* if the next token is a sign, there is another term */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS) continue;\r\n            /* clear marks of the variables used in the linear form */\r\n            for (k = 1; k <= len; k++) csa.flag[csa.ind[k]] = 0;\r\n            /* remove zero coefficients */\r\n            newlen = 0;\r\n            for (k = 1; k <= len; k++)\r\n            {  if (csa.val[k] != 0.0)\r\n            {  newlen++;\r\n                csa.ind[newlen] = csa.ind[k];\r\n                csa.val[newlen] = csa.val[k];\r\n            }\r\n            }\r\n            break;\r\n        }\r\n        return newlen;\r\n    }\r\n\r\n    function parse_objective(csa){\r\n        /* parse objective sense */\r\n        var k, len;\r\n        /* parse the keyword 'minimize' or 'maximize' */\r\n        if (csa.token == T_MINIMIZE)\r\n            glp_set_obj_dir(csa.P, GLP_MIN);\r\n        else if (csa.token == T_MAXIMIZE)\r\n            glp_set_obj_dir(csa.P, GLP_MAX);\r\n        else\r\n            xassert(csa != csa);\r\n        scan_token(csa);\r\n        /* parse objective name */\r\n        if (csa.token == T_NAME && csa.c == ':')\r\n        {  /* objective name is followed by a colon */\r\n            glp_set_obj_name(csa.P, csa.image);\r\n            scan_token(csa);\r\n            xassert(csa.token == T_COLON);\r\n            scan_token(csa);\r\n        }\r\n        else\r\n        {  /* objective name is not specified; use default */\r\n            glp_set_obj_name(csa.P, \"obj\");\r\n        }\r\n        /* parse linear form */\r\n        len = parse_linear_form(csa);\r\n        for (k = 1; k <= len; k++)\r\n            glp_set_obj_coef(csa.P, csa.ind[k], csa.val[k]);\r\n    }\r\n\r\n    function parse_constraints(csa){\r\n        var i, len, type;\r\n        var s;\r\n        /* parse the keyword 'subject to' */\r\n        xassert(csa.token == T_SUBJECT_TO);\r\n        scan_token(csa);\r\n\r\n        while (true){\r\n            /* create new row (constraint) */\r\n            i = glp_add_rows(csa.P, 1);\r\n            /* parse row name */\r\n            if (csa.token == T_NAME && csa.c == ':')\r\n            {  /* row name is followed by a colon */\r\n                if (glp_find_row(csa.P, csa.image) != 0)\r\n                    error(csa, \"constraint `\" + csa.image + \"' multiply defined\");\r\n                glp_set_row_name(csa.P, i, csa.image);\r\n                scan_token(csa);\r\n                xassert(csa.token == T_COLON);\r\n                scan_token(csa);\r\n            }\r\n            else\r\n            {  /* row name is not specified; use default */\r\n                glp_set_row_name(csa.P, i, \"r.\" + csa.count);\r\n            }\r\n            /* parse linear form */\r\n            len = parse_linear_form(csa);\r\n            glp_set_mat_row(csa.P, i, len, csa.ind, csa.val);\r\n            /* parse constraint sense */\r\n            if (csa.token == T_LE){\r\n                type = GLP_UP; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_GE){\r\n                type = GLP_LO; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_EQ){\r\n                type = GLP_FX; scan_token(csa);\r\n            }\r\n            else\r\n                error(csa, \"missing constraint sense\");\r\n            /* parse right-hand side */\r\n            if (csa.token == T_PLUS){\r\n                s = +1.0; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_MINUS){\r\n                s = -1.0; scan_token(csa);\r\n            }\r\n            else\r\n                s = +1.0;\r\n            if (csa.token != T_NUMBER)\r\n                error(csa, \"missing right-hand side\");\r\n            glp_set_row_bnds(csa.P, i, type, s * csa.value, s * csa.value);\r\n            /* the rest of the current line must be empty */\r\n            if (!(csa.c == '\\n' || csa.c == XEOF))\r\n                error(csa, \"invalid symbol(s) beyond right-hand side\");\r\n            scan_token(csa);\r\n            /* if the next token is a sign, numeric constant, or a symbolic\r\n             name, here is another constraint */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS ||\r\n                csa.token == T_NUMBER || csa.token == T_NAME) continue;\r\n            break;\r\n        }\r\n    }\r\n\r\n    function set_lower_bound(csa, j, lb){\r\n        /* set lower bound of j-th variable */\r\n        if (csa.lb[j] != +DBL_MAX)\r\n        {\r\n            warning(csa, \"lower bound of variable `\" + glp_get_col_name(csa.P, j) + \"' redefined\");\r\n        }\r\n        csa.lb[j] = lb;\r\n    }\r\n\r\n    function set_upper_bound(csa, j, ub){\r\n        /* set upper bound of j-th variable */\r\n        if (csa.ub[j] != -DBL_MAX)\r\n        {\r\n            warning(csa, \"upper bound of variable `\" + glp_get_col_name(csa.P, j) + \"' redefined\");\r\n        }\r\n        csa.ub[j] = ub;\r\n    }\r\n\r\n    function parse_bounds(csa){\r\n        var j, lb_flag;\r\n        var lb, s;\r\n        /* parse the keyword 'bounds' */\r\n        xassert(csa.token == T_BOUNDS);\r\n        scan_token(csa);\r\n\r\n        while (true){\r\n            /* bound definition can start with a sign, numeric constant, or\r\n             a symbolic name */\r\n            if (!(csa.token == T_PLUS || csa.token == T_MINUS ||\r\n                csa.token == T_NUMBER || csa.token == T_NAME)) return;\r\n            /* parse bound definition */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n            {  /* parse signed lower bound */\r\n                lb_flag = 1;\r\n                s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                scan_token(csa);\r\n                if (csa.token == T_NUMBER){\r\n                    lb = s * csa.value; scan_token(csa);\r\n                }\r\n                else if (the_same(csa.image, \"infinity\") ||\r\n                    the_same(csa.image, \"inf\"))\r\n                {  if (s > 0.0)\r\n                    error(csa, \"invalid use of `+inf' as lower bound\");\r\n                    lb = -DBL_MAX; scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing lower bound\");\r\n            }\r\n            else if (csa.token == T_NUMBER)\r\n            {  /* parse unsigned lower bound */\r\n                lb_flag = 1;\r\n                lb = csa.value; scan_token(csa);\r\n            }\r\n            else\r\n            {  /* lower bound is not specified */\r\n                lb_flag = 0;\r\n            }\r\n            /* parse the token that should follow the lower bound */\r\n            if (lb_flag)\r\n            {  if (csa.token != T_LE)\r\n                error(csa, \"missing `<', `<=', or `=<' after lower bound\");\r\n                scan_token(csa);\r\n            }\r\n            /* parse variable name */\r\n            if (csa.token != T_NAME)\r\n                error(csa, \"missing variable name\");\r\n            j = find_col(csa, csa.image);\r\n            /* set lower bound */\r\n            if (lb_flag) set_lower_bound(csa, j, lb);\r\n            scan_token(csa);\r\n            /* parse the context that follows the variable name */\r\n            if (csa.token == T_LE)\r\n            {  /* parse upper bound */\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed upper bound */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_upper_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else if (the_same(csa.image, \"infinity\") ||\r\n                        the_same(csa.image, \"inf\"))\r\n                    {  if (s < 0.0)\r\n                        error(csa, \"invalid use of `-inf' as upper bound\");\r\n                        set_upper_bound(csa, j, +DBL_MAX);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing upper bound\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned upper bound */\r\n                    set_upper_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing upper bound\");\r\n            }\r\n            else if (csa.token == T_GE)\r\n            {  /* parse lower bound */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x >= ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed lower bound */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_lower_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else if (the_same(csa.image, \"infinity\") ||\r\n                        the_same(csa.image, \"inf\") == 0)\r\n                    {  if (s > 0.0)\r\n                        error(csa, \"invalid use of `+inf' as lower bound\");\r\n                        set_lower_bound(csa, j, -DBL_MAX);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing lower bound\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned lower bound */\r\n                    set_lower_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing lower bound\");\r\n            }\r\n            else if (csa.token == T_EQ)\r\n            {  /* parse fixed value */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x = ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed fixed value */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_lower_bound(csa, j, s * csa.value);\r\n                        set_upper_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing fixed value\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned fixed value */\r\n                    set_lower_bound(csa, j, csa.value);\r\n                    set_upper_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing fixed value\");\r\n            }\r\n            else if (the_same(csa.image, \"free\"))\r\n            {  /* parse the keyword 'free' */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x free ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                set_lower_bound(csa, j, -DBL_MAX);\r\n                set_upper_bound(csa, j, +DBL_MAX);\r\n                scan_token(csa);\r\n            }\r\n            else if (!lb_flag)\r\n            {  /* neither lower nor upper bounds are specified */\r\n                error(csa, \"invalid bound definition\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function parse_integer(csa){\r\n        var j, binary;\r\n        /* parse the keyword 'general', 'integer', or 'binary' */\r\n        if (csa.token == T_GENERAL){\r\n            binary = 0; scan_token(csa);\r\n        }\r\n        else if (csa.token == T_INTEGER){\r\n            binary = 0; scan_token(csa);\r\n        }\r\n        else if (csa.token == T_BINARY){\r\n            binary = 1; scan_token(csa);\r\n        }\r\n        else\r\n            xassert(csa != csa);\r\n        /* parse list of variables (may be empty) */\r\n        while (csa.token == T_NAME)\r\n        {  /* find the corresponding column */\r\n            j = find_col(csa, csa.image);\r\n            /* change kind of the variable */\r\n            glp_set_col_kind(csa.P, j, GLP_IV);\r\n            /* set 0-1 bounds for the binary variable */\r\n            if (binary)\r\n            {  set_lower_bound(csa, j, 0.0);\r\n                set_upper_bound(csa, j, 1.0);\r\n            }\r\n            scan_token(csa);\r\n        }\r\n    }\r\n\r\n    /* read problem data in CPLEX LP format */\r\n    var csa = {};\r\n    var ret;\r\n    xprintf(\"Reading problem data\");\r\n    if (parm == null){\r\n        parm = {};\r\n    }\r\n    /* check control parameters */\r\n    check_parm(\"glp_read_lp\", parm);\r\n    /* initialize common storage area */\r\n    csa.P = P;\r\n    csa.parm = parm;\r\n    csa.callback = callback;\r\n    csa.count = 0;\r\n    csa.c = '\\n';\r\n    csa.token = T_EOF;\r\n    csa.image = \"\";\r\n    csa.value = 0.0;\r\n    csa.n_max = 100;\r\n    csa.ind = new Int32Array(1+csa.n_max);\r\n    csa.val = new Float64Array(1+csa.n_max);\r\n    csa.flag = new Int8Array(1+csa.n_max);\r\n    xfillArr(csa.flag, 1, 0, csa.n_max);\r\n    csa.lb = new Float64Array(1+csa.n_max);\r\n    csa.ub = new Float64Array(1+csa.n_max);\r\n    /* erase problem object */\r\n    glp_erase_prob(P);\r\n    glp_create_index(P);\r\n    /* scan very first token */\r\n    scan_token(csa);\r\n    /* parse definition of the objective function */\r\n    if (!(csa.token == T_MINIMIZE || csa.token == T_MAXIMIZE))\r\n        error(csa, \"`minimize' or `maximize' keyword missing\");\r\n    parse_objective(csa);\r\n    /* parse constraints section */\r\n    if (csa.token != T_SUBJECT_TO)\r\n        error(csa, \"constraints section missing\");\r\n    parse_constraints(csa);\r\n    /* parse optional bounds section */\r\n    if (csa.token == T_BOUNDS) parse_bounds(csa);\r\n    /* parse optional general, integer, and binary sections */\r\n    while (csa.token == T_GENERAL ||\r\n        csa.token == T_INTEGER ||\r\n        csa.token == T_BINARY) parse_integer(csa);\r\n    /* check for the keyword 'end' */\r\n    if (csa.token == T_END)\r\n        scan_token(csa);\r\n    else if (csa.token == T_EOF)\r\n        warning(csa, \"keyword `end' missing\");\r\n    else\r\n        error(csa, \"symbol \" + csa.image + \" in wrong position\");\r\n    /* nothing must follow the keyword 'end' (except comments) */\r\n    if (csa.token != T_EOF)\r\n        error(csa, \"extra symbol(s) detected beyond `end'\");\r\n    /* set bounds of variables */\r\n    {  var j, type;\r\n        var lb, ub;\r\n        for (j = 1; j <= P.n; j++)\r\n        {  lb = csa.lb[j];\r\n            ub = csa.ub[j];\r\n            if (lb == +DBL_MAX) lb = 0.0;      /* default lb */\r\n            if (ub == -DBL_MAX) ub = +DBL_MAX; /* default ub */\r\n            if (lb == -DBL_MAX && ub == +DBL_MAX)\r\n                type = GLP_FR;\r\n            else if (ub == +DBL_MAX)\r\n                type = GLP_LO;\r\n            else if (lb == -DBL_MAX)\r\n                type = GLP_UP;\r\n            else if (lb != ub)\r\n                type = GLP_DB;\r\n            else\r\n                type = GLP_FX;\r\n            glp_set_col_bnds(csa.P, j, type, lb, ub);\r\n        }\r\n    }\r\n    /* print some statistics */\r\n    xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" + P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\"));\r\n    if (glp_get_num_int(P) > 0)\r\n    {  var ni = glp_get_num_int(P);\r\n        var nb = glp_get_num_bin(P);\r\n        if (ni == 1)\r\n        {  if (nb == 0)\r\n            xprintf(\"One variable is integer\");\r\n        else\r\n            xprintf(\"One variable is binary\");\r\n        }\r\n        else\r\n        {   var line = ni + \" integer variables, \";\r\n            if (nb == 0)\r\n                line += \"none\";\r\n            else if (nb == 1)\r\n                line += \"one\";\r\n            else if (nb == ni)\r\n                line += \"all\";\r\n            else\r\n                line += nb;\r\n            xprintf(line + \" of which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n        }\r\n    }\r\n    xprintf(csa.count + \" lines were read\");\r\n    /* problem data has been successfully read */\r\n    glp_delete_index(P);\r\n    glp_sort_matrix(P);\r\n    ret = 0;\r\n\r\n    function done(){\r\n        if (ret != 0) glp_erase_prob(P);\r\n        return ret;\r\n    }\r\n    return done();\r\n};\r\n\r\nvar glp_write_lp = exports[\"glp_write_lp\"] = function(P, parm, callback){\r\n\r\n    function check_name(name){\r\n        /* check if specified name is valid for CPLEX LP format */\r\n        if (name[0] == '.') return 1;\r\n        if (isdigit((name[0]))) return 1;\r\n        for (var i = 0; i < name.length; i++)\r\n        {  if (!isalnum(name[i]) &&\r\n            strchr(CHAR_SET, name[i]) < 0) return 1;\r\n        }\r\n        return 0; /* name is ok */\r\n    }\r\n\r\n    function adjust_name(name){\r\n        /* attempt to adjust specified name to make it valid for CPLEX LP format */\r\n        for (var i = 0; i < name.length; i++)\r\n        {  if (name[i] == ' ')\r\n            name[i] = '_';\r\n        else if (name[i] == '-')\r\n            name[i] = '~';\r\n        else if (name[i] == '[')\r\n            name[i] = '(';\r\n        else if (name[i] == ']')\r\n            name[i] = ')';\r\n        }\r\n    }\r\n\r\n    function row_name(csa, i){\r\n        /* construct symbolic name of i-th row (constraint) */\r\n        var name;\r\n        if (i == 0)\r\n            name = glp_get_obj_name(csa.P);\r\n        else\r\n            name = glp_get_row_name(csa.P, i);\r\n        if (name == null) return fake();\r\n        adjust_name(name);\r\n        if (check_name(name)) return fake();\r\n        return name;\r\n\r\n        function fake(){\r\n            if (i == 0)\r\n                return \"obj\";\r\n            else\r\n                return \"r_\" + i;\r\n        }\r\n    }\r\n\r\n    function col_name(csa, j){\r\n        /* construct symbolic name of j-th column (variable) */\r\n        var name = glp_get_col_name(csa.P, j);\r\n        if (name == null) return fake();\r\n        adjust_name(name);\r\n        if (check_name(name)) return fake();\r\n        return name;\r\n        function fake(){\r\n            return \"x_\" + j;\r\n        }\r\n    }\r\n\r\n    /* write problem data in CPLEX LP format */\r\n    var csa = {};\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, len, flag, count, ret;\r\n    var line, term, name;\r\n    xprintf(\"Writing problem data\");\r\n    if (parm == null){\r\n        parm = {};\r\n    }\r\n    /* check control parameters */\r\n    check_parm(\"glp_write_lp\", parm);\r\n    /* initialize common storage area */\r\n    csa.P = P;\r\n    csa.parm = parm;\r\n    count = 0;\r\n    /* write problem name */\r\n    callback(\"\\\\* Problem: \" + (P.name == null ? \"Unknown\" : P.name) + \" *\\\\\"); count++;\r\n    callback(\"\"); count++;\r\n    /* the problem should contain at least one row and one column */\r\n    if (!(P.m > 0 && P.n > 0))\r\n    {  xprintf(\"Warning: problem has no rows/columns\");\r\n        callback(\"\\\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\\\"); count++;\r\n        callback(\"\"); count++;\r\n        return skip();\r\n    }\r\n    /* write the objective function definition */\r\n    if (P.dir == GLP_MIN){\r\n        callback(\"Minimize\"); count++;\r\n    }\r\n    else if (P.dir == GLP_MAX){\r\n        callback(\"Maximize\"); count++;\r\n    }\r\n    else\r\n        xassert(P != P);\r\n    name = row_name(csa, 0);\r\n    line = \" \" + name + \":\";\r\n    len = 0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.coef != 0.0 || col.ptr == null)\r\n        {  len++;\r\n            name = col_name(csa, j);\r\n            if (col.coef == 0.0)\r\n                term = \" + 0 \" + name; /* empty column */\r\n            else if (col.coef == +1.0)\r\n                term = \" + \" + name;\r\n            else if (col.coef == -1.0)\r\n                term = \" - \" + name;\r\n            else if (col.coef > 0.0)\r\n                term = \" + \" + col.coef + \" \" + name;\r\n            else\r\n                term = \" - \" + (-col.coef) + \" \" + name;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n\r\n            line += term;\r\n        }\r\n    }\r\n    if (len == 0)\r\n    {  /* empty objective */\r\n        term = \" 0 \" + col_name(csa, 1);\r\n        line += term;\r\n    }\r\n    callback(line); count++;\r\n    if (P.c0 != 0.0){\r\n        callback(\"\\\\* constant term = \" + P.c0 + \" *\\\\\"); count++;\r\n    }\r\n\r\n    callback(\"\"); count++;\r\n    /* write the constraints section */\r\n    callback(\"Subject To\"); count++;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.type == GLP_FR) continue; /* skip free row */\r\n        name = row_name(csa, i);\r\n        line = \" \" + name + \":\";\r\n        /* linear form */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  name = col_name(csa, aij.col.j);\r\n            if (aij.val == +1.0)\r\n                term =  \" + \" + name;\r\n            else if (aij.val == -1.0)\r\n                term = \" - \" + name;\r\n            else if (aij.val > 0.0)\r\n                term = \" + \" + aij.val + \" \"  + name;\r\n            else\r\n                term = \" - \" + (-aij.val) + \" \" + name;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n\r\n            line += term;\r\n        }\r\n        if (row.type == GLP_DB)\r\n        {  /* double-bounded (ranged) constraint */\r\n            term = \" - ~r_\" + i;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n            line += term;\r\n        }\r\n        else if (row.ptr == null)\r\n        {  /* empty constraint */\r\n            term = \" 0 \" + col_name(csa, 1);\r\n            line += term;\r\n        }\r\n        /* right hand-side */\r\n        if (row.type == GLP_LO)\r\n            term = \" >= \" + row.lb;\r\n        else if (row.type == GLP_UP)\r\n            term = \" <= \" + row.ub;\r\n        else if (row.type == GLP_DB || row.type == GLP_FX)\r\n            term = \" = \" + row.lb;\r\n        else\r\n            xassert(row != row);\r\n        if (line.length + term.length > 72){\r\n            callback(line); line = \"\"; count++;\r\n        }\r\n        line += term;\r\n        callback(line); count++;\r\n    }\r\n    callback(\"\"); count++;\r\n    /* write the bounds section */\r\n    flag = 0;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.type != GLP_DB) continue;\r\n        if (!flag){\r\n            callback(\"Bounds\"); flag = 1; count++;\r\n        }\r\n\r\n        callback(\" 0 <= ~r_\" + i + \" <= \" + (row.ub - row.lb)); count++;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.type == GLP_LO && col.lb == 0.0) continue;\r\n        if (!flag){\r\n            callback(\"Bounds\"); flag = 1; count++;\r\n        }\r\n        name = col_name(csa, j);\r\n        if (col.type == GLP_FR){\r\n            callback(\" \" + name + \" free\"); count++;\r\n        }\r\n        else if (col.type == GLP_LO){\r\n            callback(\" \" + name + \" >= \" + col.lb); count++;\r\n        }\r\n        else if (col.type == GLP_UP){\r\n            callback(\" -Inf <= \" + name + \" <= \" + col.ub); count++;\r\n        }\r\n        else if (col.type == GLP_DB){\r\n            callback(\" \" + col.lb + \" <= \" + name + \" <= \" + col.ub); count++;\r\n        }\r\n        else if (col.type == GLP_FX){\r\n            callback(\" \" + name + \" = \" + col.lb); count++;\r\n        }\r\n        else\r\n            xassert(col != col);\r\n    }\r\n    if (flag) callback(\"\"); count++;\r\n    /* write the integer section */\r\n    flag = 0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.kind == GLP_CV) continue;\r\n        xassert(col.kind == GLP_IV);\r\n        if (!flag){\r\n            callback(\"Generals\"); flag = 1; count++;\r\n        }\r\n\r\n        callback(\" \" + col_name(csa, j)); count++;\r\n    }\r\n    if (flag) {callback(\"\"); count++}\r\n\r\n    function skip(){\r\n        /* write the end keyword */\r\n        callback(\"End\"); count++;\r\n        /* problem data has been successfully written */\r\n        xprintf(count + \" lines were written\");\r\n        return 0;\r\n    }\r\n    return skip();\r\n};\r\n\r\nvar glp_read_lp_from_string = exports[\"glp_read_lp_from_string\"] = function(P, parm, str){\r\n    var pos = 0;\r\n    return glp_read_lp(P, parm,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        }\r\n    )\r\n};\r\n\r\n/* return codes: */\r\nvar\r\n    FHV_ESING   = 1,  /* singular matrix */\r\n    FHV_ECOND   = 2,  /* ill-conditioned matrix */\r\n    FHV_ECHECK  = 3,  /* insufficient accuracy */\r\n    FHV_ELIMIT  = 4,  /* update limit reached */\r\n    FHV_EROOM   = 5;  /* SVA overflow */\r\n\r\nfunction fhv_create_it(){\r\n    var fhv;\r\n    fhv = {};\r\n    fhv.m_max = fhv.m = 0;\r\n    fhv.valid = 0;\r\n    fhv.luf = luf_create_it();\r\n    fhv.hh_max = 50;\r\n    fhv.hh_nfs = 0;\r\n    fhv.hh_ind = fhv.hh_ptr = fhv.hh_len = null;\r\n    fhv.p0_row = fhv.p0_col = null;\r\n    fhv.cc_ind = null;\r\n    fhv.cc_val = null;\r\n    fhv.upd_tol = 1e-6;\r\n    fhv.nnz_h = 0;\r\n    return fhv;\r\n}\r\n\r\nfunction fhv_factorize(fhv, m, col, info){\r\n    var ret;\r\n    if (m < 1)\r\n        xerror(\"fhv_factorize: m = \" + m + \"; invalid parameter\");\r\n    if (m > M_MAX)\r\n        xerror(\"fhv_factorize: m = \" + m + \"; matrix too big\");\r\n    fhv.m = m;\r\n    /* invalidate the factorization */\r\n    fhv.valid = 0;\r\n    /* allocate/reallocate arrays, if necessary */\r\n    if (fhv.hh_ind == null)\r\n        fhv.hh_ind = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.hh_ptr == null)\r\n        fhv.hh_ptr = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.hh_len == null)\r\n        fhv.hh_len = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.m_max < m)\r\n    {\r\n        fhv.m_max = m + 100;\r\n        fhv.p0_row = new Int32Array(1+fhv.m_max);\r\n        fhv.p0_col = new Int32Array(1+fhv.m_max);\r\n        fhv.cc_ind = new Int32Array(1+fhv.m_max);\r\n        fhv.cc_val = new Float64Array(1+fhv.m_max);\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    switch (luf_factorize(fhv.luf, m, col, info))\r\n    {  case 0:\r\n        break;\r\n        case LUF_ESING:\r\n            ret = FHV_ESING;\r\n            return ret;\r\n        case LUF_ECOND:\r\n            ret = FHV_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(fhv != fhv);\r\n    }\r\n    /* the basis matrix has been successfully factorized */\r\n    fhv.valid = 1;\r\n    /* H := I */\r\n    fhv.hh_nfs = 0;\r\n    /* P0 := P */\r\n    xcopyArr(fhv.p0_row, 1, fhv.luf.pp_row, 1, m);\r\n    xcopyArr(fhv.p0_col, 1, fhv.luf.pp_col, 1, m);\r\n    /* currently H has no factors */\r\n    fhv.nnz_h = 0;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction fhv_h_solve(fhv, tr, x){\r\n    var nfs = fhv.hh_nfs;\r\n    var hh_ind = fhv.hh_ind;\r\n    var hh_ptr = fhv.hh_ptr;\r\n    var hh_len = fhv.hh_len;\r\n    var sv_ind = fhv.luf.sv_ind;\r\n    var sv_val = fhv.luf.sv_val;\r\n    var i, k, beg, end, ptr;\r\n    var temp;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_h_solve: the factorization is not valid\");\r\n    if (!tr)\r\n    {  /* solve the system H*x = b */\r\n        for (k = 1; k <= nfs; k++)\r\n        {  i = hh_ind[k];\r\n            temp = x[i];\r\n            beg = hh_ptr[k];\r\n            end = beg + hh_len[k] - 1;\r\n            for (ptr = beg; ptr <= end; ptr++)\r\n                temp -= sv_val[ptr] * x[sv_ind[ptr]];\r\n            x[i] = temp;\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system H'*x = b */\r\n        for (k = nfs; k >= 1; k--)\r\n        {  i = hh_ind[k];\r\n            temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            beg = hh_ptr[k];\r\n            end = beg + hh_len[k] - 1;\r\n            for (ptr = beg; ptr <= end; ptr++)\r\n                x[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n        }\r\n    }\r\n}\r\n\r\nfunction fhv_ftran(fhv, x){\r\n    var pp_row = fhv.luf.pp_row;\r\n    var pp_col = fhv.luf.pp_col;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_ftran: the factorization is not valid\");\r\n    /* B = F*H*V, therefore inv(B) = inv(V)*inv(H)*inv(F) */\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 0, x);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n    fhv_h_solve(fhv, 0, x);\r\n    luf_v_solve(fhv.luf, 0, x);\r\n}\r\n\r\nfunction fhv_btran(fhv, x){\r\n    var pp_row = fhv.luf.pp_row;\r\n    var pp_col = fhv.luf.pp_col;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_btran: the factorization is not valid\");\r\n    /* B = F*H*V, therefore inv(B') = inv(F')*inv(H')*inv(V') */\r\n    luf_v_solve(fhv.luf, 1, x);\r\n    fhv_h_solve(fhv, 1, x);\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 1, x);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n}\r\n\r\nfunction fhv_update_it(fhv, j, len, ind, idx, val){\r\n    var m = fhv.m;\r\n    var luf = fhv.luf;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var pp_row = luf.pp_row;\r\n    var pp_col = luf.pp_col;\r\n    var qq_row = luf.qq_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var work = luf.work;\r\n    var eps_tol = luf.eps_tol;\r\n    var hh_ind = fhv.hh_ind;\r\n    var hh_ptr = fhv.hh_ptr;\r\n    var hh_len = fhv.hh_len;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    var cc_ind = fhv.cc_ind;\r\n    var cc_val = fhv.cc_val;\r\n    var upd_tol = fhv.upd_tol;\r\n    var i, i_beg, i_end, i_ptr, j_beg, j_end, j_ptr, k, k1, k2, p, q,\r\n        p_beg, p_end, p_ptr, ptr, ret;\r\n    var f, temp;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_update_it: the factorization is not valid\");\r\n    if (!(1 <= j && j <= m))\r\n        xerror(\"fhv_update_it: j = \" + j + \"; column number out of range\");\r\n    /* check if the new factor of matrix H can be created */\r\n    if (fhv.hh_nfs == fhv.hh_max)\r\n    {  /* maximal number of updates has been reached */\r\n        fhv.valid = 0;\r\n        ret = FHV_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* convert new j-th column of B to dense format */\r\n    for (i = 1; i <= m; i++)\r\n        cc_val[i] = 0.0;\r\n    for (k = 1; k <= len; k++)\r\n    {  i = ind[idx + k];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"fhv_update_it: ind[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        if (cc_val[i] != 0.0)\r\n            xerror(\"fhv_update_it: ind[\" + k + \"] = \" + i + \"; duplicate row index not allowed\");\r\n        if (val[k] == 0.0)\r\n            xerror(\"fhv_update_it: val[\" + k + \"] = \" + val[k] + \"; zero element not allowed\");\r\n        cc_val[i] = val[k];\r\n    }\r\n    /* new j-th column of V := inv(F * H) * (new B[j]) */\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 0, cc_val);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n    fhv_h_solve(fhv, 0, cc_val);\r\n    /* convert new j-th column of V to sparse format */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  temp = cc_val[i];\r\n        if (temp == 0.0 || Math.abs(temp) < eps_tol) continue;\r\n        len++; cc_ind[len] = i; cc_val[len] = temp;\r\n    }\r\n    /* clear old content of j-th column of matrix V */\r\n    j_beg = vc_ptr[j];\r\n    j_end = j_beg + vc_len[j] - 1;\r\n    for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n    {  /* get row index of v[i,j] */\r\n        i = sv_ind[j_ptr];\r\n        /* find v[i,j] in the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; sv_ind[i_ptr] != j; i_ptr++){/* nop */}\r\n        xassert(i_ptr <= i_end);\r\n        /* remove v[i,j] from the i-th row */\r\n        sv_ind[i_ptr] = sv_ind[i_end];\r\n        sv_val[i_ptr] = sv_val[i_end];\r\n        vr_len[i]--;\r\n    }\r\n    /* now j-th column of matrix V is empty */\r\n    luf.nnz_v -= vc_len[j];\r\n    vc_len[j] = 0;\r\n    /* add new elements of j-th column of matrix V to corresponding\r\n     row lists; determine indices k1 and k2 */\r\n    k1 = qq_row[j]; k2 = 0;\r\n    for (ptr = 1; ptr <= len; ptr++)\r\n    {  /* get row index of v[i,j] */\r\n        i = cc_ind[ptr];\r\n        /* at least one unused location is needed in i-th row */\r\n        if (vr_len[i] + 1 > vr_cap[i])\r\n        {  if (luf_enlarge_row(luf, i, vr_len[i] + 10))\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n        }\r\n        /* add v[i,j] to i-th row */\r\n        i_ptr = vr_ptr[i] + vr_len[i];\r\n        sv_ind[i_ptr] = j;\r\n        sv_val[i_ptr] = cc_val[ptr];\r\n        vr_len[i]++;\r\n        /* adjust index k2 */\r\n        if (k2 < pp_col[i]) k2 = pp_col[i];\r\n    }\r\n    /* capacity of j-th column (which is currently empty) should be\r\n     not less than len locations */\r\n    if (vc_cap[j] < len)\r\n    {  if (luf_enlarge_col(luf, j, len))\r\n    {  /* overflow of the sparse vector area */\r\n        fhv.valid = 0;\r\n        luf.new_sva = luf.sv_size + luf.sv_size;\r\n        xassert(luf.new_sva > luf.sv_size);\r\n        ret = FHV_EROOM;\r\n        return ret;\r\n    }\r\n    }\r\n    /* add new elements of matrix V to j-th column list */\r\n    j_ptr = vc_ptr[j];\r\n    xcopyArr(sv_ind, j_ptr, cc_ind, 1, len);\r\n    xcopyArr(sv_val, j_ptr, cc_val, 1, len);\r\n    vc_len[j] = len;\r\n    luf.nnz_v += len;\r\n    /* if k1 > k2, diagonal element u[k2,k2] of matrix U is zero and\r\n     therefore the adjacent basis matrix is structurally singular */\r\n    if (k1 > k2)\r\n    {  fhv.valid = 0;\r\n        ret = FHV_ESING;\r\n        return ret;\r\n    }\r\n    /* perform implicit symmetric permutations of rows and columns of\r\n     matrix U */\r\n    i = pp_row[k1]; j = qq_col[k1];\r\n    for (k = k1; k < k2; k++)\r\n    {  pp_row[k] = pp_row[k+1]; pp_col[pp_row[k]] = k;\r\n        qq_col[k] = qq_col[k+1]; qq_row[qq_col[k]] = k;\r\n    }\r\n    pp_row[k2] = i; pp_col[i] = k2;\r\n    qq_col[k2] = j; qq_row[j] = k2;\r\n    /* now i-th row of the matrix V is k2-th row of matrix U; since\r\n     no pivoting is used, only this row will be transformed */\r\n    /* copy elements of i-th row of matrix V to the working array and\r\n     remove these elements from matrix V */\r\n    for (j = 1; j <= m; j++) work[j] = 0.0;\r\n    i_beg = vr_ptr[i];\r\n    i_end = i_beg + vr_len[i] - 1;\r\n    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n    {  /* get column index of v[i,j] */\r\n        j = sv_ind[i_ptr];\r\n        /* store v[i,j] to the working array */\r\n        work[j] = sv_val[i_ptr];\r\n        /* find v[i,j] in the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++){/* nop */}\r\n        xassert(j_ptr <= j_end);\r\n        /* remove v[i,j] from the j-th column */\r\n        sv_ind[j_ptr] = sv_ind[j_end];\r\n        sv_val[j_ptr] = sv_val[j_end];\r\n        vc_len[j]--;\r\n    }\r\n    /* now i-th row of matrix V is empty */\r\n    luf.nnz_v -= vr_len[i];\r\n    vr_len[i] = 0;\r\n    /* create the next row-like factor of the matrix H; this factor\r\n     corresponds to i-th (transformed) row */\r\n    fhv.hh_nfs++;\r\n    hh_ind[fhv.hh_nfs] = i;\r\n    /* hh_ptr[] will be set later */\r\n    hh_len[fhv.hh_nfs] = 0;\r\n    /* up to (k2 - k1) free locations are needed to add new elements\r\n     to the non-trivial row of the row-like factor */\r\n    if (luf.sv_end - luf.sv_beg < k2 - k1)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < k2 - k1)\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = luf.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n    }\r\n    /* eliminate subdiagonal elements of matrix U */\r\n    for (k = k1; k < k2; k++)\r\n    {  /* v[p,q] = u[k,k] */\r\n        p = pp_row[k]; q = qq_col[k];\r\n        /* this is the crucial point, where even tiny non-zeros should\r\n         not be dropped */\r\n        if (work[q] == 0.0) continue;\r\n        /* compute gaussian multiplier f = v[i,q] / v[p,q] */\r\n        f = work[q] / vr_piv[p];\r\n        /* perform gaussian transformation:\r\n         (i-th row) := (i-th row) - f * (p-th row)\r\n         in order to eliminate v[i,q] = u[k2,k] */\r\n        p_beg = vr_ptr[p];\r\n        p_end = p_beg + vr_len[p] - 1;\r\n        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n            work[sv_ind[p_ptr]] -= f * sv_val[p_ptr];\r\n        /* store new element (gaussian multiplier that corresponds to\r\n         p-th row) in the current row-like factor */\r\n        luf.sv_end--;\r\n        sv_ind[luf.sv_end] = p;\r\n        sv_val[luf.sv_end] = f;\r\n        hh_len[fhv.hh_nfs]++;\r\n    }\r\n    /* set pointer to the current row-like factor of the matrix H\r\n     (if no elements were added to this factor, it is unity matrix\r\n     and therefore can be discarded) */\r\n    if (hh_len[fhv.hh_nfs] == 0)\r\n        fhv.hh_nfs--;\r\n    else\r\n    {  hh_ptr[fhv.hh_nfs] = luf.sv_end;\r\n        fhv.nnz_h += hh_len[fhv.hh_nfs];\r\n    }\r\n    /* store new pivot which corresponds to u[k2,k2] */\r\n    vr_piv[i] = work[qq_col[k2]];\r\n    /* new elements of i-th row of matrix V (which are non-diagonal\r\n     elements u[k2,k2+1], ..., u[k2,m] of matrix U = P*V*Q) now are\r\n     contained in the working array; add them to matrix V */\r\n    len = 0;\r\n    for (k = k2+1; k <= m; k++)\r\n    {  /* get column index and value of v[i,j] = u[k2,k] */\r\n        j = qq_col[k];\r\n        temp = work[j];\r\n        /* if v[i,j] is close to zero, skip it */\r\n        if (Math.abs(temp) < eps_tol) continue;\r\n        /* at least one unused location is needed in j-th column */\r\n        if (vc_len[j] + 1 > vc_cap[j])\r\n        {  if (luf_enlarge_col(luf, j, vc_len[j] + 10))\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n        }\r\n        /* add v[i,j] to j-th column */\r\n        j_ptr = vc_ptr[j] + vc_len[j];\r\n        sv_ind[j_ptr] = i;\r\n        sv_val[j_ptr] = temp;\r\n        vc_len[j]++;\r\n        /* also store v[i,j] to the auxiliary array */\r\n        len++; cc_ind[len] = j; cc_val[len] = temp;\r\n    }\r\n    /* capacity of i-th row (which is currently empty) should be not\r\n     less than len locations */\r\n    if (vr_cap[i] < len)\r\n    {  if (luf_enlarge_row(luf, i, len))\r\n    {  /* overflow of the sparse vector area */\r\n        fhv.valid = 0;\r\n        luf.new_sva = luf.sv_size + luf.sv_size;\r\n        xassert(luf.new_sva > luf.sv_size);\r\n        ret = FHV_EROOM;\r\n        return ret;\r\n    }\r\n    }\r\n    /* add new elements to i-th row list */\r\n    i_ptr = vr_ptr[i];\r\n    xcopyArr(sv_ind, i_ptr, cc_ind, 1, len);\r\n    xcopyArr(sv_val, i_ptr, cc_val, 1, len);\r\n    vr_len[i] = len;\r\n    luf.nnz_v += len;\r\n    /* updating is finished; check that diagonal element u[k2,k2] is\r\n     not very small in absolute value among other elements in k2-th\r\n     row and k2-th column of matrix U = P*V*Q */\r\n    /* temp = max(|u[k2,*]|, |u[*,k2]|) */\r\n    temp = 0.0;\r\n    /* walk through k2-th row of U which is i-th row of V */\r\n    i = pp_row[k2];\r\n    i_beg = vr_ptr[i];\r\n    i_end = i_beg + vr_len[i] - 1;\r\n    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        if (temp < Math.abs(sv_val[i_ptr])) temp = Math.abs(sv_val[i_ptr]);\r\n    /* walk through k2-th column of U which is j-th column of V */\r\n    j = qq_col[k2];\r\n    j_beg = vc_ptr[j];\r\n    j_end = j_beg + vc_len[j] - 1;\r\n    for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n        if (temp < Math.abs(sv_val[j_ptr])) temp = Math.abs(sv_val[j_ptr]);\r\n    /* check that u[k2,k2] is not very small */\r\n    if (Math.abs(vr_piv[i]) < upd_tol * temp)\r\n    {  /* the factorization seems to be inaccurate and therefore must\r\n     be recomputed */\r\n        fhv.valid = 0;\r\n        ret = FHV_ECHECK;\r\n        return ret;\r\n    }\r\n    /* the factorization has been successfully updated */\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction glp_adv_basis(lp, flags){\r\n    function triang(m, n, info, mat, rn, cn){\r\n        var ndx; /* int ndx[1+max(m,n)]; */\r\n        /* this array is used for querying row and column patterns of the\r\n         given matrix A (the third parameter to the routine mat) */\r\n        var rs_len; /* int rs_len[1+m]; */\r\n        /* rs_len[0] is not used;\r\n         rs_len[i], 1 <= i <= m, is number of non-zeros in the i-th row\r\n         of the matrix A, which (non-zeros) belong to the current active\r\n         submatrix */\r\n        var rs_head; /* int rs_head[1+n]; */\r\n        /* rs_head[len], 0 <= len <= n, is the number i of the first row\r\n         of the matrix A, for which rs_len[i] = len */\r\n        var rs_prev; /* int rs_prev[1+m]; */\r\n        /* rs_prev[0] is not used;\r\n         rs_prev[i], 1 <= i <= m, is a number i' of the previous row of\r\n         the matrix A, for which rs_len[i] = rs_len[i'] (zero marks the\r\n         end of this linked list) */\r\n        var rs_next; /* int rs_next[1+m]; */\r\n        /* rs_next[0] is not used;\r\n         rs_next[i], 1 <= i <= m, is a number i' of the next row of the\r\n         matrix A, for which rs_len[i] = rs_len[i'] (zero marks the end\r\n         this linked list) */\r\n        var cs_head;\r\n        /* is a number j of the first column of the matrix A, which has\r\n         maximal number of non-zeros among other columns */\r\n        var cs_prev; /* cs_prev[1+n]; */\r\n        /* cs_prev[0] is not used;\r\n         cs_prev[j], 1 <= j <= n, is a number of the previous column of\r\n         the matrix A with the same or greater number of non-zeros than\r\n         in the j-th column (zero marks the end of this linked list) */\r\n        var cs_next; /* cs_next[1+n]; */\r\n        /* cs_next[0] is not used;\r\n         cs_next[j], 1 <= j <= n, is a number of the next column of\r\n         the matrix A with the same or lesser number of non-zeros than\r\n         in the j-th column (zero marks the end of this linked list) */\r\n        var i, j, ii, jj, k1, k2, len, t, size = 0;\r\n        var head, rn_inv, cn_inv;\r\n        if (!(m > 0 && n > 0))\r\n            xerror(\"triang: m = \" + m + \"; n = \" + n + \"; invalid dimension\");\r\n        /* allocate working arrays */\r\n        ndx = new Int32Array(1+(m >= n ? m : n));\r\n        rs_len = new Int32Array(1+m);\r\n        rs_head = new Int32Array(1+n);\r\n        rs_prev = new Int32Array(1+m);\r\n        rs_next = new Int32Array(1+m);\r\n        cs_prev = new Int32Array(1+n);\r\n        cs_next = new Int32Array(1+n);\r\n        /* build linked lists of columns of the matrix A with the same\r\n         number of non-zeros */\r\n        head = rs_len; /* currently rs_len is used as working array */\r\n        for (j = 1; j <= n; j++)\r\n        {  /* obtain length of the j-th column */\r\n            len = mat(info, -j, ndx);\r\n            xassert(0 <= len && len <= m);\r\n            /* include the j-th column in the corresponding linked list */\r\n            cs_prev[j] = head[len];\r\n            head[len] = j;\r\n        }\r\n        /* merge all linked lists of columns in one linked list, where\r\n         columns are ordered by descending of their lengths */\r\n        cs_head = 0;\r\n        for (len = 0; len <= m; len++)\r\n        {  for (j = head[len]; j != 0; j = cs_prev[j])\r\n        {  cs_next[j] = cs_head;\r\n            cs_head = j;\r\n        }\r\n        }\r\n        jj = 0;\r\n        for (j = cs_head; j != 0; j = cs_next[j])\r\n        {  cs_prev[j] = jj;\r\n            jj = j;\r\n        }\r\n        /* build initial doubly linked lists of rows of the matrix A with\r\n         the same number of non-zeros */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* obtain length of the i-th row */\r\n            rs_len[i] = len = mat(info, +i, ndx);\r\n            xassert(0 <= len && len <= n);\r\n            /* include the i-th row in the correspondng linked list */\r\n            rs_prev[i] = 0;\r\n            rs_next[i] = rs_head[len];\r\n            if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n            rs_head[len] = i;\r\n        }\r\n        /* initially all rows and columns of the matrix A are active */\r\n        for (i = 1; i <= m; i++) rn[i] = 0;\r\n        for (j = 1; j <= n; j++) cn[j] = 0;\r\n        /* set initial bounds of the active submatrix */\r\n        k1 = 1; k2 = n;\r\n        /* main loop starts here */\r\n        while (k1 <= k2)\r\n        {  i = rs_head[1];\r\n            if (i != 0)\r\n            {  /* the i-th row of the matrix A is a row singleton, since\r\n             it has the only non-zero in the active submatrix */\r\n                xassert(rs_len[i] == 1);\r\n                /* determine the number j of an active column of the matrix\r\n                 A, in which this non-zero is placed */\r\n                j = 0;\r\n                t = mat(info, +i, ndx);\r\n                xassert(0 <= t && t <= n);\r\n                for (; t >= 1; t--)\r\n                {  jj = ndx[t];\r\n                    xassert(1 <= jj && jj <= n);\r\n                    if (cn[jj] == 0)\r\n                    {  xassert(j == 0);\r\n                        j = jj;\r\n                    }\r\n                }\r\n                xassert(j != 0);\r\n                /* the singleton is a[i,j]; move a[i,j] to the position\r\n                 b[k1,k1] of the matrix B */\r\n                rn[i] = cn[j] = k1;\r\n                /* shift the left bound of the active submatrix */\r\n                k1++;\r\n                /* increase the size of the lower triangular part */\r\n                size++;\r\n            }\r\n            else\r\n            {  /* the current active submatrix has no row singletons */\r\n                /* remove an active column with maximal number of non-zeros\r\n                 from the active submatrix */\r\n                j = cs_head;\r\n                xassert(j != 0);\r\n                cn[j] = k2;\r\n                /* shift the right bound of the active submatrix */\r\n                k2--;\r\n            }\r\n            /* the j-th column of the matrix A has been removed from the\r\n             active submatrix */\r\n            /* remove the j-th column from the linked list */\r\n            if (cs_prev[j] == 0)\r\n                cs_head = cs_next[j];\r\n            else\r\n                cs_next[cs_prev[j]] = cs_next[j];\r\n            if (cs_next[j] != 0)\r\n                cs_prev[cs_next[j]] = cs_prev[j];\r\n            /* go through non-zeros of the j-th columns and update active\r\n             lengths of the corresponding rows */\r\n            t = mat(info, -j, ndx);\r\n            xassert(0 <= t && t <= m);\r\n            for (; t >= 1; t--)\r\n            {  i = ndx[t];\r\n                xassert(1 <= i && i <= m);\r\n                /* the non-zero a[i,j] has left the active submatrix */\r\n                len = rs_len[i];\r\n                xassert(len >= 1);\r\n                /* remove the i-th row from the linked list of rows with\r\n                 active length len */\r\n                if (rs_prev[i] == 0)\r\n                    rs_head[len] = rs_next[i];\r\n                else\r\n                    rs_next[rs_prev[i]] = rs_next[i];\r\n                if (rs_next[i] != 0)\r\n                    rs_prev[rs_next[i]] = rs_prev[i];\r\n                /* decrease the active length of the i-th row */\r\n                rs_len[i] = --len;\r\n                /* return the i-th row to the corresponding linked list */\r\n                rs_prev[i] = 0;\r\n                rs_next[i] = rs_head[len];\r\n                if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n                rs_head[len] = i;\r\n            }\r\n        }\r\n        /* other rows of the matrix A, which are still active, correspond\r\n         to rows k1, ..., m of the matrix B (in arbitrary order) */\r\n        for (i = 1; i <= m; i++) if (rn[i] == 0) rn[i] = k1++;\r\n        /* but for columns this is not needed, because now the submatrix\r\n         B2 has no columns */\r\n        for (j = 1; j <= n; j++) xassert(cn[j] != 0);\r\n        /* perform some optional checks */\r\n        /* make sure that rn is a permutation of {1, ..., m} and cn is a\r\n         permutation of {1, ..., n} */\r\n        rn_inv = rs_len; /* used as working array */\r\n        for (ii = 1; ii <= m; ii++) rn_inv[ii] = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  ii = rn[i];\r\n            xassert(1 <= ii && ii <= m);\r\n            xassert(rn_inv[ii] == 0);\r\n            rn_inv[ii] = i;\r\n        }\r\n        cn_inv = rs_head; /* used as working array */\r\n        for (jj = 1; jj <= n; jj++) cn_inv[jj] = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  jj = cn[j];\r\n            xassert(1 <= jj && jj <= n);\r\n            xassert(cn_inv[jj] == 0);\r\n            cn_inv[jj] = j;\r\n        }\r\n        /* make sure that the matrix B = P*A*Q really has the form, which\r\n         was declared */\r\n        for (ii = 1; ii <= size; ii++)\r\n        {  var diag = 0;\r\n            i = rn_inv[ii];\r\n            t = mat(info, +i, ndx);\r\n            xassert(0 <= t && t <= n);\r\n            for (; t >= 1; t--)\r\n            {  j = ndx[t];\r\n                xassert(1 <= j && j <= n);\r\n                jj = cn[j];\r\n                if (jj <= size) xassert(jj <= ii);\r\n                if (jj == ii)\r\n                {  xassert(!diag);\r\n                    diag = 1;\r\n                }\r\n            }\r\n            xassert(diag);\r\n        }\r\n        /* return to the calling program */\r\n        return size;\r\n    }\r\n\r\n    function mat(lp, k, ndx){\r\n        /* this auxiliary routine returns the pattern of a given row or\r\n         a given column of the augmented constraint matrix A~ = (I|-A),\r\n         in which columns of fixed variables are implicitly cleared */\r\n        var m = lpx_get_num_rows(lp);\r\n        var n = lpx_get_num_cols(lp);\r\n        var i, j, lll, len = 0;\r\n\r\n        if (k > 0)\r\n        {  /* the pattern of the i-th row is required */\r\n            i = +k;\r\n            xassert(1 <= i && i <= m);\r\n            lll = lpx_get_mat_row(lp, i, ndx, null);\r\n            for (k = 1; k <= lll; k++)\r\n            {\r\n                lpx_get_col_bnds(lp, ndx[k], function(typx){\r\n                        if (typx != LPX_FX) ndx[++len] = m + ndx[k];\r\n                });\r\n\r\n            }\r\n            lpx_get_row_bnds(lp, i, function(typx){\r\n                if (typx != LPX_FX) ndx[++len] = i;\r\n            });\r\n        }\r\n        else\r\n        {  /* the pattern of the j-th column is required */\r\n            j = -k;\r\n            xassert(1 <= j && j <= m+n);\r\n            /* if the (auxiliary or structural) variable x[j] is fixed,\r\n             the pattern of its column is empty */\r\n\r\n            function doit(typx){\r\n                if (typx != LPX_FX)\r\n                {  if (j <= m)\r\n                {  /* x[j] is non-fixed auxiliary variable */\r\n                    ndx[++len] = j;\r\n                }\r\n                else\r\n                {  /* x[j] is non-fixed structural variables */\r\n                    len = lpx_get_mat_col(lp, j-m, ndx, null);\r\n                }\r\n                }\r\n            }\r\n\r\n            if (j <= m)\r\n                lpx_get_row_bnds(lp, j, doit);\r\n            else\r\n                lpx_get_col_bnds(lp, j-m, doit);\r\n\r\n        }\r\n        /* return the length of the row/column pattern */\r\n        return len;\r\n    }\r\n\r\n    function adv_basis(lp){\r\n        var m = lpx_get_num_rows(lp);\r\n        var n = lpx_get_num_cols(lp);\r\n        var i, j, jj, k, size;\r\n        var rn, cn, rn_inv, cn_inv;\r\n        var tagx = new Int32Array(1+m+n);\r\n        xprintf(\"Constructing initial basis...\");\r\n        if (m == 0 || n == 0)\r\n        {  glp_std_basis(lp);\r\n            return;\r\n        }\r\n        /* use the routine triang (see above) to find maximal triangular\r\n         part of the augmented constraint matrix A~ = (I|-A); in order\r\n         to prevent columns of fixed variables to be included in the\r\n         triangular part, such columns are implictly removed from the\r\n         matrix A~ by the routine adv_mat */\r\n        rn = new Int32Array(1+m);\r\n        cn = new Int32Array(1+m+n);\r\n        size = triang(m, m+n, lp, mat, rn, cn);\r\n        if (lpx_get_int_parm(lp, LPX_K_MSGLEV) >= 3)\r\n            xprintf(\"Size of triangular part = \" + size + \"\");\r\n        /* the first size rows and columns of the matrix P*A~*Q (where\r\n         P and Q are permutation matrices defined by the arrays rn and\r\n         cn) form a lower triangular matrix; build the arrays (rn_inv\r\n         and cn_inv), which define the matrices inv(P) and inv(Q) */\r\n        rn_inv = new Int32Array(1+m);\r\n        cn_inv = new Int32Array(1+m+n);\r\n        for (i = 1; i <= m; i++) rn_inv[rn[i]] = i;\r\n        for (j = 1; j <= m+n; j++) cn_inv[cn[j]] = j;\r\n        /* include the columns of the matrix A~, which correspond to the\r\n         first size columns of the matrix P*A~*Q, in the basis */\r\n        for (k = 1; k <= m+n; k++) tagx[k] = -1;\r\n        for (jj = 1; jj <= size; jj++)\r\n        {  j = cn_inv[jj];\r\n            /* the j-th column of A~ is the jj-th column of P*A~*Q */\r\n            tagx[j] = LPX_BS;\r\n        }\r\n        /* if size < m, we need to add appropriate columns of auxiliary\r\n         variables to the basis */\r\n        for (jj = size + 1; jj <= m; jj++)\r\n        {  /* the jj-th column of P*A~*Q should be replaced by the column\r\n         of the auxiliary variable, for which the only unity element\r\n         is placed in the position [jj,jj] */\r\n            i = rn_inv[jj];\r\n            /* the jj-th row of P*A~*Q is the i-th row of A~, but in the\r\n             i-th row of A~ the unity element belongs to the i-th column\r\n             of A~; therefore the disired column corresponds to the i-th\r\n             auxiliary variable (note that this column doesn't belong to\r\n             the triangular part found by the routine triang) */\r\n            xassert(1 <= i && i <= m);\r\n            xassert(cn[i] > size);\r\n            tagx[i] = LPX_BS;\r\n        }\r\n        /* build tags of non-basic variables */\r\n        for (k = 1; k <= m+n; k++){\r\n            if (tagx[k] != LPX_BS){\r\n\r\n                function doit(typx, lb, ub){\r\n                    switch (typx){\r\n                        case LPX_FR:\r\n                            tagx[k] = LPX_NF; break;\r\n                        case LPX_LO:\r\n                            tagx[k] = LPX_NL; break;\r\n                        case LPX_UP:\r\n                            tagx[k] = LPX_NU; break;\r\n                        case LPX_DB:\r\n                            tagx[k] = (Math.abs(lb) <= Math.abs(ub) ? LPX_NL : LPX_NU); break;\r\n                        case LPX_FX:\r\n                            tagx[k] = LPX_NS; break;\r\n                        default:\r\n                            xassert(typx != typx);\r\n                    }\r\n                }\r\n\r\n                if (k <= m)\r\n                    lpx_get_row_bnds(lp, k, doit);\r\n                else\r\n                    lpx_get_col_bnds(lp, k-m, doit);\r\n            }\r\n        }\r\n        for (k = 1; k <= m+n; k++){\r\n            if (k <= m)\r\n                lpx_set_row_stat(lp, k, tagx[k]);\r\n            else\r\n                lpx_set_col_stat(lp, k-m, tagx[k]);\r\n        }\r\n    }\r\n\r\n    if (flags != 0)\r\n        xerror(\"glp_adv_basis: flags = \" + flags + \"; invalid flags\");\r\n    if (lp.m == 0 || lp.n == 0)\r\n        glp_std_basis(lp);\r\n    else\r\n        adv_basis(lp);\r\n}\r\n\r\nfunction cpx_basis(lp){\r\n    /* main routine */\r\n    var C, C2, C3, C4;\r\n    var m, n, i, j, jk, k, l, ll, t, n2, n3, n4, type, len, I, r, ind;\r\n    var alpha, gamma, cmax, temp, v, val;\r\n    xprintf(\"Constructing initial basis...\");\r\n    /* determine the number of rows and columns */\r\n    m = glp_get_num_rows(lp);\r\n    n = glp_get_num_cols(lp);\r\n    /* allocate working arrays */\r\n    C = new Array(1+n);\r\n    I = new Int32Array(1+m);\r\n    r = new Int32Array(1+m);\r\n    v = new Float64Array(1+m);\r\n    ind = new Int32Array(1+m);\r\n    val = new Float64Array(1+m);\r\n    /* make all auxiliary variables non-basic */\r\n    for (i = 1; i <= m; i++)\r\n    {  if (glp_get_row_type(lp, i) != GLP_DB)\r\n        glp_set_row_stat(lp, i, GLP_NS);\r\n    else if (Math.abs(glp_get_row_lb(lp, i)) <=\r\n        Math.abs(glp_get_row_ub(lp, i)))\r\n        glp_set_row_stat(lp, i, GLP_NL);\r\n    else\r\n        glp_set_row_stat(lp, i, GLP_NU);\r\n    }\r\n    /* make all structural variables non-basic */\r\n    for (j = 1; j <= n; j++)\r\n    {  if (glp_get_col_type(lp, j) != GLP_DB)\r\n        glp_set_col_stat(lp, j, GLP_NS);\r\n    else if (Math.abs(glp_get_col_lb(lp, j)) <=\r\n        Math.abs(glp_get_col_ub(lp, j)))\r\n        glp_set_col_stat(lp, j, GLP_NL);\r\n    else\r\n        glp_set_col_stat(lp, j, GLP_NU);\r\n    }\r\n    /* C2 is a set of free structural variables */\r\n    n2 = 0; C2 = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_FR)\r\n        {   n2++;\r\n            C[C2 + n2].j = j;\r\n            C[C2 + n2].q = 0.0;\r\n        }\r\n    }\r\n    /* C3 is a set of structural variables having excatly one (lower\r\n     or upper) bound */\r\n    n3 = 0; C3 = C2 + n2;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_LO)\r\n        {  n3++;\r\n            C[C3 + n3].j = j;\r\n            C[C3 + n3].q = + glp_get_col_lb(lp, j);\r\n        }\r\n        else if (type == GLP_UP)\r\n        {  n3++;\r\n            C[C3 + n3].j = j;\r\n            C[C3 + n3].q = - glp_get_col_ub(lp, j);\r\n        }\r\n    }\r\n    /* C4 is a set of structural variables having both (lower and\r\n     upper) bounds */\r\n    n4 = 0; C4 = C3 + n3;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_DB)\r\n        {  n4++;\r\n            C[C4 + n4].j = j;\r\n            C[C4 + n4].q = glp_get_col_lb(lp, j) - glp_get_col_ub(lp, j);\r\n        }\r\n    }\r\n    /* compute gamma = max{|c[j]|: 1 <= j <= n} */\r\n    gamma = 0.0;\r\n    for (j = 1; j <= n; j++)\r\n    {  temp = Math.abs(glp_get_obj_coef(lp, j));\r\n        if (gamma < temp) gamma = temp;\r\n    }\r\n    /* compute cmax */\r\n    cmax = (gamma == 0.0 ? 1.0 : 1000.0 * gamma);\r\n    /* compute final penalty for all structural variables within sets\r\n     C2, C3, and C4 */\r\n    switch (glp_get_obj_dir(lp))\r\n    {  case GLP_MIN: temp = +1.0; break;\r\n        case GLP_MAX: temp = -1.0; break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    for (k = 1; k <= n2+n3+n4; k++)\r\n    {  j = C[k].j;\r\n        C[k].q += (temp * glp_get_obj_coef(lp, j)) / cmax;\r\n    }\r\n    /* sort structural variables within C2, C3, and C4 in ascending\r\n     order of penalty value */\r\n\r\n    function fcmp(col1, col2){\r\n        /* this routine is passed to the qsort() function */\r\n        if (col1.q < col2.q) return -1;\r\n        if (col1.q > col2.q) return +1;\r\n        return 0;\r\n    }\r\n\r\n    xqsort(C, C2+1+n2, fcmp);\r\n    for (k = 1; k < n2; k++) xassert(C[C2+k].q <= C[C2+k+1].q);\r\n    xqsort(C, C3+1+n3, fcmp);\r\n    for (k = 1; k < n3; k++) xassert(C[C3+k].q <= C[C3+k+1].q);\r\n    xqsort(C, C4+1+n4, fcmp);\r\n    for (k = 1; k < n4; k++) xassert(C[C4+k].q <= C[C4+k+1].q);\r\n    /*** STEP 1 ***/\r\n    for (i = 1; i <= m; i++)\r\n    {  type = glp_get_row_type(lp, i);\r\n        if (type != GLP_FX)\r\n        {  /* row i is either free or inequality constraint */\r\n            glp_set_row_stat(lp, i, GLP_BS);\r\n            I[i] = 1;\r\n            r[i] = 1;\r\n        }\r\n        v[i] = +DBL_MAX;\r\n    }\r\n    /*** STEP 2 ***/\r\n\r\n    function get_column(lp, j, ind, val){\r\n        /* Bixby's algorithm assumes that the constraint matrix is scaled\r\n         such that the maximum absolute value in every non-zero row and\r\n         column is 1 */\r\n        var k;\r\n        var len = glp_get_mat_col(lp, j, ind, val);\r\n        var big = 0.0;\r\n        for (k = 1; k <= len; k++)\r\n            if (big < Math.abs(val[k])) big = Math.abs(val[k]);\r\n        if (big == 0.0) big = 1.0;\r\n        for (k = 1; k <= len; k++) val[k] /= big;\r\n        return len;\r\n    }\r\n\r\n    for (k = 1; k <= n2+n3+n4; k++)\r\n    {  jk = C[k].j;\r\n        len = get_column(lp, jk, ind, val);\r\n        /* let alpha = max{|A[l,jk]|: r[l] = 0} and let l' be such\r\n         that alpha = |A[l',jk]| */\r\n        alpha = 0.0; ll = 0;\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (r[l] == 0 && alpha < Math.abs(val[t])){\r\n                alpha = Math.abs(val[t]); ll = l;\r\n            }\r\n        }\r\n        if (alpha >= 0.99)\r\n        {  /* B := B union {jk} */\r\n            glp_set_col_stat(lp, jk, GLP_BS);\r\n            I[ll] = 1;\r\n            v[ll] = alpha;\r\n            /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\r\n            for (t = 1; t <= len; t++)\r\n            {  l = ind[t];\r\n                if (val[t] != 0.0) r[l]++;\r\n            }\r\n            /* continue to the next k */\r\n            continue;\r\n        }\r\n        /* if |A[l,jk]| > 0.01 * v[l] for some l, continue to the\r\n         next k */\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (Math.abs(val[t]) > 0.01 * v[l]) break;\r\n        }\r\n        if (t <= len) continue;\r\n        /* otherwise, let alpha = max{|A[l,jk]|: I[l] = 0} and let l'\r\n         be such that alpha = |A[l',jk]| */\r\n        alpha = 0.0; ll = 0;\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (I[l] == 0 && alpha < Math.abs(val[t])){\r\n                alpha = Math.abs(val[t]); ll = l;\r\n            }\r\n        }\r\n        /* if alpha = 0, continue to the next k */\r\n        if (alpha == 0.0) continue;\r\n        /* B := B union {jk} */\r\n        glp_set_col_stat(lp, jk, GLP_BS);\r\n        I[ll] = 1;\r\n        v[ll] = alpha;\r\n        /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (val[t] != 0.0) r[l]++;\r\n        }\r\n    }\r\n    /*** STEP 3 ***/\r\n    /* add an artificial variable (auxiliary variable for equality\r\n     constraint) to cover each remaining uncovered row */\r\n    for (i = 1; i <= m; i++)\r\n        if (I[i] == 0) glp_set_row_stat(lp, i, GLP_BS);\r\n}\r\n\r\nfunction glp_cpx_basis(lp){\r\n    if (lp.m == 0 || lp.n == 0)\r\n        glp_std_basis(lp);\r\n    else\r\n        cpx_basis(lp);\r\n}\r\n\r\nfunction new_node(tree, parent){\r\n    /* pull a free slot for the new node */\r\n    var p = get_slot(tree);\r\n    /* create descriptor of the new subproblem */\r\n    var node = {};\r\n    tree.slot[p].node = node;\r\n    node.p = p;\r\n    node.up = parent;\r\n    node.level = (parent == null ? 0 : parent.level + 1);\r\n    node.count = 0;\r\n    node.b_ptr = null;\r\n    node.s_ptr = null;\r\n    node.r_ptr = null;\r\n    node.solved = 0;\r\n    node.lp_obj = (parent == null ? (tree.mip.dir == GLP_MIN ?\r\n        -DBL_MAX : +DBL_MAX) : parent.lp_obj);\r\n    node.bound = (parent == null ? (tree.mip.dir == GLP_MIN ?\r\n        -DBL_MAX : +DBL_MAX) : parent.bound);\r\n    node.br_var = 0;\r\n    node.br_val = 0.0;\r\n    node.ii_cnt = 0;\r\n    node.ii_sum = 0.0;\r\n    node.changed = 0;\r\n    if (tree.parm.cb_size == 0)\r\n        node.data = null;\r\n    else\r\n    {\r\n        node.data = {};\r\n    }\r\n    node.temp = null;\r\n    node.prev = tree.tail;\r\n    node.next = null;\r\n    /* add the new subproblem to the end of the active list */\r\n    if (tree.head == null)\r\n        tree.head = node;\r\n    else\r\n        tree.tail.next = node;\r\n    tree.tail = node;\r\n    tree.a_cnt++;\r\n    tree.n_cnt++;\r\n    tree.t_cnt++;\r\n    /* increase the number of child subproblems */\r\n    if (parent == null)\r\n        xassert(p == 1);\r\n    else\r\n        parent.count++;\r\n    return node;\r\n}\r\n\r\nfunction get_slot(tree){\r\n    var p;\r\n    /* if no free slots are available, increase the room */\r\n    if (tree.avail == 0)\r\n    {  var nslots = tree.nslots;\r\n        var save = tree.slot;\r\n        if (nslots == 0)\r\n            tree.nslots = 20;\r\n        else\r\n        {  tree.nslots = nslots + nslots;\r\n            xassert(tree.nslots > nslots);\r\n        }\r\n        tree.slot = new Array(1+tree.nslots);\r\n        xfillObjArr(tree.slot, 0, 1+tree.nslots);\r\n        if (save != null)\r\n        {\r\n            xcopyArr(tree.slot, 1, save, 1, nslots);\r\n        }\r\n        /* push more free slots into the stack */\r\n        for (p = tree.nslots; p > nslots; p--)\r\n        {  tree.slot[p].node = null;\r\n            tree.slot[p].next = tree.avail;\r\n            tree.avail = p;\r\n        }\r\n    }\r\n    /* pull a free slot from the stack */\r\n    p = tree.avail;\r\n    tree.avail = tree.slot[p].next;\r\n    xassert(tree.slot[p].node == null);\r\n    tree.slot[p].next = 0;\r\n    return p;\r\n}\r\n\r\nfunction ios_create_tree(mip, parm){\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var tree;\r\n    var i, j;\r\n    xassert(mip.tree == null);\r\n    mip.tree = tree = {};\r\n    tree.n = n;\r\n    /* save original problem components */\r\n    tree.orig_m = m;\r\n    tree.orig_type = new Int8Array(1+m+n);\r\n    tree.orig_lb = new Float64Array(1+m+n);\r\n    tree.orig_ub = new Float64Array(1+m+n);\r\n    tree.orig_stat = new Int8Array(1+m+n);\r\n    tree.orig_prim = new Float64Array(1+m+n);\r\n    tree.orig_dual = new Float64Array(1+m+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  var row = mip.row[i];\r\n        tree.orig_type[i] = row.type;\r\n        tree.orig_lb[i] = row.lb;\r\n        tree.orig_ub[i] = row.ub;\r\n        tree.orig_stat[i] = row.stat;\r\n        tree.orig_prim[i] = row.prim;\r\n        tree.orig_dual[i] = row.dual;\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        tree.orig_type[m+j] = col.type;\r\n        tree.orig_lb[m+j] = col.lb;\r\n        tree.orig_ub[m+j] = col.ub;\r\n        tree.orig_stat[m+j] = col.stat;\r\n        tree.orig_prim[m+j] = col.prim;\r\n        tree.orig_dual[m+j] = col.dual;\r\n    }\r\n    tree.orig_obj = mip.obj_val;\r\n    /* initialize the branch-and-bound tree */\r\n    tree.nslots = 0;\r\n    tree.avail = 0;\r\n    tree.slot = null;\r\n    tree.head = tree.tail = null;\r\n    tree.a_cnt = tree.n_cnt = tree.t_cnt = 0;\r\n    /* the root subproblem is not solved yet, so its final components\r\n     are unknown so far */\r\n    tree.root_m = 0;\r\n    tree.root_type = null;\r\n    tree.root_lb = tree.root_ub = null;\r\n    tree.root_stat = null;\r\n    /* the current subproblem does not exist yet */\r\n    tree.curr = null;\r\n    tree.mip = mip;\r\n    /*tree.solved = 0;*/\r\n    tree.non_int = new Int8Array(1+n);\r\n    /* arrays to save parent subproblem components will be allocated\r\n     later */\r\n    tree.pred_m = tree.pred_max = 0;\r\n    tree.pred_type = null;\r\n    tree.pred_lb = tree.pred_ub = null;\r\n    tree.pred_stat = null;\r\n    /* cut generator */\r\n    tree.local = ios_create_pool(tree);\r\n    /*tree.first_attempt = 1;*/\r\n    /*tree.max_added_cuts = 0;*/\r\n    /*tree.min_eff = 0.0;*/\r\n    /*tree.miss = 0;*/\r\n    /*tree.just_selected = 0;*/\r\n    tree.mir_gen = null;\r\n    tree.clq_gen = null;\r\n    /*tree.round = 0;*/\r\n    /* pseudocost branching */\r\n    tree.pcost = null;\r\n    tree.iwrk = new Int32Array(1+n);\r\n    tree.dwrk = new Float64Array(1+n);\r\n    /* initialize control parameters */\r\n    tree.parm = parm;\r\n    tree.tm_beg = xtime();\r\n    tree.tm_lag = 0;\r\n    tree.sol_cnt = 0;\r\n    /* initialize advanced solver interface */\r\n    tree.reason = 0;\r\n    tree.reopt = 0;\r\n    tree.reinv = 0;\r\n    tree.br_var = 0;\r\n    tree.br_sel = 0;\r\n    tree.child = 0;\r\n    tree.next_p = 0;\r\n    /*tree.btrack = null;*/\r\n    tree.stop = 0;\r\n    /* create the root subproblem, which initially is identical to\r\n     the original MIP */\r\n    new_node(tree, null);\r\n    return tree;\r\n}\r\n\r\nfunction ios_revive_node(tree, p){\r\n    var mip = tree.mip;\r\n    var node, root;\r\n    var b, r, s, a;\r\n    /* obtain pointer to the specified subproblem */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* the current subproblem must not exist */\r\n    xassert(tree.curr == null);\r\n    /* the specified subproblem becomes current */\r\n    tree.curr = node;\r\n    /*tree.solved = 0;*/\r\n    /* obtain pointer to the root subproblem */\r\n    root = tree.slot[1].node;\r\n    xassert(root != null);\r\n    /* at this point problem object components correspond to the root\r\n     subproblem, so if the root subproblem should be revived, there\r\n     is nothing more to do */\r\n    if (node == root) return;\r\n    xassert(mip.m == tree.root_m);\r\n    /* build path from the root to the current node */\r\n    node.temp = null;\r\n    for (; node != null; node = node.up)\r\n    {  if (node.up == null)\r\n        xassert(node == root);\r\n    else\r\n        node.up.temp = node;\r\n    }\r\n    /* go down from the root to the current node and make necessary\r\n     changes to restore components of the current subproblem */\r\n    for (node = root; node != null; node = node.temp)\r\n    {  var m = mip.m;\r\n        var n = mip.n;\r\n        /* if the current node is reached, the problem object at this\r\n         point corresponds to its parent, so save attributes of rows\r\n         and columns for the parent subproblem */\r\n        if (node.temp == null)\r\n        {   var i, j;\r\n            tree.pred_m = m;\r\n            /* allocate/reallocate arrays, if necessary */\r\n            if (tree.pred_max < m + n)\r\n            {  var new_size = m + n + 100;\r\n                tree.pred_max = new_size;\r\n                tree.pred_type = new Int8Array(1+new_size);\r\n                tree.pred_lb = new Float64Array(1+new_size);\r\n                tree.pred_ub = new Float64Array(1+new_size);\r\n                tree.pred_stat = new Int8Array(1+new_size);\r\n            }\r\n            /* save row attributes */\r\n            for (i = 1; i <= m; i++)\r\n            {  var row = mip.row[i];\r\n                tree.pred_type[i] = row.type;\r\n                tree.pred_lb[i] = row.lb;\r\n                tree.pred_ub[i] = row.ub;\r\n                tree.pred_stat[i] = row.stat;\r\n            }\r\n            /* save column attributes */\r\n            for (j = 1; j <= n; j++)\r\n            {  var col = mip.col[j];\r\n                tree.pred_type[mip.m+j] = col.type;\r\n                tree.pred_lb[mip.m+j] = col.lb;\r\n                tree.pred_ub[mip.m+j] = col.ub;\r\n                tree.pred_stat[mip.m+j] = col.stat;\r\n            }\r\n        }\r\n        /* change bounds of rows and columns */\r\n        {   for (b = node.b_ptr; b != null; b = b.next)\r\n        {  if (b.k <= m)\r\n            glp_set_row_bnds(mip, b.k, b.type, b.lb, b.ub);\r\n        else\r\n            glp_set_col_bnds(mip, b.k-m, b.type, b.lb, b.ub);\r\n        }\r\n        }\r\n        /* change statuses of rows and columns */\r\n        {   for (s = node.s_ptr; s != null; s = s.next)\r\n        {  if (s.k <= m)\r\n            glp_set_row_stat(mip, s.k, s.stat);\r\n        else\r\n            glp_set_col_stat(mip, s.k-m, s.stat);\r\n        }\r\n        }\r\n        /* add new rows */\r\n        if (node.r_ptr != null)\r\n        {\r\n            var len, ind;\r\n            var val;\r\n            ind = new Int32Array(1+n);\r\n            val = new Float64Array(1+n);\r\n            for (r = node.r_ptr; r != null; r = r.next)\r\n            {  i = glp_add_rows(mip, 1);\r\n                glp_set_row_name(mip, i, r.name);\r\n                xassert(mip.row[i].level == 0);\r\n                mip.row[i].level = node.level;\r\n                mip.row[i].origin = r.origin;\r\n                mip.row[i].klass = r.klass;\r\n                glp_set_row_bnds(mip, i, r.type, r.lb, r.ub);\r\n                len = 0;\r\n                for (a = r.ptr; a != null; a = a.next){\r\n                    len++; ind[len] = a.j; val[len] = a.val;\r\n                }\r\n                glp_set_mat_row(mip, i, len, ind, val);\r\n                glp_set_rii(mip, i, r.rii);\r\n                glp_set_row_stat(mip, i, r.stat);\r\n            }\r\n        }\r\n    }\r\n    /* the specified subproblem has been revived */\r\n    node = tree.curr;\r\n    /* delete its bound change list */\r\n    while (node.b_ptr != null)\r\n    {   b = node.b_ptr;\r\n        node.b_ptr = b.next;\r\n    }\r\n    /* delete its status change list */\r\n    while (node.s_ptr != null)\r\n    {   s = node.s_ptr;\r\n        node.s_ptr = s.next;\r\n    }\r\n    /* delete its row addition list (additional rows may appear, for\r\n     example, due to branching on GUB constraints */\r\n    while (node.r_ptr != null)\r\n    {   r = node.r_ptr;\r\n        node.r_ptr = r.next;\r\n        xassert(r.name == null);\r\n        while (r.ptr != null)\r\n        {   a = r.ptr;\r\n            r.ptr = a.next;\r\n        }\r\n    }\r\n}\r\n\r\nfunction ios_freeze_node(tree){\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    /* obtain pointer to the current subproblem */\r\n    var node = tree.curr;\r\n    xassert(node != null);\r\n\r\n\r\n    var k, i, row, col;\r\n    if (node.up == null)\r\n    {  /* freeze the root subproblem */\r\n        xassert(node.p == 1);\r\n        xassert(tree.root_m == 0);\r\n        xassert(tree.root_type == null);\r\n        xassert(tree.root_lb == null);\r\n        xassert(tree.root_ub == null);\r\n        xassert(tree.root_stat == null);\r\n        tree.root_m = m;\r\n        tree.root_type = new Int8Array(1+m+n);\r\n        tree.root_lb = new Float64Array(1+m+n);\r\n        tree.root_ub = new Float64Array(1+m+n);\r\n        tree.root_stat = new Int8Array(1+m+n);\r\n        for (k = 1; k <= m+n; k++)\r\n        {  if (k <= m)\r\n        {   row = mip.row[k];\r\n            tree.root_type[k] = row.type;\r\n            tree.root_lb[k] = row.lb;\r\n            tree.root_ub[k] = row.ub;\r\n            tree.root_stat[k] = row.stat;\r\n        }\r\n        else\r\n        {   col = mip.col[k-m];\r\n            tree.root_type[k] = col.type;\r\n            tree.root_lb[k] = col.lb;\r\n            tree.root_ub[k] = col.ub;\r\n            tree.root_stat[k] = col.stat;\r\n        }\r\n        }\r\n    }\r\n    else\r\n    {  /* freeze non-root subproblem */\r\n        var root_m = tree.root_m;\r\n        var pred_m = tree.pred_m;\r\n        var j;\r\n        xassert(pred_m <= m);\r\n        /* build change lists for rows and columns which exist in the\r\n         parent subproblem */\r\n        xassert(node.b_ptr == null);\r\n        xassert(node.s_ptr == null);\r\n        for (k = 1; k <= pred_m + n; k++)\r\n        {  var pred_type, pred_stat, type, stat;\r\n            var pred_lb, pred_ub, lb, ub;\r\n            /* determine attributes in the parent subproblem */\r\n            pred_type = tree.pred_type[k];\r\n            pred_lb = tree.pred_lb[k];\r\n            pred_ub = tree.pred_ub[k];\r\n            pred_stat = tree.pred_stat[k];\r\n            /* determine attributes in the current subproblem */\r\n            if (k <= pred_m)\r\n            {   row = mip.row[k];\r\n                type = row.type;\r\n                lb = row.lb;\r\n                ub = row.ub;\r\n                stat = row.stat;\r\n            }\r\n            else\r\n            {   col = mip.col[k - pred_m];\r\n                type = col.type;\r\n                lb = col.lb;\r\n                ub = col.ub;\r\n                stat = col.stat;\r\n            }\r\n            /* save type and bounds of a row/column, if changed */\r\n            if (!(pred_type == type && pred_lb == lb && pred_ub == ub))\r\n            {   var b = {};\r\n                b.k = k;\r\n                b.type = type;\r\n                b.lb = lb;\r\n                b.ub = ub;\r\n                b.next = node.b_ptr;\r\n                node.b_ptr = b;\r\n            }\r\n            /* save status of a row/column, if changed */\r\n            if (pred_stat != stat)\r\n            {   var s = {};\r\n                s.k = k;\r\n                s.stat = stat;\r\n                s.next = node.s_ptr;\r\n                node.s_ptr = s;\r\n            }\r\n        }\r\n        /* save new rows added to the current subproblem */\r\n        xassert(node.r_ptr == null);\r\n        if (pred_m < m)\r\n        {  var len, ind;\r\n            var val;\r\n            ind = new Int32Array(1+n);\r\n            val = new Float64Array(1+n);\r\n            for (i = m; i > pred_m; i--)\r\n            {   row = mip.row[i];\r\n                var r = {};\r\n                var name = glp_get_row_name(mip, i);\r\n                if (name == null)\r\n                    r.name = null;\r\n                else\r\n                {\r\n                    r.name = name;\r\n                }\r\n                r.type = row.type;\r\n                r.lb = row.lb;\r\n                r.ub = row.ub;\r\n                r.ptr = null;\r\n                len = glp_get_mat_row(mip, i, ind, val);\r\n                for (k = 1; k <= len; k++)\r\n                {\r\n                    var a = {};\r\n                    a.j = ind[k];\r\n                    a.val = val[k];\r\n                    a.next = r.ptr;\r\n                    r.ptr = a;\r\n                }\r\n                r.rii = row.rii;\r\n                r.stat = row.stat;\r\n                r.next = node.r_ptr;\r\n                node.r_ptr = r;\r\n            }\r\n        }\r\n        /* remove all rows missing in the root subproblem */\r\n        if (m != root_m)\r\n        {\r\n            var nrs = m - root_m;\r\n            xassert(nrs > 0);\r\n            var num = new Int32Array(1+nrs);\r\n            for (i = 1; i <= nrs; i++) num[i] = root_m + i;\r\n            glp_del_rows(mip, nrs, num);\r\n        }\r\n        m = mip.m;\r\n        /* and restore attributes of all rows and columns for the root\r\n         subproblem */\r\n        xassert(m == root_m);\r\n        for (i = 1; i <= m; i++)\r\n        {  glp_set_row_bnds(mip, i, tree.root_type[i],\r\n            tree.root_lb[i], tree.root_ub[i]);\r\n            glp_set_row_stat(mip, i, tree.root_stat[i]);\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  glp_set_col_bnds(mip, j, tree.root_type[m+j],\r\n            tree.root_lb[m+j], tree.root_ub[m+j]);\r\n            glp_set_col_stat(mip, j, tree.root_stat[m+j]);\r\n        }\r\n    }\r\n    /* the current subproblem has been frozen */\r\n    tree.curr = null;\r\n}\r\n\r\nfunction ios_clone_node(tree, p, nnn, ref){\r\n    var node, k;\r\n    /* obtain pointer to the subproblem to be cloned */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* and must be in the frozen state */\r\n    xassert(tree.curr != node);\r\n    /* remove the specified subproblem from the active list, because\r\n     it becomes inactive */\r\n    if (node.prev == null)\r\n        tree.head = node.next;\r\n    else\r\n        node.prev.next = node.next;\r\n    if (node.next == null)\r\n        tree.tail = node.prev;\r\n    else\r\n        node.next.prev = node.prev;\r\n    node.prev = node.next = null;\r\n    tree.a_cnt--;\r\n    /* create clone subproblems */\r\n    xassert(nnn > 0);\r\n    for (k = 1; k <= nnn; k++)\r\n        ref[k] = new_node(tree, node).p;\r\n}\r\n\r\nfunction ios_delete_node(tree, p){\r\n    var node, temp;\r\n    /* obtain pointer to the subproblem to be deleted */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* and must be in the frozen state */\r\n    xassert(tree.curr != node);\r\n    /* remove the specified subproblem from the active list, because\r\n     it is gone from the tree */\r\n    if (node.prev == null)\r\n        tree.head = node.next;\r\n    else\r\n        node.prev.next = node.next;\r\n    if (node.next == null)\r\n        tree.tail = node.prev;\r\n    else\r\n        node.next.prev = node.prev;\r\n    node.prev = node.next = null;\r\n    tree.a_cnt--;\r\n    while (true){\r\n        /* recursive deletion starts here */\r\n        /* delete the bound change list */\r\n        {  var b;\r\n            while (node.b_ptr != null)\r\n            {  b = node.b_ptr;\r\n                node.b_ptr = b.next;\r\n            }\r\n        }\r\n        /* delete the status change list */\r\n        {  var s;\r\n            while (node.s_ptr != null)\r\n            {  s = node.s_ptr;\r\n                node.s_ptr = s.next;\r\n            }\r\n        }\r\n        /* delete the row addition list */\r\n        while (node.r_ptr != null)\r\n        {  var r;\r\n            r = node.r_ptr;\r\n            r.name = null;\r\n            while (r.ptr != null)\r\n            {  var a;\r\n                a = r.ptr;\r\n                r.ptr = a.next;\r\n            }\r\n            node.r_ptr = r.next;\r\n        }\r\n        /* free application-specific data */\r\n        if (tree.parm.cb_size == 0)\r\n            xassert(node.data == null);\r\n        /* free the corresponding node slot */\r\n        p = node.p;\r\n        xassert(tree.slot[p].node == node);\r\n        tree.slot[p].node = null;\r\n        tree.slot[p].next = tree.avail;\r\n        tree.avail = p;\r\n        /* save pointer to the parent subproblem */\r\n        temp = node.up;\r\n        /* delete the subproblem descriptor */\r\n        tree.n_cnt--;\r\n        /* take pointer to the parent subproblem */\r\n        node = temp;\r\n        if (node != null)\r\n        {  /* the parent subproblem exists; decrease the number of its\r\n         child subproblems */\r\n            xassert(node.count > 0);\r\n            node.count--;\r\n            /* if now the parent subproblem has no childs, it also must be\r\n             deleted */\r\n            if (node.count == 0) continue;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nfunction ios_delete_tree(tree){\r\n    var mip = tree.mip;\r\n    var i, j;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    xassert(mip.tree == tree);\r\n    /* remove all additional rows */\r\n    if (m != tree.orig_m)\r\n    {  var nrs, num;\r\n        nrs = m - tree.orig_m;\r\n        xassert(nrs > 0);\r\n        num = new Int32Array(1+nrs);\r\n        for (i = 1; i <= nrs; i++) num[i] = tree.orig_m + i;\r\n        glp_del_rows(mip, nrs, num);\r\n    }\r\n    m = tree.orig_m;\r\n    /* restore original attributes of rows and columns */\r\n    xassert(m == tree.orig_m);\r\n    xassert(n == tree.n);\r\n    for (i = 1; i <= m; i++)\r\n    {  glp_set_row_bnds(mip, i, tree.orig_type[i],\r\n        tree.orig_lb[i], tree.orig_ub[i]);\r\n        glp_set_row_stat(mip, i, tree.orig_stat[i]);\r\n        mip.row[i].prim = tree.orig_prim[i];\r\n        mip.row[i].dual = tree.orig_dual[i];\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  glp_set_col_bnds(mip, j, tree.orig_type[m+j],\r\n        tree.orig_lb[m+j], tree.orig_ub[m+j]);\r\n        glp_set_col_stat(mip, j, tree.orig_stat[m+j]);\r\n        mip.col[j].prim = tree.orig_prim[m+j];\r\n        mip.col[j].dual = tree.orig_dual[m+j];\r\n    }\r\n    mip.pbs_stat = mip.dbs_stat = GLP_FEAS;\r\n    mip.obj_val = tree.orig_obj;\r\n    /* delete the branch-and-bound tree */\r\n    xassert(tree.local != null);\r\n    ios_delete_pool(tree.local);\r\n    xassert(tree.mir_gen == null);\r\n    xassert(tree.clq_gen == null);\r\n    mip.tree = null;\r\n}\r\n\r\nfunction ios_eval_degrad(tree, j, callback){\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var len, kase, k, t, stat;\r\n    var alfa, beta, gamma, delta, dz;\r\n    var ind = tree.iwrk;\r\n    var val = tree.dwrk;\r\n    var dn, up;\r\n\r\n    /* current basis must be optimal */\r\n    xassert(glp_get_status(mip) == GLP_OPT);\r\n    /* basis factorization must exist */\r\n    xassert(glp_bf_exists(mip));\r\n    /* obtain (fractional) value of x[j] in optimal basic solution\r\n     to LP relaxation of the current subproblem */\r\n    xassert(1 <= j && j <= n);\r\n    beta = mip.col[j].prim;\r\n    /* since the value of x[j] is fractional, it is basic; compute\r\n     corresponding row of the simplex table */\r\n    len = lpx_eval_tab_row(mip, m+j, ind, val);\r\n    /* kase < 0 means down-branch; kase > 0 means up-branch */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* for down-branch we introduce new upper bound floor(beta)\r\n     for x[j]; similarly, for up-branch we introduce new lower\r\n     bound ceil(beta) for x[j]; in the current basis this new\r\n     upper/lower bound is violated, so in the adjacent basis\r\n     x[j] will leave the basis and go to its new upper/lower\r\n     bound; we need to know which non-basic variable x[k] should\r\n     enter the basis to keep dual feasibility */\r\n        k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-9);\r\n        /* if no variable has been chosen, current basis being primal\r\n         infeasible due to the new upper/lower bound of x[j] is dual\r\n         unbounded, therefore, LP relaxation to corresponding branch\r\n         has no primal feasible solution */\r\n        if (k == 0)\r\n        {  if (mip.dir == GLP_MIN)\r\n        {  if (kase < 0)\r\n            dn = +DBL_MAX;\r\n        else\r\n            up = +DBL_MAX;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (kase < 0)\r\n            dn = -DBL_MAX;\r\n        else\r\n            up = -DBL_MAX;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n            continue;\r\n        }\r\n        xassert(1 <= k && k <= m+n);\r\n        /* row of the simplex table corresponding to specified basic\r\n         variable x[j] is the following:\r\n         x[j] = ... + alfa * x[k] + ... ;\r\n         we need to know influence coefficient, alfa, at non-basic\r\n         variable x[k] chosen with the dual ratio test */\r\n        for (t = 1; t <= len; t++)\r\n            if (ind[t] == k) break;\r\n        xassert(1 <= t && t <= len);\r\n        alfa = val[t];\r\n        /* determine status and reduced cost of variable x[k] */\r\n        if (k <= m)\r\n        {  stat = mip.row[k].stat;\r\n            gamma = mip.row[k].dual;\r\n        }\r\n        else\r\n        {  stat = mip.col[k-m].stat;\r\n            gamma = mip.col[k-m].dual;\r\n        }\r\n        /* x[k] cannot be basic or fixed non-basic */\r\n        xassert(stat == GLP_NL || stat == GLP_NU || stat == GLP_NF);\r\n        /* if the current basis is dual degenerative, some reduced\r\n         costs, which are close to zero, may have wrong sign due to\r\n         round-off errors, so correct the sign of gamma */\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (stat == GLP_NL && gamma < 0.0 ||\r\n            stat == GLP_NU && gamma > 0.0 ||\r\n            stat == GLP_NF) gamma = 0.0;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (stat == GLP_NL && gamma > 0.0 ||\r\n            stat == GLP_NU && gamma < 0.0 ||\r\n            stat == GLP_NF) gamma = 0.0;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* determine the change of x[j] in the adjacent basis:\r\n         delta x[j] = new x[j] - old x[j] */\r\n        delta = (kase < 0 ? Math.floor(beta) : Math.ceil(beta)) - beta;\r\n        /* compute the change of x[k] in the adjacent basis:\r\n         delta x[k] = new x[k] - old x[k] = delta x[j] / alfa */\r\n        delta /= alfa;\r\n        /* compute the change of the objective in the adjacent basis:\r\n         delta z = new z - old z = gamma * delta x[k] */\r\n        dz = gamma * delta;\r\n        if (mip.dir == GLP_MIN)\r\n            xassert(dz >= 0.0);\r\n        else if (mip.dir == GLP_MAX)\r\n            xassert(dz <= 0.0);\r\n        else\r\n            xassert(mip != mip);\r\n        /* compute the new objective value in the adjacent basis:\r\n         new z = old z + delta z */\r\n        if (kase < 0)\r\n            dn = mip.obj_val + dz;\r\n        else\r\n            up = mip.obj_val + dz;\r\n    }\r\n    callback(dn, up);\r\n    /*xprintf(\"obj = %g; dn = %g; up = %g\",\r\n     mip.obj_val, *dn, *up);*/\r\n}\r\n\r\nfunction ios_round_bound(tree, bound){\r\n    var mip = tree.mip;\r\n    var n = mip.n;\r\n    var d, j, nn;\r\n    var c = tree.iwrk;\r\n    var s, h;\r\n    /* determine c[j] and compute s */\r\n    nn = 0; s = mip.c0; d = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        if (col.coef == 0.0) continue;\r\n        if (col.type == GLP_FX)\r\n        {  /* fixed variable */\r\n            s += col.coef * col.prim;\r\n        }\r\n        else\r\n        {  /* non-fixed variable */\r\n            if (col.kind != GLP_IV) return bound;\r\n            if (col.coef != Math.floor(col.coef)) return bound;\r\n            if (Math.abs(col.coef) <= INT_MAX)\r\n                c[++nn] = Math.abs(col.coef)|0;\r\n            else\r\n                d = 1;\r\n        }\r\n    }\r\n    /* compute d = gcd(c[1],...c[nn]) */\r\n    if (d == 0)\r\n    {  if (nn == 0) return bound;\r\n        d = gcdn(nn, c);\r\n    }\r\n    xassert(d > 0);\r\n    /* compute new local bound */\r\n    if (mip.dir == GLP_MIN)\r\n    {  if (bound != +DBL_MAX)\r\n    {  h = (bound - s) / d;\r\n        if (h >= Math.floor(h) + 0.001)\r\n        {  /* round up */\r\n            h = Math.ceil(h);\r\n            /*xprintf(\"d = %d; old = %g; \", d, bound);*/\r\n            bound = d * h + s;\r\n            /*xprintf(\"new = %g\", bound);*/\r\n        }\r\n    }\r\n    }\r\n    else if (mip.dir == GLP_MAX)\r\n    {  if (bound != -DBL_MAX)\r\n    {  h = (bound - s) / d;\r\n        if (h <= Math.ceil(h) - 0.001)\r\n        {  /* round down */\r\n            h = Math.floor(h);\r\n            bound = d * h + s;\r\n        }\r\n    }\r\n    }\r\n    else\r\n        xassert(mip != mip);\r\n    return bound;\r\n}\r\n\r\nfunction ios_is_hopeful(tree, bound){\r\n    var mip = tree.mip;\r\n    var ret = 1;\r\n    var eps;\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  eps = tree.parm.tol_obj * (1.0 + Math.abs(mip.mip_obj));\r\n        switch (mip.dir)\r\n        {  case GLP_MIN:\r\n            if (bound >= mip.mip_obj - eps) ret = 0;\r\n            break;\r\n            case GLP_MAX:\r\n                if (bound <= mip.mip_obj + eps) ret = 0;\r\n                break;\r\n            default:\r\n                xassert(mip != mip);\r\n        }\r\n    }\r\n    else\r\n    {  switch (mip.dir)\r\n    {  case GLP_MIN:\r\n            if (bound == +DBL_MAX) ret = 0;\r\n            break;\r\n        case GLP_MAX:\r\n            if (bound == -DBL_MAX) ret = 0;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction ios_best_node(tree){\r\n    var node, best = null;\r\n    switch (tree.mip.dir)\r\n    {  case GLP_MIN:\r\n        /* minimization */\r\n        for (node = tree.head; node != null; node = node.next)\r\n            if (best == null || best.bound > node.bound)\r\n                best = node;\r\n        break;\r\n        case GLP_MAX:\r\n            /* maximization */\r\n            for (node = tree.head; node != null; node = node.next)\r\n                if (best == null || best.bound < node.bound)\r\n                    best = node;\r\n            break;\r\n        default:\r\n            xassert(tree != tree);\r\n    }\r\n    return best == null ? 0 : best.p;\r\n}\r\n\r\nvar ios_relative_gap = exports['glp_ios_relative_gap'] = function(tree){\r\n    var mip = tree.mip;\r\n    var p;\r\n    var best_mip, best_bnd, gap;\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  best_mip = mip.mip_obj;\r\n        p = ios_best_node(tree);\r\n        if (p == 0)\r\n        {  /* the tree is empty */\r\n            gap = 0.0;\r\n        }\r\n        else\r\n        {  best_bnd = tree.slot[p].node.bound;\r\n            gap = Math.abs(best_mip - best_bnd) / (Math.abs(best_mip) +\r\n                DBL_EPSILON);\r\n        }\r\n    }\r\n    else\r\n    {  /* no integer feasible solution has been found yet */\r\n        gap = DBL_MAX;\r\n    }\r\n    return gap;\r\n};\r\n\r\nfunction ios_solve_node(tree){\r\n    var mip = tree.mip;\r\n    var ret;\r\n    /* the current subproblem must exist */\r\n    xassert(tree.curr != null);\r\n    /* set some control parameters */\r\n    var parm = new SMCP();\r\n    // glp_init_smcp(parm);\r\n    switch (tree.parm.msg_lev)\r\n    {  case GLP_MSG_OFF:\r\n        parm.msg_lev = GLP_MSG_OFF; break;\r\n        case GLP_MSG_ERR:\r\n            parm.msg_lev = GLP_MSG_ERR; break;\r\n        case GLP_MSG_ON:\r\n        case GLP_MSG_ALL:\r\n            parm.msg_lev = GLP_MSG_ON; break;\r\n        case GLP_MSG_DBG:\r\n            parm.msg_lev = GLP_MSG_ALL; break;\r\n        default:\r\n            xassert(tree != tree);\r\n    }\r\n    parm.meth = GLP_DUALP;\r\n    if (tree.parm.msg_lev < GLP_MSG_DBG)\r\n        parm.out_dly = tree.parm.out_dly;\r\n    else\r\n        parm.out_dly = 0;\r\n    /* if the incumbent objective value is already known, use it to\r\n     prematurely terminate the dual simplex search */\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  switch (tree.mip.dir)\r\n    {  case GLP_MIN:\r\n            parm.obj_ul = mip.mip_obj;\r\n            break;\r\n        case GLP_MAX:\r\n            parm.obj_ll = mip.mip_obj;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    /* try to solve/re-optimize the LP relaxation */\r\n    ret = glp_simplex(mip, parm);\r\n    tree.curr.solved++;\r\n    return ret;\r\n}\r\n\r\nfunction ios_create_pool(tree){\r\n    /* create cut pool */\r\n    xassert(tree == tree);\r\n    var pool = {};\r\n    pool.size = 0;\r\n    pool.head = pool.tail = null;\r\n    pool.ord = 0; pool.curr = null;\r\n    return pool;\r\n}\r\n\r\nfunction ios_add_row(tree, pool, name, klass, flags, len, ind, val, type, rhs){\r\n    /* add row (constraint) to the cut pool */\r\n    var cut, aij, k;\r\n    xassert(pool != null);\r\n    cut = {};\r\n    if (name == null || name[0] == '\\0')\r\n        cut.name = null;\r\n    else\r\n    {\r\n        cut.name = name;\r\n    }\r\n    if (!(0 <= klass && klass <= 255))\r\n        xerror(\"glp_ios_add_row: klass = \" + klass + \"; invalid cut class\");\r\n    cut.klass = klass;\r\n    if (flags != 0)\r\n        xerror(\"glp_ios_add_row: flags = \" + flags + \"; invalid cut flags\");\r\n    cut.ptr = null;\r\n    if (!(0 <= len && len <= tree.n))\r\n        xerror(\"glp_ios_add_row: len = \" + len + \"; invalid cut length\");\r\n    for (k = 1; k <= len; k++)\r\n    {  aij = {};\r\n        if (!(1 <= ind[k] && ind[k] <= tree.n))\r\n            xerror(\"glp_ios_add_row: ind[\" + k + \"] = \" + ind[k] + \"; column index out of range\");\r\n        aij.j = ind[k];\r\n        aij.val = val[k];\r\n        aij.next = cut.ptr;\r\n        cut.ptr = aij;\r\n    }\r\n    if (!(type == GLP_LO || type == GLP_UP || type == GLP_FX))\r\n        xerror(\"glp_ios_add_row: type = \" + type + \"; invalid cut type\");\r\n    cut.type = type;\r\n    cut.rhs = rhs;\r\n    cut.prev = pool.tail;\r\n    cut.next = null;\r\n    if (cut.prev == null)\r\n        pool.head = cut;\r\n    else\r\n        cut.prev.next = cut;\r\n    pool.tail = cut;\r\n    pool.size++;\r\n    return pool.size;\r\n}\r\n\r\nfunction ios_find_row(pool, i){\r\n    /* find row (constraint) in the cut pool */\r\n    /* (smart linear search) */\r\n    xassert(pool != null);\r\n    xassert(1 <= i && i <= pool.size);\r\n    if (pool.ord == 0)\r\n    {  xassert(pool.curr == null);\r\n        pool.ord = 1;\r\n        pool.curr = pool.head;\r\n    }\r\n    xassert(pool.curr != null);\r\n    if (i < pool.ord)\r\n    {  if (i < pool.ord - i)\r\n    {  pool.ord = 1;\r\n        pool.curr = pool.head;\r\n        while (pool.ord != i)\r\n        {  pool.ord++;\r\n            xassert(pool.curr != null);\r\n            pool.curr = pool.curr.next;\r\n        }\r\n    }\r\n    else\r\n    {  while (pool.ord != i)\r\n    {  pool.ord--;\r\n        xassert(pool.curr != null);\r\n        pool.curr = pool.curr.prev;\r\n    }\r\n    }\r\n    }\r\n    else if (i > pool.ord)\r\n    {  if (i - pool.ord < pool.size - i)\r\n    {  while (pool.ord != i)\r\n    {  pool.ord++;\r\n        xassert(pool.curr != null);\r\n        pool.curr = pool.curr.next;\r\n    }\r\n    }\r\n    else\r\n    {  pool.ord = pool.size;\r\n        pool.curr = pool.tail;\r\n        while (pool.ord != i)\r\n        {  pool.ord--;\r\n            xassert(pool.curr != null);\r\n            pool.curr = pool.curr.prev;\r\n        }\r\n    }\r\n    }\r\n    xassert(pool.ord == i);\r\n    xassert(pool.curr != null);\r\n    return pool.curr;\r\n}\r\n\r\nfunction ios_del_row(pool, i){\r\n    /* remove row (constraint) from the cut pool */\r\n    var cut, aij;\r\n    xassert(pool != null);\r\n    if (!(1 <= i && i <= pool.size))\r\n        xerror(\"glp_ios_del_row: i = \" + i + \"; cut number out of range\");\r\n    cut = ios_find_row(pool, i);\r\n    xassert(pool.curr == cut);\r\n    if (cut.next != null)\r\n        pool.curr = cut.next;\r\n    else if (cut.prev != null){\r\n        pool.ord--; pool.curr = cut.prev;\r\n    }\r\n    else {\r\n        pool.ord = 0; pool.curr = null;\r\n    }\r\n    if (cut.prev == null)\r\n    {  xassert(pool.head == cut);\r\n        pool.head = cut.next;\r\n    }\r\n    else\r\n    {  xassert(cut.prev.next == cut);\r\n        cut.prev.next = cut.next;\r\n    }\r\n    if (cut.next == null)\r\n    {  xassert(pool.tail == cut);\r\n        pool.tail = cut.prev;\r\n    }\r\n    else\r\n    {  xassert(cut.next.prev == cut);\r\n        cut.next.prev = cut.prev;\r\n    }\r\n    while (cut.ptr != null)\r\n    {  aij = cut.ptr;\r\n        cut.ptr = aij.next;\r\n    }\r\n    pool.size--;\r\n\r\n}\r\n\r\nfunction ios_clear_pool(pool){\r\n    /* remove all rows (constraints) from the cut pool */\r\n    xassert(pool != null);\r\n    while (pool.head != null)\r\n    {  var cut = pool.head;\r\n        pool.head = cut.next;\r\n        while (cut.ptr != null)\r\n        {  var aij = cut.ptr;\r\n            cut.ptr = aij.next;\r\n        }\r\n    }\r\n    pool.size = 0;\r\n    pool.head = pool.tail = null;\r\n    pool.ord = 0;\r\n    pool.curr = null;\r\n}\r\n\r\nfunction ios_delete_pool(pool){\r\n    /* delete cut pool */\r\n    xassert(pool != null);\r\n    ios_clear_pool(pool);\r\n}\r\n\r\nfunction ios_preprocess_node(tree, max_pass){\r\n    function prepare_row_info(n, a, l, u, f){\r\n        var j, j_min, j_max;\r\n        var f_min, f_max;\r\n        xassert(n >= 0);\r\n        /* determine f_min and j_min */\r\n        f_min = 0.0; j_min = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (a[j] > 0.0)\r\n        {  if (l[j] == -DBL_MAX)\r\n        {  if (j_min == 0)\r\n            j_min = j;\r\n        else\r\n        {  f_min = -DBL_MAX; j_min = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_min += a[j] * l[j];\r\n        }\r\n        else if (a[j] < 0.0)\r\n        {  if (u[j] == +DBL_MAX)\r\n        {  if (j_min == 0)\r\n            j_min = j;\r\n        else\r\n        {  f_min = -DBL_MAX; j_min = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_min += a[j] * u[j];\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        f.f_min = f_min; f.j_min = j_min;\r\n        /* determine f_max and j_max */\r\n        f_max = 0.0; j_max = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (a[j] > 0.0)\r\n        {  if (u[j] == +DBL_MAX)\r\n        {  if (j_max == 0)\r\n            j_max = j;\r\n        else\r\n        {  f_max = +DBL_MAX; j_max = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_max += a[j] * u[j];\r\n        }\r\n        else if (a[j] < 0.0)\r\n        {  if (l[j] == -DBL_MAX)\r\n        {  if (j_max == 0)\r\n            j_max = j;\r\n        else\r\n        {  f_max = +DBL_MAX; j_max = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_max += a[j] * l[j];\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        f.f_max = f_max; f.j_max = j_max;\r\n    }\r\n\r\n    function row_implied_bounds(f, callback){\r\n        callback((f.j_min == 0 ? f.f_min : -DBL_MAX), (f.j_max == 0 ? f.f_max : +DBL_MAX));\r\n    }\r\n\r\n    function col_implied_bounds(f, n, a, L, U, l, u, k, callback){\r\n        var ilb, iub, ll, uu;\r\n        xassert(n >= 0);\r\n        xassert(1 <= k && k <= n);\r\n        /* determine implied lower bound of term a[k] * x[k] (14) */\r\n        if (L == -DBL_MAX || f.f_max == +DBL_MAX)\r\n            ilb = -DBL_MAX;\r\n        else if (f.j_max == 0)\r\n        {  if (a[k] > 0.0)\r\n        {  xassert(u[k] != +DBL_MAX);\r\n            ilb = L - (f.f_max - a[k] * u[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  xassert(l[k] != -DBL_MAX);\r\n            ilb = L - (f.f_max - a[k] * l[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        else if (f.j_max == k)\r\n            ilb = L - f.f_max;\r\n        else\r\n            ilb = -DBL_MAX;\r\n        /* determine implied upper bound of term a[k] * x[k] (15) */\r\n        if (U == +DBL_MAX || f.f_min == -DBL_MAX)\r\n            iub = +DBL_MAX;\r\n        else if (f.j_min == 0)\r\n        {  if (a[k] > 0.0)\r\n        {  xassert(l[k] != -DBL_MAX);\r\n            iub = U - (f.f_min - a[k] * l[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  xassert(u[k] != +DBL_MAX);\r\n            iub = U - (f.f_min - a[k] * u[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        else if (f.j_min == k)\r\n            iub = U - f.f_min;\r\n        else\r\n            iub = +DBL_MAX;\r\n        /* determine implied bounds of x[k] (16) and (17) */\r\n        /* do not use a[k] if it has small magnitude to prevent wrong\r\n         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where\r\n         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that\r\n         x1 >= 0 */\r\n        if (Math.abs(a[k]) < 1e-6){\r\n            ll = -DBL_MAX;\r\n            uu = +DBL_MAX\r\n        } else if (a[k] > 0.0)\r\n        {  ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);\r\n            uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);\r\n            uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        callback(ll, uu);\r\n    }\r\n\r\n    function check_row_bounds(f, L_, Lx, U_, Ux){\r\n        var eps, ret = 0;\r\n        var L = L_[Lx], U = U_[Ux], LL = null, UU = null;\r\n        /* determine implied bounds of the row */\r\n        row_implied_bounds(f, function(a, b){LL = a; UU = b});\r\n        /* check if the original lower bound is infeasible */\r\n        if (L != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(L));\r\n            if (UU < L - eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original upper bound is infeasible */\r\n        if (U != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(U));\r\n            if (LL > U + eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original lower bound is redundant */\r\n        if (L != -DBL_MAX)\r\n        {   eps = 1e-12 * (1.0 + Math.abs(L));\r\n            if (LL > L - eps)\r\n            {  /* it cannot be active, so remove it */\r\n                L_[Lx] = -DBL_MAX;\r\n            }\r\n        }\r\n        /* check if the original upper bound is redundant */\r\n        if (U != +DBL_MAX)\r\n        {   eps = 1e-12 * (1.0 + Math.abs(U));\r\n            if (UU < U + eps)\r\n            {  /* it cannot be active, so remove it */\r\n                U_[Ux] = +DBL_MAX;\r\n            }\r\n        }\r\n        return ret\r\n    }\r\n\r\n    function check_col_bounds(f, n, a, L, U, l, u, flag, j, callback){\r\n        var eps, ret = 0;\r\n        var lj, uj, ll = null, uu = null;\r\n        xassert(n >= 0);\r\n        xassert(1 <= j && j <= n);\r\n        lj = l[j]; uj = u[j];\r\n        /* determine implied bounds of the column */\r\n        col_implied_bounds(f, n, a, L, U, l, u, j, function(a,b){ll = a; uu = b});\r\n        /* if x[j] is integral, round its implied bounds */\r\n        if (flag)\r\n        {  if (ll != -DBL_MAX)\r\n            ll = (ll - Math.floor(ll) < 1e-3 ? Math.floor(ll) : Math.ceil(ll));\r\n            if (uu != +DBL_MAX)\r\n                uu = (Math.ceil(uu) - uu < 1e-3 ? Math.ceil(uu) : Math.floor(uu));\r\n        }\r\n        /* check if the original lower bound is infeasible */\r\n        if (lj != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(lj));\r\n            if (uu < lj - eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original upper bound is infeasible */\r\n        if (uj != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(uj));\r\n            if (ll > uj + eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original lower bound is redundant */\r\n        if (ll != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(ll));\r\n            if (lj < ll - eps)\r\n            {  /* it cannot be active, so tighten it */\r\n                lj = ll;\r\n            }\r\n        }\r\n        /* check if the original upper bound is redundant */\r\n        if (uu != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(uu));\r\n            if (uj > uu + eps)\r\n            {  /* it cannot be active, so tighten it */\r\n                uj = uu;\r\n            }\r\n        }\r\n        /* due to round-off errors it may happen that lj > uj (although\r\n         lj < uj + eps, since no primal infeasibility is detected), so\r\n         adjuct the new actual bounds to provide lj <= uj */\r\n        if (!(lj == -DBL_MAX || uj == +DBL_MAX))\r\n        {   var t1 = Math.abs(lj), t2 = Math.abs(uj);\r\n            eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));\r\n            if (lj > uj - eps)\r\n            {  if (lj == l[j])\r\n                uj = lj;\r\n            else if (uj == u[j])\r\n                lj = uj;\r\n            else if (t1 <= t2)\r\n                uj = lj;\r\n            else\r\n                lj = uj;\r\n            }\r\n        }\r\n        callback(lj, uj);\r\n        return ret;\r\n    }\r\n\r\n    function check_efficiency(flag, l, u, ll, uu){\r\n        var r, eff = 0;\r\n        /* check efficiency for lower bound */\r\n        if (l < ll)\r\n        {  if (flag || l == -DBL_MAX)\r\n            eff++;\r\n        else\r\n        {\r\n            if (u == +DBL_MAX)\r\n                r = 1.0 + Math.abs(l);\r\n            else\r\n                r = 1.0 + (u - l);\r\n            if (ll - l >= 0.25 * r)\r\n                eff++;\r\n        }\r\n        }\r\n        /* check efficiency for upper bound */\r\n        if (u > uu)\r\n        {  if (flag || u == +DBL_MAX)\r\n            eff++;\r\n        else\r\n        {\r\n            if (l == -DBL_MAX)\r\n                r = 1.0 + Math.abs(u);\r\n            else\r\n                r = 1.0 + (u - l);\r\n            if (u - uu >= 0.25 * r)\r\n                eff++;\r\n        }\r\n        }\r\n        return eff;\r\n    }\r\n\r\n    function basic_preprocessing(mip, L, U, l, u, nrs, num, max_pass){\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var f = {};\r\n        var i, j, k, len, size, ret = 0;\r\n        var ind, list, mark, pass;\r\n        var val, lb, ub;\r\n        var aij, col;\r\n        xassert(0 <= nrs && nrs <= m+1);\r\n        xassert(max_pass > 0);\r\n        /* allocate working arrays */\r\n        ind = new Int32Array(1+n);\r\n        list = new Int32Array(1+m+1);\r\n        mark = new Int32Array(1+m+1);\r\n        pass = new Int32Array(1+m+1);\r\n        val = new Float64Array(1+n);\r\n        lb = new Float64Array(1+n);\r\n        ub = new Float64Array(1+n);\r\n        /* initialize the list of rows to be processed */\r\n        size = 0;\r\n        for (k = 1; k <= nrs; k++)\r\n        {  i = num[k];\r\n            xassert(0 <= i && i <= m);\r\n            /* duplicate row numbers are not allowed */\r\n            xassert(!mark[i]);\r\n            list[++size] = i; mark[i] = 1;\r\n        }\r\n        xassert(size == nrs);\r\n        /* process rows in the list until it becomes empty */\r\n        while (size > 0)\r\n        {  /* get a next row from the list */\r\n            i = list[size--]; mark[i] = 0;\r\n            /* increase the row processing count */\r\n            pass[i]++;\r\n            /* if the row is free, skip it */\r\n            if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\r\n            /* obtain coefficients of the row */\r\n            len = 0;\r\n            if (i == 0)\r\n            {   for (j = 1; j <= n; j++)\r\n            {   col = mip.col[j];\r\n                if (col.coef != 0.0){\r\n                    len++; ind[len] = j; val[len] = col.coef;\r\n                }\r\n            }\r\n            }\r\n            else\r\n            {   var row = mip.row[i];\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next){\r\n                    len++; ind[len] = aij.col.j; val[len] = aij.val;\r\n                }\r\n            }\r\n            /* determine lower and upper bounds of columns corresponding\r\n             to non-zero row coefficients */\r\n            for (k = 1; k <= len; k++){\r\n                j = ind[k]; lb[k] = l[j]; ub[k] = u[j];\r\n            }\r\n            /* prepare the row info to determine implied bounds */\r\n            prepare_row_info(len, val, lb, ub, f);\r\n            /* check and relax bounds of the row */\r\n            if (check_row_bounds(f, L, i, U, i))\r\n            {  /* the feasible region is empty */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* if the row became free, drop it */\r\n            if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\r\n            /* process columns having non-zero coefficients in the row */\r\n            for (k = 1; k <= len; k++){\r\n                var flag, eff;\r\n                var ll = null, uu = null;\r\n                /* take a next column in the row */\r\n                j = ind[k]; col = mip.col[j];\r\n                flag = col.kind != GLP_CV;\r\n                /* check and tighten bounds of the column */\r\n                if (check_col_bounds(f, len, val, L[i], U[i], lb, ub,\r\n                    flag, k, function(a, b){ll = a; uu = b}))\r\n                {  /* the feasible region is empty */\r\n                    ret = 1;\r\n                    return ret;\r\n                }\r\n                /* check if change in the column bounds is efficient */\r\n                eff = check_efficiency(flag, l[j], u[j], ll, uu);\r\n                /* set new actual bounds of the column */\r\n                l[j] = ll; u[j] = uu;\r\n                /* if the change is efficient, add all rows affected by the\r\n                 corresponding column, to the list */\r\n                if (eff > 0)\r\n                {\r\n                    for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    {  var ii = aij.row.i;\r\n                        /* if the row was processed maximal number of times,\r\n                         skip it */\r\n                        if (pass[ii] >= max_pass) continue;\r\n                        /* if the row is free, skip it */\r\n                        if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;\r\n                        /* put the row into the list */\r\n                        if (mark[ii] == 0)\r\n                        {  xassert(size <= m);\r\n                            list[++size] = ii; mark[ii] = 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var i, j, nrs, num, ret = 0;\r\n    var L, U, l, u;\r\n    /* the current subproblem must exist */\r\n    xassert(tree.curr != null);\r\n    /* determine original row bounds */\r\n    L = new Float64Array(1+m);\r\n    U = new Float64Array(1+m);\r\n    switch (mip.mip_stat)\r\n    {  case GLP_UNDEF:\r\n        L[0] = -DBL_MAX; U[0] = +DBL_MAX;\r\n        break;\r\n        case GLP_FEAS:\r\n            switch (mip.dir)\r\n            {  case GLP_MIN:\r\n                L[0] = -DBL_MAX; U[0] = mip.mip_obj - mip.c0;\r\n                break;\r\n                case GLP_MAX:\r\n                    L[0] = mip.mip_obj - mip.c0; U[0] = +DBL_MAX;\r\n                    break;\r\n                default:\r\n                    xassert(mip != mip);\r\n            }\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    for (i = 1; i <= m; i++)\r\n    {  L[i] = glp_get_row_lb(mip, i);\r\n        U[i] = glp_get_row_ub(mip, i);\r\n    }\r\n    /* determine original column bounds */\r\n    l = new Float64Array(1+n);\r\n    u = new Float64Array(1+n);\r\n    for (j = 1; j <= n; j++)\r\n    {  l[j] = glp_get_col_lb(mip, j);\r\n        u[j] = glp_get_col_ub(mip, j);\r\n    }\r\n    /* build the initial list of rows to be analyzed */\r\n    nrs = m + 1;\r\n    num = new Int32Array(1+nrs);\r\n    for (i = 1; i <= nrs; i++) num[i] = i - 1;\r\n    /* perform basic preprocessing */\r\n    if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))\r\n    {  ret = 1;\r\n        return ret;\r\n    }\r\n    /* set new actual (relaxed) row bounds */\r\n    for (i = 1; i <= m; i++)\r\n    {  /* consider only non-active rows to keep dual feasibility */\r\n        if (glp_get_row_stat(mip, i) == GLP_BS)\r\n        {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);\r\n        else if (U[i] == +DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);\r\n        else if (L[i] == -DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);\r\n        }\r\n    }\r\n    /* set new actual (tightened) column bounds */\r\n    for (j = 1; j <= n; j++)\r\n    {  var type;\r\n        if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (u[j] == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (l[j] == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (l[j] != u[j])\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_col_bnds(mip, j, type, l[j], u[j]);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction ios_driver(T){\r\n    function show_progress(T, bingo){\r\n        var p;\r\n        var temp;\r\n        var best_mip, best_bound, rho, rel_gap;\r\n        /* format the best known integer feasible solution */\r\n        if (T.mip.mip_stat == GLP_FEAS)\r\n            best_mip = String(T.mip.mip_obj);\r\n        else\r\n            best_mip = \"not found yet\";\r\n        /* determine reference number of an active subproblem whose local\r\n         bound is best */\r\n        p = ios_best_node(T);\r\n        /* format the best bound */\r\n        if (p == 0)\r\n            best_bound = \"tree is empty\";\r\n        else\r\n        {  temp = T.slot[p].node.bound;\r\n            if (temp == -DBL_MAX)\r\n                best_bound = \"-inf\";\r\n            else if (temp == +DBL_MAX)\r\n                best_bound = \"+inf\";\r\n            else\r\n                best_bound = temp;\r\n        }\r\n        /* choose the relation sign between global bounds */\r\n        if (T.mip.dir == GLP_MIN)\r\n            rho = \">=\";\r\n        else if (T.mip.dir == GLP_MAX)\r\n            rho = \"<=\";\r\n        else\r\n            xassert(T != T);\r\n        /* format the relative mip gap */\r\n        temp = ios_relative_gap(T);\r\n        if (temp == 0.0)\r\n            rel_gap = \"  0.0%\";\r\n        else if (temp < 0.001)\r\n            rel_gap = \" < 0.1%\";\r\n        else if (temp <= 9.999){\r\n            rel_gap = \"  \" + Number(100.0 * temp).toFixed(1) + \"%\";\r\n        }\r\n        else\r\n            rel_gap = \"\";\r\n        /* display progress of the search */\r\n        xprintf(\"+\" + T.mip.it_cnt + \": \" + (bingo ? \">>>>>\" : \"mip =\") + \" \" + best_mip + \" \" + rho + \" \" + best_bound\r\n            + \" \" + rel_gap + \" (\" + T.a_cnt + \"; \" + (T.t_cnt - T.n_cnt) + \")\");\r\n        T.tm_lag = xtime();\r\n    }\r\n\r\n    function is_branch_hopeful(T, p){\r\n        xassert(1 <= p && p <= T.nslots);\r\n        xassert(T.slot[p].node != null);\r\n        return ios_is_hopeful(T, T.slot[p].node.bound);\r\n    }\r\n\r\n    function check_integrality(T){\r\n        var mip = T.mip;\r\n        var j, type, ii_cnt = 0;\r\n        var lb, ub, x, temp1, temp2, ii_sum = 0.0;\r\n        /* walk through the set of columns (structural variables) */\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            T.non_int[j] = 0;\r\n            /* if the column is not integer, skip it */\r\n            if (col.kind != GLP_IV) continue;\r\n            /* if the column is non-basic, it is integer feasible */\r\n            if (col.stat != GLP_BS) continue;\r\n            /* obtain the type and bounds of the column */\r\n            type = col.type; lb = col.lb; ub = col.ub;\r\n            /* obtain value of the column in optimal basic solution */\r\n            x = col.prim;\r\n            /* if the column's primal value is close to the lower bound,\r\n             the column is integer feasible within given tolerance */\r\n            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n            {  temp1 = lb - T.parm.tol_int;\r\n                temp2 = lb + T.parm.tol_int;\r\n                if (temp1 <= x && x <= temp2) continue;\r\n                if (x < lb) continue;\r\n            }\r\n            /* if the column's primal value is close to the upper bound,\r\n             the column is integer feasible within given tolerance */\r\n            if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n            {  temp1 = ub - T.parm.tol_int;\r\n                temp2 = ub + T.parm.tol_int;\r\n                if (temp1 <= x && x <= temp2) continue;\r\n                if (x > ub) continue;\r\n            }\r\n            /* if the column's primal value is close to nearest integer,\r\n             the column is integer feasible within given tolerance */\r\n            temp1 = Math.floor(x + 0.5) - T.parm.tol_int;\r\n            temp2 = Math.floor(x + 0.5) + T.parm.tol_int;\r\n            if (temp1 <= x && x <= temp2) continue;\r\n            /* otherwise the column is integer infeasible */\r\n            T.non_int[j] = 1;\r\n            /* increase the number of fractional-valued columns */\r\n            ii_cnt++;\r\n            /* compute the sum of integer infeasibilities */\r\n            temp1 = x - Math.floor(x);\r\n            temp2 = Math.ceil(x) - x;\r\n            xassert(temp1 > 0.0 && temp2 > 0.0);\r\n            ii_sum += (temp1 <= temp2 ? temp1 : temp2);\r\n        }\r\n        /* store ii_cnt and ii_sum to the current problem descriptor */\r\n        xassert(T.curr != null);\r\n        T.curr.ii_cnt = ii_cnt;\r\n        T.curr.ii_sum = ii_sum;\r\n        /* and also display these parameters */\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (ii_cnt == 0)\r\n            xprintf(\"There are no fractional columns\");\r\n        else if (ii_cnt == 1)\r\n            xprintf(\"There is one fractional column, integer infeasibility is \" + ii_sum + \"\");\r\n        else\r\n            xprintf(\"There are \" + ii_cnt + \" fractional columns, integer infeasibility is \" + ii_sum + \"\");\r\n        }\r\n    }\r\n\r\n    function record_solution(T){\r\n        var mip = T.mip;\r\n        var i, j;\r\n        mip.mip_stat = GLP_FEAS;\r\n        mip.mip_obj = mip.obj_val;\r\n        for (i = 1; i <= mip.m; i++)\r\n        {  var row = mip.row[i];\r\n            row.mipx = row.prim;\r\n        }\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            if (col.kind == GLP_CV)\r\n                col.mipx = col.prim;\r\n            else if (col.kind == GLP_IV)\r\n            {  /* value of the integer column must be integral */\r\n                col.mipx = Math.floor(col.prim + 0.5);\r\n            }\r\n            else\r\n                xassert(col != col);\r\n        }\r\n        T.sol_cnt++;\r\n    }\r\n\r\n    function branch_on(T, j, next){\r\n        var mip = T.mip;\r\n        var node;\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var type, dn_type, up_type, dn_bad, up_bad, p, ret, clone = new Array(1+2);\r\n        var lb, ub, beta, new_ub, new_lb, dn_lp = null, up_lp = null, dn_bnd, up_bnd;\r\n        /* determine bounds and value of x[j] in optimal solution to LP\r\n         relaxation of the current subproblem */\r\n        xassert(1 <= j && j <= n);\r\n        type = mip.col[j].type;\r\n        lb = mip.col[j].lb;\r\n        ub = mip.col[j].ub;\r\n        beta = mip.col[j].prim;\r\n        /* determine new bounds of x[j] for down- and up-branches */\r\n        new_ub = Math.floor(beta);\r\n        new_lb = Math.ceil(beta);\r\n        switch (type)\r\n        {  case GLP_FR:\r\n            dn_type = GLP_UP;\r\n            up_type = GLP_LO;\r\n            break;\r\n            case GLP_LO:\r\n                xassert(lb <= new_ub);\r\n                dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\r\n                xassert(lb + 1.0 <= new_lb);\r\n                up_type = GLP_LO;\r\n                break;\r\n            case GLP_UP:\r\n                xassert(new_ub <= ub - 1.0);\r\n                dn_type = GLP_UP;\r\n                xassert(new_lb <= ub);\r\n                up_type = (new_lb == ub ? GLP_FX : GLP_DB);\r\n                break;\r\n            case GLP_DB:\r\n                xassert(lb <= new_ub && new_ub <= ub - 1.0);\r\n                dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\r\n                xassert(lb + 1.0 <= new_lb && new_lb <= ub);\r\n                up_type = (new_lb == ub ? GLP_FX : GLP_DB);\r\n                break;\r\n            default:\r\n                xassert(type != type);\r\n        }\r\n        /* compute local bounds to LP relaxation for both branches */\r\n        ios_eval_degrad(T, j, function(a, b){dn_lp = a; up_lp = b});\r\n        /* and improve them by rounding */\r\n        dn_bnd = ios_round_bound(T, dn_lp);\r\n        up_bnd = ios_round_bound(T, up_lp);\r\n        /* check local bounds for down- and up-branches */\r\n        dn_bad = !ios_is_hopeful(T, dn_bnd);\r\n        up_bad = !ios_is_hopeful(T, up_bnd);\r\n        if (dn_bad && up_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Both down- and up-branches are hopeless\");\r\n            ret = 2;\r\n            return ret;\r\n        }\r\n        else if (up_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Up-branch is hopeless\");\r\n            glp_set_col_bnds(mip, j, dn_type, lb, new_ub);\r\n            T.curr.lp_obj = dn_lp;\r\n            if (mip.dir == GLP_MIN)\r\n            {  if (T.curr.bound < dn_bnd)\r\n                T.curr.bound = dn_bnd;\r\n            }\r\n            else if (mip.dir == GLP_MAX)\r\n            {  if (T.curr.bound > dn_bnd)\r\n                T.curr.bound = dn_bnd;\r\n            }\r\n            else\r\n                xassert(mip != mip);\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        else if (dn_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Down-branch is hopeless\");\r\n            glp_set_col_bnds(mip, j, up_type, new_lb, ub);\r\n            T.curr.lp_obj = up_lp;\r\n            if (mip.dir == GLP_MIN)\r\n            {  if (T.curr.bound < up_bnd)\r\n                T.curr.bound = up_bnd;\r\n            }\r\n            else if (mip.dir == GLP_MAX)\r\n            {  if (T.curr.bound > up_bnd)\r\n                T.curr.bound = up_bnd;\r\n            }\r\n            else\r\n                xassert(mip != mip);\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* both down- and up-branches seem to be hopeful */\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Branching on column \" + j + \", primal value is \" + beta + \"\");\r\n        /* determine the reference number of the current subproblem */\r\n        xassert(T.curr != null);\r\n        p = T.curr.p;\r\n        T.curr.br_var = j;\r\n        T.curr.br_val = beta;\r\n        /* freeze the current subproblem */\r\n        ios_freeze_node(T);\r\n        /* create two clones of the current subproblem; the first clone\r\n         begins the down-branch, the second one begins the up-branch */\r\n        ios_clone_node(T, p, 2, clone);\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Node \" + clone[1] + \" begins down branch, node \" + clone[2] + \" begins up branch \");\r\n        /* set new upper bound of j-th column in the down-branch */\r\n        node = T.slot[clone[1]].node;\r\n        xassert(node != null);\r\n        xassert(node.up != null);\r\n        xassert(node.b_ptr == null);\r\n        node.b_ptr = {};\r\n        node.b_ptr.k = m + j;\r\n        node.b_ptr.type = dn_type;\r\n        node.b_ptr.lb = lb;\r\n        node.b_ptr.ub = new_ub;\r\n        node.b_ptr.next = null;\r\n        node.lp_obj = dn_lp;\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (node.bound < dn_bnd)\r\n            node.bound = dn_bnd;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (node.bound > dn_bnd)\r\n            node.bound = dn_bnd;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* set new lower bound of j-th column in the up-branch */\r\n        node = T.slot[clone[2]].node;\r\n        xassert(node != null);\r\n        xassert(node.up != null);\r\n        xassert(node.b_ptr == null);\r\n        node.b_ptr = {};\r\n        node.b_ptr.k = m + j;\r\n        node.b_ptr.type = up_type;\r\n        node.b_ptr.lb = new_lb;\r\n        node.b_ptr.ub = ub;\r\n        node.b_ptr.next = null;\r\n        node.lp_obj = up_lp;\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (node.bound < up_bnd)\r\n            node.bound = up_bnd;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (node.bound > up_bnd)\r\n            node.bound = up_bnd;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* suggest the subproblem to be solved next */\r\n        xassert(T.child == 0);\r\n        if (next == GLP_NO_BRNCH)\r\n            T.child = 0;\r\n        else if (next == GLP_DN_BRNCH)\r\n            T.child = clone[1];\r\n        else if (next == GLP_UP_BRNCH)\r\n            T.child = clone[2];\r\n        else\r\n            xassert(next != next);\r\n        ret = 0;\r\n        return ret;\r\n    }\r\n\r\n    function fix_by_red_cost(T){\r\n        var mip = T.mip;\r\n        var j, stat, fixed = 0;\r\n        var obj, lb, ub, dj;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* basic solution of LP relaxation must be optimal */\r\n        xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);\r\n        /* determine the objective function value */\r\n        obj = mip.obj_val;\r\n        /* walk through the column list */\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            /* if the column is not integer, skip it */\r\n            if (col.kind != GLP_IV) continue;\r\n            /* obtain bounds of j-th column */\r\n            lb = col.lb; ub = col.ub;\r\n            /* and determine its status and reduced cost */\r\n            stat = col.stat; dj = col.dual;\r\n            /* analyze the reduced cost */\r\n            switch (mip.dir)\r\n            {  case GLP_MIN:\r\n                /* minimization */\r\n                if (stat == GLP_NL)\r\n                {  /* j-th column is non-basic on its lower bound */\r\n                    if (dj < 0.0) dj = 0.0;\r\n                    if (obj + dj >= mip.mip_obj){\r\n                        glp_set_col_bnds(mip, j, GLP_FX, lb, lb); fixed++;\r\n                    }\r\n                }\r\n                else if (stat == GLP_NU)\r\n                {  /* j-th column is non-basic on its upper bound */\r\n                    if (dj > 0.0) dj = 0.0;\r\n                    if (obj - dj >= mip.mip_obj){\r\n                        glp_set_col_bnds(mip, j, GLP_FX, ub, ub); fixed++;\r\n                    }\r\n                }\r\n                break;\r\n                case GLP_MAX:\r\n                    /* maximization */\r\n                    if (stat == GLP_NL)\r\n                    {  /* j-th column is non-basic on its lower bound */\r\n                        if (dj > 0.0) dj = 0.0;\r\n                        if (obj + dj <= mip.mip_obj){\r\n                            glp_set_col_bnds(mip, j, GLP_FX, lb, lb); fixed++;\r\n                        }\r\n                    }\r\n                    else if (stat == GLP_NU)\r\n                    {  /* j-th column is non-basic on its upper bound */\r\n                        if (dj < 0.0) dj = 0.0;\r\n                        if (obj - dj <= mip.mip_obj){\r\n                            glp_set_col_bnds(mip, j, GLP_FX, ub, ub); fixed++;\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    xassert(T != T);\r\n            }\r\n        }\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (fixed == 0)\r\n        {/* nothing to say */}\r\n        else if (fixed == 1)\r\n            xprintf(\"One column has been fixed by reduced cost\");\r\n        else\r\n            xprintf(fixed + \" columns have been fixed by reduced costs\");\r\n        }\r\n        /* fixing non-basic columns on their current bounds does not\r\n         change the basic solution */\r\n        xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);\r\n    }\r\n\r\n\r\n    function remove_cuts(T){\r\n        /* remove inactive cuts (some valueable globally valid cut might\r\n         be saved in the global cut pool) */\r\n        var i, cnt = 0, num = null;\r\n        xassert(T.curr != null);\r\n        for (i = T.orig_m+1; i <= T.mip.m; i++)\r\n        {  if (T.mip.row[i].origin == GLP_RF_CUT &&\r\n            T.mip.row[i].level == T.curr.level &&\r\n            T.mip.row[i].stat == GLP_BS)\r\n        {  if (num == null)\r\n            num = new Int32Array(1+T.mip.m);\r\n            num[++cnt] = i;\r\n        }\r\n        }\r\n        if (cnt > 0)\r\n        {  glp_del_rows(T.mip, cnt, num);\r\n            xassert(glp_factorize(T.mip) == 0);\r\n        }\r\n    }\r\n\r\n    function display_cut_info(T){\r\n        var mip = T.mip;\r\n        var i, gmi = 0, mir = 0, cov = 0, clq = 0, app = 0;\r\n        for (i = mip.m; i > 0; i--)\r\n        {\r\n            var row = mip.row[i];\r\n            /* if (row.level < T.curr.level) break; */\r\n            if (row.origin == GLP_RF_CUT)\r\n            {  if (row.klass == GLP_RF_GMI)\r\n                gmi++;\r\n            else if (row.klass == GLP_RF_MIR)\r\n                mir++;\r\n            else if (row.klass == GLP_RF_COV)\r\n                cov++;\r\n            else if (row.klass == GLP_RF_CLQ)\r\n                clq++;\r\n            else\r\n                app++;\r\n            }\r\n        }\r\n        xassert(T.curr != null);\r\n        if (gmi + mir + cov + clq + app > 0)\r\n        {  xprintf(\"Cuts on level \" + T.curr.level + \":\");\r\n            if (gmi > 0) xprintf(\" gmi = \" + gmi + \";\");\r\n            if (mir > 0) xprintf(\" mir = \" + mir + \";\");\r\n            if (cov > 0) xprintf(\" cov = \" + cov + \";\");\r\n            if (clq > 0) xprintf(\" clq = \" + clq + \";\");\r\n            if (app > 0) xprintf(\" app = \" + app + \";\");\r\n            xprintf(\"\");\r\n        }\r\n    }\r\n\r\n    function generate_cuts(T){\r\n        /* generate generic cuts with built-in generators */\r\n        if (!(T.parm.mir_cuts == GLP_ON ||\r\n            T.parm.gmi_cuts == GLP_ON ||\r\n            T.parm.cov_cuts == GLP_ON ||\r\n            T.parm.clq_cuts == GLP_ON)) return;\r\n        {   var i, max_cuts, added_cuts;\r\n            max_cuts = T.n;\r\n            if (max_cuts < 1000) max_cuts = 1000;\r\n            added_cuts = 0;\r\n            for (i = T.orig_m+1; i <= T.mip.m; i++)\r\n            {  if (T.mip.row[i].origin == GLP_RF_CUT)\r\n                added_cuts++;\r\n            }\r\n            /* xprintf(\"added_cuts = %d\", added_cuts); */\r\n            if (added_cuts >= max_cuts) return;\r\n        }\r\n        /* generate and add to POOL all cuts violated by x* */\r\n        if (T.parm.gmi_cuts == GLP_ON)\r\n        {  if (T.curr.changed < 5)\r\n            ios_gmi_gen(T);\r\n        }\r\n        if (T.parm.mir_cuts == GLP_ON)\r\n        {  xassert(T.mir_gen != null);\r\n            ios_mir_gen(T, T.mir_gen);\r\n        }\r\n        if (T.parm.cov_cuts == GLP_ON)\r\n        {  /* cover cuts works well along with mir cuts */\r\n            /*if (T.round <= 5)*/\r\n            ios_cov_gen(T);\r\n        }\r\n        if (T.parm.clq_cuts == GLP_ON)\r\n        {  if (T.clq_gen != null)\r\n        {  if (T.curr.level == 0 && T.curr.changed < 50 ||\r\n            T.curr.level >  0 && T.curr.changed < 5)\r\n            ios_clq_gen(T, T.clq_gen);\r\n        }\r\n        }\r\n    }\r\n\r\n    function cleanup_the_tree(T){\r\n        var node, next_node;\r\n        var count = 0;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* walk through the list of active subproblems */\r\n        for (node = T.head; node != null; node = next_node)\r\n        {  /* deleting some active problem node may involve deleting its\r\n         parents recursively; however, all its parents being created\r\n         *before* it are always *precede* it in the node list, so\r\n         the next problem node is never affected by such deletion */\r\n            next_node = node.next;\r\n            /* if the branch is hopeless, prune it */\r\n            if (!is_branch_hopeful(T, node.p)){\r\n                ios_delete_node(T, node.p); count++;\r\n            }\r\n        }\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (count == 1)\r\n            xprintf(\"One hopeless branch has been pruned\");\r\n        else if (count > 1)\r\n            xprintf(count + \" hopeless branches have been pruned\");\r\n        }\r\n    }\r\n\r\n    var p, curr_p, p_stat, d_stat, ret;\r\n    var pred_p = 0;\r\n    /* if the current subproblem has been just created due to\r\n     branching, pred_p is the reference number of its parent\r\n     subproblem, otherwise pred_p is zero */\r\n    var ttt = T.tm_beg;\r\n    /* on entry to the B&B driver it is assumed that the active list\r\n     contains the only active (i.e. root) subproblem, which is the\r\n     original MIP problem to be solved */\r\n\r\n    var\r\n        loop = 0,\r\n        more = 1,\r\n        fath = 2,\r\n        done = 3;\r\n\r\n    var label = loop;\r\n\r\n    while (true){\r\n        var go_to = null;\r\n        switch (label){\r\n            case loop:\r\n                /* main loop starts here */\r\n                /* at this point the current subproblem does not exist */\r\n                xassert(T.curr == null);\r\n                /* if the active list is empty, the search is finished */\r\n                if (T.head == null)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Active list is empty!\");\r\n                    //xassert(Object.keys(T.pool).length == 0);\r\n                    ret = 0;\r\n                    go_to = done; break;\r\n                }\r\n                /* select some active subproblem to continue the search */\r\n                xassert(T.next_p == 0);\r\n                /* let the application program select subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ISELECT;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                if (T.next_p != 0)\r\n                {  /* the application program has selected something */\r\n\r\n                }\r\n                else if (T.a_cnt == 1)\r\n                {  /* the only active subproblem exists, so select it */\r\n                    xassert(T.head.next == null);\r\n                    T.next_p = T.head.p;\r\n                }\r\n                else if (T.child != 0)\r\n                {  /* select one of branching childs suggested by the branching\r\n                 heuristic */\r\n                    T.next_p = T.child;\r\n                }\r\n                else\r\n                {  /* select active subproblem as specified by the backtracking\r\n                 technique option */\r\n                    T.next_p = ios_choose_node(T);\r\n                }\r\n                /* the active subproblem just selected becomes current */\r\n                ios_revive_node(T, T.next_p);\r\n                T.next_p = T.child = 0;\r\n                /* invalidate pred_p, if it is not the reference number of the\r\n                 parent of the current subproblem */\r\n                if (T.curr.up != null && T.curr.up.p != pred_p) pred_p = 0;\r\n                /* determine the reference number of the current subproblem */\r\n                p = T.curr.p;\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                {  xprintf(\"-----------------------------------------------------\" +\r\n                    \"-------------------\");\r\n                    xprintf(\"Processing node \" + p + \" at level \" + T.curr.level + \"\");\r\n                }\r\n                /* if it is the root subproblem, initialize cut generators */\r\n                if (p == 1)\r\n                {  if (T.parm.gmi_cuts == GLP_ON)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Gomory's cuts enabled\");\r\n                }\r\n                    if (T.parm.mir_cuts == GLP_ON)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"MIR cuts enabled\");\r\n                        xassert(T.mir_gen == null);\r\n                        T.mir_gen = ios_mir_init(T);\r\n                    }\r\n                    if (T.parm.cov_cuts == GLP_ON)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"Cover cuts enabled\");\r\n                    }\r\n                    if (T.parm.clq_cuts == GLP_ON)\r\n                    {  xassert(T.clq_gen == null);\r\n                        if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                            xprintf(\"Clique cuts enabled\");\r\n                        T.clq_gen = ios_clq_init(T);\r\n                    }\r\n                }\r\n            case more:\r\n                /* minor loop starts here */\r\n                /* at this point the current subproblem needs either to be solved\r\n                 for the first time or re-optimized due to reformulation */\r\n                /* display current progress of the search */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG ||\r\n                    T.parm.msg_lev >= GLP_MSG_ON &&\r\n                        (T.parm.out_frq - 1) <=\r\n                            1000.0 * xdifftime(xtime(), T.tm_lag))\r\n                    show_progress(T, 0);\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL &&\r\n                    xdifftime(xtime(), ttt) >= 60.0)\r\n                {\r\n                    xprintf(\"Time used: \" + xdifftime(xtime(), T.tm_beg) + \" secs\");\r\n                    ttt = xtime();\r\n                }\r\n                /* check the mip gap */\r\n                if (T.parm.mip_gap > 0.0 &&\r\n                    ios_relative_gap(T) <= T.parm.mip_gap)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Relative gap tolerance reached; search terminated \");\r\n                    ret = GLP_EMIPGAP;\r\n                    go_to = done; break;\r\n                }\r\n                /* check if the time limit has been exhausted */\r\n                if (T.parm.tm_lim < INT_MAX &&\r\n                    (T.parm.tm_lim - 1) <=\r\n                        1000.0 * xdifftime(xtime(), T.tm_beg))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Time limit exhausted; search terminated\");\r\n                    ret = GLP_ETMLIM;\r\n                    go_to = done; break;\r\n                }\r\n                /* let the application program preprocess the subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IPREPRO;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* perform basic preprocessing */\r\n                if (T.parm.pp_tech == GLP_PP_NONE){\r\n\r\n                }\r\n                else if (T.parm.pp_tech == GLP_PP_ROOT)\r\n                {  if (T.curr.level == 0)\r\n                {  if (ios_preprocess_node(T, 100)){\r\n                    go_to  = fath; break;\r\n                }\r\n                }\r\n                }\r\n                else if (T.parm.pp_tech == GLP_PP_ALL)\r\n                {  if (ios_preprocess_node(T, T.curr.level == 0 ? 100 : 10)){\r\n                    go_to = fath; break;\r\n                }\r\n                }\r\n                else\r\n                    xassert(T != T);\r\n                /* preprocessing may improve the global bound */\r\n                if (!is_branch_hopeful(T, p))\r\n                {  xprintf(\"*** not tested yet ***\");\r\n                    go_to = fath; break;\r\n                }\r\n                /* solve LP relaxation of the current subproblem */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Solving LP relaxation...\");\r\n                ret = ios_solve_node(T);\r\n                if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"ios_driver: unable to solve current LP relaxation; glp_simplex returned \" + ret + \"\");\r\n                    ret = GLP_EFAIL;\r\n                    go_to = done; break;\r\n                }\r\n                /* analyze status of the basic solution to LP relaxation found */\r\n                p_stat = T.mip.pbs_stat;\r\n                d_stat = T.mip.dbs_stat;\r\n                if (p_stat == GLP_FEAS && d_stat == GLP_FEAS)\r\n                {  /* LP relaxation has optimal solution */\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Found optimal solution to LP relaxation\");\r\n                }\r\n                else if (d_stat == GLP_NOFEAS)\r\n                {  /* LP relaxation has no dual feasible solution */\r\n                    /* since the current subproblem cannot have a larger feasible\r\n                     region than its parent, there is something wrong */\r\n                    if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"ios_driver: current LP relaxation has no dual feasible solution\");\r\n                    ret = GLP_EFAIL;\r\n                    go_to = done; break;\r\n                }\r\n                else if (p_stat == GLP_INFEAS && d_stat == GLP_FEAS)\r\n                {  /* LP relaxation has no primal solution which is better than\r\n                 the incumbent objective value */\r\n                    xassert(T.mip.mip_stat == GLP_FEAS);\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"LP relaxation has no solution better than incumbent objective value\");\r\n                    /* prune the branch */\r\n                    go_to = fath; break;\r\n                }\r\n                else if (p_stat == GLP_NOFEAS)\r\n                {  /* LP relaxation has no primal feasible solution */\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"LP relaxation has no feasible solution\");\r\n                    /* prune the branch */\r\n                    go_to = fath; break;\r\n                }\r\n                else\r\n                {  /* other cases cannot appear */\r\n                    xassert(T.mip != T.mip);\r\n                }\r\n                /* at this point basic solution to LP relaxation of the current\r\n                 subproblem is optimal */\r\n                xassert(p_stat == GLP_FEAS && d_stat == GLP_FEAS);\r\n                xassert(T.curr != null);\r\n                T.curr.lp_obj = T.mip.obj_val;\r\n                /* thus, it defines a local bound to integer optimal solution of\r\n                 the current subproblem */\r\n                {  var bound = T.mip.obj_val;\r\n                    /* some local bound to the current subproblem could be already\r\n                    set before, so we should only improve it */\r\n                    bound = ios_round_bound(T, bound);\r\n                    if (T.mip.dir == GLP_MIN)\r\n                    {  if (T.curr.bound < bound)\r\n                        T.curr.bound = bound;\r\n                    }\r\n                    else if (T.mip.dir == GLP_MAX)\r\n                    {  if (T.curr.bound > bound)\r\n                        T.curr.bound = bound;\r\n                    }\r\n                    else\r\n                        xassert(T.mip != T.mip);\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Local bound is \" + bound + \"\");\r\n                }\r\n                /* if the local bound indicates that integer optimal solution of\r\n                 the current subproblem cannot be better than the global bound,\r\n                 prune the branch */\r\n                if (!is_branch_hopeful(T, p))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Current branch is hopeless and can be pruned\");\r\n                    go_to = fath; break;\r\n                }\r\n                /* let the application program generate additional rows (\"lazy\"\r\n                 constraints) */\r\n                xassert(T.reopt == 0);\r\n                xassert(T.reinv == 0);\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IROWGEN;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                    if (T.reopt)\r\n                    {  /* some rows were added; re-optimization is needed */\r\n                        T.reopt = T.reinv = 0;\r\n                        go_to = more; break;\r\n                    }\r\n                    if (T.reinv)\r\n                    {  /* no rows were added, however, some inactive rows were\r\n                     removed */\r\n                        T.reinv = 0;\r\n                        xassert(glp_factorize(T.mip) == 0);\r\n                    }\r\n                }\r\n                /* check if the basic solution is integer feasible */\r\n                check_integrality(T);\r\n                /* if the basic solution satisfies to all integrality conditions,\r\n                 it is a new, better integer feasible solution */\r\n                if (T.curr.ii_cnt == 0)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"New integer feasible solution found\");\r\n                    if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        display_cut_info(T);\r\n                    record_solution(T);\r\n                    if (T.parm.msg_lev >= GLP_MSG_ON)\r\n                        show_progress(T, 1);\r\n                    /* make the application program happy */\r\n                    if (T.parm.cb_func != null)\r\n                    {  xassert(T.reason == 0);\r\n                        T.reason = GLP_IBINGO;\r\n                        T.parm.cb_func(T, T.parm.cb_info);\r\n                        T.reason = 0;\r\n                        if (T.stop)\r\n                        {  ret = GLP_ESTOP;\r\n                            go_to = done; break;\r\n                        }\r\n                    }\r\n                    /* since the current subproblem has been fathomed, prune its\r\n                     branch */\r\n                    go_to = fath; break;\r\n                }\r\n                /* at this point basic solution to LP relaxation of the current\r\n                 subproblem is optimal, but integer infeasible */\r\n                /* try to fix some non-basic structural variables of integer kind\r\n                 on their current bounds due to reduced costs */\r\n                if (T.mip.mip_stat == GLP_FEAS)\r\n                    fix_by_red_cost(T);\r\n                /* let the application program try to find some solution to the\r\n                 original MIP with a primal heuristic */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IHEUR;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                    /* check if the current branch became hopeless */\r\n                    if (!is_branch_hopeful(T, p))\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Current branch became hopeless and can be pruned\");\r\n                        go_to = fath; break;\r\n                    }\r\n                }\r\n                /* try to find solution with the feasibility pump heuristic */\r\n                if (T.parm.fp_heur)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IHEUR;\r\n                    ios_feas_pump(T);\r\n                    T.reason = 0;\r\n                    /* check if the current branch became hopeless */\r\n                    if (!is_branch_hopeful(T, p))\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Current branch became hopeless and can be pruned\");\r\n                        go_to = fath; break;\r\n                    }\r\n                }\r\n                /* it's time to generate cutting planes */\r\n                xassert(T.local != null);\r\n                xassert(T.local.size == 0);\r\n                /* let the application program generate some cuts; note that it\r\n                 can add cuts either to the local cut pool or directly to the\r\n                 current subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* try to generate generic cuts with built-in generators\r\n                 (as suggested by Matteo Fischetti et al. the built-in cuts\r\n                 are not generated at each branching node; an intense attempt\r\n                 of generating new cuts is only made at the root node, and then\r\n                 a moderate effort is spent after each backtracking step) */\r\n                if (T.curr.level == 0 || pred_p == 0)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    generate_cuts(T);\r\n                    T.reason = 0;\r\n                }\r\n                /* if the local cut pool is not empty, select useful cuts and add\r\n                 them to the current subproblem */\r\n                if (T.local.size > 0)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    ios_process_cuts(T);\r\n                    T.reason = 0;\r\n                }\r\n                /* clear the local cut pool */\r\n                ios_clear_pool(T.local);\r\n                /* perform re-optimization, if necessary */\r\n                if (T.reopt)\r\n                {  T.reopt = 0;\r\n                    T.curr.changed++;\r\n                    go_to = more; break;\r\n                }\r\n                /* no cuts were generated; remove inactive cuts */\r\n                remove_cuts(T);\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL && T.curr.level == 0)\r\n                    display_cut_info(T);\r\n                /* update history information used on pseudocost branching */\r\n                if (T.pcost != null) ios_pcost_update(T);\r\n                /* it's time to perform branching */\r\n                xassert(T.br_var == 0);\r\n                xassert(T.br_sel == 0);\r\n                /* let the application program choose variable to branch on */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    xassert(T.br_var == 0);\r\n                    xassert(T.br_sel == 0);\r\n                    T.reason = GLP_IBRANCH;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* if nothing has been chosen, choose some variable as specified\r\n                 by the branching technique option */\r\n                if (T.br_var == 0)\r\n                    T.br_var = ios_choose_var(T, function(next){T.br_sel = next});\r\n                /* perform actual branching */\r\n                curr_p = T.curr.p;\r\n                ret = branch_on(T, T.br_var, T.br_sel);\r\n                T.br_var = T.br_sel = 0;\r\n                if (ret == 0)\r\n                {  /* both branches have been created */\r\n                    pred_p = curr_p;\r\n                    go_to = loop; break;\r\n                }\r\n                else if (ret == 1)\r\n                {  /* one branch is hopeless and has been pruned, so now the\r\n                 current subproblem is other branch */\r\n                    /* the current subproblem should be considered as a new one,\r\n                     since one bound of the branching variable was changed */\r\n                    T.curr.solved = T.curr.changed = 0;\r\n                    go_to = more; break;\r\n                }\r\n                else if (ret == 2)\r\n                {  /* both branches are hopeless and have been pruned; new\r\n                 subproblem selection is needed to continue the search */\r\n                    go_to = fath; break;\r\n                }\r\n                else\r\n                    xassert(ret != ret);\r\n            case fath:\r\n                /* the current subproblem has been fathomed */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Node \" + p + \" fathomed\");\r\n                /* freeze the current subproblem */\r\n                ios_freeze_node(T);\r\n                /* and prune the corresponding branch of the tree */\r\n                ios_delete_node(T, p);\r\n                /* if a new integer feasible solution has just been found, other\r\n                 branches may become hopeless and therefore must be pruned */\r\n                if (T.mip.mip_stat == GLP_FEAS) cleanup_the_tree(T);\r\n                /* new subproblem selection is needed due to backtracking */\r\n                pred_p = 0;\r\n                go_to = loop; break;\r\n            case done:\r\n                /* display progress of the search on exit from the solver */\r\n                if (T.parm.msg_lev >= GLP_MSG_ON)\r\n                    show_progress(T, 0);\r\n                T.mir_gen = null;\r\n                T.clq_gen = null;\r\n                /* return to the calling program */\r\n                return ret;\r\n        }\r\n        if (go_to == null) break;\r\n        label = go_to;\r\n    }\r\n}\r\n\r\nfunction ios_create_vec(n){\r\n    var v;\r\n    xassert(n >= 0);\r\n    v = {};\r\n    v.n = n;\r\n    v.nnz = 0;\r\n    v.pos = new Int32Array(1+n);\r\n    v.ind = new Int32Array(1+n);\r\n    v.val = new Float64Array(1+n);\r\n    return v;\r\n}\r\n\r\nfunction ios_check_vec(v){\r\n    var j, k, nnz;\r\n    xassert(v.n >= 0);\r\n    nnz = 0;\r\n    for (j = v.n; j >= 1; j--)\r\n    {  k = v.pos[j];\r\n        xassert(0 <= k && k <= v.nnz);\r\n        if (k != 0)\r\n        {  xassert(v.ind[k] == j);\r\n            nnz++;\r\n        }\r\n    }\r\n    xassert(v.nnz == nnz);\r\n}\r\n\r\nfunction ios_get_vj(v, j){\r\n    var k;\r\n    xassert(1 <= j && j <= v.n);\r\n    k = v.pos[j];\r\n    xassert(0 <= k && k <= v.nnz);\r\n    return (k == 0 ? 0.0 : v.val[k]);\r\n}\r\n\r\nfunction ios_set_vj(v, j, val){\r\n    xassert(1 <= j && j <= v.n);\r\n    var k = v.pos[j];\r\n    if (val == 0.0)\r\n    {  if (k != 0)\r\n    {  /* remove j-th component */\r\n        v.pos[j] = 0;\r\n        if (k < v.nnz)\r\n        {  v.pos[v.ind[v.nnz]] = k;\r\n            v.ind[k] = v.ind[v.nnz];\r\n            v.val[k] = v.val[v.nnz];\r\n        }\r\n        v.nnz--;\r\n    }\r\n    }\r\n    else\r\n    {  if (k == 0)\r\n    {  /* create j-th component */\r\n        k = ++(v.nnz);\r\n        v.pos[j] = k;\r\n        v.ind[k] = j;\r\n    }\r\n        v.val[k] = val;\r\n    }\r\n}\r\n\r\nfunction ios_clear_vec(v){\r\n    for (var k = 1; k <= v.nnz; k++)\r\n        v.pos[v.ind[k]] = 0;\r\n    v.nnz = 0;\r\n}\r\n\r\nfunction ios_clean_vec(v, eps){\r\n    var nnz = 0;\r\n    for (var k = 1; k <= v.nnz; k++)\r\n    {  if (Math.abs(v.val[k]) == 0.0 || Math.abs(v.val[k]) < eps)\r\n    {  /* remove component */\r\n        v.pos[v.ind[k]] = 0;\r\n    }\r\n    else\r\n    {  /* keep component */\r\n        nnz++;\r\n        v.pos[v.ind[k]] = nnz;\r\n        v.ind[nnz] = v.ind[k];\r\n        v.val[nnz] = v.val[k];\r\n    }\r\n    }\r\n    v.nnz = nnz;\r\n}\r\n\r\nfunction ios_copy_vec(x, y){\r\n    xassert(x != y);\r\n    xassert(x.n == y.n);\r\n    ios_clear_vec(x);\r\n    x.nnz = y.nnz;\r\n    xcopyArr(x.ind, 1, y.ind, 1, x.nnz);\r\n    xcopyArr(x.val, 1, y.val, 1, x.nnz);\r\n    for (var j = 1; j <= x.nnz; j++)\r\n        x.pos[x.ind[j]] = j;\r\n}\r\n\r\nfunction ios_linear_comb(x, a, y){\r\n    var j, xj, yj;\r\n    xassert(x != y);\r\n    xassert(x.n == y.n);\r\n    for (var k = 1; k <= y.nnz; k++)\r\n    {   j = y.ind[k];\r\n        xj = ios_get_vj(x, j);\r\n        yj = y.val[k];\r\n        ios_set_vj(x, j, xj + a * yj);\r\n    }\r\n}\r\n\r\nfunction ios_gmi_gen(tree){\r\n\r\n    var MAXCUTS = 50;\r\n    /* maximal number of cuts to be generated for one round */\r\n\r\n    function f(x) {return x - Math.floor(x)}\r\n    /* compute fractional part of x */\r\n\r\n    function gen_cut(tree, worka, j){\r\n        /* this routine tries to generate Gomory's mixed integer cut for\r\n         specified structural variable x[m+j] of integer kind, which is\r\n         basic and has fractional value in optimal solution to current\r\n         LP relaxation */\r\n        var mip = tree.mip;\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var ind = worka.ind;\r\n        var val = worka.val;\r\n        var phi = worka.phi;\r\n        var i, k, len, kind, stat;\r\n        var lb, ub, alfa, beta, ksi, phi1, rhs;\r\n        var row, col;\r\n        /* compute row of the simplex tableau, which (row) corresponds\r\n         to specified basic variable xB[i] = x[m+j]; see (23) */\r\n        len = glp_eval_tab_row(mip, m+j, ind, val);\r\n        /* determine beta[i], which a value of xB[i] in optimal solution\r\n         to current LP relaxation; note that this value is the same as\r\n         if it would be computed with formula (27); it is assumed that\r\n         beta[i] is fractional enough */\r\n        beta = mip.col[j].prim;\r\n        /* compute cut coefficients phi and right-hand side rho, which\r\n         correspond to formula (30); dense format is used, because rows\r\n         of the simplex tableau is usually dense */\r\n        for (k = 1; k <= m+n; k++) phi[k] = 0.0;\r\n        rhs = f(beta); /* initial value of rho; see (28), (32) */\r\n        for (j = 1; j <= len; j++)\r\n        {  /* determine original number of non-basic variable xN[j] */\r\n            k = ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            /* determine the kind, bounds and current status of xN[j] in\r\n             optimal solution to LP relaxation */\r\n            if (k <= m)\r\n            {  /* auxiliary variable */\r\n                row = mip.row[k];\r\n                kind = GLP_CV;\r\n                lb = row.lb;\r\n                ub = row.ub;\r\n                stat = row.stat;\r\n            }\r\n            else\r\n            {  /* structural variable */\r\n                col = mip.col[k-m];\r\n                kind = col.kind;\r\n                lb = col.lb;\r\n                ub = col.ub;\r\n                stat = col.stat;\r\n            }\r\n            /* xN[j] cannot be basic */\r\n            xassert(stat != GLP_BS);\r\n            /* determine row coefficient ksi[i,j] at xN[j]; see (23) */\r\n            ksi = val[j];\r\n            /* if ksi[i,j] is too large in the magnitude, do not generate\r\n             the cut */\r\n            if (Math.abs(ksi) > 1e+05) return;\r\n            /* if ksi[i,j] is too small in the magnitude, skip it */\r\n            if (Math.abs(ksi) < 1e-10) continue;\r\n            /* compute row coefficient alfa[i,j] at y[j]; see (26) */\r\n            switch (stat)\r\n            {  case GLP_NF:\r\n                /* xN[j] is free (unbounded) having non-zero ksi[i,j];\r\n                 do not generate the cut */\r\n                return;\r\n                case GLP_NL:\r\n                    /* xN[j] has active lower bound */\r\n                    alfa = - ksi;\r\n                    break;\r\n                case GLP_NU:\r\n                    /* xN[j] has active upper bound */\r\n                    alfa = + ksi;\r\n                    break;\r\n                case GLP_NS:\r\n                    /* xN[j] is fixed; skip it */\r\n                    continue;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n            /* compute cut coefficient phi'[j] at y[j]; see (21), (28) */\r\n            switch (kind)\r\n            {  case GLP_IV:\r\n                /* y[j] is integer */\r\n                if (Math.abs(alfa - Math.floor(alfa + 0.5)) < 1e-10)\r\n                {  /* alfa[i,j] is close to nearest integer; skip it */\r\n                    continue;\r\n                }\r\n                else if (f(alfa) <= f(beta))\r\n                    phi1 = f(alfa);\r\n                else\r\n                    phi1 = (f(beta) / (1.0 - f(beta))) * (1.0 - f(alfa));\r\n                break;\r\n                case GLP_CV:\r\n                    /* y[j] is continuous */\r\n                    if (alfa >= 0.0)\r\n                        phi1 = + alfa;\r\n                    else\r\n                        phi1 = (f(beta) / (1.0 - f(beta))) * (- alfa);\r\n                    break;\r\n                default:\r\n                    xassert(kind != kind);\r\n            }\r\n            /* compute cut coefficient phi[j] at xN[j] and update right-\r\n             hand side rho; see (31), (32) */\r\n            switch (stat)\r\n            {  case GLP_NL:\r\n                /* xN[j] has active lower bound */\r\n                phi[k] = + phi1;\r\n                rhs += phi1 * lb;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[j] has active upper bound */\r\n                    phi[k] = - phi1;\r\n                    rhs -= phi1 * ub;\r\n                    break;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n        }\r\n        /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut\r\n         coefficients are stored in the array phi in dense format;\r\n         x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-\r\n         tural variables; see (30) */\r\n        /* eliminate auxiliary variables in order to express the cut only\r\n         through structural variables; see (33) */\r\n        for (i = 1; i <= m; i++)\r\n        {\r\n            var aij;\r\n            if (Math.abs(phi[i]) < 1e-10) continue;\r\n            /* auxiliary variable x[i] has non-zero cut coefficient */\r\n            row = mip.row[i];\r\n            /* x[i] cannot be fixed */\r\n            xassert(row.type != GLP_FX);\r\n            /* substitute x[i] = sum_j a[i,j] * x[m+j] */\r\n            for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                phi[m+aij.col.j] += phi[i] * aij.val;\r\n        }\r\n        /* convert the final cut to sparse format and substitute fixed\r\n         (structural) variables */\r\n        len = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (Math.abs(phi[m+j]) < 1e-10) continue;\r\n            /* structural variable x[m+j] has non-zero cut coefficient */\r\n            col = mip.col[j];\r\n            if (col.type == GLP_FX)\r\n            {  /* eliminate x[m+j] */\r\n                rhs -= phi[m+j] * col.lb;\r\n            }\r\n            else\r\n            {  len++;\r\n                ind[len] = j;\r\n                val[len] = phi[m+j];\r\n            }\r\n        }\r\n        if (Math.abs(rhs) < 1e-12) rhs = 0.0;\r\n        /* if the cut inequality seems to be badly scaled, reject it to\r\n         avoid numeric difficulties */\r\n        for (k = 1; k <= len; k++)\r\n        {  if (Math.abs(val[k]) < 1e-03) return;\r\n            if (Math.abs(val[k]) > 1e+03) return;\r\n        }\r\n        /* add the cut to the cut pool for further consideration */\r\n        glp_ios_add_row(tree, null, GLP_RF_GMI, 0, len, ind, val, GLP_LO, rhs);\r\n    }\r\n\r\n    /* main routine to generate Gomory's cuts */\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var var_;\r\n    var k, nv, j, size;\r\n    var worka = {};\r\n    /* allocate working arrays */\r\n    var_ = new Array(1+n);\r\n    worka.ind = new Int32Array(1+n);\r\n    worka.val = new Float64Array(1+n);\r\n    worka.phi = new Float64Array(1+m+n);\r\n    /* build the list of integer structural variables, which are\r\n     basic and have fractional value in optimal solution to current\r\n     LP relaxation */\r\n    nv = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        var frac;\r\n        if (col.kind != GLP_IV) continue;\r\n        if (col.type == GLP_FX) continue;\r\n        if (col.stat != GLP_BS) continue;\r\n        frac = f(col.prim);\r\n        if (!(0.05 <= frac && frac <= 0.95)) continue;\r\n        /* add variable to the list */\r\n        nv++; var_[nv].j = j; var_[nv].f = frac;\r\n    }\r\n    /* order the list by descending fractionality */\r\n    xqsort(var_, 1, nv,\r\n        function(v1, v2){\r\n            if (v1.f > v2.f) return -1;\r\n            if (v1.f < v2.f) return +1;\r\n            return 0;\r\n        }\r\n    );\r\n    /* try to generate cuts by one for each variable in the list, but\r\n     not more than MAXCUTS cuts */\r\n    size = glp_ios_pool_size(tree);\r\n    for (k = 1; k <= nv; k++)\r\n    {  if (glp_ios_pool_size(tree) - size >= MAXCUTS) break;\r\n        gen_cut(tree, worka, var_[k].j);\r\n    }\r\n}\r\n\r\n\r\nvar _MIR_DEBUG = 0;\r\n\r\nvar MAXAGGR = 5;\r\n/* maximal number of rows which can be aggregated */\r\n\r\nvar\r\n    MIR_N = 0,\r\n    MIR_L = 1,\r\n    MIR_U = 2;\r\n\r\nfunction ios_mir_init(tree){\r\n    function set_row_attrib(tree, mir){\r\n        /* set global row attributes */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var k;\r\n        for (k = 1; k <= m; k++)\r\n        {  var row = mip.row[k];\r\n            mir.skip[k] = 0;\r\n            mir.isint[k] = 0;\r\n            switch (row.type)\r\n            {  case GLP_FR:\r\n                mir.lb[k] = -DBL_MAX; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_LO:\r\n                    mir.lb[k] = row.lb; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_UP:\r\n                    mir.lb[k] = -DBL_MAX; mir.ub[k] = row.ub; break;\r\n                case GLP_DB:\r\n                    mir.lb[k] = row.lb; mir.ub[k] = row.ub; break;\r\n                case GLP_FX:\r\n                    mir.lb[k] = mir.ub[k] = row.lb; break;\r\n                default:\r\n                    xassert(row != row);\r\n            }\r\n            mir.vlb[k] = mir.vub[k] = 0;\r\n        }\r\n    }\r\n\r\n    function set_col_attrib(tree, mir){\r\n        /* set global column attributes */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var k;\r\n        for (k = m+1; k <= m+n; k++)\r\n        {  var col = mip.col[k-m];\r\n            switch (col.kind)\r\n            {  case GLP_CV:\r\n                mir.isint[k] = 0; break;\r\n                case GLP_IV:\r\n                    mir.isint[k] = 1; break;\r\n                default:\r\n                    xassert(col != col);\r\n            }\r\n            switch (col.type)\r\n            {  case GLP_FR:\r\n                mir.lb[k] = -DBL_MAX; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_LO:\r\n                    mir.lb[k] = col.lb; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_UP:\r\n                    mir.lb[k] = -DBL_MAX; mir.ub[k] = col.ub; break;\r\n                case GLP_DB:\r\n                    mir.lb[k] = col.lb; mir.ub[k] = col.ub; break;\r\n                case GLP_FX:\r\n                    mir.lb[k] = mir.ub[k] = col.lb; break;\r\n                default:\r\n                    xassert(col != col);\r\n            }\r\n            mir.vlb[k] = mir.vub[k] = 0;\r\n        }\r\n    }\r\n\r\n    function set_var_bounds(tree, mir){\r\n        /* set variable bounds */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        var i, k1, k2;\r\n        var a1, a2;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* we need the row to be '>= 0' or '<= 0' */\r\n            if (!(mir.lb[i] == 0.0 && mir.ub[i] == +DBL_MAX ||\r\n                mir.lb[i] == -DBL_MAX && mir.ub[i] == 0.0)) continue;\r\n            /* take first term */\r\n            aij = mip.row[i].ptr;\r\n            if (aij == null) continue;\r\n            k1 = m + aij.col.j; a1 = aij.val;\r\n            /* take second term */\r\n            aij = aij.r_next;\r\n            if (aij == null) continue;\r\n            k2 = m + aij.col.j; a2 = aij.val;\r\n            /* there must be only two terms */\r\n            if (aij.r_next != null) continue;\r\n            /* interchange terms, if needed */\r\n            if (!mir.isint[k1] && mir.isint[k2]){\r\n\r\n            }\r\n            else if (mir.isint[k1] && !mir.isint[k2])\r\n            {  k2 = k1; a2 = a1;\r\n                k1 = m + aij.col.j; a1 = aij.val;\r\n            }\r\n            else\r\n            {  /* both terms are either continuous or integer */\r\n                continue;\r\n            }\r\n            /* x[k2] should be double-bounded */\r\n            if (mir.lb[k2] == -DBL_MAX || mir.ub[k2] == +DBL_MAX ||\r\n                mir.lb[k2] == mir.ub[k2]) continue;\r\n            /* change signs, if necessary */\r\n            if (mir.ub[i] == 0.0){a1 = - a1; a2 = - a2}\r\n            /* now the row has the form a1 * x1 + a2 * x2 >= 0, where x1\r\n             is continuous, x2 is integer */\r\n            if (a1 > 0.0)\r\n            {  /* x1 >= - (a2 / a1) * x2 */\r\n                if (mir.vlb[k1] == 0)\r\n                {  /* set variable lower bound for x1 */\r\n                    mir.lb[k1] = - a2 / a1;\r\n                    mir.vlb[k1] = k2;\r\n                    /* the row should not be used */\r\n                    mir.skip[i] = 1;\r\n                }\r\n            }\r\n            else /* a1 < 0.0 */\r\n            {  /* x1 <= - (a2 / a1) * x2 */\r\n                if (mir.vub[k1] == 0)\r\n                {  /* set variable upper bound for x1 */\r\n                    mir.ub[k1] = - a2 / a1;\r\n                    mir.vub[k1] = k2;\r\n                    /* the row should not be used */\r\n                    mir.skip[i] = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function mark_useless_rows(tree, mir){\r\n        /* mark rows which should not be used */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        var i, k, nv;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* free rows should not be used */\r\n            if (mir.lb[i] == -DBL_MAX && mir.ub[i] == +DBL_MAX)\r\n            {  mir.skip[i] = 1;\r\n                continue;\r\n            }\r\n            nv = 0;\r\n            for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next)\r\n            {  k = m + aij.col.j;\r\n                /* rows with free variables should not be used */\r\n                if (mir.lb[k] == -DBL_MAX && mir.ub[k] == +DBL_MAX)\r\n                {  mir.skip[i] = 1;\r\n                    break;\r\n                }\r\n                /* rows with integer variables having infinite (lower or\r\n                 upper) bound should not be used */\r\n                if (mir.isint[k] && mir.lb[k] == -DBL_MAX ||\r\n                    mir.isint[k] && mir.ub[k] == +DBL_MAX)\r\n                {  mir.skip[i] = 1;\r\n                    break;\r\n                }\r\n                /* count non-fixed variables */\r\n                if (!(mir.vlb[k] == 0 && mir.vub[k] == 0 &&\r\n                    mir.lb[k] == mir.ub[k])) nv++;\r\n            }\r\n            /* rows with all variables fixed should not be used */\r\n            if (nv == 0)\r\n            {  mir.skip[i] = 1;\r\n                //continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* initialize MIR cut generator */\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var mir;\r\n    if (_MIR_DEBUG){\r\n        xprintf(\"ios_mir_init: warning: debug mode enabled\");\r\n    }\r\n    /* allocate working area */\r\n    mir = {};\r\n    mir.m = m;\r\n    mir.n = n;\r\n    mir.skip = new Int8Array(1+m);\r\n    mir.isint = new Int8Array(1+m+n);\r\n    mir.lb = new Float64Array(1+m+n);\r\n    mir.vlb = new Int32Array(1+m+n);\r\n    mir.ub = new Float64Array(1+m+n);\r\n    mir.vub = new Int32Array(1+m+n);\r\n    mir.x = new Float64Array(1+m+n);\r\n    mir.agg_row = new Int32Array(1+MAXAGGR);\r\n    mir.agg_vec = ios_create_vec(m+n);\r\n    mir.subst = new Int8Array(1+m+n);\r\n    mir.mod_vec = ios_create_vec(m+n);\r\n    mir.cut_vec = ios_create_vec(m+n);\r\n    /* set global row attributes */\r\n    set_row_attrib(tree, mir);\r\n    /* set global column attributes */\r\n    set_col_attrib(tree, mir);\r\n    /* set variable bounds */\r\n    set_var_bounds(tree, mir);\r\n    /* mark rows which should not be used */\r\n    mark_useless_rows(tree, mir);\r\n    return mir;\r\n}\r\n\r\nfunction ios_mir_gen(tree, mir){\r\n\r\n    var beta, gamma;\r\n\r\n    function cmir_sep(n, a, b, u, x, s, alpha){\r\n\r\n        function cmir_cmp(v1, v2){\r\n            if (v1.v < v2.v) return -1;\r\n            if (v1.v > v2.v) return +1;\r\n            return 0;\r\n        }\r\n\r\n        function cmir_ineq(n, a, b, u, cset, delta, alpha){\r\n\r\n            function mir_ineq(n, a, b, alpha){\r\n                var j;\r\n                var f, t;\r\n                if (Math.abs(b - Math.floor(b + .5)) < 0.01)\r\n                    return 1;\r\n                f = b - Math.floor(b);\r\n                for (j = 1; j <= n; j++)\r\n                {  t = (a[j] - Math.floor(a[j])) - f;\r\n                    if (t <= 0.0)\r\n                        alpha[j] = Math.floor(a[j]);\r\n                    else\r\n                        alpha[j] = Math.floor(a[j]) + t / (1.0 - f);\r\n                }\r\n                beta = Math.floor(b);\r\n                gamma = 1.0 / (1.0 - f);\r\n                return 0;\r\n            }\r\n\r\n\r\n            var j;\r\n            var aa, bb;\r\n\r\n            aa = alpha; bb = b;\r\n            for (j = 1; j <= n; j++)\r\n            {  aa[j] = a[j] / delta;\r\n                if (cset[j])\r\n                    aa[j] = - aa[j]; bb -= a[j] * u[j];\r\n            }\r\n            bb /= delta;\r\n            if (mir_ineq(n, aa, bb, alpha)) return 1;\r\n            for (j = 1; j <= n; j++)\r\n            {  if (cset[j]){\r\n                alpha[j] = - alpha[j];\r\n                beta += alpha[j] * u[j];\r\n            }\r\n\r\n            }\r\n            gamma /= delta;\r\n            return 0;\r\n        }\r\n\r\n        var fail, j, k, nv, v;\r\n        var delta, eps, d_try = new Array(1+3), r, r_best;\r\n        var cset;\r\n        var vset;\r\n\r\n        /* allocate working arrays */\r\n        cset = new Int8Array(1+n);\r\n        vset = new Array(1+n);\r\n        /* choose initial C */\r\n        for (j = 1; j <= n; j++)\r\n            cset[j] = (x[j] >= 0.5 * u[j]);\r\n        /* choose initial delta */\r\n        r_best = delta = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  xassert(a[j] != 0.0);\r\n            /* if x[j] is close to its bounds, skip it */\r\n            eps = 1e-9 * (1.0 + Math.abs(u[j]));\r\n            if (x[j] < eps || x[j] > u[j] - eps) continue;\r\n            /* try delta = |a[j]| to construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, Math.abs(a[j]), alpha);\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; delta = Math.abs(a[j])}\r\n        }\r\n        if (r_best < 0.001) r_best = 0.0;\r\n        if (r_best == 0.0) return r_best;\r\n        xassert(delta > 0.0);\r\n        /* try to increase violation by dividing delta by 2, 4, and 8,\r\n         respectively */\r\n        d_try[1] = delta / 2.0;\r\n        d_try[2] = delta / 4.0;\r\n        d_try[3] = delta / 8.0;\r\n        for (j = 1; j <= 3; j++)\r\n        {  /* construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha);\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; delta = d_try[j]}\r\n        }\r\n        /* build subset of variables lying strictly between their bounds\r\n         and order it by nondecreasing values of |x[j] - u[j]/2| */\r\n        nv = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  /* if x[j] is close to its bounds, skip it */\r\n            eps = 1e-9 * (1.0 + Math.abs(u[j]));\r\n            if (x[j] < eps || x[j] > u[j] - eps) continue;\r\n            /* add x[j] to the subset */\r\n            nv++;\r\n            vset[nv].j = j;\r\n            vset[nv].v = Math.abs(x[j] - 0.5 * u[j]);\r\n        }\r\n        xqsort(vset, 1, nv, cmir_cmp);\r\n        /* try to increase violation by successively complementing each\r\n         variable in the subset */\r\n        for (v = 1; v <= nv; v++)\r\n        {  j = vset[v].j;\r\n            /* replace x[j] by its complement or vice versa */\r\n            cset[j] = !cset[j];\r\n            /* construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, delta, alpha);\r\n            /* restore the variable */\r\n            cset[j] = !cset[j];\r\n            /* do not replace the variable in case of failure */\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; cset[j] = !cset[j]}\r\n        }\r\n        /* construct the best c-MIR inequality chosen */\r\n        fail = cmir_ineq(n, a, b, u, cset, delta, alpha);\r\n        xassert(!fail);\r\n        /* return to the calling routine */\r\n        return r_best;\r\n    }\r\n\r\n    function get_current_point(tree, mir){\r\n        /* obtain current point */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var k;\r\n        for (k = 1; k <= m; k++)\r\n            mir.x[k] = mip.row[k].prim;\r\n        for (k = m+1; k <= m+n; k++)\r\n            mir.x[k] = mip.col[k-m].prim;\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_current_point(mir){\r\n            /* check current point */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var k, kk;\r\n            var lb, ub, eps;\r\n            for (k = 1; k <= m+n; k++)\r\n            {  /* determine lower bound */\r\n                lb = mir.lb[k];\r\n                kk = mir.vlb[k];\r\n                if (kk != 0)\r\n                {  xassert(lb != -DBL_MAX);\r\n                    xassert(!mir.isint[k]);\r\n                    xassert(mir.isint[kk]);\r\n                    lb *= mir.x[kk];\r\n                }\r\n                /* check lower bound */\r\n                if (lb != -DBL_MAX)\r\n                {  eps = 1e-6 * (1.0 + Math.abs(lb));\r\n                    xassert(mir.x[k] >= lb - eps);\r\n                }\r\n                /* determine upper bound */\r\n                ub = mir.ub[k];\r\n                kk = mir.vub[k];\r\n                if (kk != 0)\r\n                {  xassert(ub != +DBL_MAX);\r\n                    xassert(!mir.isint[k]);\r\n                    xassert(mir.isint[kk]);\r\n                    ub *= mir.x[kk];\r\n                }\r\n                /* check upper bound */\r\n                if (ub != +DBL_MAX)\r\n                {  eps = 1e-6 * (1.0 + Math.abs(ub));\r\n                    xassert(mir.x[k] <= ub + eps);\r\n                }\r\n            }\r\n        }\r\n    //}\r\n\r\n    function initial_agg_row(tree, mir, i){\r\n        /* use original i-th row as initial aggregated constraint */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        xassert(1 <= i && i <= m);\r\n        xassert(!mir.skip[i]);\r\n        /* mark i-th row in order not to use it in the same aggregated\r\n         constraint */\r\n        mir.skip[i] = 2;\r\n        mir.agg_cnt = 1;\r\n        mir.agg_row[1] = i;\r\n        /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary\r\n         variable of row i, x[m+j] are structural variables */\r\n        ios_clear_vec(mir.agg_vec);\r\n        ios_set_vj(mir.agg_vec, i, 1.0);\r\n        for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next)\r\n            ios_set_vj(mir.agg_vec, m + aij.col.j, - aij.val);\r\n        mir.agg_rhs = 0.0;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_agg_row(mir)\r\n        {     /* check aggregated constraint */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k;\r\n            var r, big;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n            {  k = mir.agg_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                r += mir.agg_vec.val[j] * mir.x[k];\r\n                if (big < Math.abs(mir.agg_vec.val[j]))\r\n                    big = Math.abs(mir.agg_vec.val[j]);\r\n            }\r\n            r -= mir.agg_rhs;\r\n            if (big < Math.abs(mir.agg_rhs))\r\n                big = Math.abs(mir.agg_rhs);\r\n            /* the residual must be close to zero */\r\n            xassert(Math.abs(r) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function subst_fixed_vars(mir){\r\n        /* substitute fixed variables into aggregated constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k;\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.vlb[k] == 0 && mir.vub[k] == 0 &&\r\n                mir.lb[k] == mir.ub[k])\r\n            {  /* x[k] is fixed */\r\n                mir.agg_rhs -= mir.agg_vec.val[j] * mir.lb[k];\r\n                mir.agg_vec.val[j] = 0.0;\r\n            }\r\n        }\r\n        /* remove terms corresponding to fixed variables */\r\n        ios_clean_vec(mir.agg_vec, DBL_EPSILON);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n    }\r\n\r\n    function bound_subst_heur(mir){\r\n        /* bound substitution heuristic */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, kk;\r\n        var d1, d2;\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer variable */\r\n            /* compute distance from x[k] to its lower bound */\r\n            kk = mir.vlb[k];\r\n            if (kk == 0)\r\n            {  if (mir.lb[k] == -DBL_MAX)\r\n                d1 = DBL_MAX;\r\n            else\r\n                d1 = mir.x[k] - mir.lb[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                d1 = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            /* compute distance from x[k] to its upper bound */\r\n            kk = mir.vub[k];\r\n            if (kk == 0)\r\n            {  if (mir.vub[k] == +DBL_MAX)\r\n                d2 = DBL_MAX;\r\n            else\r\n                d2 = mir.ub[k] - mir.x[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                d2 = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            /* x[k] cannot be free */\r\n            xassert(d1 != DBL_MAX || d2 != DBL_MAX);\r\n            /* choose the bound which is closer to x[k] */\r\n            xassert(mir.subst[k] == MIR_N);\r\n            if (d1 <= d2)\r\n                mir.subst[k] = MIR_L;\r\n            else\r\n                mir.subst[k] = MIR_U;\r\n        }\r\n    }\r\n\r\n    function build_mod_row(mir){\r\n        /* substitute bounds and build modified constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, jj, k, kk;\r\n        /* initially modified constraint is aggregated constraint */\r\n        ios_copy_vec(mir.mod_vec, mir.agg_vec);\r\n        mir.mod_rhs = mir.agg_rhs;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n        /* substitute bounds for continuous variables; note that due to\r\n         substitution of variable bounds additional terms may appear in\r\n         modified constraint */\r\n        for (j = mir.mod_vec.nnz; j >= 1; j--)\r\n        {  k = mir.mod_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer variable */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x[k] = (lower bound) + x'[k] */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                {  /* x[k] = lb[k] + x'[k] */\r\n                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];\r\n                }\r\n                else\r\n                {  /* x[k] = lb[k] * x[kk] + x'[k] */\r\n                    xassert(mir.isint[kk]);\r\n                    jj = mir.mod_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.mod_vec, kk, 1.0);\r\n                        jj = mir.mod_vec.pos[kk];\r\n                        mir.mod_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.mod_vec.val[jj] +=\r\n                        mir.mod_vec.val[j] * mir.lb[k];\r\n                }\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x[k] = (upper bound) - x'[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                {  /* x[k] = ub[k] - x'[k] */\r\n                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];\r\n                }\r\n                else\r\n                {  /* x[k] = ub[k] * x[kk] - x'[k] */\r\n                    xassert(mir.isint[kk]);\r\n                    jj = mir.mod_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.mod_vec, kk, 1.0);\r\n                        jj = mir.mod_vec.pos[kk];\r\n                        mir.mod_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.mod_vec.val[jj] +=\r\n                        mir.mod_vec.val[j] * mir.ub[k];\r\n                }\r\n                mir.mod_vec.val[j] = - mir.mod_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n        /* substitute bounds for integer variables */\r\n        for (j = 1; j <= mir.mod_vec.nnz; j++)\r\n        {  k = mir.mod_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k]) continue; /* skip continuous variable */\r\n            xassert(mir.subst[k] == MIR_N);\r\n            xassert(mir.vlb[k] == 0 && mir.vub[k] == 0);\r\n            xassert(mir.lb[k] != -DBL_MAX && mir.ub[k] != +DBL_MAX);\r\n            if (Math.abs(mir.lb[k]) <= Math.abs(mir.ub[k]))\r\n            {  /* x[k] = lb[k] + x'[k] */\r\n                mir.subst[k] = MIR_L;\r\n                mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];\r\n            }\r\n            else\r\n            {  /* x[k] = ub[k] - x'[k] */\r\n                mir.subst[k] = MIR_U;\r\n                mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];\r\n                mir.mod_vec.val[j] = - mir.mod_vec.val[j];\r\n            }\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_mod_row(mir){\r\n            /* check modified constraint */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k, kk;\r\n            var r, big, x;\r\n            /* compute the residual r = sum a'[k] * x'[k] - b' and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.mod_vec.nnz; j++)\r\n            {  k = mir.mod_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                if (mir.subst[k] == MIR_L)\r\n                {  /* x'[k] = x[k] - (lower bound) */\r\n                    xassert(mir.lb[k] != -DBL_MAX);\r\n                    kk = mir.vlb[k];\r\n                    if (kk == 0)\r\n                        x = mir.x[k] - mir.lb[k];\r\n                    else\r\n                        x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n                }\r\n                else if (mir.subst[k] == MIR_U)\r\n                {  /* x'[k] = (upper bound) - x[k] */\r\n                    xassert(mir.ub[k] != +DBL_MAX);\r\n                    kk = mir.vub[k];\r\n                    if (kk == 0)\r\n                        x = mir.ub[k] - mir.x[k];\r\n                    else\r\n                        x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n                }\r\n                else\r\n                    xassert(k != k);\r\n                r += mir.mod_vec.val[j] * x;\r\n                if (big < Math.abs(mir.mod_vec.val[j]))\r\n                    big = Math.abs(mir.mod_vec.val[j]);\r\n            }\r\n            r -= mir.mod_rhs;\r\n            if (big < Math.abs(mir.mod_rhs))\r\n                big = Math.abs(mir.mod_rhs);\r\n            /* the residual must be close to zero */\r\n            xassert(Math.abs(r) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function generate(mir){\r\n        /* try to generate violated c-MIR cut for modified constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, kk, nint;\r\n        var s, u, x, alpha, r_best = 0.0, b, beta = null, gamma = null;\r\n        ios_copy_vec(mir.cut_vec, mir.mod_vec);\r\n        mir.cut_rhs = mir.mod_rhs;\r\n        /* remove small terms, which can appear due to substitution of\r\n         variable bounds */\r\n        ios_clean_vec(mir.cut_vec, DBL_EPSILON);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* remove positive continuous terms to obtain MK relaxation */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k] && mir.cut_vec.val[j] > 0.0)\r\n                mir.cut_vec.val[j] = 0.0;\r\n        }\r\n        ios_clean_vec(mir.cut_vec, 0.0);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* move integer terms to the beginning of the sparse vector and\r\n         determine the number of integer variables */\r\n        nint = 0;\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k])\r\n            {  var temp;\r\n                nint++;\r\n                /* interchange elements [nint] and [j] */\r\n                kk = mir.cut_vec.ind[nint];\r\n                mir.cut_vec.pos[k] = nint;\r\n                mir.cut_vec.pos[kk] = j;\r\n                mir.cut_vec.ind[nint] = k;\r\n                mir.cut_vec.ind[j] = kk;\r\n                temp = mir.cut_vec.val[nint];\r\n                mir.cut_vec.val[nint] = mir.cut_vec.val[j];\r\n                mir.cut_vec.val[j] = temp;\r\n            }\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* if there is no integer variable, nothing to generate */\r\n        if (nint == 0) return r_best;\r\n        /* allocate working arrays */\r\n        u = new Float64Array(1+nint);\r\n        x = new Float64Array(1+nint);\r\n        alpha = new Float64Array(1+nint);\r\n        /* determine u and x */\r\n        for (j = 1; j <= nint; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(m+1 <= k && k <= m+n);\r\n            xassert(mir.isint[k]);\r\n            u[j] = mir.ub[k] - mir.lb[k];\r\n            xassert(u[j] >= 1.0);\r\n            if (mir.subst[k] == MIR_L)\r\n                x[j] = mir.x[k] - mir.lb[k];\r\n            else if (mir.subst[k] == MIR_U)\r\n                x[j] = mir.ub[k] - mir.x[k];\r\n            else\r\n                xassert(k != k);\r\n            xassert(x[j] >= -0.001);\r\n            if (x[j] < 0.0) x[j] = 0.0;\r\n        }\r\n        /* compute s = - sum of continuous terms */\r\n        s = 0.0;\r\n        for (j = nint+1; j <= mir.cut_vec.nnz; j++)\r\n        {\r\n            k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            /* must be continuous */\r\n            xassert(!mir.isint[k]);\r\n            if (mir.subst[k] == MIR_L)\r\n            {  xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                    x = mir.x[k] - mir.lb[k];\r\n                else\r\n                    x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                    x = mir.ub[k] - mir.x[k];\r\n                else\r\n                    x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n            xassert(x >= -0.001);\r\n            if (x < 0.0) x = 0.0;\r\n            s -= mir.cut_vec.val[j] * x;\r\n        }\r\n        xassert(s >= 0.0);\r\n        /* apply heuristic to obtain most violated c-MIR inequality */\r\n        b = mir.cut_rhs;\r\n        r_best = cmir_sep(nint, mir.cut_vec.val, b, u, x, s, alpha);\r\n        if (r_best == 0.0) return r_best;\r\n        xassert(r_best > 0.0);\r\n        /* convert to raw cut */\r\n        /* sum alpha[j] * x[j] <= beta + gamma * s */\r\n        for (j = 1; j <= nint; j++)\r\n            mir.cut_vec.val[j] = alpha[j];\r\n        for (j = nint+1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            if (k <= m+n) mir.cut_vec.val[j] *= gamma;\r\n        }\r\n        mir.cut_rhs = beta;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        return r_best;\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_raw_cut(mir, r_best){\r\n            /* check raw cut before back bound substitution */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k, kk;\r\n            var r, big, x;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n            {  k = mir.cut_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                if (mir.subst[k] == MIR_L)\r\n                {  xassert(mir.lb[k] != -DBL_MAX);\r\n                    kk = mir.vlb[k];\r\n                    if (kk == 0)\r\n                        x = mir.x[k] - mir.lb[k];\r\n                    else\r\n                        x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n                }\r\n                else if (mir.subst[k] == MIR_U)\r\n                {  xassert(mir.ub[k] != +DBL_MAX);\r\n                    kk = mir.vub[k];\r\n                    if (kk == 0)\r\n                        x = mir.ub[k] - mir.x[k];\r\n                    else\r\n                        x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n                }\r\n                else\r\n                    xassert(k != k);\r\n                r += mir.cut_vec.val[j] * x;\r\n                if (big < Math.abs(mir.cut_vec.val[j]))\r\n                    big = Math.abs(mir.cut_vec.val[j]);\r\n            }\r\n            r -= mir.cut_rhs;\r\n            if (big < Math.abs(mir.cut_rhs))\r\n                big = Math.abs(mir.cut_rhs);\r\n            /* the residual must be close to r_best */\r\n            xassert(Math.abs(r - r_best) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function back_subst(mir){\r\n        /* back substitution of original bounds */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, jj, k, kk;\r\n        /* at first, restore bounds of integer variables (because on\r\n         restoring variable bounds of continuous variables we need\r\n         original, not shifted, bounds of integer variables) */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k]) continue; /* skip continuous */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x'[k] = x[k] - lb[k] */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                xassert(mir.vlb[k] == 0);\r\n                mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x'[k] = ub[k] - x[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                xassert(mir.vub[k] == 0);\r\n                mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];\r\n                mir.cut_vec.val[j] = - mir.cut_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        /* now restore bounds of continuous variables */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x'[k] = x[k] - (lower bound) */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                {  /* x'[k] = x[k] - lb[k] */\r\n                    mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];\r\n                }\r\n                else\r\n                {  /* x'[k] = x[k] - lb[k] * x[kk] */\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                        jj = mir.cut_vec.pos[kk];\r\n                        xassert(jj != 0);\r\n                        mir.cut_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.cut_vec.val[jj] -= mir.cut_vec.val[j] *\r\n                        mir.lb[k];\r\n                }\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x'[k] = (upper bound) - x[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                {  /* x'[k] = ub[k] - x[k] */\r\n                    mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];\r\n                }\r\n                else\r\n                {  /* x'[k] = ub[k] * x[kk] - x[k] */\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                        jj = mir.cut_vec.pos[kk];\r\n                        xassert(jj != 0);\r\n                        mir.cut_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.cut_vec.val[jj] += mir.cut_vec.val[j] *\r\n                        mir.ub[k];\r\n                }\r\n                mir.cut_vec.val[j] = - mir.cut_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_cut_row(mir, r_best){\r\n            /* check the cut after back bound substitution or elimination of\r\n             auxiliary variables */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k;\r\n            var r, big;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n            {  k = mir.cut_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                r += mir.cut_vec.val[j] * mir.x[k];\r\n                if (big < Math.abs(mir.cut_vec.val[j]))\r\n                    big = Math.abs(mir.cut_vec.val[j]);\r\n            }\r\n            r -= mir.cut_rhs;\r\n            if (big < Math.abs(mir.cut_rhs))\r\n                big = Math.abs(mir.cut_rhs);\r\n            /* the residual must be close to r_best */\r\n            xassert(Math.abs(r - r_best) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function subst_aux_vars(tree, mir){\r\n        /* final substitution to eliminate auxiliary variables */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var aij;\r\n        var j, k, kk, jj;\r\n        for (j = mir.cut_vec.nnz; j >= 1; j--)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (k > m) continue; /* skip structurals */\r\n            for (aij = mip.row[k].ptr; aij != null; aij = aij.r_next)\r\n            {  kk = m + aij.col.j; /* structural */\r\n                jj = mir.cut_vec.pos[kk];\r\n                if (jj == 0)\r\n                {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    mir.cut_vec.val[jj] = 0.0;\r\n                }\r\n                mir.cut_vec.val[jj] += mir.cut_vec.val[j] * aij.val;\r\n            }\r\n            mir.cut_vec.val[j] = 0.0;\r\n        }\r\n        ios_clean_vec(mir.cut_vec, 0.0);\r\n    }\r\n\r\n    function add_cut(tree, mir){\r\n        /* add constructed cut inequality to the cut pool */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, len;\r\n        var ind = new Int32Array(1+n);\r\n        var val = new Float64Array(1+n);\r\n        len = 0;\r\n        for (j = mir.cut_vec.nnz; j >= 1; j--)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(m+1 <= k && k <= m+n);\r\n            len++; ind[len] = k - m; val[len] = mir.cut_vec.val[j];\r\n        }\r\n        glp_ios_add_row(tree, null, GLP_RF_MIR, 0, len, ind, val, GLP_UP,\r\n            mir.cut_rhs);\r\n    }\r\n\r\n    function aggregate_row(tree, mir){\r\n        /* try to aggregate another row */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var aij;\r\n        var v;\r\n        var ii, j, jj, k, kk, kappa = 0, ret = 0;\r\n        var d1, d2, d, d_max = 0.0;\r\n        /* choose appropriate structural variable in the aggregated row\r\n         to be substituted */\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (k <= m) continue; /* skip auxiliary var */\r\n            if (mir.isint[k]) continue; /* skip integer var */\r\n            if (Math.abs(mir.agg_vec.val[j]) < 0.001) continue;\r\n            /* compute distance from x[k] to its lower bound */\r\n            kk = mir.vlb[k];\r\n            if (kk == 0)\r\n            {  if (mir.lb[k] == -DBL_MAX)\r\n                d1 = DBL_MAX;\r\n            else\r\n                d1 = mir.x[k] - mir.lb[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                d1 = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            /* compute distance from x[k] to its upper bound */\r\n            kk = mir.vub[k];\r\n            if (kk == 0)\r\n            {  if (mir.vub[k] == +DBL_MAX)\r\n                d2 = DBL_MAX;\r\n            else\r\n                d2 = mir.ub[k] - mir.x[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                d2 = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            /* x[k] cannot be free */\r\n            xassert(d1 != DBL_MAX || d2 != DBL_MAX);\r\n            /* d = min(d1, d2) */\r\n            d = (d1 <= d2 ? d1 : d2);\r\n            xassert(d != DBL_MAX);\r\n            /* should not be close to corresponding bound */\r\n            if (d < 0.001) continue;\r\n            if (d_max < d) {d_max = d; kappa = k}\r\n        }\r\n        if (kappa == 0)\r\n        {  /* nothing chosen */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* x[kappa] has been chosen */\r\n        xassert(m+1 <= kappa && kappa <= m+n);\r\n        xassert(!mir.isint[kappa]);\r\n        /* find another row, which have not been used yet, to eliminate\r\n         x[kappa] from the aggregated row */\r\n        for (ii = 1; ii <= m; ii++)\r\n        {  if (mir.skip[ii]) continue;\r\n            for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)\r\n                if (aij.col.j == kappa - m) break;\r\n            if (aij != null && Math.abs(aij.val) >= 0.001) break;\r\n        }\r\n        if (ii > m)\r\n        {  /* nothing found */\r\n            ret = 2;\r\n            return ret;\r\n        }\r\n        /* row ii has been found; include it in the aggregated list */\r\n        mir.agg_cnt++;\r\n        xassert(mir.agg_cnt <= MAXAGGR);\r\n        mir.agg_row[mir.agg_cnt] = ii;\r\n        mir.skip[ii] = 2;\r\n        /* v := new row */\r\n        v = ios_create_vec(m+n);\r\n        ios_set_vj(v, ii, 1.0);\r\n        for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)\r\n            ios_set_vj(v, m + aij.col.j, - aij.val);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(v);\r\n        }\r\n        /* perform gaussian elimination to remove x[kappa] */\r\n        j = mir.agg_vec.pos[kappa];\r\n        xassert(j != 0);\r\n        jj = v.pos[kappa];\r\n        xassert(jj != 0);\r\n        ios_linear_comb(mir.agg_vec, - mir.agg_vec.val[j] / v.val[jj], v);\r\n        ios_set_vj(mir.agg_vec, kappa, 0.0);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /* main routine to generate MIR cuts */\r\n    var mip = tree.mip;\r\n    var m = mir.m;\r\n    var n = mir.n;\r\n    var i, k;\r\n    var r_best;\r\n    xassert(mip.m >= m);\r\n    xassert(mip.n == n);\r\n    /* obtain current point */\r\n    get_current_point(tree, mir);\r\n    if (_MIR_DEBUG){\r\n        /* check current point */\r\n        check_current_point(mir);\r\n    }\r\n    /* reset bound substitution flags */\r\n    xfillArr(mir.subst, 1, MIR_N, m+n);\r\n    /* try to generate a set of violated MIR cuts */\r\n    for (i = 1; i <= m; i++)\r\n    {  if (mir.skip[i]) continue;\r\n        /* use original i-th row as initial aggregated constraint */\r\n        initial_agg_row(tree, mir, i);\r\n        while (true){\r\n            if (_MIR_DEBUG){\r\n                /* check aggregated row */\r\n                check_agg_row(mir);\r\n            }\r\n            /* substitute fixed variables into aggregated constraint */\r\n            subst_fixed_vars(mir);\r\n            if (_MIR_DEBUG){\r\n                /* check aggregated row */\r\n                check_agg_row(mir);\r\n                /* check bound substitution flags */\r\n                {\r\n                    for (k = 1; k <= m+n; k++)\r\n                        xassert(mir.subst[k] == MIR_N);\r\n                }\r\n            }\r\n            /* apply bound substitution heuristic */\r\n            bound_subst_heur(mir);\r\n            /* substitute bounds and build modified constraint */\r\n            build_mod_row(mir);\r\n            if (_MIR_DEBUG){\r\n                /* check modified row */\r\n                check_mod_row(mir);\r\n            }\r\n            /* try to generate violated c-MIR cut for modified row */\r\n            r_best = generate(mir);\r\n            if (r_best > 0.0){\r\n                /* success */\r\n                if (_MIR_DEBUG){\r\n                    /* check raw cut before back bound substitution */\r\n                    check_raw_cut(mir, r_best);\r\n                }\r\n                /* back substitution of original bounds */\r\n                back_subst(mir);\r\n                if (_MIR_DEBUG){\r\n                    /* check the cut after back bound substitution */\r\n                    check_cut_row(mir, r_best);\r\n                }\r\n                /* final substitution to eliminate auxiliary variables */\r\n                subst_aux_vars(tree, mir);\r\n                if (_MIR_DEBUG){\r\n                    /* check the cut after elimination of auxiliaries */\r\n                    check_cut_row(mir, r_best);\r\n                }\r\n                /* add constructed cut inequality to the cut pool */\r\n                add_cut(tree, mir);\r\n            }\r\n            /* reset bound substitution flags */\r\n            {\r\n                for (var j = 1; j <= mir.mod_vec.nnz; j++)\r\n                {  k = mir.mod_vec.ind[j];\r\n                    xassert(1 <= k && k <= m+n);\r\n                    xassert(mir.subst[k] != MIR_N);\r\n                    mir.subst[k] = MIR_N;\r\n                }\r\n            }\r\n            if (r_best == 0.0)\r\n            {  /* failure */\r\n                if (mir.agg_cnt < MAXAGGR)\r\n                {  /* try to aggregate another row */\r\n                    if (aggregate_row(tree, mir) == 0) continue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        /* unmark rows used in the aggregated constraint */\r\n        {  var ii;\r\n            for (k = 1; k <= mir.agg_cnt; k++)\r\n            {  ii = mir.agg_row[k];\r\n                xassert(1 <= ii && ii <= m);\r\n                xassert(mir.skip[ii] == 2);\r\n                mir.skip[ii] = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction lpx_cover_cut(lp, len, ind, val, x){\r\n    var alfa = null, beta = null;\r\n\r\n    var MAXTRY = 1000;\r\n\r\n    function cover2(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut using two-element cover */\r\n        var i, j, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n            {  /* C = {i, j} */\r\n                try_++;\r\n                if (try_ > MAXTRY) return ret;\r\n                /* check if condition (8) is satisfied */\r\n                if (a[i] + a[j] + y > b + eps)\r\n                {  /* compute parameters for inequality (15) */\r\n                    temp = a[i] + a[j] - b;\r\n                    alfa = 1.0 / (temp + u);\r\n                    beta = 2.0 - alfa * temp;\r\n                    /* compute violation of inequality (15) */\r\n                    temp = x[i] + x[j] + alfa * y - beta;\r\n                    /* choose C providing maximum violation */\r\n                    if (rmax < temp)\r\n                    {  rmax = temp;\r\n                        cov[1] = i;\r\n                        cov[2] = j;\r\n                        ret = 1;\r\n                    }\r\n                }\r\n            }\r\n        return ret;\r\n    }\r\n\r\n    function cover3(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut using three-element cover */\r\n        var i, j, k, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n                for (k = j+1; k <= n; k++)\r\n                {  /* C = {i, j, k} */\r\n                    try_++;\r\n                    if (try_ > MAXTRY) return ret;\r\n                    /* check if condition (8) is satisfied */\r\n                    if (a[i] + a[j] + a[k] + y > b + eps)\r\n                    {  /* compute parameters for inequality (15) */\r\n                        temp = a[i] + a[j] + a[k] - b;\r\n                        alfa = 1.0 / (temp + u);\r\n                        beta = 3.0 - alfa * temp;\r\n                        /* compute violation of inequality (15) */\r\n                        temp = x[i] + x[j] + x[k] + alfa * y - beta;\r\n                        /* choose C providing maximum violation */\r\n                        if (rmax < temp)\r\n                        {  rmax = temp;\r\n                            cov[1] = i;\r\n                            cov[2] = j;\r\n                            cov[3] = k;\r\n                            ret = 1;\r\n                        }\r\n                    }\r\n                }\r\n        return ret;\r\n    }\r\n\r\n    function cover4(n, a, b, u, x, y, cov){\r\n        /* try_ to generate mixed cover cut using four-element cover */\r\n        var i, j, k, l, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n                for (k = j+1; k <= n; k++)\r\n                    for (l = k+1; l <= n; l++)\r\n                    {  /* C = {i, j, k, l} */\r\n                        try_++;\r\n                        if (try_ > MAXTRY) return ret;\r\n                        /* check if condition (8) is satisfied */\r\n                        if (a[i] + a[j] + a[k] + a[l] + y > b + eps)\r\n                        {  /* compute parameters for inequality (15) */\r\n                            temp = a[i] + a[j] + a[k] + a[l] - b;\r\n                            alfa = 1.0 / (temp + u);\r\n                            beta = 4.0 - alfa * temp;\r\n                            /* compute violation of inequality (15) */\r\n                            temp = x[i] + x[j] + x[k] + x[l] + alfa * y - beta;\r\n                            /* choose C providing maximum violation */\r\n                            if (rmax < temp)\r\n                            {  rmax = temp;\r\n                                cov[1] = i;\r\n                                cov[2] = j;\r\n                                cov[3] = k;\r\n                                cov[4] = l;\r\n                                ret = 1;\r\n                            }\r\n                        }\r\n                    }\r\n        return ret;\r\n    }\r\n\r\n    function cover(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut;\r\n         input (see (5)):\r\n         n        is the number of binary variables;\r\n         a[1:n]   are coefficients at binary variables;\r\n         b        is the right-hand side;\r\n         u        is upper bound of continuous variable;\r\n         x[1:n]   are values of binary variables at current point;\r\n         y        is value of continuous variable at current point;\r\n         output (see (15), (16), (17)):\r\n         cov[1:r] are indices of binary variables included in cover C,\r\n         where r is the set cardinality returned on exit;\r\n         alfa     coefficient at continuous variable;\r\n         beta     is the right-hand side; */\r\n        var j;\r\n        /* perform some sanity checks */\r\n        xassert(n >= 2);\r\n        for (j = 1; j <= n; j++) xassert(a[j] > 0.0);\r\n        xassert(b > -1e-5);\r\n        xassert(u >= 0.0);\r\n        for (j = 1; j <= n; j++) xassert(0.0 <= x[j] && x[j] <= 1.0);\r\n        xassert(0.0 <= y && y <= u);\r\n        /* try to generate mixed cover cut */\r\n        if (cover2(n, a, b, u, x, y, cov)) return 2;\r\n        if (cover3(n, a, b, u, x, y, cov)) return 3;\r\n        if (cover4(n, a, b, u, x, y, cov)) return 4;\r\n        return 0;\r\n    }\r\n\r\n\r\n\r\n    var cov = new Array(1+4), j, k, nb, newlen, r;\r\n    var f_min, f_max, u, y;\r\n    /* substitute and remove fixed variables */\r\n    newlen = 0;\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (lpx_get_col_type(lp, j) == LPX_FX)\r\n            val[0] -= val[k] * lpx_get_col_lb(lp, j);\r\n        else\r\n        {  newlen++;\r\n            ind[newlen] = ind[k];\r\n            val[newlen] = val[k];\r\n        }\r\n    }\r\n    len = newlen;\r\n    /* move binary variables to the beginning of the list so that\r\n     elements 1, 2, ..., nb correspond to binary variables, and\r\n     elements nb+1, nb+2, ..., len correspond to rest variables */\r\n    nb = 0;\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (lpx_get_col_kind(lp, j) == LPX_IV &&\r\n            lpx_get_col_type(lp, j) == LPX_DB &&\r\n            lpx_get_col_lb(lp, j) == 0.0 &&\r\n            lpx_get_col_ub(lp, j) == 1.0)\r\n        {  /* binary variable */\r\n            var ind_k;\r\n            var val_k;\r\n            nb++;\r\n            ind_k = ind[nb]; val_k = val[nb];\r\n            ind[nb] = ind[k]; val[nb] = val[k];\r\n            ind[k] = ind_k; val[k] = val_k;\r\n        }\r\n    }\r\n    /* now the specified row has the form:\r\n     sum a[j]*x[j] + sum a[j]*y[j] <= b,\r\n     where x[j] are binary variables, y[j] are rest variables */\r\n    /* at least two binary variables are needed */\r\n    if (nb < 2) return 0;\r\n    /* compute implied lower and upper bounds for sum a[j]*y[j] */\r\n    f_min = f_max = 0.0;\r\n    for (k = nb+1; k <= len; k++)\r\n    {  j = ind[k];\r\n        /* both bounds must be finite */\r\n        if (lpx_get_col_type(lp, j) != LPX_DB) return 0;\r\n        if (val[k] > 0.0)\r\n        {  f_min += val[k] * lpx_get_col_lb(lp, j);\r\n            f_max += val[k] * lpx_get_col_ub(lp, j);\r\n        }\r\n        else\r\n        {  f_min += val[k] * lpx_get_col_ub(lp, j);\r\n            f_max += val[k] * lpx_get_col_lb(lp, j);\r\n        }\r\n    }\r\n    /* sum a[j]*x[j] + sum a[j]*y[j] <= b ===>\r\n     sum a[j]*x[j] + (sum a[j]*y[j] - f_min) <= b - f_min ===>\r\n     sum a[j]*x[j] + y <= b - f_min,\r\n     where y = sum a[j]*y[j] - f_min;\r\n     note that 0 <= y <= u, u = f_max - f_min */\r\n    /* determine upper bound of y */\r\n    u = f_max - f_min;\r\n    /* determine value of y at the current point */\r\n    y = 0.0;\r\n    for (k = nb+1; k <= len; k++)\r\n    {  j = ind[k];\r\n        y += val[k] * lpx_get_col_prim(lp, j);\r\n    }\r\n    y -= f_min;\r\n    if (y < 0.0) y = 0.0;\r\n    if (y > u) y = u;\r\n    /* modify the right-hand side b */\r\n    val[0] -= f_min;\r\n    /* now the transformed row has the form:\r\n     sum a[j]*x[j] + y <= b, where 0 <= y <= u */\r\n    /* determine values of x[j] at the current point */\r\n    for (k = 1; k <= nb; k++)\r\n    {  j = ind[k];\r\n        x[k] = lpx_get_col_prim(lp, j);\r\n        if (x[k] < 0.0) x[k] = 0.0;\r\n        if (x[k] > 1.0) x[k] = 1.0;\r\n    }\r\n    /* if a[j] < 0, replace x[j] by its complement 1 - x'[j] */\r\n    for (k = 1; k <= nb; k++)\r\n    {  if (val[k] < 0.0)\r\n    {  ind[k] = - ind[k];\r\n        val[k] = - val[k];\r\n        val[0] += val[k];\r\n        x[k] = 1.0 - x[k];\r\n    }\r\n    }\r\n    /* try to generate a mixed cover cut for the transformed row */\r\n    r = cover(nb, val, val[0], u, x, y, cov);\r\n    if (r == 0) return 0;\r\n    xassert(2 <= r && r <= 4);\r\n    /* now the cut is in the form:\r\n     sum{j in C} x[j] + alfa * y <= beta */\r\n    /* store the right-hand side beta */\r\n    ind[0] = 0; val[0] = beta;\r\n    /* restore the original ordinal numbers of x[j] */\r\n    for (j = 1; j <= r; j++) cov[j] = ind[cov[j]];\r\n    /* store cut coefficients at binary variables complementing back\r\n     the variables having negative row coefficients */\r\n    xassert(r <= nb);\r\n    for (k = 1; k <= r; k++)\r\n    {  if (cov[k] > 0)\r\n    {  ind[k] = +cov[k];\r\n        val[k] = +1.0;\r\n    }\r\n    else\r\n    {  ind[k] = -cov[k];\r\n        val[k] = -1.0;\r\n        val[0] -= 1.0;\r\n    }\r\n    }\r\n    /* substitute y = sum a[j]*y[j] - f_min */\r\n    for (k = nb+1; k <= len; k++)\r\n    {  r++;\r\n        ind[r] = ind[k];\r\n        val[r] = alfa * val[k];\r\n    }\r\n    val[0] += alfa * f_min;\r\n    xassert(r <= len);\r\n    len = r;\r\n    return len;\r\n}\r\n\r\nfunction lpx_eval_row(lp, len, ind, val){\r\n    var n = lpx_get_num_cols(lp);\r\n    var j, k;\r\n    var sum = 0.0;\r\n    if (len < 0)\r\n        xerror(\"lpx_eval_row: len = \" + len + \"; invalid row length\");\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (!(1 <= j && j <= n))\r\n            xerror(\"lpx_eval_row: j = \" + j + \"; column number out of range\");\r\n        sum += val[k] * lpx_get_col_prim(lp, j);\r\n    }\r\n    return sum;\r\n}\r\n\r\nfunction ios_cov_gen(tree){\r\n    var prob = tree.mip;\r\n    var m = lpx_get_num_rows(prob);\r\n    var n = lpx_get_num_cols(prob);\r\n    var i, k, type, kase, len, ind;\r\n    var r, val, work;\r\n    xassert(lpx_get_status(prob) == LPX_OPT);\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    work = new Float64Array(1+n);\r\n    /* look through all rows */\r\n    for (i = 1; i <= m; i++)\r\n        for (kase = 1; kase <= 2; kase++)\r\n        {  type = lpx_get_row_type(prob, i);\r\n            if (kase == 1)\r\n            {  /* consider rows of '<=' type */\r\n                if (!(type == LPX_UP || type == LPX_DB)) continue;\r\n                len = lpx_get_mat_row(prob, i, ind, val);\r\n                val[0] = lpx_get_row_ub(prob, i);\r\n            }\r\n            else\r\n            {  /* consider rows of '>=' type */\r\n                if (!(type == LPX_LO || type == LPX_DB)) continue;\r\n                len = lpx_get_mat_row(prob, i, ind, val);\r\n                for (k = 1; k <= len; k++) val[k] = - val[k];\r\n                val[0] = - lpx_get_row_lb(prob, i);\r\n            }\r\n            /* generate mixed cover cut:\r\n             sum{j in J} a[j] * x[j] <= b */\r\n            len = lpx_cover_cut(prob, len, ind, val, work);\r\n            if (len == 0) continue;\r\n            /* at the current point the cut inequality is violated, i.e.\r\n             sum{j in J} a[j] * x[j] - b > 0 */\r\n            r = lpx_eval_row(prob, len, ind, val) - val[0];\r\n            if (r < 1e-3) continue;\r\n            /* add the cut to the cut pool */\r\n            glp_ios_add_row(tree, null, GLP_RF_COV, 0, len, ind, val,\r\n                GLP_UP, val[0]);\r\n        }\r\n}\r\n\r\n\r\nfunction lpx_create_cog(lp){\r\n    var MAX_NB = 4000;\r\n    var MAX_ROW_LEN = 500;\r\n\r\n    function get_row_lb(lp, i){\r\n        /* this routine returns lower bound of row i or -DBL_MAX if the\r\n         row has no lower bound */\r\n        var lb;\r\n        switch (lpx_get_row_type(lp, i))\r\n        {  case LPX_FR:\r\n            case LPX_UP:\r\n                lb = -DBL_MAX;\r\n                break;\r\n            case LPX_LO:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                lb = lpx_get_row_lb(lp, i);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return lb;\r\n    }\r\n\r\n    function get_row_ub(lp, i){\r\n        /* this routine returns upper bound of row i or +DBL_MAX if the\r\n         row has no upper bound */\r\n        var ub;\r\n        switch (lpx_get_row_type(lp, i))\r\n        {  case LPX_FR:\r\n            case LPX_LO:\r\n                ub = +DBL_MAX;\r\n                break;\r\n            case LPX_UP:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                ub = lpx_get_row_ub(lp, i);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return ub;\r\n    }\r\n\r\n    function get_col_lb(lp, j){\r\n        /* this routine returns lower bound of column j or -DBL_MAX if\r\n         the column has no lower bound */\r\n        var lb;\r\n        switch (lpx_get_col_type(lp, j))\r\n        {  case LPX_FR:\r\n            case LPX_UP:\r\n                lb = -DBL_MAX;\r\n                break;\r\n            case LPX_LO:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                lb = lpx_get_col_lb(lp, j);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return lb;\r\n    }\r\n\r\n    function get_col_ub(lp, j){\r\n        /* this routine returns upper bound of column j or +DBL_MAX if\r\n         the column has no upper bound */\r\n        var ub;\r\n        switch (lpx_get_col_type(lp, j))\r\n        {  case LPX_FR:\r\n            case LPX_LO:\r\n                ub = +DBL_MAX;\r\n                break;\r\n            case LPX_UP:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                ub = lpx_get_col_ub(lp, j);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return ub;\r\n    }\r\n\r\n    function is_binary(lp, j){\r\n        /* this routine checks if variable x[j] is binary */\r\n        return lpx_get_col_kind(lp, j) == LPX_IV &&\r\n            lpx_get_col_type(lp, j) == LPX_DB &&\r\n            lpx_get_col_lb(lp, j) == 0.0 && lpx_get_col_ub(lp, j) == 1.0;\r\n    }\r\n\r\n    function eval_lf_min(lp, len, ind, val){\r\n        /* this routine computes the minimum of a specified linear form\r\n\r\n         sum a[j]*x[j]\r\n         j\r\n\r\n         using the formula:\r\n\r\n         min =   sum   a[j]*lb[j] +   sum   a[j]*ub[j],\r\n         j in J+              j in J-\r\n\r\n         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]\r\n         are lower and upper bound of variable x[j], resp. */\r\n        var j, t;\r\n        var lb, ub, sum;\r\n        sum = 0.0;\r\n        for (t = 1; t <= len; t++)\r\n        {  j = ind[t];\r\n            if (val[t] > 0.0)\r\n            {  lb = get_col_lb(lp, j);\r\n                if (lb == -DBL_MAX)\r\n                {  sum = -DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * lb;\r\n            }\r\n            else if (val[t] < 0.0)\r\n            {  ub = get_col_ub(lp, j);\r\n                if (ub == +DBL_MAX)\r\n                {  sum = -DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * ub;\r\n            }\r\n            else\r\n                xassert(val != val);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function eval_lf_max(lp, len, ind, val){\r\n        /* this routine computes the maximum of a specified linear form\r\n\r\n         sum a[j]*x[j]\r\n         j\r\n\r\n         using the formula:\r\n\r\n         max =   sum   a[j]*ub[j] +   sum   a[j]*lb[j],\r\n         j in J+              j in J-\r\n\r\n         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]\r\n         are lower and upper bound of variable x[j], resp. */\r\n        var j, t;\r\n        var lb, ub, sum;\r\n        sum = 0.0;\r\n        for (t = 1; t <= len; t++)\r\n        {  j = ind[t];\r\n            if (val[t] > 0.0)\r\n            {  ub = get_col_ub(lp, j);\r\n                if (ub == +DBL_MAX)\r\n                {  sum = +DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * ub;\r\n            }\r\n            else if (val[t] < 0.0)\r\n            {  lb = get_col_lb(lp, j);\r\n                if (lb == -DBL_MAX)\r\n                {  sum = +DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * lb;\r\n            }\r\n            else\r\n                xassert(val != val);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function probing(len, val, L, U, lf_min, lf_max, p, set, q){\r\n        var temp;\r\n        xassert(1 <= p && p < q && q <= len);\r\n        /* compute L' (3) */\r\n        if (L != -DBL_MAX && set) L -= val[p];\r\n        /* compute U' (4) */\r\n        if (U != +DBL_MAX && set) U -= val[p];\r\n        /* compute MIN (9) */\r\n        if (lf_min != -DBL_MAX)\r\n        {  if (val[p] < 0.0) lf_min -= val[p];\r\n            if (val[q] < 0.0) lf_min -= val[q];\r\n        }\r\n        /* compute MAX (10) */\r\n        if (lf_max != +DBL_MAX)\r\n        {  if (val[p] > 0.0) lf_max -= val[p];\r\n            if (val[q] > 0.0) lf_max -= val[q];\r\n        }\r\n        /* compute implied lower bound of x[q]; see (7), (8) */\r\n        if (val[q] > 0.0)\r\n        {  if (L == -DBL_MAX || lf_max == +DBL_MAX)\r\n            temp = -DBL_MAX;\r\n        else\r\n            temp = (L - lf_max) / val[q];\r\n        }\r\n        else\r\n        {  if (U == +DBL_MAX || lf_min == -DBL_MAX)\r\n            temp = -DBL_MAX;\r\n        else\r\n            temp = (U - lf_min) / val[q];\r\n        }\r\n        if (temp > 0.001) return 2;\r\n        /* compute implied upper bound of x[q]; see (7), (8) */\r\n        if (val[q] > 0.0)\r\n        {  if (U == +DBL_MAX || lf_min == -DBL_MAX)\r\n            temp = +DBL_MAX;\r\n        else\r\n            temp = (U - lf_min) / val[q];\r\n        }\r\n        else\r\n        {  if (L == -DBL_MAX || lf_max == +DBL_MAX)\r\n            temp = +DBL_MAX;\r\n        else\r\n            temp = (L - lf_max) / val[q];\r\n        }\r\n        if (temp < 0.999) return 1;\r\n        /* there is no logical relation between x[p] and x[q] */\r\n        return 0;\r\n    }\r\n\r\n    var cog = null;\r\n    var m, n, nb, i, j, p, q, len, ind, vert, orig;\r\n    var L, U, lf_min, lf_max, val;\r\n    xprintf(\"Creating the conflict graph...\");\r\n    m = lpx_get_num_rows(lp);\r\n    n = lpx_get_num_cols(lp);\r\n    /* determine which binary variables should be included in the\r\n     conflict graph */\r\n    nb = 0;\r\n    vert = new Int32Array(1+n);\r\n    orig = new Int32Array(1+n);\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  L = get_row_lb(lp, i);\r\n        U = get_row_ub(lp, i);\r\n        if (L == -DBL_MAX && U == +DBL_MAX) continue;\r\n        len = lpx_get_mat_row(lp, i, ind, val);\r\n        if (len > MAX_ROW_LEN) continue;\r\n        lf_min = eval_lf_min(lp, len, ind, val);\r\n        lf_max = eval_lf_max(lp, len, ind, val);\r\n        for (p = 1; p <= len; p++)\r\n        {  if (!is_binary(lp, ind[p])) continue;\r\n            for (q = p+1; q <= len; q++)\r\n            {  if (!is_binary(lp, ind[q])) continue;\r\n                if (probing(len, val, L, U, lf_min, lf_max, p, 0, q) ||\r\n                    probing(len, val, L, U, lf_min, lf_max, p, 1, q))\r\n                {  /* there is a logical relation */\r\n                    /* include the first variable in the graph */\r\n                    j = ind[p];\r\n                    if (vert[j] == 0) {nb++; vert[j] = nb; orig[nb] = j}\r\n                    /* incude the second variable in the graph */\r\n                    j = ind[q];\r\n                    if (vert[j] == 0) {nb++; vert[j] = nb; orig[nb] = j}\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /* if the graph is either empty or has too many vertices, do not\r\n     create it */\r\n    if (nb == 0 || nb > MAX_NB)\r\n    {  xprintf(\"The conflict graph is either empty or too big\");\r\n       return cog;\r\n    }\r\n    /* create the conflict graph */\r\n    cog = {};\r\n    cog.n = n;\r\n    cog.nb = nb;\r\n    cog.ne = 0;\r\n    cog.vert = vert;\r\n    cog.orig = orig;\r\n    len = nb + nb; /* number of vertices */\r\n    len = (len * (len - 1)) / 2; /* number of entries in triangle */\r\n    len = (len + (CHAR_BIT - 1)) / CHAR_BIT; /* bytes needed */\r\n    cog.a = new Array(len);\r\n    for (j = 1; j <= nb; j++)\r\n    {  /* add edge between variable and its complement */\r\n        lpx_add_cog_edge(cog, +orig[j], -orig[j]);\r\n    }\r\n    for (i = 1; i <= m; i++)\r\n    {  L = get_row_lb(lp, i);\r\n        U = get_row_ub(lp, i);\r\n        if (L == -DBL_MAX && U == +DBL_MAX) continue;\r\n        len = lpx_get_mat_row(lp, i, ind, val);\r\n        if (len > MAX_ROW_LEN) continue;\r\n        lf_min = eval_lf_min(lp, len, ind, val);\r\n        lf_max = eval_lf_max(lp, len, ind, val);\r\n        for (p = 1; p <= len; p++)\r\n        {  if (!is_binary(lp, ind[p])) continue;\r\n            for (q = p+1; q <= len; q++)\r\n            {  if (!is_binary(lp, ind[q])) continue;\r\n                /* set x[p] to 0 and examine x[q] */\r\n                switch (probing(len, val, L, U, lf_min, lf_max, p, 0, q))\r\n                {  case 0:\r\n                    /* no logical relation */\r\n                    break;\r\n                    case 1:\r\n                        /* x[p] = 0 implies x[q] = 0 */\r\n                        lpx_add_cog_edge(cog, -ind[p], +ind[q]);\r\n                        break;\r\n                    case 2:\r\n                        /* x[p] = 0 implies x[q] = 1 */\r\n                        lpx_add_cog_edge(cog, -ind[p], -ind[q]);\r\n                        break;\r\n                    default:\r\n                        xassert(lp != lp);\r\n                }\r\n                /* set x[p] to 1 and examine x[q] */\r\n                switch (probing(len, val, L, U, lf_min, lf_max, p, 1, q))\r\n                {  case 0:\r\n                    /* no logical relation */\r\n                    break;\r\n                    case 1:\r\n                        /* x[p] = 1 implies x[q] = 0 */\r\n                        lpx_add_cog_edge(cog, +ind[p], +ind[q]);\r\n                        break;\r\n                    case 2:\r\n                        /* x[p] = 1 implies x[q] = 1 */\r\n                        lpx_add_cog_edge(cog, +ind[p], -ind[q]);\r\n                        break;\r\n                    default:\r\n                        xassert(lp != lp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    xprintf(\"The conflict graph has 2*\" + cog.nb + \" vertices and \" + cog.ne + \" edges\");\r\n    return cog;\r\n}\r\n\r\nfunction lpx_add_cog_edge(cog, i, j){\r\n    var k;\r\n    xassert(i != j);\r\n    /* determine indices of corresponding vertices */\r\n    if (i > 0)\r\n    {  xassert(1 <= i && i <= cog.n);\r\n        i = cog.vert[i];\r\n        xassert(i != 0);\r\n    }\r\n    else\r\n    {  i = -i;\r\n        xassert(1 <= i && i <= cog.n);\r\n        i = cog.vert[i];\r\n        xassert(i != 0);\r\n        i += cog.nb;\r\n    }\r\n    if (j > 0)\r\n    {  xassert(1 <= j && j <= cog.n);\r\n        j = cog.vert[j];\r\n        xassert(j != 0);\r\n    }\r\n    else\r\n    {  j = -j;\r\n        xassert(1 <= j && j <= cog.n);\r\n        j = cog.vert[j];\r\n        xassert(j != 0);\r\n        j += cog.nb;\r\n    }\r\n    /* only lower triangle is stored, so we need i > j */\r\n    if (i < j){k = i; i = j; j = k}\r\n    k = ((i - 1) * (i - 2)) / 2 + (j - 1);\r\n    cog.a[k / CHAR_BIT] |=\r\n        (1 << ((CHAR_BIT - 1) - k % CHAR_BIT));\r\n    cog.ne++;\r\n}\r\n\r\nfunction lpx_clique_cut(lp, cog, ind, val){\r\n\r\n    function is_edge(dsa, i, j) { return i == j ? 0 : i > j ? is_edge1(dsa, i, j) : is_edge1(dsa, j, i)}\r\n    function is_edge1(dsa, i, j) {return is_edge2(dsa, (i * (i - 1)) / 2 + j)}\r\n    function is_edge2(dsa, k){return (dsa.a[k / CHAR_BIT] & (1 << ((CHAR_BIT - 1) - k % CHAR_BIT)))}\r\n\r\n    function sub(dsa, ct, table, level, weight, l_weight){\r\n        var i, j, k, curr_weight, left_weight, p1, p2, newtable;\r\n        newtable = new Int32Array(dsa.n);\r\n        if (ct <= 0)\r\n        {  /* 0 or 1 elements left; include these */\r\n            if (ct == 0)\r\n            {  dsa.set[level++] = table[0];\r\n                weight += l_weight;\r\n            }\r\n            if (weight > dsa.record)\r\n            {  dsa.record = weight;\r\n                dsa.rec_level = level;\r\n                for (i = 0; i < level; i++) dsa.rec[i+1] = dsa.set[i];\r\n            }\r\n            return;\r\n        }\r\n        for (i = ct; i >= 0; i--)\r\n        {  if ((level == 0) && (i < ct)) return;\r\n            k = table[i];\r\n            if ((level > 0) && (dsa.clique[k] <= (dsa.record - weight)))\r\n                return; /* prune */\r\n            dsa.set[level] = k;\r\n            curr_weight = weight + dsa.wt[k+1];\r\n            l_weight -= dsa.wt[k+1];\r\n            if (l_weight <= (dsa.record - curr_weight))\r\n                return; /* prune */\r\n            p1 = 0;\r\n            p2 = 0;\r\n            left_weight = 0;\r\n            while (p2 < table + i)\r\n            {  j = table[p2]; p2++;\r\n                if (is_edge(dsa, j, k))\r\n                {  newtable[p1] = j; p1++;\r\n                    left_weight += dsa.wt[j+1];\r\n                }\r\n            }\r\n            if (left_weight <= (dsa.record - curr_weight)) continue;\r\n            sub(dsa, p1 - 1, newtable, level + 1, curr_weight, left_weight);\r\n        }\r\n    }\r\n\r\n    function wclique(_n, w, _a, sol){\r\n        var dsa = {};\r\n        var i, j, p, max_wt, max_nwt, wth, used, nwt, pos;\r\n        var timer;\r\n        dsa.n = _n;\r\n        dsa.wt = w;\r\n        dsa.a = _a;\r\n        dsa.record = 0;\r\n        dsa.rec_level = 0;\r\n        dsa.rec = sol;\r\n        dsa.clique = new Int32Array(dsa.n);\r\n        dsa.set = new Int32Array(dsa.n);\r\n        used = new Int32Array(dsa.n);\r\n        nwt = new Int32Array(dsa.n);\r\n        pos = new Int32Array(dsa.n);\r\n        /* start timer */\r\n        timer = xtime();\r\n        /* order vertices */\r\n        for (i = 0; i < dsa.n; i++)\r\n        {  nwt[i] = 0;\r\n            for (j = 0; j < dsa.n; j++)\r\n                if (is_edge(dsa, i, j)) nwt[i] += dsa.wt[j+1];\r\n        }\r\n        for (i = 0; i < dsa.n; i++)\r\n            used[i] = 0;\r\n        for (i = dsa.n-1; i >= 0; i--)\r\n        {  max_wt = -1;\r\n            max_nwt = -1;\r\n            for (j = 0; j < dsa.n; j++)\r\n            {  if ((!used[j]) && ((dsa.wt[j+1] > max_wt) || (dsa.wt[j+1] == max_wt\r\n                && nwt[j] > max_nwt)))\r\n            {  max_wt = dsa.wt[j+1];\r\n                max_nwt = nwt[j];\r\n                p = j;\r\n            }\r\n            }\r\n            pos[i] = p;\r\n            used[p] = 1;\r\n            for (j = 0; j < dsa.n; j++)\r\n                if ((!used[j]) && (j != p) && (is_edge(dsa, p, j)))\r\n                    nwt[j] -= dsa.wt[p+1];\r\n        }\r\n        /* main routine */\r\n        wth = 0;\r\n        for (i = 0; i < dsa.n; i++)\r\n        {  wth += dsa.wt[pos[i]+1];\r\n            sub(dsa, i, pos, 0, 0, wth);\r\n            dsa.clique[pos[i]] = dsa.record;\r\n            if (xdifftime(xtime(), timer) >= 5.0 - 0.001)\r\n            {  /* print current record and reset timer */\r\n                xprintf(\"level = \" + i+1 + \" (\" + dsa.n + \"); best = \" + dsa.record + \"\");\r\n                timer = xtime();\r\n            }\r\n        }\r\n        /* return the solution found */\r\n        for (i = 1; i <= dsa.rec_level; i++) sol[i]++;\r\n        return dsa.rec_level;\r\n    }\r\n\r\n    var n = lpx_get_num_cols(lp);\r\n    var j, t, v, card, temp, len = 0, w, sol;\r\n    var x, sum, b, vec;\r\n    /* allocate working arrays */\r\n    w = new Int32Array(1 + 2 * cog.nb);\r\n    sol = new Int32Array(1 + 2 * cog.nb);\r\n    vec = new Float64Array(1+n);\r\n    /* assign weights to vertices of the conflict graph */\r\n    for (t = 1; t <= cog.nb; t++)\r\n    {  j = cog.orig[t];\r\n        x = lpx_get_col_prim(lp, j);\r\n        temp = (100.0 * x + 0.5)|0;\r\n        if (temp < 0) temp = 0;\r\n        if (temp > 100) temp = 100;\r\n        w[t] = temp;\r\n        w[cog.nb + t] = 100 - temp;\r\n    }\r\n    /* find a clique of maximum weight */\r\n    card = wclique(2 * cog.nb, w, cog.a, sol);\r\n    /* compute the clique weight for unscaled values */\r\n    sum = 0.0;\r\n    for ( t = 1; t <= card; t++)\r\n    {  v = sol[t];\r\n        xassert(1 <= v && v <= 2 * cog.nb);\r\n        if (v <= cog.nb)\r\n        {  /* vertex v corresponds to binary variable x[j] */\r\n            j = cog.orig[v];\r\n            x = lpx_get_col_prim(lp, j);\r\n            sum += x;\r\n        }\r\n        else\r\n        {  /* vertex v corresponds to the complement of x[j] */\r\n            j = cog.orig[v - cog.nb];\r\n            x = lpx_get_col_prim(lp, j);\r\n            sum += 1.0 - x;\r\n        }\r\n    }\r\n    /* if the sum of binary variables and their complements in the\r\n     clique greater than 1, the clique cut is violated */\r\n    if (sum >= 1.01)\r\n    {  /* construct the inquality */\r\n        b = 1.0;\r\n        for (t = 1; t <= card; t++)\r\n        {  v = sol[t];\r\n            if (v <= cog.nb)\r\n            {  /* vertex v corresponds to binary variable x[j] */\r\n                j = cog.orig[v];\r\n                xassert(1 <= j && j <= n);\r\n                vec[j] += 1.0;\r\n            }\r\n            else\r\n            {  /* vertex v corresponds to the complement of x[j] */\r\n                j = cog.orig[v - cog.nb];\r\n                xassert(1 <= j && j <= n);\r\n                vec[j] -= 1.0;\r\n                b -= 1.0;\r\n            }\r\n        }\r\n        xassert(len == 0);\r\n        for (j = 1; j <= n; j++)\r\n        {  if (vec[j] != 0.0)\r\n        {  len++;\r\n            ind[len] = j; val[len] = vec[j];\r\n        }\r\n        }\r\n        ind[0] = 0; val[0] = b;\r\n    }\r\n    /* return to the calling program */\r\n    return len;\r\n}\r\n\r\nfunction ios_clq_init(tree){\r\n    /* initialize clique cut generator */\r\n    var mip = tree.mip;\r\n    xassert(mip != null);\r\n    return lpx_create_cog(mip);\r\n}\r\n\r\nfunction ios_clq_gen(tree, gen){\r\n    var n = lpx_get_num_cols(tree.mip);\r\n    var len, ind;\r\n    var val;\r\n    xassert(gen != null);\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    len = lpx_clique_cut(tree.mip, gen, ind, val);\r\n    if (len > 0)\r\n    {  /* xprintf(\"len = %d\", len); */\r\n        glp_ios_add_row(tree, null, GLP_RF_CLQ, 0, len, ind, val, GLP_UP, val[0]);\r\n    }\r\n}\r\n\r\nfunction ios_choose_var(T, callback){\r\n    var j;\r\n    if (T.parm.br_tech == GLP_BR_FFV)\r\n    {  /* branch on first fractional variable */\r\n        j = branch_first(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_LFV)\r\n    {  /* branch on last fractional variable */\r\n        j = branch_last(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_MFV)\r\n    {  /* branch on most fractional variable */\r\n        j = branch_mostf(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_DTH)\r\n    {  /* branch using the heuristic by Dreebeck and Tomlin */\r\n        j = branch_drtom(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_PCH)\r\n    {  /* hybrid pseudocost heuristic */\r\n        j = ios_pcost_branch(T, callback);\r\n    }\r\n    else\r\n        xassert(T != T);\r\n    return j;\r\n}\r\n\r\nfunction branch_first(T, callback){\r\n    var j, next;\r\n    var beta;\r\n    /* choose the column to branch on */\r\n    for (j = 1; j <= T.n; j++)\r\n        if (T.non_int[j]) break;\r\n    xassert(1 <= j && j <= T.n);\r\n    /* select the branch to be solved next */\r\n    beta = glp_get_col_prim(T.mip, j);\r\n    if (beta - Math.floor(beta) < Math.ceil(beta) - beta)\r\n        next = GLP_DN_BRNCH;\r\n    else\r\n        next = GLP_UP_BRNCH;\r\n    callback(next);\r\n    return j;\r\n}\r\n\r\nfunction branch_last(T, callback){\r\n    var j, next;\r\n    var beta;\r\n    /* choose the column to branch on */\r\n    for (j = T.n; j >= 1; j--)\r\n        if (T.non_int[j]) break;\r\n    xassert(1 <= j && j <= T.n);\r\n    /* select the branch to be solved next */\r\n    beta = glp_get_col_prim(T.mip, j);\r\n    if (beta - Math.floor(beta) < Math.ceil(beta) - beta)\r\n        next = GLP_DN_BRNCH;\r\n    else\r\n        next = GLP_UP_BRNCH;\r\n    callback(next);\r\n    return j;\r\n}\r\n\r\nfunction branch_mostf(T, callback){\r\n    var j, jj, next;\r\n    var beta, most, temp;\r\n    /* choose the column to branch on */\r\n    jj = 0; most = DBL_MAX;\r\n    for (j = 1; j <= T.n; j++)\r\n    {  if (T.non_int[j])\r\n    {  beta = glp_get_col_prim(T.mip, j);\r\n        temp = Math.floor(beta) + 0.5;\r\n        if (most > Math.abs(beta - temp))\r\n        {  jj = j; most = Math.abs(beta - temp);\r\n            if (beta < temp)\r\n                next = GLP_DN_BRNCH;\r\n            else\r\n                next = GLP_UP_BRNCH;\r\n        }\r\n    }\r\n    }\r\n    callback(next);\r\n    return jj;\r\n}\r\n\r\nfunction branch_drtom(T, callback){\r\n    var mip = T.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var non_int = T.non_int;\r\n    var j, jj, k, t, next, kase, len, stat, ind;\r\n    var x, dk, alfa, delta_j, delta_k, delta_z, dz_dn, dz_up,\r\n        dd_dn, dd_up, degrad, val;\r\n    /* basic solution of LP relaxation must be optimal */\r\n    xassert(glp_get_status(mip) == GLP_OPT);\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    /* nothing has been chosen so far */\r\n    jj = 0; degrad = -1.0;\r\n    /* walk through the list of columns (structural variables) */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* if j-th column is not marked as fractional, skip it */\r\n        if (!non_int[j]) continue;\r\n        /* obtain (fractional) value of j-th column in basic solution\r\n         of LP relaxation */\r\n        x = glp_get_col_prim(mip, j);\r\n        /* since the value of j-th column is fractional, the column is\r\n         basic; compute corresponding row of the simplex table */\r\n        len = glp_eval_tab_row(mip, m+j, ind, val);\r\n        /* the following fragment computes a change in the objective\r\n         function: delta Z = new Z - old Z, where old Z is the\r\n         objective value in the current optimal basis, and new Z is\r\n         the objective value in the adjacent basis, for two cases:\r\n         1) if new upper bound ub' = Math.floor(x[j]) is introduced for\r\n         j-th column (down branch);\r\n         2) if new lower bound lb' = Math.ceil(x[j]) is introduced for\r\n         j-th column (up branch);\r\n         since in both cases the solution remaining dual feasible\r\n         becomes primal infeasible, one implicit simplex iteration\r\n         is performed to determine the change delta Z;\r\n         it is obvious that new Z, which is never better than old Z,\r\n         is a lower (minimization) or upper (maximization) bound of\r\n         the objective function for down- and up-branches. */\r\n        for (kase = -1; kase <= +1; kase += 2)\r\n        {  /* if kase < 0, the new upper bound of x[j] is introduced;\r\n         in this case x[j] should decrease in order to leave the\r\n         basis and go to its new upper bound */\r\n            /* if kase > 0, the new lower bound of x[j] is introduced;\r\n             in this case x[j] should increase in order to leave the\r\n             basis and go to its new lower bound */\r\n            /* apply the dual ratio test in order to determine which\r\n             auxiliary or structural variable should enter the basis\r\n             to keep dual feasibility */\r\n            k = glp_dual_rtest(mip, len, ind, val, kase, 1e-9);\r\n            if (k != 0) k = ind[k];\r\n            /* if no non-basic variable has been chosen, LP relaxation\r\n             of corresponding branch being primal infeasible and dual\r\n             unbounded has no primal feasible solution; in this case\r\n             the change delta Z is formally set to infinity */\r\n            if (k == 0)\r\n            {  delta_z =\r\n                (T.mip.dir == GLP_MIN ? +DBL_MAX : -DBL_MAX);\r\n            } else {\r\n                /* row of the simplex table that corresponds to non-basic\r\n                 variable x[k] choosen by the dual ratio test is:\r\n                 x[j] = ... + alfa * x[k] + ...\r\n                 where alfa is the influence coefficient (an element of\r\n                 the simplex table row) */\r\n                /* determine the coefficient alfa */\r\n                for (t = 1; t <= len; t++) if (ind[t] == k) break;\r\n                xassert(1 <= t && t <= len);\r\n                alfa = val[t];\r\n                /* since in the adjacent basis the variable x[j] becomes\r\n                 non-basic, knowing its value in the current basis we can\r\n                 determine its change delta x[j] = new x[j] - old x[j] */\r\n                delta_j = (kase < 0 ? Math.floor(x) : Math.ceil(x)) - x;\r\n                /* and knowing the coefficient alfa we can determine the\r\n                 corresponding change delta x[k] = new x[k] - old x[k],\r\n                 where old x[k] is a value of x[k] in the current basis,\r\n                 and new x[k] is a value of x[k] in the adjacent basis */\r\n                delta_k = delta_j / alfa;\r\n                /* Tomlin noticed that if the variable x[k] is of integer\r\n                 kind, its change cannot be less (eventually) than one in\r\n                 the magnitude */\r\n                if (k > m && glp_get_col_kind(mip, k-m) != GLP_CV)\r\n                {  /* x[k] is structural integer variable */\r\n                    if (Math.abs(delta_k - Math.floor(delta_k + 0.5)) > 1e-3)\r\n                    {  if (delta_k > 0.0)\r\n                        delta_k = Math.ceil(delta_k);  /* +3.14 . +4 */\r\n                    else\r\n                        delta_k = Math.floor(delta_k); /* -3.14 . -4 */\r\n                    }\r\n                }\r\n                /* now determine the status and reduced cost of x[k] in the\r\n                 current basis */\r\n                if (k <= m)\r\n                {  stat = glp_get_row_stat(mip, k);\r\n                    dk = glp_get_row_dual(mip, k);\r\n                }\r\n                else\r\n                {  stat = glp_get_col_stat(mip, k-m);\r\n                    dk = glp_get_col_dual(mip, k-m);\r\n                }\r\n                /* if the current basis is dual degenerate, some reduced\r\n                 costs which are close to zero may have wrong sign due to\r\n                 round-off errors, so correct the sign of d[k] */\r\n                switch (T.mip.dir)\r\n                {  case GLP_MIN:\r\n                    if (stat == GLP_NL && dk < 0.0 ||\r\n                        stat == GLP_NU && dk > 0.0 ||\r\n                        stat == GLP_NF) dk = 0.0;\r\n                    break;\r\n                    case GLP_MAX:\r\n                        if (stat == GLP_NL && dk > 0.0 ||\r\n                            stat == GLP_NU && dk < 0.0 ||\r\n                            stat == GLP_NF) dk = 0.0;\r\n                        break;\r\n                    default:\r\n                        xassert(T != T);\r\n                }\r\n                /* now knowing the change of x[k] and its reduced cost d[k]\r\n                 we can compute the corresponding change in the objective\r\n                 function delta Z = new Z - old Z = d[k] * delta x[k];\r\n                 note that due to Tomlin's modification new Z can be even\r\n                 worse than in the adjacent basis */\r\n                delta_z = dk * delta_k;\r\n            }\r\n\r\n            /* new Z is never better than old Z, therefore the change\r\n            delta Z is always non-negative (in case of minimization)\r\n            or non-positive (in case of maximization) */\r\n               switch (T.mip.dir)\r\n               {  case GLP_MIN: xassert(delta_z >= 0.0); break;\r\n                   case GLP_MAX: xassert(delta_z <= 0.0); break;\r\n                   default: xassert(T != T);\r\n               }\r\n            /* save the change in the objective fnction for down- and\r\n               up-branches, respectively */\r\n            if (kase < 0) dz_dn = delta_z; else dz_up = delta_z;\r\n        }\r\n        /* thus, in down-branch no integer feasible solution can be\r\n         better than Z + dz_dn, and in up-branch no integer feasible\r\n         solution can be better than Z + dz_up, where Z is value of\r\n         the objective function in the current basis */\r\n        /* following the heuristic by Driebeck and Tomlin we choose a\r\n         column (i.e. structural variable) which provides largest\r\n         degradation of the objective function in some of branches;\r\n         besides, we select the branch with smaller degradation to\r\n         be solved next and keep other branch with larger degradation\r\n         in the active list hoping to minimize the number of further\r\n         backtrackings */\r\n        if (degrad < Math.abs(dz_dn) || degrad < Math.abs(dz_up))\r\n        {  jj = j;\r\n            if (Math.abs(dz_dn) < Math.abs(dz_up))\r\n            {  /* select down branch to be solved next */\r\n                next = GLP_DN_BRNCH;\r\n                degrad = Math.abs(dz_up);\r\n            }\r\n            else\r\n            {  /* select up branch to be solved next */\r\n                next = GLP_UP_BRNCH;\r\n                degrad = Math.abs(dz_dn);\r\n            }\r\n            /* save the objective changes for printing */\r\n            dd_dn = dz_dn; dd_up = dz_up;\r\n            /* if down- or up-branch has no feasible solution, we does\r\n             not need to consider other candidates (in principle, the\r\n             corresponding branch could be pruned right now) */\r\n            if (degrad == DBL_MAX) break;\r\n        }\r\n    }\r\n    /* something must be chosen */\r\n    xassert(1 <= jj && jj <= n);\r\n    if (degrad < 1e-6 * (1.0 + 0.001 * Math.abs(mip.obj_val)))\r\n    {  jj = branch_mostf(T, callback);\r\n        return jj;\r\n    }\r\n    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n    {  xprintf(\"branch_drtom: column \" + jj + \" chosen to branch on\");\r\n        if (Math.abs(dd_dn) == DBL_MAX)\r\n            xprintf(\"branch_drtom: down-branch is infeasible\");\r\n        else\r\n            xprintf(\"branch_drtom: down-branch bound is \" + (lpx_get_obj_val(mip) + dd_dn) + \"\");\r\n        if (Math.abs(dd_up) == DBL_MAX)\r\n            xprintf(\"branch_drtom: up-branch   is infeasible\");\r\n        else\r\n            xprintf(\"branch_drtom: up-branch   bound is \" + (lpx_get_obj_val(mip) + dd_up) + \"\");\r\n    }\r\n    callback(next);\r\n    return jj;\r\n}\r\n\r\nfunction ios_pcost_init(tree){\r\n    /* initialize working data used on pseudocost branching */\r\n    var n = tree.n, j;\r\n    var csa = {};\r\n    csa.dn_cnt = new Int32Array(1+n);\r\n    csa.dn_sum = new Float64Array(1+n);\r\n    csa.up_cnt = new Int32Array(1+n);\r\n    csa.up_sum = new Float64Array(1+n);\r\n    for (j = 1; j <= n; j++)\r\n    {  csa.dn_cnt[j] = csa.up_cnt[j] = 0;\r\n        csa.dn_sum[j] = csa.up_sum[j] = 0.0;\r\n    }\r\n    return csa;\r\n}\r\n\r\n\r\nfunction ios_pcost_update(tree){\r\n    /* update history information for pseudocost branching */\r\n    /* this routine is called every time when LP relaxation of the\r\n     current subproblem has been solved to optimality with all lazy\r\n     and cutting plane constraints included */\r\n    var j;\r\n    var dx, dz, psi;\r\n    var csa = tree.pcost;\r\n    xassert(csa != null);\r\n    xassert(tree.curr != null);\r\n    /* if the current subproblem is the root, skip updating */\r\n    if (tree.curr.up == null) return;\r\n    /* determine branching variable x[j], which was used in the\r\n     parent subproblem to create the current subproblem */\r\n    j = tree.curr.up.br_var;\r\n    xassert(1 <= j && j <= tree.n);\r\n    /* determine the change dx[j] = new x[j] - old x[j],\r\n     where new x[j] is a value of x[j] in optimal solution to LP\r\n     relaxation of the current subproblem, old x[j] is a value of\r\n     x[j] in optimal solution to LP relaxation of the parent\r\n     subproblem */\r\n    dx = tree.mip.col[j].prim - tree.curr.up.br_val;\r\n    xassert(dx != 0.0);\r\n    /* determine corresponding change dz = new dz - old dz in the\r\n     objective function value */\r\n    dz = tree.mip.obj_val - tree.curr.up.lp_obj;\r\n    /* determine per unit degradation of the objective function */\r\n    psi = Math.abs(dz / dx);\r\n    /* update history information */\r\n    if (dx < 0.0)\r\n    {  /* the current subproblem is down-branch */\r\n        csa.dn_cnt[j]++;\r\n        csa.dn_sum[j] += psi;\r\n    }\r\n    else /* dx > 0.0 */\r\n    {  /* the current subproblem is up-branch */\r\n        csa.up_cnt[j]++;\r\n        csa.up_sum[j] += psi;\r\n    }\r\n}\r\n\r\nfunction ios_pcost_free(tree){\r\n    /* free working area used on pseudocost branching */\r\n    var csa = tree.pcost;\r\n    xassert(csa != null);\r\n    tree.pcost = null;\r\n}\r\n\r\nfunction ios_pcost_branch(T, callback){\r\n    function eval_degrad(P, j, bnd){\r\n        /* compute degradation of the objective on fixing x[j] at given\r\n         value with a limited number of dual simplex iterations */\r\n        /* this routine fixes column x[j] at specified value bnd,\r\n         solves resulting LP, and returns a lower bound to degradation\r\n         of the objective, degrad >= 0 */\r\n        var lp;\r\n        var ret;\r\n        var degrad;\r\n        /* the current basis must be optimal */\r\n        xassert(glp_get_status(P) == GLP_OPT);\r\n        /* create a copy of P */\r\n        lp = glp_create_prob();\r\n        glp_copy_prob(lp, P, 0);\r\n        /* fix column x[j] at specified value */\r\n        glp_set_col_bnds(lp, j, GLP_FX, bnd, bnd);\r\n        /* try to solve resulting LP */\r\n        var parm = new SMCP();\r\n        //glp_init_smcp(parm);\r\n        parm.msg_lev = GLP_MSG_OFF;\r\n        parm.meth = GLP_DUAL;\r\n        parm.it_lim = 30;\r\n        parm.out_dly = 1000;\r\n        parm.meth = GLP_DUAL;\r\n        ret = glp_simplex(lp, parm);\r\n        if (ret == 0 || ret == GLP_EITLIM)\r\n        {  if (glp_get_prim_stat(lp) == GLP_NOFEAS)\r\n        {  /* resulting LP has no primal feasible solution */\r\n            degrad = DBL_MAX;\r\n        }\r\n        else if (glp_get_dual_stat(lp) == GLP_FEAS)\r\n        {  /* resulting basis is optimal or at least dual feasible,\r\n         so we have the correct lower bound to degradation */\r\n            if (P.dir == GLP_MIN)\r\n                degrad = lp.obj_val - P.obj_val;\r\n            else if (P.dir == GLP_MAX)\r\n                degrad = P.obj_val - lp.obj_val;\r\n            else\r\n                xassert(P != P);\r\n            /* degradation cannot be negative by definition */\r\n            /* note that the lower bound to degradation may be close\r\n             to zero even if its exact value is zero due to round-off\r\n             errors on computing the objective value */\r\n            if (degrad < 1e-6 * (1.0 + 0.001 * Math.abs(P.obj_val)))\r\n                degrad = 0.0;\r\n        }\r\n        else\r\n        {  /* the final basis reported by the simplex solver is dual\r\n         infeasible, so we cannot determine a non-trivial lower\r\n         bound to degradation */\r\n            degrad = 0.0;\r\n        }\r\n        }\r\n        else\r\n        {  /* the simplex solver failed */\r\n            degrad = 0.0;\r\n        }\r\n        return degrad;\r\n    }\r\n\r\n    function eval_psi(T, j, brnch){\r\n        /* compute estimation of pseudocost of variable x[j] for down-\r\n         or up-branch */\r\n        var csa = T.pcost;\r\n        var beta, degrad, psi;\r\n        xassert(csa != null);\r\n        xassert(1 <= j && j <= T.n);\r\n        if (brnch == GLP_DN_BRNCH)\r\n        {  /* down-branch */\r\n            if (csa.dn_cnt[j] == 0)\r\n            {  /* initialize down pseudocost */\r\n                beta = T.mip.col[j].prim;\r\n                degrad = eval_degrad(T.mip, j, Math.floor(beta));\r\n                if (degrad == DBL_MAX)\r\n                {  psi = DBL_MAX;\r\n                    return psi;\r\n                }\r\n                csa.dn_cnt[j] = 1;\r\n                csa.dn_sum[j] = degrad / (beta - Math.floor(beta));\r\n            }\r\n            psi = csa.dn_sum[j] / csa.dn_cnt[j];\r\n        }\r\n        else if (brnch == GLP_UP_BRNCH)\r\n        {  /* up-branch */\r\n            if (csa.up_cnt[j] == 0)\r\n            {  /* initialize up pseudocost */\r\n                beta = T.mip.col[j].prim;\r\n                degrad = eval_degrad(T.mip, j, Math.ceil(beta));\r\n                if (degrad == DBL_MAX)\r\n                {  psi = DBL_MAX;\r\n                    return psi;\r\n                }\r\n                csa.up_cnt[j] = 1;\r\n                csa.up_sum[j] = degrad / (Math.ceil(beta) - beta);\r\n            }\r\n            psi = csa.up_sum[j] / csa.up_cnt[j];\r\n        }\r\n        else\r\n            xassert(brnch != brnch);\r\n        return psi;\r\n    }\r\n\r\n    function progress(T){\r\n        /* display progress of pseudocost initialization */\r\n        var csa = T.pcost;\r\n        var j, nv = 0, ni = 0;\r\n        for (j = 1; j <= T.n; j++)\r\n        {  if (glp_ios_can_branch(T, j))\r\n        {  nv++;\r\n            if (csa.dn_cnt[j] > 0 && csa.up_cnt[j] > 0) ni++;\r\n        }\r\n        }\r\n        xprintf(\"Pseudocosts initialized for \" + ni + \" of \" + nv + \" variables\");\r\n    }\r\n\r\n    /* choose branching variable with pseudocost branching */\r\n    var t = xtime();\r\n    var j, jjj, sel;\r\n    var beta, psi, d1, d2, d, dmax;\r\n    /* initialize the working arrays */\r\n    if (T.pcost == null)\r\n        T.pcost = ios_pcost_init(T);\r\n    /* nothing has been chosen so far */\r\n    jjj = 0; dmax = -1.0;\r\n    /* go through the list of branching candidates */\r\n    for (j = 1; j <= T.n; j++)\r\n    {  if (!glp_ios_can_branch(T, j)) continue;\r\n        /* determine primal value of x[j] in optimal solution to LP\r\n         relaxation of the current subproblem */\r\n        beta = T.mip.col[j].prim;\r\n        /* estimate pseudocost of x[j] for down-branch */\r\n        psi = eval_psi(T, j, GLP_DN_BRNCH);\r\n        if (psi == DBL_MAX)\r\n        {  /* down-branch has no primal feasible solution */\r\n            jjj = j; sel = GLP_DN_BRNCH;\r\n            callback(sel);\r\n            return jjj;\r\n        }\r\n        /* estimate degradation of the objective for down-branch */\r\n        d1 = psi * (beta - Math.floor(beta));\r\n        /* estimate pseudocost of x[j] for up-branch */\r\n        psi = eval_psi(T, j, GLP_UP_BRNCH);\r\n        if (psi == DBL_MAX)\r\n        {  /* up-branch has no primal feasible solution */\r\n            jjj = j; sel = GLP_UP_BRNCH;\r\n            callback(sel);\r\n            return jjj;\r\n        }\r\n        /* estimate degradation of the objective for up-branch */\r\n        d2 = psi * (Math.ceil(beta) - beta);\r\n        /* determine d = max(d1, d2) */\r\n        d = (d1 > d2 ? d1 : d2);\r\n        /* choose x[j] which provides maximal estimated degradation of\r\n         the objective either in down- or up-branch */\r\n        if (dmax < d)\r\n        {  dmax = d;\r\n            jjj = j;\r\n            /* continue the search from a subproblem, where degradation\r\n             is less than in other one */\r\n            sel = (d1 <= d2 ? GLP_DN_BRNCH : GLP_UP_BRNCH);\r\n        }\r\n        /* display progress of pseudocost initialization */\r\n        if (T.parm.msg_lev >= GLP_ON)\r\n        {  if (xdifftime(xtime(), t) >= 10.0)\r\n        {  progress(T);\r\n            t = xtime();\r\n        }\r\n        }\r\n    }\r\n    if (dmax == 0.0)\r\n    {  /* no degradation is indicated; choose a variable having most\r\n     fractional value */\r\n        jjj = branch_mostf(T, callback);\r\n        return jjj;\r\n    }\r\n    callback(sel);\r\n    return jjj;\r\n}\r\n\r\nfunction ios_feas_pump(T){\r\n    var P = T.mip;\r\n    var n = P.n;\r\n    var lp = null;\r\n    var var_ = null;\r\n    var rand = null;\r\n    var col;\r\n    var parm;\r\n    var j, k, new_x, nfail, npass, nv, ret, stalling;\r\n    var dist, tol;\r\n\r\n    var\r\n        start = 0,\r\n        more = 1,\r\n        pass = 2,\r\n        loop = 3,\r\n        skip = 4,\r\n        done = 5;\r\n\r\n    var label = start;\r\n\r\n    while (true){\r\n        var go_to = null;\r\n        switch (label){\r\n            case start:\r\n                xassert(glp_get_status(P) == GLP_OPT);\r\n                /* this heuristic is applied only once on the root level */\r\n                if (!(T.curr.level == 0 && T.curr.solved == 1)){go_to = done; break}\r\n                /* determine number of binary variables */\r\n                nv = 0;\r\n                for (j = 1; j <= n; j++)\r\n                {  col = P.col[j];\r\n                    /* if x[j] is continuous, skip it */\r\n                    if (col.kind == GLP_CV) continue;\r\n                    /* if x[j] is fixed, skip it */\r\n                    if (col.type == GLP_FX) continue;\r\n                    /* x[j] is non-fixed integer */\r\n                    xassert(col.kind == GLP_IV);\r\n                    if (col.type == GLP_DB && col.lb == 0.0 && col.ub == 1.0)\r\n                    {  /* x[j] is binary */\r\n                        nv++;\r\n                    }\r\n                    else\r\n                    {  /* x[j] is general integer */\r\n                        if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                            xprintf(\"FPUMP heuristic cannot be applied due to genera\"+\r\n                                \"l integer variables\");\r\n                        go_to = done;\r\n                        break;\r\n                    }\r\n                }\r\n                if (go_to != null) break;\r\n\r\n                /* there must be at least one binary variable */\r\n                if (nv == 0) {go_to = done; break}\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Applying FPUMP heuristic...\");\r\n                /* build the list of binary variables */\r\n                var_ = new Array(1+nv);\r\n                xfillObjArr(var_, 1, nv);\r\n                k = 0;\r\n                for (j = 1; j <= n; j++)\r\n                {  col = P.col[j];\r\n                    if (col.kind == GLP_IV && col.type == GLP_DB)\r\n                        var_[++k].j = j;\r\n                }\r\n                xassert(k == nv);\r\n                /* create working problem object */\r\n                lp = glp_create_prob();\r\n            case more:\r\n                /* copy the original problem object to keep it intact */\r\n                glp_copy_prob(lp, P, GLP_OFF);\r\n                /* we are interested to find an integer feasible solution, which\r\n                 is better than the best known one */\r\n                if (P.mip_stat == GLP_FEAS)\r\n                {  var ind;\r\n                    var val, bnd;\r\n                    /* add a row and make it identical to the objective row */\r\n                    glp_add_rows(lp, 1);\r\n                    ind = new Int32Array(1+n);\r\n                    val = new Float64Array(1+n);\r\n                    for (j = 1; j <= n; j++)\r\n                    {  ind[j] = j;\r\n                        val[j] = P.col[j].coef;\r\n                    }\r\n                    glp_set_mat_row(lp, lp.m, n, ind, val);\r\n\r\n                    /* introduce upper (minimization) or lower (maximization)\r\n                     bound to the original objective function; note that this\r\n                     additional constraint is not violated at the optimal point\r\n                     to LP relaxation */\r\n                    bnd = 0.1 * P.obj_val + 0.9 * P.mip_obj;\r\n                    /* xprintf(\"bnd = %f\", bnd); */\r\n                    if (P.dir == GLP_MIN)\r\n                        glp_set_row_bnds(lp, lp.m, GLP_UP, 0.0, bnd - P.c0);\r\n                    else if (P.dir == GLP_MAX)\r\n                        glp_set_row_bnds(lp, lp.m, GLP_LO, bnd - P.c0, 0.0);\r\n                    else\r\n                        xassert(P != P);\r\n                }\r\n                /* reset pass count */\r\n                npass = 0;\r\n                /* invalidate the rounded point */\r\n                for (k = 1; k <= nv; k++)\r\n                    var_[k].x = -1;\r\n            case pass:\r\n                /* next pass starts here */\r\n                npass++;\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Pass \" + npass + \"\");\r\n                /* initialize minimal distance between the basic point and the\r\n                 rounded one obtained during this pass */\r\n                dist = DBL_MAX;\r\n                /* reset failure count (the number of succeeded iterations failed\r\n                 to improve the distance) */\r\n                nfail = 0;\r\n                /* if it is not the first pass, perturb the last rounded point\r\n                 rather than construct it from the basic solution */\r\n                if (npass > 1)\r\n                {  var rho, temp;\r\n                    if (rand == null)\r\n                        rand = rng_create_rand();\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  j = var_[k].j;\r\n                        col = lp.col[j];\r\n                        rho = rng_uniform(rand, -0.3, 0.7);\r\n                        if (rho < 0.0) rho = 0.0;\r\n                        temp = Math.abs(var_[k].x - col.prim);\r\n                        if (temp + rho > 0.5) var_[k].x = 1 - var_[k].x;\r\n                    }\r\n                    go_to = skip;\r\n                    break;\r\n                }\r\n            case loop:\r\n                /* innermost loop begins here */\r\n                /* round basic solution (which is assumed primal feasible) */\r\n                stalling = 1;\r\n                for (k = 1; k <= nv; k++)\r\n                {  col = lp.col[var_[k].j];\r\n                    if (col.prim < 0.5)\r\n                    {  /* rounded value is 0 */\r\n                        new_x = 0;\r\n                    }\r\n                    else\r\n                    {  /* rounded value is 1 */\r\n                        new_x = 1;\r\n                    }\r\n                    if (var_[k].x != new_x)\r\n                    {  stalling = 0;\r\n                        var_[k].x = new_x;\r\n                    }\r\n                }\r\n                /* if the rounded point has not changed (stalling), choose and\r\n                 flip some its entries heuristically */\r\n                if (stalling)\r\n                {  /* compute d[j] = |x[j] - round(x[j])| */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  col = lp.col[var_[k].j];\r\n                        var_[k].d = Math.abs(col.prim - var_[k].x);\r\n                    }\r\n                    /* sort the list of binary variables by descending d[j] */\r\n                    xqsort(var_, 1, nv,\r\n                        function(vx, vy){\r\n                            /* comparison routine */\r\n                            if (vx.d > vy.d)\r\n                                return -1;\r\n                            else if (vx.d < vy.d)\r\n                                return +1;\r\n                            else\r\n                                return 0;\r\n                        }\r\n                    );\r\n                    /* choose and flip some rounded components */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  if (k >= 5 && var_[k].d < 0.35 || k >= 10) break;\r\n                        var_[k].x = 1 - var_[k].x;\r\n                    }\r\n                }\r\n            case skip:\r\n                /* check if the time limit has been exhausted */\r\n                if (T.parm.tm_lim < INT_MAX &&\r\n                    (T.parm.tm_lim - 1) <=\r\n                        1000.0 * xdifftime(xtime(), T.tm_beg)) {go_to = done; break}\r\n                /* build the objective, which is the distance between the current\r\n                 (basic) point and the rounded one */\r\n                lp.dir = GLP_MIN;\r\n                lp.c0 = 0.0;\r\n                for (j = 1; j <= n; j++)\r\n                    lp.col[j].coef = 0.0;\r\n                for (k = 1; k <= nv; k++)\r\n                {  j = var_[k].j;\r\n                    if (var_[k].x == 0)\r\n                        lp.col[j].coef = +1.0;\r\n                    else\r\n                    {  lp.col[j].coef = -1.0;\r\n                        lp.c0 += 1.0;\r\n                    }\r\n                }\r\n                /* minimize the distance with the simplex method */\r\n                parm = new SMCP();\r\n                //glp_init_smcp(parm);\r\n                if (T.parm.msg_lev <= GLP_MSG_ERR)\r\n                    parm.msg_lev = T.parm.msg_lev;\r\n                else if (T.parm.msg_lev <= GLP_MSG_ALL)\r\n                {  parm.msg_lev = GLP_MSG_ON;\r\n                    parm.out_dly = 10000;\r\n                }\r\n                ret = glp_simplex(lp, parm);\r\n                if (ret != 0)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: glp_simplex returned \" + ret + \"\");\r\n                    go_to = done; break;\r\n                }\r\n                ret = glp_get_status(lp);\r\n                if (ret != GLP_OPT)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: glp_get_status returned \" + ret + \"\");\r\n                    go_to = done; break;\r\n                }\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"delta = \" + lp.obj_val + \"\");\r\n                /* check if the basic solution is integer feasible; note that it\r\n                 may be so even if the minimial distance is positive */\r\n                tol = 0.3 * T.parm.tol_int;\r\n                for (k = 1; k <= nv; k++)\r\n                {  col = lp.col[var_[k].j];\r\n                    if (tol < col.prim && col.prim < 1.0 - tol) break;\r\n                }\r\n                if (k > nv)\r\n                {  /* okay; the basic solution seems to be integer feasible */\r\n                    var x = new Float64Array(1+n);\r\n                    for (j = 1; j <= n; j++)\r\n                    {  x[j] = lp.col[j].prim;\r\n                        if (P.col[j].kind == GLP_IV) x[j] = Math.floor(x[j] + 0.5);\r\n                    }\r\n                    /* reset direction and right-hand side of objective */\r\n                    lp.c0  = P.c0;\r\n                    lp.dir = P.dir;\r\n                    /* fix integer variables */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  lp.col[var_[k].j].lb   = x[var_[k].j];\r\n                        lp.col[var_[k].j].ub   = x[var_[k].j];\r\n                        lp.col[var_[k].j].type = GLP_FX;\r\n                    }\r\n                    /* copy original objective function */\r\n                    for (j = 1; j <= n; j++)\r\n                        lp.col[j].coef = P.col[j].coef;\r\n                    /* solve original LP and copy result */\r\n                    ret = glp_simplex(lp, parm);\r\n                    if (ret != 0)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"Warning: glp_simplex returned \" + ret + \"\");\r\n                        go_to = done; break;\r\n                    }\r\n                    ret = glp_get_status(lp);\r\n                    if (ret != GLP_OPT)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"Warning: glp_get_status returned \" + ret + \"\");\r\n                        go_to = done; break;\r\n                    }\r\n                    for (j = 1; j <= n; j++)\r\n                        if (P.col[j].kind != GLP_IV) x[j] = lp.col[j].prim;\r\n                    ret = glp_ios_heur_sol(T, x);\r\n                    if (ret == 0)\r\n                    {  /* the integer solution is accepted */\r\n                        if (ios_is_hopeful(T, T.curr.bound))\r\n                        {  /* it is reasonable to apply the heuristic once again */\r\n                            go_to = more; break;\r\n                        }\r\n                        else\r\n                        {  /* the best known integer feasible solution just found\r\n                         is close to optimal solution to LP relaxation */\r\n                            go_to = done; break;\r\n                        }\r\n                    }\r\n                }\r\n                /* the basic solution is fractional */\r\n                if (dist == DBL_MAX ||\r\n                    lp.obj_val <= dist - 1e-6 * (1.0 + dist))\r\n                {  /* the distance is reducing */\r\n                    nfail = 0; dist = lp.obj_val;\r\n                }\r\n                else\r\n                {  /* improving the distance failed */\r\n                    nfail++;\r\n                }\r\n                if (nfail < 3) {go_to = loop; break}\r\n                if (npass < 5) {go_to = pass; break}\r\n            case done:\r\n\r\n\r\n        }\r\n        if (go_to == null) break;\r\n        label = go_to;\r\n    }\r\n}\r\n\r\nfunction ios_process_cuts(T){\r\n\r\n    function parallel(a, b, work){\r\n        var aij;\r\n        var s = 0.0, sa = 0.0, sb = 0.0, temp;\r\n        for (aij = a.ptr; aij != null; aij = aij.next)\r\n        {  work[aij.j] = aij.val;\r\n            sa += aij.val * aij.val;\r\n        }\r\n        for (aij = b.ptr; aij != null; aij = aij.next)\r\n        {  s += work[aij.j] * aij.val;\r\n            sb += aij.val * aij.val;\r\n        }\r\n        for (aij = a.ptr; aij != null; aij = aij.next)\r\n            work[aij.j] = 0.0;\r\n        temp = Math.sqrt(sa) * Math.sqrt(sb);\r\n        if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\r\n        return s / temp;\r\n    }\r\n\r\n    var pool;\r\n    var cut;\r\n    var aij;\r\n    var info;\r\n    var k, kk, max_cuts, len, ret, ind;\r\n    var val, work;\r\n    /* the current subproblem must exist */\r\n    xassert(T.curr != null);\r\n    /* the pool must exist and be non-empty */\r\n    pool = T.local;\r\n    xassert(pool != null);\r\n    xassert(pool.size > 0);\r\n    /* allocate working arrays */\r\n    info = new Array(1+pool.size);\r\n    ind = new Int32Array(1+T.n);\r\n    val = new Float64Array(1+T.n);\r\n    work = new Float64Array(1+T.n);\r\n    /* build the list of cuts stored in the cut pool */\r\n    for (k = 0, cut = pool.head; cut != null; cut = cut.next){\r\n        k++; info[k].cut = cut; info[k].flag = 0;\r\n    }\r\n    xassert(k == pool.size);\r\n    /* estimate efficiency of all cuts in the cut pool */\r\n    for (k = 1; k <= pool.size; k++)\r\n    {  var temp, dy = null, dz = null;\r\n        cut = info[k].cut;\r\n        /* build the vector of cut coefficients and compute its\r\n         Euclidean norm */\r\n        len = 0; temp = 0.0;\r\n        for (aij = cut.ptr; aij != null; aij = aij.next)\r\n        {  xassert(1 <= aij.j && aij.j <= T.n);\r\n            len++; ind[len] = aij.j; val[len] = aij.val;\r\n            temp += aij.val * aij.val;\r\n        }\r\n        if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\r\n        /* transform the cut to express it only through non-basic\r\n         (auxiliary and structural) variables */\r\n        len = glp_transform_row(T.mip, len, ind, val);\r\n        /* determine change in the cut value and in the objective\r\n         value for the adjacent basis by simulating one step of the\r\n         dual simplex */\r\n        ret = _glp_analyze_row(T.mip, len, ind, val, cut.type,\r\n            cut.rhs, 1e-9,  function(piv, x, dx, y, dy_, dz_){dy = dy_; dz = dz_});\r\n        /* determine normalized residual and lower bound to objective\r\n         degradation */\r\n        if (ret == 0)\r\n        {  info[k].eff = Math.abs(dy) / Math.sqrt(temp);\r\n            /* if some reduced costs violates (slightly) their zero\r\n             bounds (i.e. have wrong signs) due to round-off errors,\r\n             dz also may have wrong sign being close to zero */\r\n            if (T.mip.dir == GLP_MIN)\r\n            {  if (dz < 0.0) dz = 0.0;\r\n                info[k].deg = + dz;\r\n            }\r\n            else /* GLP_MAX */\r\n            {  if (dz > 0.0) dz = 0.0;\r\n                info[k].deg = - dz;\r\n            }\r\n        }\r\n        else if (ret == 1)\r\n        {  /* the constraint is not violated at the current point */\r\n            info[k].eff = info[k].deg = 0.0;\r\n        }\r\n        else if (ret == 2)\r\n        {  /* no dual feasible adjacent basis exists */\r\n            info[k].eff = 1.0;\r\n            info[k].deg = DBL_MAX;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        /* if the degradation is too small, just ignore it */\r\n        if (info[k].deg < 0.01) info[k].deg = 0.0;\r\n    }\r\n    /* sort the list of cuts by decreasing objective degradation and\r\n     then by decreasing efficacy */\r\n\r\n\r\n\r\n    xqsort(info, 1, pool.size,\r\n        function(info1, info2){\r\n            if (info1.deg == 0.0 && info2.deg == 0.0)\r\n            {  if (info1.eff > info2.eff) return -1;\r\n                if (info1.eff < info2.eff) return +1;\r\n            }\r\n            else\r\n            {  if (info1.deg > info2.deg) return -1;\r\n                if (info1.deg < info2.deg) return +1;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    /* only first (most efficient) max_cuts in the list are qualified\r\n     as candidates to be added to the current subproblem */\r\n    max_cuts = (T.curr.level == 0 ? 90 : 10);\r\n    if (max_cuts > pool.size) max_cuts = pool.size;\r\n    /* add cuts to the current subproblem */\r\n    for (k = 1; k <= max_cuts; k++)\r\n    {  var i;\r\n        /* if this cut seems to be inefficient, skip it */\r\n        if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;\r\n        /* if the angle between this cut and every other cut included\r\n         in the current subproblem is small, skip this cut */\r\n        for (kk = 1; kk < k; kk++)\r\n        {  if (info[kk].flag)\r\n        {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)\r\n            break;\r\n        }\r\n        }\r\n        if (kk < k) continue;\r\n        /* add this cut to the current subproblem */\r\n        cut = info[k].cut; info[k].flag = 1;\r\n        i = glp_add_rows(T.mip, 1);\r\n        if (cut.name != null)\r\n            glp_set_row_name(T.mip, i, cut.name);\r\n        xassert(T.mip.row[i].origin == GLP_RF_CUT);\r\n        T.mip.row[i].klass = cut.klass;\r\n        len = 0;\r\n        for (aij = cut.ptr; aij != null; aij = aij.next){\r\n            len++; ind[len] = aij.j; val[len] = aij.val;\r\n        }\r\n        glp_set_mat_row(T.mip, i, len, ind, val);\r\n        xassert(cut.type == GLP_LO || cut.type == GLP_UP);\r\n        glp_set_row_bnds(T.mip, i, cut.type, cut.rhs, cut.rhs);\r\n    }\r\n}\r\n\r\n\r\nfunction ios_choose_node(T){\r\n    function most_feas(T){\r\n        /* select subproblem whose parent has minimal sum of integer\r\n         infeasibilities */\r\n        var node;\r\n        var p;\r\n        var best;\r\n        p = 0; best = DBL_MAX;\r\n        for (node = T.head; node != null; node = node.next)\r\n        {  xassert(node.up != null);\r\n            if (best > node.up.ii_sum){\r\n                p = node.p; best = node.up.ii_sum;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function best_proj(T){\r\n        /* select subproblem using the best projection heuristic */\r\n        var root, node;\r\n        var p;\r\n        var best, deg, obj;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* obtain pointer to the root node, which must exist */\r\n        root = T.slot[1].node;\r\n        xassert(root != null);\r\n        /* deg estimates degradation of the objective function per unit\r\n         of the sum of integer infeasibilities */\r\n        xassert(root.ii_sum > 0.0);\r\n        deg = (T.mip.mip_obj - root.bound) / root.ii_sum;\r\n        /* nothing has been selected so far */\r\n        p = 0; best = DBL_MAX;\r\n        /* walk through the list of active subproblems */\r\n        for (node = T.head; node != null; node = node.next)\r\n        {  xassert(node.up != null);\r\n            /* obj estimates optimal objective value if the sum of integer\r\n             infeasibilities were zero */\r\n            obj = node.up.bound + deg * node.up.ii_sum;\r\n            if (T.mip.dir == GLP_MAX) obj = - obj;\r\n            /* select the subproblem which has the best estimated optimal\r\n             objective value */\r\n            if (best > obj){p = node.p; best = obj}\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function best_node(T){\r\n        /* select subproblem with best local bound */\r\n        var node, best = null;\r\n        var bound, eps;\r\n        switch (T.mip.dir)\r\n        {  case GLP_MIN:\r\n            bound = +DBL_MAX;\r\n            for (node = T.head; node != null; node = node.next)\r\n                if (bound > node.bound) bound = node.bound;\r\n            xassert(bound != +DBL_MAX);\r\n            eps = 0.001 * (1.0 + Math.abs(bound));\r\n            for (node = T.head; node != null; node = node.next)\r\n            {  if (node.bound <= bound + eps)\r\n            {  xassert(node.up != null);\r\n                if (best == null ||\r\n                    best.up.ii_sum > node.up.ii_sum) best = node;\r\n            }\r\n            }\r\n            break;\r\n            case GLP_MAX:\r\n                bound = -DBL_MAX;\r\n                for (node = T.head; node != null; node = node.next)\r\n                    if (bound < node.bound) bound = node.bound;\r\n                xassert(bound != -DBL_MAX);\r\n                eps = 0.001 * (1.0 + Math.abs(bound));\r\n                for (node = T.head; node != null; node = node.next)\r\n                {  if (node.bound >= bound - eps)\r\n                {  xassert(node.up != null);\r\n                    if (best == null ||\r\n                        best.lp_obj < node.lp_obj) best = node;\r\n                }\r\n                }\r\n                break;\r\n            default:\r\n                xassert(T != T);\r\n        }\r\n        xassert(best != null);\r\n        return best.p;\r\n    }\r\n\r\n    var p;\r\n    if (T.parm.bt_tech == GLP_BT_DFS)\r\n    {  /* depth first search */\r\n        xassert(T.tail != null);\r\n        p = T.tail.p;\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BFS)\r\n    {  /* breadth first search */\r\n        xassert(T.head != null);\r\n        p = T.head.p;\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BLB)\r\n    {  /* select node with best local bound */\r\n        p = best_node(T);\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BPH)\r\n    {  if (T.mip.mip_stat == GLP_UNDEF)\r\n    {  /* \"most integer feasible\" subproblem */\r\n        p = most_feas(T);\r\n    }\r\n    else\r\n    {  /* best projection heuristic */\r\n        p = best_proj(T);\r\n    }\r\n    }\r\n    else\r\n        xassert(T != T);\r\n    return p;\r\n}\r\n\r\n/* library version numbers: */\r\nvar\r\n    GLP_MAJOR_VERSION = exports[\"GLP_MAJOR_VERSION\"] = 4,\r\n    GLP_MINOR_VERSION = exports[\"GLP_MINOR_VERSION\"] = 49,\r\n\r\n/* optimization direction flag: */\r\n    /** @const */GLP_MIN = exports[\"GLP_MIN\"] = 1, /* minimization */\r\n    /** @const */GLP_MAX = exports[\"GLP_MAX\"] = 2, /* maximization */\r\n\r\n/* kind of structural variable: */\r\n    /** @const */GLP_CV = exports[\"GLP_CV\"] = 1, /* continuous variable */\r\n    /** @const */GLP_IV = exports[\"GLP_IV\"] = 2, /* integer variable */\r\n    /** @const */GLP_BV = exports[\"GLP_BV\"] = 3, /* binary variable */\r\n\r\n/* type of auxiliary/structural variable: */\r\n    /** @const */GLP_FR = exports[\"GLP_FR\"] = 1, /* free variable */\r\n    /** @const */GLP_LO = exports[\"GLP_LO\"] = 2, /* variable with lower bound */\r\n    /** @const */GLP_UP = exports[\"GLP_UP\"] = 3, /* variable with upper bound */\r\n    /** @const */GLP_DB = exports[\"GLP_DB\"] = 4, /* double-bounded variable */\r\n    /** @const */GLP_FX = exports[\"GLP_FX\"] = 5, /* fixed variable */\r\n\r\n/* status of auxiliary/structural variable: */\r\n    /** @const */GLP_BS = exports[\"GLP_BS\"] = 1, /* basic variable */\r\n    /** @const */GLP_NL = exports[\"GLP_NL\"] = 2, /* non-basic variable on lower bound */\r\n    /** @const */GLP_NU = exports[\"GLP_NU\"] = 3, /* non-basic variable on upper bound */\r\n    /** @const */GLP_NF = exports[\"GLP_NF\"] = 4, /* non-basic free variable */\r\n    /** @const */GLP_NS = exports[\"GLP_NS\"] = 5, /* non-basic fixed variable */\r\n\r\n/* scaling options: */\r\n    /** @const */GLP_SF_GM = exports[\"GLP_SF_GM\"] = 0x01, /* perform geometric mean scaling */\r\n    /** @const */GLP_SF_EQ = exports[\"GLP_SF_EQ\"] = 0x10, /* perform equilibration scaling */\r\n    /** @const */GLP_SF_2N = exports[\"GLP_SF_2N\"] = 0x20, /* round scale factors to power of two */\r\n    /** @const */GLP_SF_SKIP = exports[\"GLP_SF_SKIP\"] = 0x40, /* skip if problem is well scaled */\r\n    /** @const */GLP_SF_AUTO = exports[\"GLP_SF_AUTO\"] = 0x80, /* choose scaling options automatically */\r\n\r\n/* solution indicator: */\r\n    /** @const */GLP_SOL = exports[\"GLP_SOL\"] = 1, /* basic solution */\r\n    /** @const */GLP_IPT = exports[\"GLP_IPT\"] = 2, /* interior-point solution */\r\n    /** @const */GLP_MIP = exports[\"GLP_MIP\"] = 3, /* mixed integer solution */\r\n\r\n/* solution status: */\r\n    /** @const */GLP_UNDEF = exports[\"GLP_UNDEF\"] = 1, /* solution is undefined */\r\n    /** @const */GLP_FEAS = exports[\"GLP_FEAS\"] = 2, /* solution is feasible */\r\n    /** @const */GLP_INFEAS = exports[\"GLP_INFEAS\"] = 3, /* solution is infeasible */\r\n    /** @const */GLP_NOFEAS = exports[\"GLP_NOFEAS\"] = 4, /* no feasible solution exists */\r\n    /** @const */GLP_OPT = exports[\"GLP_OPT\"] = 5, /* solution is optimal */\r\n    /** @const */GLP_UNBND = exports[\"GLP_UNBND\"] = 6, /* solution is unbounded */\r\n\r\n/* basis factorization control parameters */\r\n    /** @const */GLP_BF_FT = exports[\"GLP_BF_FT\"] = 1, /* LUF + Forrest-Tomlin */\r\n    /** @const */GLP_BF_BG = exports[\"GLP_BF_BG\"] = 2, /* LUF + Schur compl. + Bartels-Golub */\r\n    /** @const */GLP_BF_GR = exports[\"GLP_BF_GR\"] = 3, /* LUF + Schur compl. + Givens rotation */\r\n\r\n/* simplex method control parameters */\r\n    /** @const */GLP_MSG_OFF = exports[\"GLP_MSG_OFF\"] = 0, /* no output */\r\n    /** @const */GLP_MSG_ERR = exports[\"GLP_MSG_ERR\"] = 1, /* warning and error messages only */\r\n    /** @const */GLP_MSG_ON = exports[\"GLP_MSG_ON\"] = 2, /* normal output */\r\n    /** @const */GLP_MSG_ALL = exports[\"GLP_MSG_ALL\"] = 3, /* full output */\r\n    /** @const */GLP_MSG_DBG = exports[\"GLP_MSG_DBG\"] = 4, /* debug output */\r\n\r\n    /** @const */GLP_PRIMAL = exports[\"GLP_PRIMAL\"] = 1, /* use primal simplex */\r\n    /** @const */GLP_DUALP = exports[\"GLP_DUALP\"] = 2, /* use dual; if it fails, use primal */\r\n    /** @const */GLP_DUAL = exports[\"GLP_DUAL\"] = 3, /* use dual simplex */\r\n\r\n    /** @const */GLP_PT_STD = exports[\"GLP_PT_STD\"] = 0x11, /* standard (Dantzig rule) */\r\n    /** @const */GLP_PT_PSE = exports[\"GLP_PT_PSE\"] = 0x22, /* projected steepest edge */\r\n\r\n    /** @const */GLP_RT_STD = exports[\"GLP_RT_STD\"] = 0x11, /* standard (textbook) */\r\n    /** @const */GLP_RT_HAR = exports[\"GLP_RT_HAR\"] = 0x22, /* two-pass Harris' ratio test */\r\n\r\n/* interior-point solver control parameters */\r\n    /** @const */GLP_ORD_NONE = exports[\"GLP_ORD_NONE\"] = 0, /* natural (original) ordering */\r\n    /** @const */GLP_ORD_QMD = exports[\"GLP_ORD_QMD\"] = 1, /* quotient minimum degree (QMD) */\r\n    /** @const */GLP_ORD_AMD = exports[\"GLP_ORD_AMD\"] = 2, /* approx. minimum degree (AMD) */\r\n    /** @const */GLP_ORD_SYMAMD = exports[\"GLP_ORD_SYMAMD\"] = 3, /* approx. minimum degree (SYMAMD) */\r\n\r\n/* integer optimizer control parameters */\r\n    /** @const */GLP_BR_FFV = exports[\"GLP_BR_FFV\"] = 1, /* first fractional variable */\r\n    /** @const */GLP_BR_LFV = exports[\"GLP_BR_LFV\"] = 2, /* last fractional variable */\r\n    /** @const */GLP_BR_MFV = exports[\"GLP_BR_MFV\"] = 3, /* most fractional variable */\r\n    /** @const */GLP_BR_DTH = exports[\"GLP_BR_DTH\"] = 4, /* heuristic by Driebeck and Tomlin */\r\n    /** @const */GLP_BR_PCH = exports[\"GLP_BR_PCH\"] = 5, /* hybrid pseudocost heuristic */\r\n\r\n    /** @const */GLP_BT_DFS = exports[\"GLP_BT_DFS\"] = 1, /* depth first search */\r\n    /** @const */GLP_BT_BFS = exports[\"GLP_BT_BFS\"] = 2, /* breadth first search */\r\n    /** @const */GLP_BT_BLB = exports[\"GLP_BT_BLB\"] = 3, /* best local bound */\r\n    /** @const */GLP_BT_BPH = exports[\"GLP_BT_BPH\"] = 4, /* best projection heuristic */\r\n\r\n    /** @const */GLP_PP_NONE = exports[\"GLP_PP_NONE\"] = 0, /* disable preprocessing */\r\n    /** @const */GLP_PP_ROOT = exports[\"GLP_PP_ROOT\"] = 1, /* preprocessing only on root level */\r\n    /** @const */GLP_PP_ALL = exports[\"GLP_PP_ALL\"] = 2, /* preprocessing on all levels */\r\n\r\n/* additional row attributes */\r\n    /** @const */GLP_RF_REG = exports[\"GLP_RF_REG\"] = 0, /* regular constraint */\r\n    /** @const */GLP_RF_LAZY = exports[\"GLP_RF_LAZY\"] = 1, /* \"lazy\" constraint */\r\n    /** @const */GLP_RF_CUT = exports[\"GLP_RF_CUT\"] = 2, /* cutting plane constraint */\r\n\r\n/* row class descriptor: */\r\n    /** @const */GLP_RF_GMI = exports[\"GLP_RF_GMI\"] = 1, /* Gomory's mixed integer cut */\r\n    /** @const */GLP_RF_MIR = exports[\"GLP_RF_MIR\"] = 2, /* mixed integer rounding cut */\r\n    /** @const */GLP_RF_COV = exports[\"GLP_RF_COV\"] = 3, /* mixed cover cut */\r\n    /** @const */GLP_RF_CLQ = exports[\"GLP_RF_CLQ\"] = 4, /* clique cut */\r\n\r\n/* enable/disable flag: */\r\n    /** @const */GLP_ON = exports[\"GLP_ON\"] = 1, /* enable something */\r\n    /** @const */GLP_OFF = exports[\"GLP_OFF\"] = 0, /* disable something */\r\n\r\n/* reason codes: */\r\n    /** @const */GLP_IROWGEN = exports[\"GLP_IROWGEN\"] = 0x01, /* request for row generation */\r\n    /** @const */GLP_IBINGO = exports[\"GLP_IBINGO\"] = 0x02, /* better integer solution found */\r\n    /** @const */GLP_IHEUR = exports[\"GLP_IHEUR\"] = 0x03, /* request for heuristic solution */\r\n    /** @const */GLP_ICUTGEN = exports[\"GLP_ICUTGEN\"] = 0x04, /* request for cut generation */\r\n    /** @const */GLP_IBRANCH = exports[\"GLP_IBRANCH\"] = 0x05, /* request for branching */\r\n    /** @const */GLP_ISELECT = exports[\"GLP_ISELECT\"] = 0x06, /* request for subproblem selection */\r\n    /** @const */GLP_IPREPRO = exports[\"GLP_IPREPRO\"] = 0x07, /* request for preprocessing */\r\n\r\n/* branch selection indicator: */\r\n    /** @const */GLP_NO_BRNCH = exports[\"GLP_NO_BRNCH\"] = 0, /* select no branch */\r\n    /** @const */GLP_DN_BRNCH = exports[\"GLP_DN_BRNCH\"] = 1, /* select down-branch */\r\n    /** @const */GLP_UP_BRNCH = exports[\"GLP_UP_BRNCH\"] = 2, /* select up-branch */\r\n\r\n/* return codes: */\r\n    /** @const */GLP_EBADB = exports[\"GLP_EBADB\"] = 0x01, /* invalid basis */\r\n    /** @const */GLP_ESING = exports[\"GLP_ESING\"] = 0x02, /* singular matrix */\r\n    /** @const */GLP_ECOND = exports[\"GLP_ECOND\"] = 0x03, /* ill-conditioned matrix */\r\n    /** @const */GLP_EBOUND = exports[\"GLP_EBOUND\"] = 0x04, /* invalid bounds */\r\n    /** @const */GLP_EFAIL = exports[\"GLP_EFAIL\"] = 0x05, /* solver failed */\r\n    /** @const */GLP_EOBJLL = exports[\"GLP_EOBJLL\"] = 0x06, /* objective lower limit reached */\r\n    /** @const */GLP_EOBJUL = exports[\"GLP_EOBJUL\"] = 0x07, /* objective upper limit reached */\r\n    /** @const */GLP_EITLIM = exports[\"GLP_EITLIM\"] = 0x08, /* iteration limit exceeded */\r\n    /** @const */GLP_ETMLIM = exports[\"GLP_ETMLIM\"] = 0x09, /* time limit exceeded */\r\n    /** @const */GLP_ENOPFS = exports[\"GLP_ENOPFS\"] = 0x0A, /* no primal feasible solution */\r\n    /** @const */GLP_ENODFS = exports[\"GLP_ENODFS\"] = 0x0B, /* no dual feasible solution */\r\n    /** @const */GLP_EROOT = exports[\"GLP_EROOT\"] = 0x0C, /* root LP optimum not provided */\r\n    /** @const */GLP_ESTOP = exports[\"GLP_ESTOP\"] = 0x0D, /* search terminated by application */\r\n    /** @const */GLP_EMIPGAP = exports[\"GLP_EMIPGAP\"] = 0x0E, /* relative mip gap tolerance reached */\r\n    /** @const */GLP_ENOFEAS = exports[\"GLP_ENOFEAS\"] = 0x0F, /* no primal/dual feasible solution */\r\n    /** @const */GLP_ENOCVG = exports[\"GLP_ENOCVG\"] = 0x10, /* no convergence */\r\n    /** @const */GLP_EINSTAB = exports[\"GLP_EINSTAB\"] = 0x11, /* numerical instability */\r\n    /** @const */GLP_EDATA = exports[\"GLP_EDATA\"] = 0x12, /* invalid data */\r\n    /** @const */GLP_ERANGE = exports[\"GLP_ERANGE\"] = 0x13, /* result out of range */\r\n\r\n/* condition indicator: */\r\n    /** @const */GLP_KKT_PE = exports[\"GLP_KKT_PE\"] = 1, /* primal equalities */\r\n    /** @const */GLP_KKT_PB = exports[\"GLP_KKT_PB\"] = 2, /* primal bounds */\r\n    /** @const */GLP_KKT_DE = exports[\"GLP_KKT_DE\"] = 3, /* dual equalities */\r\n    /** @const */GLP_KKT_DB = exports[\"GLP_KKT_DB\"] = 4, /* dual bounds */\r\n    /** @const */GLP_KKT_CS = exports[\"GLP_KKT_CS\"] = 5, /* complementary slackness */\r\n\r\n/* MPS file format: */\r\n    /** @const */GLP_MPS_DECK = exports[\"GLP_MPS_DECK\"] = 1, /* fixed (ancient) */\r\n    /** @const */GLP_MPS_FILE = exports[\"GLP_MPS_FILE\"] = 2, /* free (modern) */\r\n\r\n/* assignment problem formulation: */\r\n    /** @const */GLP_ASN_MIN = exports[\"GLP_ASN_MIN\"] = 1, /* perfect matching (minimization) */\r\n    /** @const */GLP_ASN_MAX = exports[\"GLP_ASN_MAX\"] = 2, /* perfect matching (maximization) */\r\n    /** @const */GLP_ASN_MMP = exports[\"GLP_ASN_MMP\"] = 3; /* maximum matching */\r\nfunction gcd(x, y){\r\n    var r;\r\n    xassert(x > 0 && y > 0);\r\n    while (y > 0){\r\n        r = x % y;\r\n        x = y;\r\n        y = r;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction gcdn(n, x){\r\n    var d = 0, j;\r\n    xassert(n > 0);\r\n    for (j = 1; j <= n; j++)\r\n    {  xassert(x[j] > 0);\r\n        if (j == 1)\r\n            d = x[1];\r\n        else\r\n            d = gcd(d, x[j]);\r\n        if (d == 1) break;\r\n    }\r\n    return d;\r\n}\r\n\r\nfunction round2n(x){\r\n    xassert(x > 0.0);\r\n    var e = Math.floor(Math.log(x) / Math.log(2)) + 1;\r\n    var f = x / Math.pow(2, e);\r\n    return Math.pow(2, f <= 0.75 ? e-1 : e);\r\n}\r\n\r\n/*  0 - no error;\r\n *  1 - value out of range;\r\n *  2 - character string is syntactically incorrect.\r\n */\r\nfunction str2num(str, callback){\r\n    var ret = Number(str);\r\n    if (isNaN(ret)) return 2;\r\n    switch (ret){\r\n        case Number.POSITIVE_INFINITY:\r\n        case Number.NEGATIVE_INFINITY:\r\n            return 1;\r\n        default:\r\n            callback(ret);\r\n            return 0;\r\n    }\r\n}\r\n\r\nfunction str2int(str, callback){\r\n    var ret = Number(str);\r\n    if (isNaN(ret)) return 2;\r\n    switch (ret){\r\n        case Number.POSITIVE_INFINITY:\r\n        case Number.NEGATIVE_INFINITY:\r\n            return 1;\r\n        default:\r\n            if (ret % 1 == 0){\r\n                callback(ret);\r\n                return 0;\r\n            } else {\r\n                return 2\r\n            }\r\n    }\r\n}\r\n\r\nfunction jday(d, m, y){\r\n    var c, ya, j, dd;\r\n    if (!(1 <= d && d <= 31 && 1 <= m && m <= 12 && 1 <= y && y <= 4000))\r\n        return -1;\r\n    if (m >= 3)m -= 3;else{m += 9;y--;}\r\n    c = (y / 100)|0;\r\n    ya = y - 100 * c;\r\n    j = ((146097 * c) / 4)|0;\r\n    j += ((1461 * ya) / 4)|0;\r\n    j += ((153 * m + 2) / 5)|0;\r\n    j += d + 1721119;\r\n    jdate(j, function(d){dd = d});\r\n    if (d != dd) j = -1;\r\n    return j;\r\n}\r\n\r\nfunction jdate(j, callback)\r\n{\r\n    var d, m, y, ret = 0;\r\n    if (!(1721426 <= j && j <= 3182395))\r\n      return 1;\r\n    j -= 1721119;\r\n    y = ((4 * j - 1) / 146097)|0;\r\n    j = (4 * j - 1) % 146097;\r\n    d = (j / 4)|0;\r\n    j = ((4 * d + 3) / 1461)|0;\r\n    d = (4 * d + 3) % 1461;\r\n    d = ((d + 4) / 4)|0;\r\n    m = ((5 * d - 3) / 153)|0;\r\n    d = (5 * d - 3) % 153;\r\n    d = ((d + 5) / 5)|0;\r\n    y = 100 * y + j;\r\n    if (m <= 9)\r\n        m += 3;\r\n    else{\r\n        m -= 9; y++;\r\n    }\r\n    callback(d, m, y);\r\n    return ret;\r\n}\r\n\r\n/* return codes: */\r\nvar\r\n    LPF_ESING    = 1;  /* singular matrix */\r\n    LPF_ECOND    = 2;  /* ill-conditioned matrix */\r\n    LPF_ELIMIT   = 3;  /* update limit reached */\r\n\r\n\r\nvar _GLPLPF_DEBUG = 0;\r\n\r\nfunction lpf_create_it(){\r\n    var lpf;\r\n    if (_GLPLPF_DEBUG){\r\n        xprintf(\"lpf_create_it: warning: debug mode enabled\");\r\n    }\r\n    lpf = {};\r\n    lpf.valid = 0;\r\n    lpf.m0_max = lpf.m0 = 0;\r\n    lpf.luf = luf_create_it();\r\n    lpf.m = 0;\r\n    lpf.B = null;\r\n    lpf.n_max = 50;\r\n    lpf.n = 0;\r\n    lpf.R_ptr = lpf.R_len = null;\r\n    lpf.S_ptr = lpf.S_len = null;\r\n    lpf.scf = null;\r\n    lpf.P_row = lpf.P_col = null;\r\n    lpf.Q_row = lpf.Q_col = null;\r\n    lpf.v_size = 1000;\r\n    lpf.v_ptr = 0;\r\n    lpf.v_ind = null;\r\n    lpf.v_val = null;\r\n    lpf.work1 = lpf.work2 = null;\r\n    return lpf;\r\n}\r\n\r\nfunction lpf_factorize(lpf, m, bh, col, info){\r\n    var k, ret;\r\n    if (_GLPLPF_DEBUG){\r\n        var i, j, len, ind;\r\n        var B, val;\r\n    }\r\n    xassert(bh == bh);\r\n    if (m < 1)\r\n        xerror(\"lpf_factorize: m = \" + m + \"; invalid parameter\");\r\n    if (m > M_MAX)\r\n        xerror(\"lpf_factorize: m = \" + m + \"; matrix too big\");\r\n    lpf.m0 = lpf.m = m;\r\n    /* invalidate the factorization */\r\n    lpf.valid = 0;\r\n    /* allocate/reallocate arrays, if necessary */\r\n    if (lpf.R_ptr == null)\r\n        lpf.R_ptr = new Int32Array(1+lpf.n_max);\r\n    if (lpf.R_len == null)\r\n        lpf.R_len = new Int32Array(1+lpf.n_max);\r\n    if (lpf.S_ptr == null)\r\n        lpf.S_ptr = new Int32Array(1+lpf.n_max);\r\n    if (lpf.S_len == null)\r\n        lpf.S_len = new Int32Array(1+lpf.n_max);\r\n    if (lpf.scf == null)\r\n        lpf.scf = scf_create_it(lpf.n_max);\r\n    if (lpf.v_ind == null)\r\n        lpf.v_ind = new Int32Array(1+lpf.v_size);\r\n    if (lpf.v_val == null)\r\n        lpf.v_val = new Float64Array(1+lpf.v_size);\r\n    if (lpf.m0_max < m)\r\n    {\r\n        lpf.m0_max = m + 100;\r\n        lpf.P_row = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.P_col = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.Q_row = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.Q_col = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.work1 = new Float64Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.work2 = new Float64Array(1+lpf.m0_max+lpf.n_max);\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    switch (luf_factorize(lpf.luf, m, col, info))\r\n    {  case 0:\r\n        break;\r\n        case LUF_ESING:\r\n            ret = LPF_ESING;\r\n            return ret;\r\n        case LUF_ECOND:\r\n            ret = LPF_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(lpf != lpf);\r\n    }\r\n    /* the basis matrix has been successfully factorized */\r\n    lpf.valid = 1;\r\n    if (_GLPLPF_DEBUG){\r\n        /* store the basis matrix for debugging */\r\n        xassert(m <= 32767);\r\n        lpf.B = B = new Float64Array(1+m*m);\r\n        ind = new Int32Array(1+m);\r\n        val = new Float64Array(1+m);\r\n        for (k = 1; k <= m * m; k++)\r\n            B[k] = 0.0;\r\n        for (j = 1; j <= m; j++)\r\n        {  len = col(info, j, ind, val);\r\n            xassert(0 <= len && len <= m);\r\n            for (k = 1; k <= len; k++)\r\n            {  i = ind[k];\r\n                xassert(1 <= i && i <= m);\r\n                xassert(B[(i - 1) * m + j] == 0.0);\r\n                xassert(val[k] != 0.0);\r\n                B[(i - 1) * m + j] = val[k];\r\n            }\r\n        }\r\n    }\r\n    /* B = B0, so there are no additional rows/columns */\r\n    lpf.n = 0;\r\n    /* reset the Schur complement factorization */\r\n    scf_reset_it(lpf.scf);\r\n    /* P := Q := I */\r\n    for (k = 1; k <= m; k++)\r\n    {  lpf.P_row[k] = lpf.P_col[k] = k;\r\n        lpf.Q_row[k] = lpf.Q_col[k] = k;\r\n    }\r\n    /* make all SVA locations free */\r\n    lpf.v_ptr = 1;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction r_prod(lpf, y, a, x, idx){\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var j, beg, end, ptr;\r\n    var t;\r\n    for (j = 1; j <= n; j++)\r\n    {  if (x[j+idx] == 0.0) continue;\r\n        /* y := y + alpha * R[j] * x[j] */\r\n        t = a * x[j+idx];\r\n        beg = R_ptr[j];\r\n        end = beg + R_len[j];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            y[v_ind[ptr]] += t * v_val[ptr];\r\n    }\r\n}\r\n\r\nfunction rt_prod(lpf, y, idx, a, x){\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var j, beg, end, ptr;\r\n    var t;\r\n    for (j = 1; j <= n; j++)\r\n    {  /* t := (j-th column of R) * x */\r\n        t = 0.0;\r\n        beg = R_ptr[j];\r\n        end = beg + R_len[j];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            t += v_val[ptr] * x[v_ind[ptr]];\r\n        /* y[j] := y[j] + alpha * t */\r\n        y[j+idx] += a * t;\r\n    }\r\n}\r\n\r\nfunction s_prod(lpf, y, idx, a, x){\r\n    var n = lpf.n;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var i, beg, end, ptr;\r\n    var t;\r\n    for (i = 1; i <= n; i++)\r\n    {  /* t := (i-th row of S) * x */\r\n        t = 0.0;\r\n        beg = S_ptr[i];\r\n        end = beg + S_len[i];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            t += v_val[ptr] * x[v_ind[ptr]];\r\n        /* y[i] := y[i] + alpha * t */\r\n        y[i+idx] += a * t;\r\n    }\r\n}\r\n\r\nfunction st_prod(lpf, y, a, x, idx){\r\n    var n = lpf.n;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var i, beg, end, ptr;\r\n    var t;\r\n    for (i = 1; i <= n; i++)\r\n    {  if (x[i+idx] == 0.0) continue;\r\n        /* y := y + alpha * S'[i] * x[i] */\r\n        t = a * x[i+idx];\r\n        beg = S_ptr[i];\r\n        end = beg + S_len[i];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            y[v_ind[ptr]] += t * v_val[ptr];\r\n    }\r\n}\r\n\r\nif (_GLPLPF_DEBUG){\r\n    /***********************************************************************\r\n     *  The routine check_error computes the maximal relative error between\r\n     *  left- and right-hand sides for the system B * x = b (if tr is zero)\r\n     *  or B' * x = b (if tr is non-zero), where B' is a matrix transposed\r\n     *  to B. (This routine is intended for debugging only.) */\r\n\r\n    function check_error(lpf, tr, x, b){\r\n        var m = lpf.m;\r\n        var B = lpf.B;\r\n        var i, j;\r\n        var d, dmax = 0.0, s, t, tmax;\r\n        for (i = 1; i <= m; i++)\r\n        {  s = 0.0;\r\n            tmax = 1.0;\r\n            for (j = 1; j <= m; j++)\r\n            {  if (!tr)\r\n                t = B[m * (i - 1) + j] * x[j];\r\n            else\r\n                t = B[m * (j - 1) + i] * x[j];\r\n                if (tmax < Math.abs(t)) tmax = Math.abs(t);\r\n                s += t;\r\n            }\r\n            d = Math.abs(s - b[i]) / tmax;\r\n            if (dmax < d) dmax = d;\r\n        }\r\n        if (dmax > 1e-8)\r\n            xprintf((!tr ? \"lpf_ftran\" : \"lpf_btran\") + \": dmax = \" + dmax + \"; relative error too large\");\r\n    }\r\n}\r\n\r\nfunction lpf_ftran(lpf, x){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    var n  = lpf.n;\r\n    var P_col = lpf.P_col;\r\n    var Q_col = lpf.Q_col;\r\n    var fg = lpf.work1;\r\n    var f = fg;\r\n    var g = fg;\r\n    var i, ii;\r\n    if (_GLPLPF_DEBUG){var b}\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_ftran: the factorization is not valid\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    if (_GLPLPF_DEBUG){\r\n        /* save the right-hand side vector */\r\n        b = new Float64Array(1+m);\r\n        for (i = 1; i <= m; i++) b[i] = x[i];\r\n    }\r\n    /* (f g) := inv(P) * (b 0) */\r\n    for (i = 1; i <= m0 + n; i++)\r\n        fg[i] = ((ii = P_col[i]) <= m ? x[ii] : 0.0);\r\n    /* f1 := inv(L0) * f */\r\n    luf_f_solve(lpf.luf, 0, f);\r\n    /* g1 := g - S * f1 */\r\n    s_prod(lpf, g, m0, -1.0, f);\r\n    /* g2 := inv(C) * g1 */\r\n    scf_solve_it(lpf.scf, 0, g, m0);\r\n    /* f2 := inv(U0) * (f1 - R * g2) */\r\n    r_prod(lpf, f, -1.0, g, m0);\r\n    luf_v_solve(lpf.luf, 0, f);\r\n    /* (x y) := inv(Q) * (f2 g2) */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] = fg[Q_col[i]];\r\n    if (_GLPLPF_DEBUG){\r\n        /* check relative error in solution */\r\n        check_error(lpf, 0, x, b);\r\n    }\r\n}\r\n\r\nfunction lpf_btran(lpf, x){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    var n = lpf.n;\r\n    var P_row = lpf.P_row;\r\n    var Q_row = lpf.Q_row;\r\n    var fg = lpf.work1;\r\n    var f = fg;\r\n    var g = fg;\r\n    var i, ii;\r\n    if (_GLPLPF_DEBUG){var b}\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_btran: the factorization is not valid\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    if (_GLPLPF_DEBUG){\r\n        /* save the right-hand side vector */\r\n        b = new Float64Array(1+m);\r\n        for (i = 1; i <= m; i++) b[i] = x[i];\r\n    }\r\n    /* (f g) := Q * (b 0) */\r\n    for (i = 1; i <= m0 + n; i++)\r\n        fg[i] = ((ii = Q_row[i]) <= m ? x[ii] : 0.0);\r\n    /* f1 := inv(U'0) * f */\r\n    luf_v_solve(lpf.luf, 1, f);\r\n    /* g1 := inv(C') * (g - R' * f1) */\r\n    rt_prod(lpf, g, m0, -1.0, f);\r\n    scf_solve_it(lpf.scf, 1, g, m0);\r\n    /* g2 := g1 */\r\n    //g = g;\r\n    /* f2 := inv(L'0) * (f1 - S' * g2) */\r\n    st_prod(lpf, f, -1.0, g, m0);\r\n    luf_f_solve(lpf.luf, 1, f);\r\n    /* (x y) := P * (f2 g2) */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] = fg[P_row[i]];\r\n    if (_GLPLPF_DEBUG){\r\n        /* check relative error in solution */\r\n        check_error(lpf, 1, x, b);\r\n    }\r\n}\r\n\r\nfunction enlarge_sva(lpf, new_size){\r\n    var v_size = lpf.v_size;\r\n    var used = lpf.v_ptr - 1;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    xassert(v_size < new_size);\r\n    while (v_size < new_size) v_size += v_size;\r\n    lpf.v_size = v_size;\r\n    lpf.v_ind = new Int32Array(1+v_size);\r\n    lpf.v_val = new Float64Array(1+v_size);\r\n    xassert(used >= 0);\r\n    xcopyArr(lpf.v_ind, 1, v_ind, 1, used);\r\n    xcopyArr(lpf.v_val, 1, v_val, 1, used);\r\n}\r\n\r\nfunction lpf_update_it(lpf, j, bh, len, ind, idx, val){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    if (_GLPLPF_DEBUG){var B = lpf.B}\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var P_row = lpf.P_row;\r\n    var P_col = lpf.P_col;\r\n    var Q_row = lpf.Q_row;\r\n    var Q_col = lpf.Q_col;\r\n    var v_ptr = lpf.v_ptr;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var a = lpf.work2; /* new column */\r\n    var fg = lpf.work1, f = fg, g = fg;\r\n    var vw = lpf.work2, v = vw, w = vw;\r\n    var x = g, y = w, z;\r\n    var i, ii, k, ret;\r\n    xassert(bh == bh);\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_update_it: the factorization is not valid\");\r\n    if (!(1 <= j && j <= m))\r\n        xerror(\"lpf_update_it: j = \" + j + \"; column number out of range\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    /* check if the basis factorization can be expanded */\r\n    if (n == lpf.n_max)\r\n    {  lpf.valid = 0;\r\n        ret = LPF_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* convert new j-th column of B to dense format */\r\n    for (i = 1; i <= m; i++)\r\n        a[i] = 0.0;\r\n    for (k = 1; k <= len; k++)\r\n    {  i = ind[idx + k];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"lpf_update_it: ind[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        if (a[i] != 0.0)\r\n            xerror(\"lpf_update_it: ind[\" + k + \"] = \" + i + \"; duplicate row index not allowed\");\r\n        if (val[k] == 0.0)\r\n            xerror(\"lpf_update_it: val[\" + k + \"] = \" + val[k] + \"; zero element not allowed\");\r\n        a[i] = val[k];\r\n    }\r\n    if (_GLPLPF_DEBUG){\r\n        /* change column in the basis matrix for debugging */\r\n        for (i = 1; i <= m; i++)\r\n            B[(i - 1) * m + j] = a[i];\r\n    }\r\n    /* (f g) := inv(P) * (a 0) */\r\n    for (i = 1; i <= m0+n; i++)\r\n        fg[i] = ((ii = P_col[i]) <= m ? a[ii] : 0.0);\r\n    /* (v w) := Q * (ej 0) */\r\n    for (i = 1; i <= m0+n; i++) vw[i] = 0.0;\r\n    vw[Q_col[j]] = 1.0;\r\n    /* f1 := inv(L0) * f (new column of R) */\r\n    luf_f_solve(lpf.luf, 0, f);\r\n    /* v1 := inv(U'0) * v (new row of S) */\r\n    luf_v_solve(lpf.luf, 1, v);\r\n    /* we need at most 2 * m0 available locations in the SVA to store\r\n     new column of matrix R and new row of matrix S */\r\n    if (lpf.v_size < v_ptr + m0 + m0)\r\n    {  enlarge_sva(lpf, v_ptr + m0 + m0);\r\n        v_ind = lpf.v_ind;\r\n        v_val = lpf.v_val;\r\n    }\r\n    /* store new column of R */\r\n    R_ptr[n+1] = v_ptr;\r\n    for (i = 1; i <= m0; i++)\r\n    {  if (f[i] != 0.0){\r\n        v_ind[v_ptr] = i; v_val[v_ptr] = f[i]; v_ptr++;\r\n    }\r\n\r\n    }\r\n    R_len[n+1] = v_ptr - lpf.v_ptr;\r\n    lpf.v_ptr = v_ptr;\r\n    /* store new row of S */\r\n    S_ptr[n+1] = v_ptr;\r\n    for (i = 1; i <= m0; i++)\r\n    {  if (v[i] != 0.0){\r\n        v_ind[v_ptr] = i; v_val[v_ptr] = v[i]; v_ptr++;\r\n    }\r\n\r\n    }\r\n    S_len[n+1] = v_ptr - lpf.v_ptr;\r\n    lpf.v_ptr = v_ptr;\r\n    /* x := g - S * f1 (new column of C) */\r\n    s_prod(lpf, x, 0, -1.0, f);\r\n    /* y := w - R' * v1 (new row of C) */\r\n    rt_prod(lpf, y, 0, -1.0, v);\r\n    /* z := - v1 * f1 (new diagonal element of C) */\r\n    z = 0.0;\r\n    for (i = 1; i <= m0; i++) z -= v[i] * f[i];\r\n    /* update factorization of new matrix C */\r\n    switch (scf_update_exp(lpf.scf, x, m0, y, m0, z))\r\n    {  case 0:\r\n        break;\r\n        case SCF_ESING:\r\n            lpf.valid = 0;\r\n            ret = LPF_ESING;\r\n            return ret;\r\n        case SCF_ELIMIT:\r\n            xassert(lpf != lpf);\r\n        default:\r\n            xassert(lpf != lpf);\r\n    }\r\n    /* expand matrix P */\r\n    P_row[m0+n+1] = P_col[m0+n+1] = m0+n+1;\r\n    /* expand matrix Q */\r\n    Q_row[m0+n+1] = Q_col[m0+n+1] = m0+n+1;\r\n    /* permute j-th and last (just added) column of matrix Q */\r\n    i = Q_col[j]; ii = Q_col[m0+n+1];\r\n    Q_row[i] = m0+n+1; Q_col[m0+n+1] = i;\r\n    Q_row[ii] = j; Q_col[j] = ii;\r\n    /* increase the number of additional rows and columns */\r\n    lpf.n++;\r\n    xassert(lpf.n <= lpf.n_max);\r\n    /* the factorization has been successfully updated */\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nvar\r\n/* problem class: */\r\n/** @const */LPX_LP = exports[\"LPX_LP\"] = 100, /* linear programming (LP) */\r\n/** @const */LPX_MIP = exports[\"LPX_MIP\"] = 101, /* mixed integer programming (MIP) */\r\n\r\n    /* type of auxiliary/structural variable: */\r\n/** @const */LPX_FR = exports[\"LPX_FR\"] = 110, /* free variable */\r\n/** @const */LPX_LO = exports[\"LPX_LO\"] = 111, /* variable with lower bound */\r\n/** @const */LPX_UP = exports[\"LPX_UP\"] = 112, /* variable with upper bound */\r\n/** @const */LPX_DB = exports[\"LPX_DB\"] = 113, /* double-bounded variable */\r\n/** @const */LPX_FX = exports[\"LPX_FX\"] = 114, /* fixed variable */\r\n\r\n    /* optimization direction flag: */\r\n/** @const */LPX_MIN = exports[\"LPX_MIN\"] = 120, /* minimization */\r\n/** @const */LPX_MAX = exports[\"LPX_MAX\"] = 121, /* maximization */\r\n\r\n    /* status of primal basic solution: */\r\n/** @const */LPX_P_UNDEF = exports[\"LPX_P_UNDEF\"] = 132, /* primal solution is undefined */\r\n/** @const */LPX_P_FEAS = exports[\"LPX_P_FEAS\"] = 133, /* solution is primal feasible */\r\n/** @const */LPX_P_INFEAS = exports[\"LPX_P_INFEAS\"] = 134, /* solution is primal infeasible */\r\n/** @const */LPX_P_NOFEAS = exports[\"LPX_P_NOFEAS\"] = 135, /* no primal feasible solution exists */\r\n\r\n    /* status of dual basic solution: */\r\n/** @const */LPX_D_UNDEF = exports[\"LPX_D_UNDEF\"] = 136, /* dual solution is undefined */\r\n/** @const */LPX_D_FEAS = exports[\"LPX_D_FEAS\"] = 137, /* solution is dual feasible */\r\n/** @const */LPX_D_INFEAS = exports[\"LPX_D_INFEAS\"] = 138, /* solution is dual infeasible */\r\n/** @const */LPX_D_NOFEAS = exports[\"LPX_D_NOFEAS\"] = 139, /* no dual feasible solution exists */\r\n\r\n    /* status of auxiliary/structural variable: */\r\n/** @const */LPX_BS = exports[\"LPX_BS\"] = 140, /* basic variable */\r\n/** @const */LPX_NL = exports[\"LPX_NL\"] = 141, /* non-basic variable on lower bound */\r\n/** @const */LPX_NU = exports[\"LPX_NU\"] = 142, /* non-basic variable on upper bound */\r\n/** @const */LPX_NF = exports[\"LPX_NF\"] = 143, /* non-basic free variable */\r\n/** @const */LPX_NS = exports[\"LPX_NS\"] = 144, /* non-basic fixed variable */\r\n\r\n    /* status of interior-point solution: */\r\n/** @const */LPX_T_UNDEF = exports[\"LPX_T_UNDEF\"] = 150, /* interior solution is undefined */\r\n/** @const */LPX_T_OPT = exports[\"LPX_T_OPT\"] = 151, /* interior solution is optimal */\r\n\r\n    /* kind of structural variable: */\r\n/** @const */LPX_CV = exports[\"LPX_CV\"] = 160, /* continuous variable */\r\n/** @const */LPX_IV = exports[\"LPX_IV\"] = 161, /* integer variable */\r\n\r\n    /* status of integer solution: */\r\n/** @const */LPX_I_UNDEF = exports[\"LPX_I_UNDEF\"] = 170, /* integer solution is undefined */\r\n/** @const */LPX_I_OPT = exports[\"LPX_I_OPT\"] = 171, /* integer solution is optimal */\r\n/** @const */LPX_I_FEAS = exports[\"LPX_I_FEAS\"] = 172, /* integer solution is feasible */\r\n/** @const */LPX_I_NOFEAS = exports[\"LPX_I_NOFEAS\"] = 173, /* no integer solution exists */\r\n\r\n    /* status codes reported by the routine lpx_get_status: */\r\n/** @const */LPX_OPT = exports[\"LPX_OPT\"] = 180, /* optimal */\r\n/** @const */LPX_FEAS = exports[\"LPX_FEAS\"] = 181, /* feasible */\r\n/** @const */LPX_INFEAS = exports[\"LPX_INFEAS\"] = 182, /* infeasible */\r\n/** @const */LPX_NOFEAS = exports[\"LPX_NOFEAS\"] = 183, /* no feasible */\r\n/** @const */LPX_UNBND = exports[\"LPX_UNBND\"] = 184, /* unbounded */\r\n/** @const */LPX_UNDEF = exports[\"LPX_UNDEF\"] = 185, /* undefined */\r\n\r\n    /* exit codes returned by solver routines: */\r\n/** @const */LPX_E_OK = exports[\"LPX_E_OK\"] = 200, /* success */\r\n/** @const */LPX_E_EMPTY = exports[\"LPX_E_EMPTY\"] = 201, /* empty problem */\r\n/** @const */LPX_E_BADB = exports[\"LPX_E_BADB\"] = 202, /* invalid initial basis */\r\n/** @const */LPX_E_INFEAS = exports[\"LPX_E_INFEAS\"] = 203, /* infeasible initial solution */\r\n/** @const */LPX_E_FAULT = exports[\"LPX_E_FAULT\"] = 204, /* unable to start the search */\r\n/** @const */LPX_E_OBJLL = exports[\"LPX_E_OBJLL\"] = 205, /* objective lower limit reached */\r\n/** @const */LPX_E_OBJUL = exports[\"LPX_E_OBJUL\"] = 206, /* objective upper limit reached */\r\n/** @const */LPX_E_ITLIM = exports[\"LPX_E_ITLIM\"] = 207, /* iterations limit exhausted */\r\n/** @const */LPX_E_TMLIM = exports[\"LPX_E_TMLIM\"] = 208, /* time limit exhausted */\r\n/** @const */LPX_E_NOFEAS = exports[\"LPX_E_NOFEAS\"] = 209, /* no feasible solution */\r\n/** @const */LPX_E_INSTAB = exports[\"LPX_E_INSTAB\"] = 210, /* numerical instability */\r\n/** @const */LPX_E_SING = exports[\"LPX_E_SING\"] = 211, /* problems with basis matrix */\r\n/** @const */LPX_E_NOCONV = exports[\"LPX_E_NOCONV\"] = 212, /* no convergence (interior) */\r\n/** @const */LPX_E_NOPFS = exports[\"LPX_E_NOPFS\"] = 213, /* no primal feas. sol. (LP presolver) */\r\n/** @const */LPX_E_NODFS = exports[\"LPX_E_NODFS\"] = 214, /* no dual feas. sol. (LP presolver) */\r\n/** @const */LPX_E_MIPGAP = exports[\"LPX_E_MIPGAP\"] = 215, /* relative mip gap tolerance reached */\r\n\r\n    /* control parameter identifiers: */\r\n/** @const */LPX_K_MSGLEV = exports[\"LPX_K_MSGLEV\"] = 300, /* lp.msg_lev */\r\n/** @const */LPX_K_SCALE = exports[\"LPX_K_SCALE\"] = 301, /* lp.scale */\r\n/** @const */LPX_K_DUAL = exports[\"LPX_K_DUAL\"] = 302, /* lp.dual */\r\n/** @const */LPX_K_PRICE = exports[\"LPX_K_PRICE\"] = 303, /* lp.price */\r\n/** @const */LPX_K_RELAX = exports[\"LPX_K_RELAX\"] = 304, /* lp.relax */\r\n/** @const */LPX_K_TOLBND = exports[\"LPX_K_TOLBND\"] = 305, /* lp.tol_bnd */\r\n/** @const */LPX_K_TOLDJ = exports[\"LPX_K_TOLDJ\"] = 306, /* lp.tol_dj */\r\n/** @const */LPX_K_TOLPIV = exports[\"LPX_K_TOLPIV\"] = 307, /* lp.tol_piv */\r\n/** @const */LPX_K_ROUND = exports[\"LPX_K_ROUND\"] = 308, /* lp.round */\r\n/** @const */LPX_K_OBJLL = exports[\"LPX_K_OBJLL\"] = 309, /* lp.obj_ll */\r\n/** @const */LPX_K_OBJUL = exports[\"LPX_K_OBJUL\"] = 310, /* lp.obj_ul */\r\n/** @const */LPX_K_ITLIM = exports[\"LPX_K_ITLIM\"] = 311, /* lp.it_lim */\r\n/** @const */LPX_K_ITCNT = exports[\"LPX_K_ITCNT\"] = 312, /* lp.it_cnt */\r\n/** @const */LPX_K_TMLIM = exports[\"LPX_K_TMLIM\"] = 313, /* lp.tm_lim */\r\n/** @const */LPX_K_OUTFRQ = exports[\"LPX_K_OUTFRQ\"] = 314, /* lp.out_frq */\r\n/** @const */LPX_K_OUTDLY = exports[\"LPX_K_OUTDLY\"] = 315, /* lp.out_dly */\r\n/** @const */LPX_K_BRANCH = exports[\"LPX_K_BRANCH\"] = 316, /* lp.branch */\r\n/** @const */LPX_K_BTRACK = exports[\"LPX_K_BTRACK\"] = 317, /* lp.btrack */\r\n/** @const */LPX_K_TOLINT = exports[\"LPX_K_TOLINT\"] = 318, /* lp.tol_int */\r\n/** @const */LPX_K_TOLOBJ = exports[\"LPX_K_TOLOBJ\"] = 319, /* lp.tol_obj */\r\n/** @const */LPX_K_MPSINFO = exports[\"LPX_K_MPSINFO\"] = 320, /* lp.mps_info */\r\n/** @const */LPX_K_MPSOBJ = exports[\"LPX_K_MPSOBJ\"] = 321, /* lp.mps_obj */\r\n/** @const */LPX_K_MPSORIG = exports[\"LPX_K_MPSORIG\"] = 322, /* lp.mps_orig */\r\n/** @const */LPX_K_MPSWIDE = exports[\"LPX_K_MPSWIDE\"] = 323, /* lp.mps_wide */\r\n/** @const */LPX_K_MPSFREE = exports[\"LPX_K_MPSFREE\"] = 324, /* lp.mps_free */\r\n/** @const */LPX_K_MPSSKIP = exports[\"LPX_K_MPSSKIP\"] = 325, /* lp.mps_skip */\r\n/** @const */LPX_K_LPTORIG = exports[\"LPX_K_LPTORIG\"] = 326, /* lp.lpt_orig */\r\n/** @const */LPX_K_PRESOL = exports[\"LPX_K_PRESOL\"] = 327, /* lp.presol */\r\n/** @const */LPX_K_BINARIZE = exports[\"LPX_K_BINARIZE\"] = 328, /* lp.binarize */\r\n/** @const */LPX_K_USECUTS = exports[\"LPX_K_USECUTS\"] = 329, /* lp.use_cuts */\r\n/** @const */LPX_K_BFTYPE = exports[\"LPX_K_BFTYPE\"] = 330, /* lp.bfcp.type */\r\n/** @const */LPX_K_MIPGAP = exports[\"LPX_K_MIPGAP\"] = 331, /* lp.mip_gap */\r\n\r\n/** @const */LPX_C_COVER = exports[\"LPX_C_COVER\"] = 0x01, /* mixed cover cuts */\r\n/** @const */LPX_C_CLIQUE = exports[\"LPX_C_CLIQUE\"] = 0x02, /* clique cuts */\r\n/** @const */LPX_C_GOMORY = exports[\"LPX_C_GOMORY\"] = 0x04, /* Gomory's mixed integer cuts */\r\n/** @const */LPX_C_MIR = exports[\"LPX_C_MIR\"] = 0x08, /* mixed integer rounding cuts */\r\n/** @const */LPX_C_ALL = exports[\"LPX_C_ALL\"] = 0xFF;\r\nfunction lpx_create_prob(){\r\n    /* create problem object */\r\n    return glp_create_prob();\r\n}\r\n\r\nfunction lpx_set_prob_name(lp, name)\r\n{     /* assign (change) problem name */\r\n    glp_set_prob_name(lp, name);\r\n}\r\n\r\nfunction lpx_set_obj_name(lp, name){\r\n    /* assign (change) objective function name */\r\n    glp_set_obj_name(lp, name);\r\n}\r\n\r\nfunction lpx_set_obj_dir(lp, dir){\r\n    /* set (change) optimization direction flag */\r\n    glp_set_obj_dir(lp, dir - LPX_MIN + GLP_MIN);\r\n}\r\n\r\nfunction lpx_add_rows(lp, nrs){\r\n    /* add new rows to problem object */\r\n    return glp_add_rows(lp, nrs);\r\n}\r\n\r\nfunction lpx_add_cols(lp, ncs){\r\n    /* add new columns to problem object */\r\n    return glp_add_cols(lp, ncs);\r\n}\r\n\r\nfunction lpx_set_row_name(lp, i, name)\r\n{     /* assign (change) row name */\r\n    glp_set_row_name(lp, i, name);\r\n}\r\n\r\nfunction lpx_set_col_name(lp, j, name){\r\n    /* assign (change) column name */\r\n    glp_set_col_name(lp, j, name);\r\n}\r\n\r\nfunction lpx_set_row_bnds(lp, i, type, lb, ub){\r\n    /* set (change) row bounds */\r\n    glp_set_row_bnds(lp, i, type - LPX_FR + GLP_FR, lb, ub);\r\n}\r\n\r\nfunction lpx_set_col_bnds(lp, j, type, lb, ub){\r\n    /* set (change) column bounds */\r\n    glp_set_col_bnds(lp, j, type - LPX_FR + GLP_FR, lb, ub);\r\n}\r\n\r\nfunction lpx_set_obj_coef(lp, j, coef){\r\n    /* set (change) obj. coefficient or constant term */\r\n    glp_set_obj_coef(lp, j, coef);\r\n}\r\n\r\nfunction lpx_set_mat_row(lp, i, len, ind, val){\r\n    /* set (replace) row of the constraint matrix */\r\n    glp_set_mat_row(lp, i, len, ind, val);\r\n}\r\n\r\nfunction lpx_set_mat_col(lp, j, len, ind, val){\r\n    /* set (replace) column of the constraint matrix */\r\n    glp_set_mat_col(lp, j, len, ind, val);\r\n}\r\n\r\nfunction lpx_load_matrix(lp, ne, ia, ja, ar){\r\n    /* load (replace) the whole constraint matrix */\r\n    glp_load_matrix(lp, ne, ia, ja, ar);\r\n}\r\n\r\nfunction lpx_del_rows(lp, nrs, num){\r\n    /* delete specified rows from problem object */\r\n    glp_del_rows(lp, nrs, num);\r\n}\r\n\r\nfunction lpx_del_cols(lp, ncs, num){\r\n    /* delete specified columns from problem object */\r\n    glp_del_cols(lp, ncs, num);\r\n}\r\n\r\nfunction lpx_get_prob_name(lp){\r\n    /* retrieve problem name */\r\n    return glp_get_prob_name(lp);\r\n}\r\n\r\nfunction lpx_get_obj_name(lp){\r\n    /* retrieve objective function name */\r\n    return glp_get_obj_name(lp);\r\n}\r\n\r\nfunction lpx_get_obj_dir(lp){\r\n    /* retrieve optimization direction flag */\r\n    return glp_get_obj_dir(lp) - GLP_MIN + LPX_MIN;\r\n}\r\n\r\nfunction lpx_get_num_rows(lp){\r\n    /* retrieve number of rows */\r\n    return glp_get_num_rows(lp);\r\n}\r\n\r\nfunction lpx_get_num_cols(lp){\r\n    /* retrieve number of columns */\r\n    return glp_get_num_cols(lp);\r\n}\r\n\r\nfunction lpx_get_row_name(lp, i){\r\n    /* retrieve row name */\r\n    return glp_get_row_name(lp, i);\r\n}\r\n\r\nfunction lpx_get_col_name(lp, j){\r\n    /* retrieve column name */\r\n    return glp_get_col_name(lp, j);\r\n}\r\n\r\nfunction lpx_get_row_type(lp, i){\r\n    /* retrieve row type */\r\n    return glp_get_row_type(lp, i) - GLP_FR + LPX_FR;\r\n}\r\n\r\nfunction lpx_get_row_lb(lp, i){\r\n    /* retrieve row lower bound */\r\n    var lb = glp_get_row_lb(lp, i);\r\n    if (lb == -DBL_MAX) lb = 0.0;\r\n    return lb;\r\n}\r\n\r\nfunction lpx_get_row_ub(lp, i){\r\n    /* retrieve row upper bound */\r\n    var ub = glp_get_row_ub(lp, i);\r\n    if (ub == +DBL_MAX) ub = 0.0;\r\n    return ub;\r\n}\r\n\r\nfunction lpx_get_row_bnds(lp, i, callback){\r\n    /* retrieve row bounds */\r\n    callback(lpx_get_row_type(lp, i), lpx_get_row_lb(lp, i), lpx_get_row_ub(lp, i));\r\n}\r\n\r\nfunction lpx_get_col_type(lp, j){\r\n    /* retrieve column type */\r\n    return glp_get_col_type(lp, j) - GLP_FR + LPX_FR;\r\n}\r\n\r\nfunction lpx_get_col_lb(lp, j){\r\n    /* retrieve column lower bound */\r\n    var lb = glp_get_col_lb(lp, j);\r\n    if (lb == -DBL_MAX) lb = 0.0;\r\n    return lb;\r\n}\r\n\r\nfunction lpx_get_col_ub(lp, j){\r\n    /* retrieve column upper bound */\r\n    var ub = glp_get_col_ub(lp, j);\r\n    if (ub == +DBL_MAX) ub = 0.0;\r\n    return ub;\r\n}\r\n\r\nfunction lpx_get_col_bnds(lp, j, callback)\r\n{     /* retrieve column bounds */\r\n    callback(lpx_get_col_type(lp, j), lpx_get_col_lb(lp, j), lpx_get_col_ub(lp, j));\r\n}\r\n\r\nfunction lpx_get_obj_coef(lp, j){\r\n    /* retrieve obj. coefficient or constant term */\r\n    return glp_get_obj_coef(lp, j);\r\n}\r\n\r\nfunction lpx_get_num_nz(lp){\r\n    /* retrieve number of constraint coefficients */\r\n    return glp_get_num_nz(lp);\r\n}\r\n\r\nfunction lpx_get_mat_row(lp, i, ind, val){\r\n    /* retrieve row of the constraint matrix */\r\n    return glp_get_mat_row(lp, i, ind, val);\r\n}\r\n\r\nfunction lpx_get_mat_col(lp, j, ind, val){\r\n    /* retrieve column of the constraint matrix */\r\n    return glp_get_mat_col(lp, j, ind, val);\r\n}\r\n\r\nfunction lpx_create_index(lp){\r\n    /* create the name index */\r\n    glp_create_index(lp);\r\n}\r\n\r\nfunction lpx_find_row(lp, name){\r\n    /* find row by its name */\r\n    return glp_find_row(lp, name);\r\n}\r\n\r\nfunction lpx_find_col(lp, name){\r\n    /* find column by its name */\r\n    return glp_find_col(lp, name);\r\n}\r\n\r\nfunction lpx_delete_index(lp){\r\n    /* delete the name index */\r\n    glp_delete_index(lp);\r\n}\r\n\r\nfunction lpx_scale_prob(lp){\r\n    /* scale problem data */\r\n    switch (lpx_get_int_parm(lp, LPX_K_SCALE))\r\n    {  case 0:\r\n        /* no scaling */\r\n        glp_unscale_prob(lp);\r\n        break;\r\n        case 1:\r\n            /* equilibration scaling */\r\n            glp_scale_prob(lp, GLP_SF_EQ);\r\n            break;\r\n        case 2:\r\n            /* geometric mean scaling */\r\n            glp_scale_prob(lp, GLP_SF_GM);\r\n            break;\r\n        case 3:\r\n            /* geometric mean scaling, then equilibration scaling */\r\n            glp_scale_prob(lp, GLP_SF_GM | GLP_SF_EQ);\r\n            break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n}\r\n\r\nfunction lpx_unscale_prob(lp){\r\n    /* unscale problem data */\r\n    glp_unscale_prob(lp);\r\n}\r\n\r\nfunction lpx_set_row_stat(lp, i, stat){\r\n    /* set (change) row status */\r\n    glp_set_row_stat(lp, i, stat - LPX_BS + GLP_BS);\r\n}\r\n\r\nfunction lpx_set_col_stat(lp, j, stat){\r\n    /* set (change) column status */\r\n    glp_set_col_stat(lp, j, stat - LPX_BS + GLP_BS);\r\n}\r\n\r\nfunction lpx_std_basis(lp){\r\n    /* construct standard initial LP basis */\r\n    glp_std_basis(lp);\r\n}\r\n\r\nfunction lpx_adv_basis(lp){\r\n    /* construct advanced initial LP basis */\r\n    glp_adv_basis(lp, 0);\r\n}\r\n\r\nfunction lpx_cpx_basis(lp){\r\n    /* construct Bixby's initial LP basis */\r\n    glp_cpx_basis(lp);\r\n}\r\n\r\nfunction fill_smcp(lp, parm){\r\n    //glp_init_smcp(parm);\r\n    switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\r\n    {  case 0:  parm.msg_lev = GLP_MSG_OFF;   break;\r\n        case 1:  parm.msg_lev = GLP_MSG_ERR;   break;\r\n        case 2:  parm.msg_lev = GLP_MSG_ON;    break;\r\n        case 3:  parm.msg_lev = GLP_MSG_ALL;   break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_DUAL))\r\n    {  case 0:  parm.meth = GLP_PRIMAL;       break;\r\n        case 1:  parm.meth = GLP_DUAL;         break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_PRICE))\r\n    {  case 0:  parm.pricing = GLP_PT_STD;    break;\r\n        case 1:  parm.pricing = GLP_PT_PSE;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    if (lpx_get_real_parm(lp, LPX_K_RELAX) == 0.0)\r\n        parm.r_test = GLP_RT_STD;\r\n    else\r\n        parm.r_test = GLP_RT_HAR;\r\n    parm.tol_bnd = lpx_get_real_parm(lp, LPX_K_TOLBND);\r\n    parm.tol_dj  = lpx_get_real_parm(lp, LPX_K_TOLDJ);\r\n    parm.tol_piv = lpx_get_real_parm(lp, LPX_K_TOLPIV);\r\n    parm.obj_ll  = lpx_get_real_parm(lp, LPX_K_OBJLL);\r\n    parm.obj_ul  = lpx_get_real_parm(lp, LPX_K_OBJUL);\r\n    if (lpx_get_int_parm(lp, LPX_K_ITLIM) < 0)\r\n        parm.it_lim = INT_MAX;\r\n    else\r\n        parm.it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);\r\n    if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0)\r\n        parm.tm_lim = INT_MAX;\r\n    else\r\n        parm.tm_lim = (1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM))|0;\r\n    parm.out_frq = lpx_get_int_parm(lp, LPX_K_OUTFRQ);\r\n    parm.out_dly = (1000.0 * lpx_get_real_parm(lp, LPX_K_OUTDLY))|0;\r\n    switch (lpx_get_int_parm(lp, LPX_K_PRESOL))\r\n    {  case 0:  parm.presolve = GLP_OFF;      break;\r\n        case 1:  parm.presolve = GLP_ON;       break;\r\n        default: xassert(lp != lp);\r\n    }\r\n}\r\n\r\nfunction lpx_simplex(lp){\r\n    /* easy-to-use driver to the simplex method */\r\n    var parm = new SMCP();\r\n    var ret;\r\n    fill_smcp(lp, parm);\r\n    ret = glp_simplex(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EBADB:\r\n        case GLP_ESING:\r\n        case GLP_ECOND:\r\n        case GLP_EBOUND:  ret = LPX_E_FAULT;   break;\r\n        case GLP_EFAIL:   ret = LPX_E_SING;    break;\r\n        case GLP_EOBJLL:  ret = LPX_E_OBJLL;   break;\r\n        case GLP_EOBJUL:  ret = LPX_E_OBJUL;   break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\r\n        case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_exact(lp){\r\n    /* easy-to-use driver to the exact simplex method */\r\n    var parm = new SMCP();\r\n    var ret;\r\n    fill_smcp(lp, parm);\r\n    ret = glp_exact(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EBADB:\r\n        case GLP_ESING:\r\n        case GLP_EBOUND:\r\n        case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_get_status(lp){\r\n    /* retrieve generic status of basic solution */\r\n    var status;\r\n    switch (glp_get_status(lp))\r\n    {  case GLP_OPT:    status = LPX_OPT;    break;\r\n        case GLP_FEAS:   status = LPX_FEAS;   break;\r\n        case GLP_INFEAS: status = LPX_INFEAS; break;\r\n        case GLP_NOFEAS: status = LPX_NOFEAS; break;\r\n        case GLP_UNBND:  status = LPX_UNBND;  break;\r\n        case GLP_UNDEF:  status = LPX_UNDEF;  break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_get_prim_stat(lp){\r\n    /* retrieve status of primal basic solution */\r\n    return glp_get_prim_stat(lp) - GLP_UNDEF + LPX_P_UNDEF;\r\n}\r\n\r\nfunction lpx_get_dual_stat(lp){\r\n    /* retrieve status of dual basic solution */\r\n    return glp_get_dual_stat(lp) - GLP_UNDEF + LPX_D_UNDEF;\r\n}\r\n\r\nfunction lpx_get_obj_val(lp){\r\n    /* retrieve objective value (basic solution) */\r\n    return glp_get_obj_val(lp);\r\n}\r\n\r\nfunction lpx_get_row_stat(lp, i){\r\n    /* retrieve row status (basic solution) */\r\n    return glp_get_row_stat(lp, i) - GLP_BS + LPX_BS;\r\n}\r\n\r\nfunction lpx_get_row_prim(lp, i){\r\n    /* retrieve row primal value (basic solution) */\r\n    return glp_get_row_prim(lp, i);\r\n}\r\n\r\nfunction lpx_get_row_dual(lp, i){\r\n    /* retrieve row dual value (basic solution) */\r\n    return glp_get_row_dual(lp, i);\r\n}\r\n\r\nfunction lpx_get_row_info(lp, i, callback){\r\n    /* obtain row solution information */\r\n    callback(lpx_get_row_stat(lp, i), lpx_get_row_prim(lp, i), lpx_get_row_dual(lp, i))\r\n}\r\n\r\nfunction lpx_get_col_stat(lp, j){\r\n    /* retrieve column status (basic solution) */\r\n    return glp_get_col_stat(lp, j) - GLP_BS + LPX_BS;\r\n}\r\n\r\nfunction lpx_get_col_prim(lp, j){\r\n    /* retrieve column primal value (basic solution) */\r\n    return glp_get_col_prim(lp, j);\r\n}\r\n\r\nfunction lpx_get_col_dual(lp, j){\r\n    /* retrieve column dual value (basic solution) */\r\n    return glp_get_col_dual(lp, j);\r\n}\r\n\r\nfunction lpx_get_col_info(lp, j, callback){\r\n    /* obtain column solution information */\r\n    callback(lpx_get_col_stat(lp, j), lpx_get_col_prim(lp, j), lpx_get_col_dual(lp, j));\r\n}\r\n\r\nfunction lpx_get_ray_info(lp){\r\n    /* determine what causes primal unboundness */\r\n    return glp_get_unbnd_ray(lp);\r\n}\r\n\r\nfunction lpx_check_kkt(lp, scaled, kkt){\r\n    /* check Karush-Kuhn-Tucker conditions */\r\n    xassert(scaled == scaled);\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_PE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pe_ae_max = ae_max;\r\n            kkt.pe_ae_row = ae_ind;\r\n            kkt.pe_re_max = re_max;\r\n            kkt.pe_re_row = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pe_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pe_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pe_quality = 'L';\r\n            else\r\n                kkt.pe_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_PB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pb_ae_max = ae_max;\r\n            kkt.pb_ae_ind = ae_ind;\r\n            kkt.pb_re_max = re_max;\r\n            kkt.pb_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pb_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pb_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pb_quality = 'L';\r\n            else\r\n                kkt.pb_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_DE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.de_ae_max = ae_max;\r\n            if (ae_ind == 0)\r\n                kkt.de_ae_col = 0;\r\n            else\r\n                kkt.de_ae_col = ae_ind - lp.m;\r\n            kkt.de_re_max = re_max;\r\n            if (re_ind == 0)\r\n                kkt.de_re_col = 0;\r\n            else\r\n                kkt.de_re_col = ae_ind - lp.m;\r\n            if (re_max <= 1e-9)\r\n                kkt.de_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.de_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.de_quality = 'L';\r\n            else\r\n                kkt.de_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_DB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.db_ae_max = ae_max;\r\n            kkt.db_ae_ind = ae_ind;\r\n            kkt.db_re_max = re_max;\r\n            kkt.db_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.db_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.db_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.db_quality = 'L';\r\n            else\r\n                kkt.db_quality = '?';\r\n            kkt.cs_ae_max = 0.0; kkt.cs_ae_ind = 0;\r\n            kkt.cs_re_max = 0.0; kkt.cs_re_ind = 0;\r\n            kkt.cs_quality = 'H';\r\n        }\r\n    );\r\n}\r\n\r\nfunction lpx_warm_up(lp){\r\n    /* \"warm up\" LP basis */\r\n    var ret = glp_warm_up(lp);\r\n    if (ret == 0)\r\n        ret = LPX_E_OK;\r\n    else if (ret == GLP_EBADB)\r\n        ret = LPX_E_BADB;\r\n    else if (ret == GLP_ESING)\r\n        ret = LPX_E_SING;\r\n    else if (ret == GLP_ECOND)\r\n        ret = LPX_E_SING;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n}\r\n\r\nfunction lpx_eval_tab_row(lp, k, ind, val){\r\n    /* compute row of the simplex tableau */\r\n    return glp_eval_tab_row(lp, k, ind, val);\r\n}\r\n\r\nfunction lpx_eval_tab_col(lp, k, ind, val){\r\n    /* compute column of the simplex tableau */\r\n    return glp_eval_tab_col(lp, k, ind, val);\r\n}\r\n\r\nfunction lpx_transform_row(lp, len, ind, val){\r\n    /* transform explicitly specified row */\r\n    return glp_transform_row(lp, len, ind, val);\r\n}\r\n\r\nfunction lpx_transform_col(lp, len, ind, val){\r\n    /* transform explicitly specified column */\r\n    return glp_transform_col(lp, len, ind, val);\r\n}\r\n\r\nfunction lpx_prim_ratio_test(lp, len, ind, val, how, tol){\r\n    /* perform primal ratio test */\r\n    var piv = glp_prim_rtest(lp, len, ind, val, how, tol);\r\n    xassert(0 <= piv && piv <= len);\r\n    return piv == 0 ? 0 : ind[piv];\r\n}\r\n\r\nfunction lpx_dual_ratio_test(lp, len, ind, val, how, tol){\r\n    /* perform dual ratio test */\r\n    var piv = glp_dual_rtest(lp, len, ind, val, how, tol);\r\n    xassert(0 <= piv && piv <= len);\r\n    return piv == 0 ? 0 : ind[piv];\r\n}\r\n\r\nfunction lpx_interior(lp){\r\n    /* easy-to-use driver to the interior-point method */\r\n    var ret = glp_interior(lp, null);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\r\n        case GLP_ENOFEAS: ret = LPX_E_NOFEAS;  break;\r\n        case GLP_ENOCVG:  ret = LPX_E_NOCONV;  break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_EINSTAB: ret = LPX_E_INSTAB;  break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_ipt_status(lp){\r\n    /* retrieve status of interior-point solution */\r\n    var status;\r\n    switch (glp_ipt_status(lp))\r\n    {  case GLP_UNDEF:  status = LPX_T_UNDEF;  break;\r\n        case GLP_OPT:    status = LPX_T_OPT;    break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_ipt_obj_val(lp){\r\n    /* retrieve objective value (interior point) */\r\n    return glp_ipt_obj_val(lp);\r\n}\r\n\r\nfunction lpx_ipt_row_prim(lp, i){\r\n    /* retrieve row primal value (interior point) */\r\n    return glp_ipt_row_prim(lp, i);\r\n}\r\n\r\nfunction lpx_ipt_row_dual(lp, i){\r\n    /* retrieve row dual value (interior point) */\r\n    return glp_ipt_row_dual(lp, i);\r\n}\r\n\r\nfunction lpx_ipt_col_prim(lp, j){\r\n    /* retrieve column primal value (interior point) */\r\n    return glp_ipt_col_prim(lp, j);\r\n}\r\n\r\nfunction lpx_ipt_col_dual(lp, j){\r\n    /* retrieve column dual value (interior point) */\r\n    return glp_ipt_col_dual(lp, j);\r\n}\r\n\r\nfunction lpx_set_class(lp, klass){\r\n    /* set problem class */\r\n    xassert(lp == lp);\r\n    if (!(klass == LPX_LP || klass == LPX_MIP))\r\n        xerror(\"lpx_set_class: invalid problem class\");\r\n}\r\n\r\nfunction lpx_get_class(lp){\r\n    /* determine problem klass */\r\n    return glp_get_num_int(lp) == 0 ? LPX_LP : LPX_MIP;\r\n}\r\n\r\nfunction lpx_set_col_kind(lp, j, kind){\r\n    /* set (change) column kind */\r\n    glp_set_col_kind(lp, j, kind - LPX_CV + GLP_CV);\r\n}\r\n\r\nfunction lpx_get_col_kind(lp, j){\r\n    /* retrieve column kind */\r\n    return glp_get_col_kind(lp, j) == GLP_CV ? LPX_CV : LPX_IV;\r\n}\r\n\r\nfunction lpx_get_num_int(lp){\r\n    /* retrieve number of integer columns */\r\n    return glp_get_num_int(lp);\r\n}\r\n\r\nfunction lpx_get_num_bin(lp){\r\n    /* retrieve number of binary columns */\r\n    return glp_get_num_bin(lp);\r\n}\r\n\r\nfunction solve_mip(lp, presolve){\r\n    var parm = new IOCP();\r\n    var ret;\r\n    //glp_init_iocp(parm);\r\n    switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\r\n    {  case 0:  parm.msg_lev = GLP_MSG_OFF;   break;\r\n        case 1:  parm.msg_lev = GLP_MSG_ERR;   break;\r\n        case 2:  parm.msg_lev = GLP_MSG_ON;    break;\r\n        case 3:  parm.msg_lev = GLP_MSG_ALL;   break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_BRANCH))\r\n    {  case 0:  parm.br_tech = GLP_BR_FFV;    break;\r\n        case 1:  parm.br_tech = GLP_BR_LFV;    break;\r\n        case 2:  parm.br_tech = GLP_BR_DTH;    break;\r\n        case 3:  parm.br_tech = GLP_BR_MFV;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_BTRACK))\r\n    {  case 0:  parm.bt_tech = GLP_BT_DFS;    break;\r\n        case 1:  parm.bt_tech = GLP_BT_BFS;    break;\r\n        case 2:  parm.bt_tech = GLP_BT_BPH;    break;\r\n        case 3:  parm.bt_tech = GLP_BT_BLB;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    parm.tol_int = lpx_get_real_parm(lp, LPX_K_TOLINT);\r\n    parm.tol_obj = lpx_get_real_parm(lp, LPX_K_TOLOBJ);\r\n    if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0 ||\r\n        lpx_get_real_parm(lp, LPX_K_TMLIM) > 1e6)\r\n        parm.tm_lim = INT_MAX;\r\n    else\r\n        parm.tm_lim = (1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM))|0;\r\n    parm.mip_gap = lpx_get_real_parm(lp, LPX_K_MIPGAP);\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_GOMORY)\r\n        parm.gmi_cuts = GLP_ON;\r\n    else\r\n        parm.gmi_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_MIR)\r\n        parm.mir_cuts = GLP_ON;\r\n    else\r\n        parm.mir_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_COVER)\r\n        parm.cov_cuts = GLP_ON;\r\n    else\r\n        parm.cov_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_CLIQUE)\r\n        parm.clq_cuts = GLP_ON;\r\n    else\r\n        parm.clq_cuts = GLP_OFF;\r\n    parm.presolve = presolve;\r\n    if (lpx_get_int_parm(lp, LPX_K_BINARIZE))\r\n        parm.binarize = GLP_ON;\r\n    ret = glp_intopt(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\r\n        case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\r\n        case GLP_EBOUND:\r\n        case GLP_EROOT:   ret = LPX_E_FAULT;   break;\r\n        case GLP_EFAIL:   ret = LPX_E_SING;    break;\r\n        case GLP_EMIPGAP: ret = LPX_E_MIPGAP;  break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_integer(lp){\r\n    /* easy-to-use driver to the branch-and-bound method */\r\n    return solve_mip(lp, GLP_OFF);\r\n}\r\n\r\nfunction lpx_intopt(lp){\r\n    /* easy-to-use driver to the branch-and-bound method */\r\n    return solve_mip(lp, GLP_ON);\r\n}\r\n\r\nfunction lpx_mip_status(lp){\r\n    /* retrieve status of MIP solution */\r\n    var status;\r\n    switch (glp_mip_status(lp))\r\n    {  case GLP_UNDEF:  status = LPX_I_UNDEF;  break;\r\n        case GLP_OPT:    status = LPX_I_OPT;    break;\r\n        case GLP_FEAS:   status = LPX_I_FEAS;   break;\r\n        case GLP_NOFEAS: status = LPX_I_NOFEAS; break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_mip_obj_val(lp){\r\n    /* retrieve objective value (MIP solution) */\r\n    return glp_mip_obj_val(lp);\r\n}\r\n\r\nfunction lpx_mip_row_val(lp, i){\r\n    /* retrieve row value (MIP solution) */\r\n    return glp_mip_row_val(lp, i);\r\n}\r\n\r\nfunction lpx_mip_col_val(lp, j){\r\n    /* retrieve column value (MIP solution) */\r\n    return glp_mip_col_val(lp, j);\r\n}\r\n\r\nfunction lpx_check_int(lp, kkt){\r\n    /* check integer feasibility conditions */\r\n    glp_check_kkt(lp, GLP_MIP, GLP_KKT_PE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pe_ae_max = ae_max;\r\n            kkt.pe_ae_row = ae_ind;\r\n            kkt.pe_re_max = re_max;\r\n            kkt.pe_re_row = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pe_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pe_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pe_quality = 'L';\r\n            else\r\n                kkt.pe_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_MIP, GLP_KKT_PB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pb_ae_max = ae_max;\r\n            kkt.pb_ae_ind = ae_ind;\r\n            kkt.pb_re_max = re_max;\r\n            kkt.pb_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pb_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pb_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pb_quality = 'L';\r\n            else\r\n                kkt.pb_quality = '?';\r\n        }\r\n    );\r\n}\r\n\r\nfunction reset_parms(lp){\r\n    /* reset control parameters to default values */\r\n    var cps = lp.parms;\r\n    xassert(cps != null);\r\n    cps.msg_lev  = 3;\r\n    cps.scale    = 1;\r\n    cps.dual     = 0;\r\n    cps.price    = 1;\r\n    cps.relax    = 0.07;\r\n    cps.tol_bnd  = 1e-7;\r\n    cps.tol_dj   = 1e-7;\r\n    cps.tol_piv  = 1e-9;\r\n    cps.round    = 0;\r\n    cps.obj_ll   = -DBL_MAX;\r\n    cps.obj_ul   = +DBL_MAX;\r\n    cps.it_lim   = -1;\r\n    cps.tm_lim   = -1.0;\r\n    cps.out_frq  = 200;\r\n    cps.out_dly  = 0.0;\r\n    cps.branch   = 2;\r\n    cps.btrack   = 3;\r\n    cps.tol_int  = 1e-5;\r\n    cps.tol_obj  = 1e-7;\r\n    cps.mps_info = 1;\r\n    cps.mps_obj  = 2;\r\n    cps.mps_orig = 0;\r\n    cps.mps_wide = 1;\r\n    cps.mps_free = 0;\r\n    cps.mps_skip = 0;\r\n    cps.lpt_orig = 0;\r\n    cps.presol = 0;\r\n    cps.binarize = 0;\r\n    cps.use_cuts = 0;\r\n    cps.mip_gap = 0.0;\r\n}\r\n\r\nfunction access_parms(lp){\r\n    /* allocate and initialize control parameters, if necessary */\r\n    if (lp.parms == null)\r\n    {  lp.parms = {};\r\n        reset_parms(lp);\r\n    }\r\n    return lp.parms;\r\n}\r\n\r\nfunction lpx_reset_parms(lp){\r\n    /* reset control parameters to default values */\r\n    access_parms(lp);\r\n    reset_parms(lp);\r\n}\r\n\r\nfunction lpx_set_int_parm(lp, parm, val){\r\n    /* set (change) integer control parameter */\r\n    var cps = access_parms(lp);\r\n    switch (parm)\r\n    {  case LPX_K_MSGLEV:\r\n        if (!(0 <= val && val <= 3))\r\n            xerror(\"lpx_set_int_parm: MSGLEV = \" + val + \"; invalid value\");\r\n        cps.msg_lev = val;\r\n        break;\r\n        case LPX_K_SCALE:\r\n            if (!(0 <= val && val <= 3))\r\n                xerror(\"lpx_set_int_parm: SCALE = \" + val + \"; invalid value\");\r\n            cps.scale = val;\r\n            break;\r\n        case LPX_K_DUAL:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: DUAL = \" + val + \"; invalid value\");\r\n            cps.dual = val;\r\n            break;\r\n        case LPX_K_PRICE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: PRICE = \" + val + \"; invalid value\");\r\n            cps.price = val;\r\n            break;\r\n        case LPX_K_ROUND:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: ROUND = \" + val + \"; invalid value\");\r\n            cps.round = val;\r\n            break;\r\n        case LPX_K_ITLIM:\r\n            cps.it_lim = val;\r\n            break;\r\n        case LPX_K_ITCNT:\r\n            lp.it_cnt = val;\r\n            break;\r\n        case LPX_K_OUTFRQ:\r\n            if (!(val > 0))\r\n                xerror(\"lpx_set_int_parm: OUTFRQ = \" + val + \"; invalid value\");\r\n            cps.out_frq = val;\r\n            break;\r\n        case LPX_K_BRANCH:\r\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\r\n                xerror(\"lpx_set_int_parm: BRANCH = \" + val + \"; invalid value\");\r\n            cps.branch = val;\r\n            break;\r\n        case LPX_K_BTRACK:\r\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\r\n                xerror(\"lpx_set_int_parm: BTRACK = \" + val + \"; invalid value\");\r\n            cps.btrack = val;\r\n            break;\r\n        case LPX_K_MPSINFO:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSINFO = \" + val + \"; invalid value\");\r\n            cps.mps_info = val;\r\n            break;\r\n        case LPX_K_MPSOBJ:\r\n            if (!(val == 0 || val == 1 || val == 2))\r\n                xerror(\"lpx_set_int_parm: MPSOBJ = \" + val + \"; invalid value\");\r\n            cps.mps_obj = val;\r\n            break;\r\n        case LPX_K_MPSORIG:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSORIG = \" + val + \"; invalid value\");\r\n            cps.mps_orig = val;\r\n            break;\r\n        case LPX_K_MPSWIDE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSWIDE = \" + val + \"; invalid value\");\r\n            cps.mps_wide = val;\r\n            break;\r\n        case LPX_K_MPSFREE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSFREE = \" + val + \"; invalid value\");\r\n            cps.mps_free = val;\r\n            break;\r\n        case LPX_K_MPSSKIP:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSSKIP = \" + val + \"; invalid value\");\r\n            cps.mps_skip = val;\r\n            break;\r\n        case LPX_K_LPTORIG:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: LPTORIG = \" + val + \"; invalid value\");\r\n            cps.lpt_orig = val;\r\n            break;\r\n        case LPX_K_PRESOL:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: PRESOL = \" + val + \"; invalid value\");\r\n            cps.presol = val;\r\n            break;\r\n        case LPX_K_BINARIZE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: BINARIZE = \" + val + \"; invalid value\");\r\n            cps.binarize = val;\r\n            break;\r\n        case LPX_K_USECUTS:\r\n            if (val & ~LPX_C_ALL)\r\n                xerror(\"lpx_set_int_parm: USECUTS = \" + val + \"; invalid value\");\r\n            cps.use_cuts = val;\r\n            break;\r\n        case LPX_K_BFTYPE:\r\n        {   parm = {};\r\n            glp_get_bfcp(lp, parm);\r\n            switch (val)\r\n            {  case 1:\r\n                parm.type = GLP_BF_FT; break;\r\n                case 2:\r\n                    parm.type = GLP_BF_BG; break;\r\n                case 3:\r\n                    parm.type = GLP_BF_GR; break;\r\n                default:\r\n                    xerror(\"lpx_set_int_parm: BFTYPE = \" + val + \"; invalid value\");\r\n            }\r\n            glp_set_bfcp(lp, parm);\r\n        }\r\n            break;\r\n        default:\r\n            xerror(\"lpx_set_int_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n}\r\n\r\nfunction lpx_get_int_parm(lp, parm){\r\n    /* query integer control parameter */\r\n    var cps = access_parms(lp);\r\n    var val = 0;\r\n    switch (parm)\r\n    {  case LPX_K_MSGLEV:\r\n        val = cps.msg_lev; break;\r\n        case LPX_K_SCALE:\r\n            val = cps.scale; break;\r\n        case LPX_K_DUAL:\r\n            val = cps.dual; break;\r\n        case LPX_K_PRICE:\r\n            val = cps.price; break;\r\n        case LPX_K_ROUND:\r\n            val = cps.round; break;\r\n        case LPX_K_ITLIM:\r\n            val = cps.it_lim; break;\r\n        case LPX_K_ITCNT:\r\n            val = lp.it_cnt; break;\r\n        case LPX_K_OUTFRQ:\r\n            val = cps.out_frq; break;\r\n        case LPX_K_BRANCH:\r\n            val = cps.branch; break;\r\n        case LPX_K_BTRACK:\r\n            val = cps.btrack; break;\r\n        case LPX_K_MPSINFO:\r\n            val = cps.mps_info; break;\r\n        case LPX_K_MPSOBJ:\r\n            val = cps.mps_obj; break;\r\n        case LPX_K_MPSORIG:\r\n            val = cps.mps_orig; break;\r\n        case LPX_K_MPSWIDE:\r\n            val = cps.mps_wide; break;\r\n        case LPX_K_MPSFREE:\r\n            val = cps.mps_free; break;\r\n        case LPX_K_MPSSKIP:\r\n            val = cps.mps_skip; break;\r\n        case LPX_K_LPTORIG:\r\n            val = cps.lpt_orig; break;\r\n        case LPX_K_PRESOL:\r\n            val = cps.presol; break;\r\n        case LPX_K_BINARIZE:\r\n            val = cps.binarize; break;\r\n        case LPX_K_USECUTS:\r\n            val = cps.use_cuts; break;\r\n        case LPX_K_BFTYPE:\r\n        {   parm = {};\r\n            glp_get_bfcp(lp, parm);\r\n            switch (parm.type)\r\n            {  case GLP_BF_FT:\r\n                val = 1; break;\r\n                case GLP_BF_BG:\r\n                    val = 2; break;\r\n                case GLP_BF_GR:\r\n                    val = 3; break;\r\n                default:\r\n                    xassert(lp != lp);\r\n            }\r\n        }\r\n            break;\r\n        default:\r\n            xerror(\"lpx_get_int_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n    return val;\r\n}\r\n\r\nfunction lpx_set_real_parm(lp, parm, val){\r\n    /* set (change) real control parameter */\r\n    var cps = access_parms(lp);\r\n    switch (parm)\r\n    {  case LPX_K_RELAX:\r\n        if (!(0.0 <= val && val <= 1.0))\r\n            xerror(\"lpx_set_real_parm: RELAX = \" + val + \"; invalid value\");\r\n        cps.relax = val;\r\n        break;\r\n        case LPX_K_TOLBND:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLBND = \" + val + \"; invalid value\");\r\n            cps.tol_bnd = val;\r\n            break;\r\n        case LPX_K_TOLDJ:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLDJ = \" + val + \"; invalid value\");\r\n            cps.tol_dj = val;\r\n            break;\r\n        case LPX_K_TOLPIV:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLPIV = \" + val + \"; invalid value\");\r\n            cps.tol_piv = val;\r\n            break;\r\n        case LPX_K_OBJLL:\r\n            cps.obj_ll = val;\r\n            break;\r\n        case LPX_K_OBJUL:\r\n            cps.obj_ul = val;\r\n            break;\r\n        case LPX_K_TMLIM:\r\n            cps.tm_lim = val;\r\n            break;\r\n        case LPX_K_OUTDLY:\r\n            cps.out_dly = val;\r\n            break;\r\n        case LPX_K_TOLINT:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLINT = \" + val + \"; invalid value\");\r\n            cps.tol_int = val;\r\n            break;\r\n        case LPX_K_TOLOBJ:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLOBJ = \" + val + \"; invalid value\");\r\n            cps.tol_obj = val;\r\n            break;\r\n        case LPX_K_MIPGAP:\r\n            if (val < 0.0)\r\n                xerror(\"lpx_set_real_parm: MIPGAP = \" + val + \"; invalid value\");\r\n            cps.mip_gap = val;\r\n            break;\r\n        default:\r\n            xerror(\"lpx_set_real_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n}\r\n\r\nfunction lpx_get_real_parm(lp, parm){\r\n    /* query real control parameter */\r\n    var cps = access_parms(lp);\r\n    var val = 0.0;\r\n    switch (parm)\r\n    {  case LPX_K_RELAX:\r\n        val = cps.relax;\r\n        break;\r\n        case LPX_K_TOLBND:\r\n            val = cps.tol_bnd;\r\n            break;\r\n        case LPX_K_TOLDJ:\r\n            val = cps.tol_dj;\r\n            break;\r\n        case LPX_K_TOLPIV:\r\n            val = cps.tol_piv;\r\n            break;\r\n        case LPX_K_OBJLL:\r\n            val = cps.obj_ll;\r\n            break;\r\n        case LPX_K_OBJUL:\r\n            val = cps.obj_ul;\r\n            break;\r\n        case LPX_K_TMLIM:\r\n            val = cps.tm_lim;\r\n            break;\r\n        case LPX_K_OUTDLY:\r\n            val = cps.out_dly;\r\n            break;\r\n        case LPX_K_TOLINT:\r\n            val = cps.tol_int;\r\n            break;\r\n        case LPX_K_TOLOBJ:\r\n            val = cps.tol_obj;\r\n            break;\r\n        case LPX_K_MIPGAP:\r\n            val = cps.mip_gap;\r\n            break;\r\n        default:\r\n            xerror(\"lpx_get_real_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n    return val;\r\n}\r\n\r\nfunction lpx_read_mps(fname){\r\n    /* read problem data in fixed MPS format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_mps(lp, GLP_MPS_DECK, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_mps(lp, fname){\r\n    /* write problem data in fixed MPS format */\r\n    return glp_write_mps(lp, GLP_MPS_DECK, null, fname);\r\n}\r\n\r\nfunction lpx_read_bas(lp, fname){\r\n    /* read LP basis in fixed MPS format */\r\n    xassert(lp == lp);\r\n    xassert(fname == fname);\r\n    xerror(\"lpx_read_bas: operation not supported\");\r\n    return 0;\r\n}\r\n\r\nfunction lpx_write_bas(lp, fname){\r\n    /* write LP basis in fixed MPS format */\r\n    xassert(lp == lp);\r\n    xassert(fname == fname);\r\n    xerror(\"lpx_write_bas: operation not supported\");\r\n    return 0;\r\n}\r\n\r\nfunction lpx_read_freemps(fname){\r\n    /* read problem data in free MPS format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_mps(lp, GLP_MPS_FILE, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_freemps(lp, fname){\r\n    /* write problem data in free MPS format */\r\n    return glp_write_mps(lp, GLP_MPS_FILE, null, fname);\r\n}\r\n\r\nfunction lpx_read_cpxlp(fname){\r\n    /* read problem data in CPLEX LP format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_lp(lp, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_cpxlp(lp, fname){\r\n    /* write problem data in CPLEX LP format */\r\n    return glp_write_lp(lp, null, fname);\r\n}\r\n\r\nfunction lpx_read_model(model, data, output, tablecb){\r\n    /* read LP/MIP model written in GNU MathProg language */\r\n    var lp = null;\r\n    /* allocate the translator workspace */\r\n    var tran = glp_mpl_alloc_wksp();\r\n    /* read model section and optional data section */\r\n    if (glp_mpl_read_model(tran, model, data != null)) return done();\r\n    /* read separate data section, if required */\r\n    if (data != null)\r\n        if (glp_mpl_read_data(tran, data)) return done();\r\n    /* generate the model */\r\n    if (glp_mpl_generate(tran, output, tablecb)) return done();\r\n    /* build the problem instance from the model */\r\n    lp = glp_create_prob();\r\n    glp_mpl_build_prob(tran, lp);\r\n    function done(){\r\n        /* bring the problem object to the calling program */\r\n        return lp;\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction lpx_print_prob(lp, fname){\r\n    /* write problem data in plain text format */\r\n    return glp_write_lp(lp, null, fname);\r\n}\r\n\r\nfunction lpx_print_sol(lp, fname){\r\n    /* write LP problem solution in printable format */\r\n    return glp_print_sol(lp, fname);\r\n}\r\n\r\nfunction lpx_print_sens_bnds(lp, fname){\r\n    /* write bounds sensitivity information */\r\n    if (glp_get_status(lp) == GLP_OPT && !glp_bf_exists(lp))\r\n        glp_factorize(lp);\r\n    return glp_print_ranges(lp, 0, null, 0, fname);\r\n}\r\n\r\nfunction lpx_print_ips(lp, fname){\r\n    /* write interior point solution in printable format */\r\n    return glp_print_ipt(lp, fname);\r\n}\r\n\r\nfunction lpx_print_mip(lp, fname){\r\n    /* write MIP problem solution in printable format */\r\n    return glp_print_mip(lp, fname);\r\n}\r\n\r\nfunction lpx_is_b_avail(lp){\r\n    /* check if LP basis is available */\r\n    return glp_bf_exists(lp);\r\n}\r\n\r\nfunction lpx_main(argc, argv)\r\n{     /* stand-alone LP/MIP solver */\r\n    return glp_main(argc, argv);\r\n}\r\n\r\n/* return codes: */\r\nvar\r\n    LUF_ESING   = 1,  /* singular matrix */\r\n    LUF_ECOND   = 2;  /* ill-conditioned matrix */\r\n\r\nfunction luf_create_it(){\r\n    var luf = {};\r\n    luf.n_max = luf.n = 0;\r\n    luf.valid = 0;\r\n    luf.fr_ptr = luf.fr_len = null;\r\n    luf.fc_ptr = luf.fc_len = null;\r\n    luf.vr_ptr = luf.vr_len = luf.vr_cap = null;\r\n    luf.vr_piv = null;\r\n    luf.vc_ptr = luf.vc_len = luf.vc_cap = null;\r\n    luf.pp_row = luf.pp_col = null;\r\n    luf.qq_row = luf.qq_col = null;\r\n    luf.sv_size = 0;\r\n    luf.sv_beg = luf.sv_end = 0;\r\n    luf.sv_ind = null;\r\n    luf.sv_val = null;\r\n    luf.sv_head = luf.sv_tail = 0;\r\n    luf.sv_prev = luf.sv_next = null;\r\n    luf.vr_max = null;\r\n    luf.rs_head = luf.rs_prev = luf.rs_next = null;\r\n    luf.cs_head = luf.cs_prev = luf.cs_next = null;\r\n    luf.flag = null;\r\n    luf.work = null;\r\n    luf.new_sva = 0;\r\n    luf.piv_tol = 0.10;\r\n    luf.piv_lim = 4;\r\n    luf.suhl = 1;\r\n    luf.eps_tol = 1e-15;\r\n    luf.max_gro = 1e+10;\r\n    luf.nnz_a = luf.nnz_f = luf.nnz_v = 0;\r\n    luf.max_a = luf.big_v = 0.0;\r\n    luf.rank = 0;\r\n    return luf;\r\n}\r\n\r\nfunction luf_defrag_sva(luf){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_next = luf.sv_next;\r\n    var sv_beg = 1;\r\n    var i, j, k;\r\n    /* skip rows and columns, which do not need to be relocated */\r\n    for (k = luf.sv_head; k != 0; k = sv_next[k])\r\n    {  if (k <= n)\r\n    {  /* i-th row of the matrix V */\r\n        i = k;\r\n        if (vr_ptr[i] != sv_beg) break;\r\n        vr_cap[i] = vr_len[i];\r\n        sv_beg += vr_cap[i];\r\n    }\r\n    else\r\n    {  /* j-th column of the matrix V */\r\n        j = k - n;\r\n        if (vc_ptr[j] != sv_beg) break;\r\n        vc_cap[j] = vc_len[j];\r\n        sv_beg += vc_cap[j];\r\n    }\r\n    }\r\n    /* relocate other rows and columns in order to gather all unused\r\n     locations in one continuous extent */\r\n    for (; k != 0; k = sv_next[k])\r\n    {  if (k <= n)\r\n    {  /* i-th row of the matrix V */\r\n        i = k;\r\n        xcopyArr(sv_ind, sv_beg, sv_ind, vr_ptr[i], vr_len[i]);\r\n        xcopyArr(sv_val, sv_beg, sv_val, vr_ptr[i], vr_len[i]);\r\n        vr_ptr[i] = sv_beg;\r\n        vr_cap[i] = vr_len[i];\r\n        sv_beg += vr_cap[i];\r\n    }\r\n    else\r\n    {  /* j-th column of the matrix V */\r\n        j = k - n;\r\n        xcopyArr(sv_ind, sv_beg, sv_ind, vc_ptr[j], vc_len[j]);\r\n        xcopyArr(sv_val, sv_beg, sv_val ,vc_ptr[j], vc_len[j]);\r\n        vc_ptr[j] = sv_beg;\r\n        vc_cap[j] = vc_len[j];\r\n        sv_beg += vc_cap[j];\r\n    }\r\n    }\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg = sv_beg;\r\n}\r\n\r\nfunction luf_enlarge_row(luf, i, cap){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var cur, k, kk;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(vr_cap[i] < cap);\r\n    /* if there are less than cap free locations, defragment SVA */\r\n    if (luf.sv_end - luf.sv_beg < cap)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < cap)\r\n        {  ret = 1;\r\n            return ret;\r\n        }\r\n    }\r\n    /* save current capacity of the i-th row */\r\n    cur = vr_cap[i];\r\n    /* copy existing elements to the beginning of the free part */\r\n    xcopyArr(sv_ind, luf.sv_beg, sv_ind, vr_ptr[i], vr_len[i]);\r\n    xcopyArr(sv_val, luf.sv_beg, sv_val, vr_ptr[i], vr_len[i]);\r\n    /* set new pointer and new capacity of the i-th row */\r\n    vr_ptr[i] = luf.sv_beg;\r\n    vr_cap[i] = cap;\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg += cap;\r\n    /* now the i-th row starts in the rightmost location among other\r\n     rows and columns of the matrix V, so its node should be moved\r\n     to the end of the row/column linked list */\r\n    k = i;\r\n    /* remove the i-th row node from the linked list */\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n    {  /* capacity of the previous row/column can be increased at the\r\n     expense of old locations of the i-th row */\r\n        kk = sv_prev[k];\r\n        if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    }\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* insert the i-th row node to the end of the linked list */\r\n    sv_prev[k] = luf.sv_tail;\r\n    sv_next[k] = 0;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = k;\r\n    else\r\n        sv_next[sv_prev[k]] = k;\r\n    luf.sv_tail = k;\r\n    return ret;\r\n}\r\n\r\nfunction luf_enlarge_col(luf, j, cap){\r\n    var n = luf.n;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var cur, k, kk;\r\n    xassert(1 <= j && j <= n);\r\n    xassert(vc_cap[j] < cap);\r\n    /* if there are less than cap free locations, defragment SVA */\r\n    if (luf.sv_end - luf.sv_beg < cap)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < cap)\r\n        {  ret = 1;\r\n            return ret;\r\n        }\r\n    }\r\n    /* save current capacity of the j-th column */\r\n    cur = vc_cap[j];\r\n    /* copy existing elements to the beginning of the free part */\r\n    xcopyArr(sv_ind, luf.sv_beg, sv_ind, vc_ptr[j], vc_len[j]);\r\n    xcopyArr(sv_val, luf.sv_beg, sv_val, vc_ptr[j], vc_len[j]);\r\n    /* set new pointer and new capacity of the j-th column */\r\n    vc_ptr[j] = luf.sv_beg;\r\n    vc_cap[j] = cap;\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg += cap;\r\n    /* now the j-th column starts in the rightmost location among\r\n     other rows and columns of the matrix V, so its node should be\r\n     moved to the end of the row/column linked list */\r\n    k = n + j;\r\n    /* remove the j-th column node from the linked list */\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n    {  /* capacity of the previous row/column can be increased at the\r\n     expense of old locations of the j-th column */\r\n        kk = sv_prev[k];\r\n        if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    }\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* insert the j-th column node to the end of the linked list */\r\n    sv_prev[k] = luf.sv_tail;\r\n    sv_next[k] = 0;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = k;\r\n    else\r\n        sv_next[sv_prev[k]] = k;\r\n    luf.sv_tail = k;\r\n    return ret;\r\n}\r\n\r\nfunction reallocate(luf, n){\r\n    var n_max = luf.n_max;\r\n    luf.n = n;\r\n    if (n <= n_max) return;\r\n    luf.n_max = n_max = n + 100;\r\n    luf.fr_ptr = new Int32Array(1+n_max);\r\n    luf.fr_len = new Int32Array(1+n_max);\r\n    luf.fc_ptr = new Int32Array(1+n_max);\r\n    luf.fc_len = new Int32Array(1+n_max);\r\n    luf.vr_ptr = new Int32Array(1+n_max);\r\n    luf.vr_len = new Int32Array(1+n_max);\r\n    luf.vr_cap = new Int32Array(1+n_max);\r\n    luf.vr_piv = new Float64Array(1+n_max);\r\n    luf.vc_ptr = new Int32Array(1+n_max);\r\n    luf.vc_len = new Int32Array(1+n_max);\r\n    luf.vc_cap = new Int32Array(1+n_max);\r\n    luf.pp_row = new Int32Array(1+n_max);\r\n    luf.pp_col = new Int32Array(1+n_max);\r\n    luf.qq_row = new Int32Array(1+n_max);\r\n    luf.qq_col = new Int32Array(1+n_max);\r\n    luf.sv_prev = new Int32Array(1+n_max+n_max);\r\n    luf.sv_next = new Int32Array(1+n_max+n_max);\r\n    luf.vr_max = new Float64Array(1+n_max);\r\n    luf.rs_head = new Int32Array(1+n_max);\r\n    luf.rs_prev = new Int32Array(1+n_max);\r\n    luf.rs_next = new Int32Array(1+n_max);\r\n    luf.cs_head = new Int32Array(1+n_max);\r\n    luf.cs_prev = new Int32Array(1+n_max);\r\n    luf.cs_next = new Int32Array(1+n_max);\r\n    luf.flag = new Int32Array(1+n_max);\r\n    luf.work = new Float64Array(1+n_max);\r\n}\r\n\r\nfunction initialize(luf, col, info){\r\n    var n = luf.n;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var pp_row = luf.pp_row;\r\n    var pp_col = luf.pp_col;\r\n    var qq_row = luf.qq_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_prev = luf.rs_prev;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var flag = luf.flag;\r\n    var work = luf.work;\r\n    var ret = 0;\r\n    var i, i_ptr, j, j_beg, j_end, k, len, nnz, sv_beg, sv_end, ptr;\r\n    var big, val;\r\n    /* free all locations of the sparse vector area */\r\n    sv_beg = 1;\r\n    sv_end = luf.sv_size + 1;\r\n    /* (row-wise representation of the matrix F is not initialized,\r\n     because it is not used at the factorization stage) */\r\n    /* build the matrix F in column-wise format (initially F = I) */\r\n    for (j = 1; j <= n; j++)\r\n    {  fc_ptr[j] = sv_end;\r\n        fc_len[j] = 0;\r\n    }\r\n    /* clear rows of the matrix V; clear the flag array */\r\n    for (i = 1; i <= n; i++)\r\n        vr_len[i] = vr_cap[i] = 0, flag[i] = 0;\r\n    /* build the matrix V in column-wise format (initially V = A);\r\n     count non-zeros in rows of this matrix; count total number of\r\n     non-zeros; compute largest of absolute values of elements */\r\n    nnz = 0;\r\n    big = 0.0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var rn = pp_row;\r\n        var aj = work;\r\n        /* obtain j-th column of the matrix A */\r\n        len = col(info, j, rn, aj);\r\n        if (!(0 <= len && len <= n))\r\n            xerror(\"luf_factorize: j = \" + j + \"; len = \" + len + \"; invalid column length\");\r\n        /* check for free locations */\r\n        if (sv_end - sv_beg < len)\r\n        {  /* overflow of the sparse vector area */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* set pointer to the j-th column */\r\n        vc_ptr[j] = sv_beg;\r\n        /* set length of the j-th column */\r\n        vc_len[j] = vc_cap[j] = len;\r\n        /* count total number of non-zeros */\r\n        nnz += len;\r\n        /* walk through elements of the j-th column */\r\n        for (ptr = 1; ptr <= len; ptr++)\r\n        {  /* get row index and numerical value of a[i,j] */\r\n            i = rn[ptr];\r\n            val = aj[ptr];\r\n            if (!(1 <= i && i <= n))\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; invalid row index\");\r\n            if (flag[i])\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; duplicate element not allowed\");\r\n            if (val == 0.0)\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; zero element not allowed\");\r\n            /* add new element v[i,j] = a[i,j] to j-th column */\r\n            sv_ind[sv_beg] = i;\r\n            sv_val[sv_beg] = val;\r\n            sv_beg++;\r\n            /* big := max(big, |a[i,j]|) */\r\n            if (val < 0.0) val = - val;\r\n            if (big < val) big = val;\r\n            /* mark non-zero in the i-th position of the j-th column */\r\n            flag[i] = 1;\r\n            /* increase length of the i-th row */\r\n            vr_cap[i]++;\r\n        }\r\n        /* reset all non-zero marks */\r\n        for (ptr = 1; ptr <= len; ptr++) flag[rn[ptr]] = 0;\r\n    }\r\n    /* allocate rows of the matrix V */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* get length of the i-th row */\r\n        len = vr_cap[i];\r\n        /* check for free locations */\r\n        if (sv_end - sv_beg < len)\r\n        {  /* overflow of the sparse vector area */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* set pointer to the i-th row */\r\n        vr_ptr[i] = sv_beg;\r\n        /* reserve locations for the i-th row */\r\n        sv_beg += len;\r\n    }\r\n    /* build the matrix V in row-wise format using representation of\r\n     this matrix in column-wise format */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (k = j_beg; k <= j_end; k++)\r\n        {  /* get row index and numerical value of v[i,j] */\r\n            i = sv_ind[k];\r\n            val = sv_val[k];\r\n            /* store element in the i-th row */\r\n            i_ptr = vr_ptr[i] + vr_len[i];\r\n            sv_ind[i_ptr] = j;\r\n            sv_val[i_ptr] = val;\r\n            /* increase count of the i-th row */\r\n            vr_len[i]++;\r\n        }\r\n    }\r\n    /* initialize the matrices P and Q (initially P = Q = I) */\r\n    for (k = 1; k <= n; k++)\r\n        pp_row[k] = pp_col[k] = qq_row[k] = qq_col[k] = k;\r\n    /* set sva partitioning pointers */\r\n    luf.sv_beg = sv_beg;\r\n    luf.sv_end = sv_end;\r\n    /* the initial physical order of rows and columns of the matrix V\r\n     is n+1, ..., n+n, 1, ..., n (firstly columns, then rows) */\r\n    luf.sv_head = n+1;\r\n    luf.sv_tail = n;\r\n    for (i = 1; i <= n; i++)\r\n    {  sv_prev[i] = i-1;\r\n        sv_next[i] = i+1;\r\n    }\r\n    sv_prev[1] = n+n;\r\n    sv_next[n] = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  sv_prev[n+j] = n+j-1;\r\n        sv_next[n+j] = n+j+1;\r\n    }\r\n    sv_prev[n+1] = 0;\r\n    sv_next[n+n] = 1;\r\n    /* clear working arrays */\r\n    for (k = 1; k <= n; k++)\r\n    {  flag[k] = 0;\r\n        work[k] = 0.0;\r\n    }\r\n    /* initialize some statistics */\r\n    luf.nnz_a = nnz;\r\n    luf.nnz_f = 0;\r\n    luf.nnz_v = nnz;\r\n    luf.max_a = big;\r\n    luf.big_v = big;\r\n    luf.rank = -1;\r\n    /* initially the active submatrix is the entire matrix V */\r\n    /* largest of absolute values of elements in each active row is\r\n     unknown yet */\r\n    for (i = 1; i <= n; i++) vr_max[i] = -1.0;\r\n    /* build linked lists of active rows */\r\n    for (len = 0; len <= n; len++) rs_head[len] = 0;\r\n    for (i = 1; i <= n; i++)\r\n    {  len = vr_len[i];\r\n        rs_prev[i] = 0;\r\n        rs_next[i] = rs_head[len];\r\n        if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n        rs_head[len] = i;\r\n    }\r\n    /* build linked lists of active columns */\r\n    for (len = 0; len <= n; len++) cs_head[len] = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  len = vc_len[j];\r\n        cs_prev[j] = 0;\r\n        cs_next[j] = cs_head[len];\r\n        if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;\r\n        cs_head[len] = j;\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction find_pivot(luf, callback){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var piv_tol = luf.piv_tol;\r\n    var piv_lim = luf.piv_lim;\r\n    var suhl = luf.suhl;\r\n    var p, q, len, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr,\r\n        ncand, next_j, min_p, min_q, min_len;\r\n    var best, cost, big, temp;\r\n    /* initially no pivot candidates have been found so far */\r\n    p = q = 0; best = DBL_MAX; ncand = 0;\r\n    /* if in the active submatrix there is a column that has the only\r\n     non-zero (column singleton), choose it as pivot */\r\n    j = cs_head[1];\r\n    if (j != 0)\r\n    {  xassert(vc_len[j] == 1);\r\n        p = sv_ind[vc_ptr[j]]; q = j;\r\n        return done();\r\n    }\r\n    /* if in the active submatrix there is a row that has the only\r\n     non-zero (row singleton), choose it as pivot */\r\n    i = rs_head[1];\r\n    if (i != 0)\r\n    {  xassert(vr_len[i] == 1);\r\n        p = i; q = sv_ind[vr_ptr[i]];\r\n        return done();\r\n    }\r\n    /* there are no singletons in the active submatrix; walk through\r\n     other non-empty rows and columns */\r\n    for (len = 2; len <= n; len++)\r\n    {  /* consider active columns that have len non-zeros */\r\n        for (j = cs_head[len]; j != 0; j = next_j)\r\n        {  /* the j-th column has len non-zeros */\r\n            j_beg = vc_ptr[j];\r\n            j_end = j_beg + vc_len[j] - 1;\r\n            /* save pointer to the next column with the same length */\r\n            next_j = cs_next[j];\r\n            /* find an element in the j-th column, which is placed in a\r\n             row with minimal number of non-zeros and satisfies to the\r\n             stability condition (such element may not exist) */\r\n            min_p = min_q = 0; min_len = INT_MAX;\r\n            for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n            {  /* get row index of v[i,j] */\r\n                i = sv_ind[j_ptr];\r\n                i_beg = vr_ptr[i];\r\n                i_end = i_beg + vr_len[i] - 1;\r\n                /* if the i-th row is not shorter than that one, where\r\n                 minimal element is currently placed, skip v[i,j] */\r\n                if (vr_len[i] >= min_len) continue;\r\n                /* determine the largest of absolute values of elements\r\n                 in the i-th row */\r\n                big = vr_max[i];\r\n                if (big < 0.0)\r\n                {  /* the largest value is unknown yet; compute it */\r\n                    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n                    {  temp = sv_val[i_ptr];\r\n                        if (temp < 0.0) temp = - temp;\r\n                        if (big < temp) big = temp;\r\n                    }\r\n                    vr_max[i] = big;\r\n                }\r\n                /* find v[i,j] in the i-th row */\r\n                for (i_ptr = vr_ptr[i]; sv_ind[i_ptr] != j; i_ptr++){}\r\n                xassert(i_ptr <= i_end);\r\n                /* if v[i,j] doesn't satisfy to the stability condition,\r\n                 skip it */\r\n                temp = sv_val[i_ptr];\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp < piv_tol * big) continue;\r\n                /* v[i,j] is better than the current minimal element */\r\n                min_p = i; min_q = j; min_len = vr_len[i];\r\n                /* if Markowitz cost of the current minimal element is\r\n                 not greater than (len-1)**2, it can be chosen right\r\n                 now; this heuristic reduces the search and works well\r\n                 in many cases */\r\n                if (min_len <= len)\r\n                {  p = min_p; q = min_q;\r\n                    return done();\r\n                }\r\n            }\r\n            /* the j-th column has been scanned */\r\n            if (min_p != 0)\r\n            {  /* the minimal element is a next pivot candidate */\r\n                ncand++;\r\n                /* compute its Markowitz cost */\r\n                cost = (min_len - 1) * (len - 1);\r\n                /* choose between the minimal element and the current\r\n                 candidate */\r\n                if (cost < best) {p = min_p; q = min_q; best = cost}\r\n                /* if piv_lim candidates have been considered, there are\r\n                 doubts that a much better candidate exists; therefore\r\n                 it's time to terminate the search */\r\n                if (ncand == piv_lim) return done();\r\n            }\r\n            else\r\n            {  /* the j-th column has no elements, which satisfy to the\r\n             stability condition; Uwe Suhl suggests to exclude such\r\n             column from the further consideration until it becomes\r\n             a column singleton; in hard cases this significantly\r\n             reduces a time needed for pivot searching */\r\n                if (suhl)\r\n                {  /* remove the j-th column from the active set */\r\n                    if (cs_prev[j] == 0)\r\n                        cs_head[len] = cs_next[j];\r\n                    else\r\n                        cs_next[cs_prev[j]] = cs_next[j];\r\n                    if (cs_next[j] == 0){\r\n                        /* nop */\r\n                    }\r\n                    else\r\n                        cs_prev[cs_next[j]] = cs_prev[j];\r\n                    /* the following assignment is used to avoid an error\r\n                     when the routine eliminate (see below) will try to\r\n                     remove the j-th column from the active set */\r\n                    cs_prev[j] = cs_next[j] = j;\r\n                }\r\n            }\r\n        }\r\n        /* consider active rows that have len non-zeros */\r\n        for (i = rs_head[len]; i != 0; i = rs_next[i])\r\n        {  /* the i-th row has len non-zeros */\r\n            i_beg = vr_ptr[i];\r\n            i_end = i_beg + vr_len[i] - 1;\r\n            /* determine the largest of absolute values of elements in\r\n             the i-th row */\r\n            big = vr_max[i];\r\n            if (big < 0.0)\r\n            {  /* the largest value is unknown yet; compute it */\r\n                for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n                {  temp = sv_val[i_ptr];\r\n                    if (temp < 0.0) temp = - temp;\r\n                    if (big < temp) big = temp;\r\n                }\r\n                vr_max[i] = big;\r\n            }\r\n            /* find an element in the i-th row, which is placed in a\r\n             column with minimal number of non-zeros and satisfies to\r\n             the stability condition (such element always exists) */\r\n            min_p = min_q = 0; min_len = INT_MAX;\r\n            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n            {  /* get column index of v[i,j] */\r\n                j = sv_ind[i_ptr];\r\n                /* if the j-th column is not shorter than that one, where\r\n                 minimal element is currently placed, skip v[i,j] */\r\n                if (vc_len[j] >= min_len) continue;\r\n                /* if v[i,j] doesn't satisfy to the stability condition,\r\n                 skip it */\r\n                temp = sv_val[i_ptr];\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp < piv_tol * big) continue;\r\n                /* v[i,j] is better than the current minimal element */\r\n                min_p = i; min_q = j; min_len = vc_len[j];\r\n                /* if Markowitz cost of the current minimal element is\r\n                 not greater than (len-1)**2, it can be chosen right\r\n                 now; this heuristic reduces the search and works well\r\n                 in many cases */\r\n                if (min_len <= len)\r\n                {  p = min_p; q = min_q;\r\n                    return done();\r\n                }\r\n            }\r\n            /* the i-th row has been scanned */\r\n            if (min_p != 0)\r\n            {  /* the minimal element is a next pivot candidate */\r\n                ncand++;\r\n                /* compute its Markowitz cost */\r\n                cost = (len - 1) * (min_len - 1);\r\n                /* choose between the minimal element and the current\r\n                 candidate */\r\n                if (cost < best) {p = min_p; q = min_q; best = cost}\r\n                /* if piv_lim candidates have been considered, there are\r\n                 doubts that a much better candidate exists; therefore\r\n                 it's time to terminate the search */\r\n                if (ncand == piv_lim) return done();\r\n            }\r\n            else\r\n            {  /* this can't be because this can never be */\r\n                xassert(min_p != min_p);\r\n            }\r\n        }\r\n    }\r\n    function done(){\r\n        /* bring the pivot to the factorizing routine */\r\n        callback(p, q);\r\n        return (p == 0);\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction eliminate(luf, p, q){\r\n    var n = luf.n;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_prev = luf.rs_prev;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var flag = luf.flag;\r\n    var work = luf.work;\r\n    var eps_tol = luf.eps_tol;\r\n    /* at this stage the row-wise representation of the matrix F is\r\n     not used, so fr_len can be used as a working array */\r\n    var ndx = luf.fr_len;\r\n    var ret = 0;\r\n    var len, fill, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr, k,\r\n        p_beg, p_end, p_ptr, q_beg, q_end, q_ptr;\r\n    var fip, val, vpq, temp;\r\n    xassert(1 <= p && p <= n);\r\n    xassert(1 <= q && q <= n);\r\n    /* remove the p-th (pivot) row from the active set; this row will\r\n     never return there */\r\n    if (rs_prev[p] == 0)\r\n        rs_head[vr_len[p]] = rs_next[p];\r\n    else\r\n        rs_next[rs_prev[p]] = rs_next[p];\r\n    if (rs_next[p] == 0){\r\n\r\n    }\r\n    else\r\n        rs_prev[rs_next[p]] = rs_prev[p];\r\n    /* remove the q-th (pivot) column from the active set; this column\r\n     will never return there */\r\n    if (cs_prev[q] == 0)\r\n        cs_head[vc_len[q]] = cs_next[q];\r\n    else\r\n        cs_next[cs_prev[q]] = cs_next[q];\r\n    if (cs_next[q] == 0){\r\n\r\n    }\r\n    else\r\n        cs_prev[cs_next[q]] = cs_prev[q];\r\n    /* find the pivot v[p,q] = u[k,k] in the p-th row */\r\n    p_beg = vr_ptr[p];\r\n    p_end = p_beg + vr_len[p] - 1;\r\n    for (p_ptr = p_beg; sv_ind[p_ptr] != q; p_ptr++){/* nop */}\r\n    xassert(p_ptr <= p_end);\r\n    /* store value of the pivot */\r\n    vpq = (vr_piv[p] = sv_val[p_ptr]);\r\n    /* remove the pivot from the p-th row */\r\n    sv_ind[p_ptr] = sv_ind[p_end];\r\n    sv_val[p_ptr] = sv_val[p_end];\r\n    vr_len[p]--;\r\n    p_end--;\r\n    /* find the pivot v[p,q] = u[k,k] in the q-th column */\r\n    q_beg = vc_ptr[q];\r\n    q_end = q_beg + vc_len[q] - 1;\r\n    for (q_ptr = q_beg; sv_ind[q_ptr] != p; q_ptr++){/* nop */}\r\n    xassert(q_ptr <= q_end);\r\n    /* remove the pivot from the q-th column */\r\n    sv_ind[q_ptr] = sv_ind[q_end];\r\n    vc_len[q]--;\r\n    q_end--;\r\n    /* walk through the p-th (pivot) row, which doesn't contain the\r\n     pivot v[p,q] already, and do the following... */\r\n    for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n    {  /* get column index of v[p,j] */\r\n        j = sv_ind[p_ptr];\r\n        /* store v[p,j] to the working array */\r\n        flag[j] = 1;\r\n        work[j] = sv_val[p_ptr];\r\n        /* remove the j-th column from the active set; this column will\r\n         return there later with new length */\r\n        if (cs_prev[j] == 0)\r\n            cs_head[vc_len[j]] = cs_next[j];\r\n        else\r\n            cs_next[cs_prev[j]] = cs_next[j];\r\n        if (cs_next[j] == 0){\r\n\r\n        }\r\n        else\r\n            cs_prev[cs_next[j]] = cs_prev[j];\r\n        /* find v[p,j] in the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (j_ptr = j_beg; sv_ind[j_ptr] != p; j_ptr++){/* nop */}\r\n        xassert(j_ptr <= j_end);\r\n        /* since v[p,j] leaves the active submatrix, remove it from the\r\n         j-th column; however, v[p,j] is kept in the p-th row */\r\n        sv_ind[j_ptr] = sv_ind[j_end];\r\n        vc_len[j]--;\r\n    }\r\n    /* walk through the q-th (pivot) column, which doesn't contain the\r\n     pivot v[p,q] already, and perform gaussian elimination */\r\n    while (q_beg <= q_end)\r\n    {  /* element v[i,q] should be eliminated */\r\n        /* get row index of v[i,q] */\r\n        i = sv_ind[q_beg];\r\n        /* remove the i-th row from the active set; later this row will\r\n         return there with new length */\r\n        if (rs_prev[i] == 0)\r\n            rs_head[vr_len[i]] = rs_next[i];\r\n        else\r\n            rs_next[rs_prev[i]] = rs_next[i];\r\n        if (rs_next[i] == 0){\r\n\r\n        }\r\n        else\r\n            rs_prev[rs_next[i]] = rs_prev[i];\r\n        /* find v[i,q] in the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; sv_ind[i_ptr] != q; i_ptr++){/* nop */}\r\n        xassert(i_ptr <= i_end);\r\n        /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] */\r\n        fip = sv_val[i_ptr] / vpq;\r\n        /* since v[i,q] should be eliminated, remove it from the i-th\r\n         row */\r\n        sv_ind[i_ptr] = sv_ind[i_end];\r\n        sv_val[i_ptr] = sv_val[i_end];\r\n        vr_len[i]--;\r\n        i_end--;\r\n        /* and from the q-th column */\r\n        sv_ind[q_beg] = sv_ind[q_end];\r\n        vc_len[q]--;\r\n        q_end--;\r\n        /* perform gaussian transformation:\r\n         (i-th row) := (i-th row) - f[i,p] * (p-th row)\r\n         note that now the p-th row, which is in the working array,\r\n         doesn't contain the pivot v[p,q], and the i-th row doesn't\r\n         contain the eliminated element v[i,q] */\r\n        /* walk through the i-th row and transform existing non-zero\r\n         elements */\r\n        fill = vr_len[p];\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        {  /* get column index of v[i,j] */\r\n            j = sv_ind[i_ptr];\r\n            /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */\r\n            if (flag[j])\r\n            {  /* v[p,j] != 0 */\r\n                temp = (sv_val[i_ptr] -= fip * work[j]);\r\n                if (temp < 0.0) temp = - temp;\r\n                flag[j] = 0;\r\n                fill--; /* since both v[i,j] and v[p,j] exist */\r\n                if (temp == 0.0 || temp < eps_tol)\r\n                {  /* new v[i,j] is closer to zero; replace it by exact\r\n                 zero, i.e. remove it from the active submatrix */\r\n                    /* remove v[i,j] from the i-th row */\r\n                    sv_ind[i_ptr] = sv_ind[i_end];\r\n                    sv_val[i_ptr] = sv_val[i_end];\r\n                    vr_len[i]--;\r\n                    i_ptr--;\r\n                    i_end--;\r\n                    /* find v[i,j] in the j-th column */\r\n                    j_beg = vc_ptr[j];\r\n                    j_end = j_beg + vc_len[j] - 1;\r\n                    for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++){}\r\n                    xassert(j_ptr <= j_end);\r\n                    /* remove v[i,j] from the j-th column */\r\n                    sv_ind[j_ptr] = sv_ind[j_end];\r\n                    vc_len[j]--;\r\n                }\r\n                else\r\n                {  /* v_big := max(v_big, |v[i,j]|) */\r\n                    if (luf.big_v < temp) luf.big_v = temp;\r\n                }\r\n            }\r\n        }\r\n        /* now flag is the pattern of the set v[p,*] \\ v[i,*], and fill\r\n         is number of non-zeros in this set; therefore up to fill new\r\n         non-zeros may appear in the i-th row */\r\n        if (vr_len[i] + fill > vr_cap[i])\r\n        {  /* enlarge the i-th row */\r\n            if (luf_enlarge_row(luf, i, vr_len[i] + fill))\r\n            {  /* overflow of the sparse vector area */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* defragmentation may change row and column pointers of the\r\n             matrix V */\r\n            p_beg = vr_ptr[p];\r\n            p_end = p_beg + vr_len[p] - 1;\r\n            q_beg = vc_ptr[q];\r\n            q_end = q_beg + vc_len[q] - 1;\r\n        }\r\n        /* walk through the p-th (pivot) row and create new elements\r\n         of the i-th row that appear due to fill-in; column indices\r\n         of these new elements are accumulated in the array ndx */\r\n        len = 0;\r\n        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n        {  /* get column index of v[p,j], which may cause fill-in */\r\n            j = sv_ind[p_ptr];\r\n            if (flag[j])\r\n            {  /* compute new non-zero v[i,j] = 0 - f[i,p] * v[p,j] */\r\n                temp = (val = - fip * work[j]);\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp == 0.0 || temp < eps_tol){\r\n                    /* if v[i,j] is closer to zero; just ignore it */\r\n                }\r\n                else\r\n                {  /* add v[i,j] to the i-th row */\r\n                    i_ptr = vr_ptr[i] + vr_len[i];\r\n                    sv_ind[i_ptr] = j;\r\n                    sv_val[i_ptr] = val;\r\n                    vr_len[i]++;\r\n                    /* remember column index of v[i,j] */\r\n                    ndx[++len] = j;\r\n                    /* big_v := max(big_v, |v[i,j]|) */\r\n                    if (luf.big_v < temp) luf.big_v = temp;\r\n                }\r\n            }\r\n            else\r\n            {  /* there is no fill-in, because v[i,j] already exists in\r\n             the i-th row; restore the flag of the element v[p,j],\r\n             which was reset before */\r\n                flag[j] = 1;\r\n            }\r\n        }\r\n        /* add new non-zeros v[i,j] to the corresponding columns */\r\n        for (k = 1; k <= len; k++)\r\n        {  /* get column index of new non-zero v[i,j] */\r\n            j = ndx[k];\r\n            /* one free location is needed in the j-th column */\r\n            if (vc_len[j] + 1 > vc_cap[j])\r\n            {  /* enlarge the j-th column */\r\n                if (luf_enlarge_col(luf, j, vc_len[j] + 10))\r\n                {  /* overflow of the sparse vector area */\r\n                    ret = 1;\r\n                    return ret;\r\n                }\r\n                /* defragmentation may change row and column pointers of\r\n                 the matrix V */\r\n                p_beg = vr_ptr[p];\r\n                p_end = p_beg + vr_len[p] - 1;\r\n                q_beg = vc_ptr[q];\r\n                q_end = q_beg + vc_len[q] - 1;\r\n            }\r\n            /* add new non-zero v[i,j] to the j-th column */\r\n            j_ptr = vc_ptr[j] + vc_len[j];\r\n            sv_ind[j_ptr] = i;\r\n            vc_len[j]++;\r\n        }\r\n        /* now the i-th row has been completely transformed, therefore\r\n         it can return to the active set with new length */\r\n        rs_prev[i] = 0;\r\n        rs_next[i] = rs_head[vr_len[i]];\r\n        if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n        rs_head[vr_len[i]] = i;\r\n        /* the largest of absolute values of elements in the i-th row\r\n         is currently unknown */\r\n        vr_max[i] = -1.0;\r\n        /* at least one free location is needed to store the gaussian\r\n         multiplier */\r\n        if (luf.sv_end - luf.sv_beg < 1)\r\n        {  /* there are no free locations at all; defragment SVA */\r\n            luf_defrag_sva(luf);\r\n            if (luf.sv_end - luf.sv_beg < 1)\r\n            {  /* overflow of the sparse vector area */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* defragmentation may change row and column pointers of the\r\n             matrix V */\r\n            p_beg = vr_ptr[p];\r\n            p_end = p_beg + vr_len[p] - 1;\r\n            q_beg = vc_ptr[q];\r\n            q_end = q_beg + vc_len[q] - 1;\r\n        }\r\n        /* add the element f[i,p], which is the gaussian multiplier,\r\n         to the matrix F */\r\n        luf.sv_end--;\r\n        sv_ind[luf.sv_end] = i;\r\n        sv_val[luf.sv_end] = fip;\r\n        fc_len[p]++;\r\n        /* end of elimination loop */\r\n    }\r\n    /* at this point the q-th (pivot) column should be empty */\r\n    xassert(vc_len[q] == 0);\r\n    /* reset capacity of the q-th column */\r\n    vc_cap[q] = 0;\r\n    /* remove node of the q-th column from the addressing list */\r\n    k = n + q;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* the p-th column of the matrix F has been completely built; set\r\n     its pointer */\r\n    fc_ptr[p] = luf.sv_end;\r\n    /* walk through the p-th (pivot) row and do the following... */\r\n    for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n    {  /* get column index of v[p,j] */\r\n        j = sv_ind[p_ptr];\r\n        /* erase v[p,j] from the working array */\r\n        flag[j] = 0;\r\n        work[j] = 0.0;\r\n        /* the j-th column has been completely transformed, therefore\r\n         it can return to the active set with new length; however\r\n         the special case c_prev[j] = c_next[j] = j means that the\r\n         routine find_pivot excluded the j-th column from the active\r\n         set due to Uwe Suhl's rule, and therefore in this case the\r\n         column can return to the active set only if it is a column\r\n         singleton */\r\n        if (!(vc_len[j] != 1 && cs_prev[j] == j && cs_next[j] == j))\r\n        {  cs_prev[j] = 0;\r\n            cs_next[j] = cs_head[vc_len[j]];\r\n            if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;\r\n            cs_head[vc_len[j]] = j;\r\n        }\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction build_v_cols(luf){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var i, i_beg, i_end, i_ptr, j, j_ptr, k, nnz;\r\n    /* it is assumed that on entry all columns of the matrix V are\r\n     empty, i.e. vc_len[j] = vc_cap[j] = 0 for all j = 1, ..., n,\r\n     and have been removed from the addressing list */\r\n    /* count non-zeros in columns of the matrix V; count total number\r\n     of non-zeros in this matrix */\r\n    nnz = 0;\r\n    for (i = 1; i <= n; i++)\r\n    {  /* walk through elements of the i-th row and count non-zeros\r\n     in the corresponding columns */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n            vc_cap[sv_ind[i_ptr]]++;\r\n        /* count total number of non-zeros */\r\n        nnz += vr_len[i];\r\n    }\r\n    /* store total number of non-zeros */\r\n    luf.nnz_v = nnz;\r\n    /* check for free locations */\r\n    if (luf.sv_end - luf.sv_beg < nnz)\r\n    {  /* overflow of the sparse vector area */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n    /* allocate columns of the matrix V */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* set pointer to the j-th column */\r\n        vc_ptr[j] = luf.sv_beg;\r\n        /* reserve locations for the j-th column */\r\n        luf.sv_beg += vc_cap[j];\r\n    }\r\n    /* build the matrix V in column-wise format using this matrix in\r\n     row-wise format */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* walk through elements of the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        {  /* get column index */\r\n            j = sv_ind[i_ptr];\r\n            /* store element in the j-th column */\r\n            j_ptr = vc_ptr[j] + vc_len[j];\r\n            sv_ind[j_ptr] = i;\r\n            sv_val[j_ptr] = sv_val[i_ptr];\r\n            /* increase length of the j-th column */\r\n            vc_len[j]++;\r\n        }\r\n    }\r\n    /* now columns are placed in the sparse vector area behind rows\r\n     in the order n+1, n+2, ..., n+n; so insert column nodes in the\r\n     addressing list using this order */\r\n    for (k = n+1; k <= n+n; k++)\r\n    {  sv_prev[k] = k-1;\r\n        sv_next[k] = k+1;\r\n    }\r\n    sv_prev[n+1] = luf.sv_tail;\r\n    sv_next[luf.sv_tail] = n+1;\r\n    sv_next[n+n] = 0;\r\n    luf.sv_tail = n+n;\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction build_f_rows(luf){\r\n    var n = luf.n;\r\n    var fr_ptr = luf.fr_ptr;\r\n    var fr_len = luf.fr_len;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var ret = 0;\r\n    var i, j, j_beg, j_end, j_ptr, ptr, nnz;\r\n    /* clear rows of the matrix F */\r\n    for (i = 1; i <= n; i++) fr_len[i] = 0;\r\n    /* count non-zeros in rows of the matrix F; count total number of\r\n     non-zeros in this matrix */\r\n    nnz = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column and count non-zeros\r\n     in the corresponding rows */\r\n        j_beg = fc_ptr[j];\r\n        j_end = j_beg + fc_len[j] - 1;\r\n        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n            fr_len[sv_ind[j_ptr]]++;\r\n        /* increase total number of non-zeros */\r\n        nnz += fc_len[j];\r\n    }\r\n    /* store total number of non-zeros */\r\n    luf.nnz_f = nnz;\r\n    /* check for free locations */\r\n    if (luf.sv_end - luf.sv_beg < nnz)\r\n    {  /* overflow of the sparse vector area */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n    /* allocate rows of the matrix F */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* set pointer to the end of the i-th row; later this pointer\r\n     will be set to the beginning of the i-th row */\r\n        fr_ptr[i] = luf.sv_end;\r\n        /* reserve locations for the i-th row */\r\n        luf.sv_end -= fr_len[i];\r\n    }\r\n    /* build the matrix F in row-wise format using this matrix in\r\n     column-wise format */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column */\r\n        j_beg = fc_ptr[j];\r\n        j_end = j_beg + fc_len[j] - 1;\r\n        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n        {  /* get row index */\r\n            i = sv_ind[j_ptr];\r\n            /* store element in the i-th row */\r\n            ptr = --fr_ptr[i];\r\n            sv_ind[ptr] = j;\r\n            sv_val[ptr] = sv_val[j_ptr];\r\n        }\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction luf_factorize(luf, n, col, info){\r\n    var pp_row, pp_col, qq_row, qq_col;\r\n    var max_gro = luf.max_gro;\r\n    var i, j, k, p, q, t, ret = null;\r\n    if (n < 1)\r\n        xerror(\"luf_factorize: n = \" + n + \"; invalid parameter\");\r\n    if (n > N_MAX)\r\n        xerror(\"luf_factorize: n = \" + n + \"; matrix too big\");\r\n    /* invalidate the factorization */\r\n    luf.valid = 0;\r\n    /* reallocate arrays, if necessary */\r\n    reallocate(luf, n);\r\n    pp_row = luf.pp_row;\r\n    pp_col = luf.pp_col;\r\n    qq_row = luf.qq_row;\r\n    qq_col = luf.qq_col;\r\n    /* estimate initial size of the SVA, if not specified */\r\n    if (luf.sv_size == 0 && luf.new_sva == 0)\r\n        luf.new_sva = 5 * (n + 10);\r\n\r\n\r\n    function more(){\r\n        /* reallocate the sparse vector area, if required */\r\n        if (luf.new_sva > 0)\r\n        {   luf.sv_size = luf.new_sva;\r\n            luf.sv_ind = new Int32Array(1+luf.sv_size);\r\n            luf.sv_val = new Float64Array(1+luf.sv_size);\r\n            luf.new_sva = 0;\r\n        }\r\n        /* initialize LU-factorization data structures */\r\n        if (initialize(luf, col, info))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        /* main elimination loop */\r\n        for (k = 1; k <= n; k++)\r\n        {  /* choose a pivot element v[p,q] */\r\n            if (find_pivot(luf, function(_p, _q){p = _p; q = _q}))\r\n            {  /* no pivot can be chosen, because the active submatrix is\r\n             exactly zero */\r\n                luf.rank = k - 1;\r\n                ret = LUF_ESING;\r\n                return false;\r\n            }\r\n            /* let v[p,q] correspond to u[i',j']; permute k-th and i'-th\r\n             rows and k-th and j'-th columns of the matrix U = P*V*Q to\r\n             move the element u[i',j'] to the position u[k,k] */\r\n            i = pp_col[p]; j = qq_row[q];\r\n            xassert(k <= i && i <= n && k <= j && j <= n);\r\n            /* permute k-th and i-th rows of the matrix U */\r\n            t = pp_row[k];\r\n            pp_row[i] = t; pp_col[t] = i;\r\n            pp_row[k] = p; pp_col[p] = k;\r\n            /* permute k-th and j-th columns of the matrix U */\r\n            t = qq_col[k];\r\n            qq_col[j] = t; qq_row[t] = j;\r\n            qq_col[k] = q; qq_row[q] = k;\r\n            /* eliminate subdiagonal elements of k-th column of the matrix\r\n             U = P*V*Q using the pivot element u[k,k] = v[p,q] */\r\n            if (eliminate(luf, p, q))\r\n            {  /* overflow of the sparse vector area */\r\n                luf.new_sva = luf.sv_size + luf.sv_size;\r\n                xassert(luf.new_sva > luf.sv_size);\r\n                return true;\r\n            }\r\n            /* check relative growth of elements of the matrix V */\r\n            if (luf.big_v > max_gro * luf.max_a)\r\n            {  /* the growth is too intensive, therefore most probably the\r\n             matrix A is ill-conditioned */\r\n                luf.rank = k - 1;\r\n                ret = LUF_ECOND;\r\n                return false;\r\n            }\r\n        }\r\n        /* now the matrix U = P*V*Q is upper triangular, the matrix V has\r\n         been built in row-wise format, and the matrix F has been built\r\n         in column-wise format */\r\n        /* defragment the sparse vector area in order to merge all free\r\n         locations in one continuous extent */\r\n        luf_defrag_sva(luf);\r\n        /* build the matrix V in column-wise format */\r\n        if (build_v_cols(luf))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        /* build the matrix F in row-wise format */\r\n        if (build_f_rows(luf))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    while (more()){}\r\n    if (ret != null)\r\n        return ret;\r\n\r\n    /* the LU-factorization has been successfully computed */\r\n    luf.valid = 1;\r\n    luf.rank = n;\r\n    ret = 0;\r\n    /* if there are few free locations in the sparse vector area, try\r\n     increasing its size in the future */\r\n    t = 3 * (n + luf.nnz_v) + 2 * luf.nnz_f;\r\n    if (luf.sv_size < t)\r\n    {  luf.new_sva = luf.sv_size;\r\n        while (luf.new_sva < t)\r\n        {  k = luf.new_sva;\r\n            luf.new_sva = k + k;\r\n            xassert(luf.new_sva > k);\r\n        }\r\n    }\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction luf_f_solve(luf, tr, x){\r\n    var n = luf.n;\r\n    var fr_ptr = luf.fr_ptr;\r\n    var fr_len = luf.fr_len;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var pp_row = luf.pp_row;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var i, j, k, beg, end, ptr;\r\n    var xk;\r\n    if (!luf.valid)\r\n        xerror(\"luf_f_solve: LU-factorization is not valid\");\r\n    if (!tr)\r\n    {  /* solve the system F*x = b */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = pp_row[j];\r\n            xk = x[k];\r\n            if (xk != 0.0)\r\n            {  beg = fc_ptr[k];\r\n                end = beg + fc_len[k] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    x[sv_ind[ptr]] -= sv_val[ptr] * xk;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system F'*x = b */\r\n        for (i = n; i >= 1; i--)\r\n        {  k = pp_row[i];\r\n            xk = x[k];\r\n            if (xk != 0.0)\r\n            {  beg = fr_ptr[k];\r\n                end = beg + fr_len[k] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    x[sv_ind[ptr]] -= sv_val[ptr] * xk;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction luf_v_solve(luf, tr, x){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var pp_row = luf.pp_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var b = luf.work;\r\n    var i, j, k, beg, end, ptr;\r\n    var temp;\r\n    if (!luf.valid)\r\n        xerror(\"luf_v_solve: LU-factorization is not valid\");\r\n    for (k = 1; k <= n; k++){b[k] = x[k]; x[k] = 0.0}\r\n    if (!tr)\r\n    {  /* solve the system V*x = b */\r\n        for (k = n; k >= 1; k--)\r\n        {  i = pp_row[k]; j = qq_col[k];\r\n            temp = b[i];\r\n            if (temp != 0.0)\r\n            {  x[j] = (temp /= vr_piv[i]);\r\n                beg = vc_ptr[j];\r\n                end = beg + vc_len[j] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    b[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system V'*x = b */\r\n        for (k = 1; k <= n; k++)\r\n        {  i = pp_row[k]; j = qq_col[k];\r\n            temp = b[j];\r\n            if (temp != 0.0)\r\n            {  x[i] = (temp /= vr_piv[i]);\r\n                beg = vr_ptr[i];\r\n                end = beg + vr_len[i] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    b[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction luf_a_solve(luf, tr, x){\r\n    if (!luf.valid)\r\n        xerror(\"luf_a_solve: LU-factorization is not valid\");\r\n    if (!tr)\r\n    {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */\r\n        luf_f_solve(luf, 0, x);\r\n        luf_v_solve(luf, 0, x);\r\n    }\r\n    else\r\n    {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */\r\n        luf_v_solve(luf, 1, x);\r\n        luf_f_solve(luf, 1, x);\r\n    }\r\n}\r\n\r\nvar\r\n    MPL_EOF = -1;\r\n\r\nvar\r\n    A_BINARY       = 101,   /* something binary */\r\n    A_CHECK        = 102,   /* check statement */\r\n    A_CONSTRAINT   = 103,   /* model constraint */\r\n    A_DISPLAY      = 104,   /* display statement */\r\n    A_ELEMCON      = 105,   /* elemental constraint/objective */\r\n    A_ELEMSET      = 106,   /* elemental set */\r\n    A_ELEMVAR      = 107,   /* elemental variable */\r\n    A_EXPRESSION   = 108,   /* expression */\r\n    A_FOR          = 109,   /* for statement */\r\n    A_FORMULA      = 110,   /* formula */\r\n    A_INDEX        = 111,   /* dummy index */\r\n    A_INPUT        = 112,   /* input table */\r\n    A_INTEGER      = 113,   /* something integer */\r\n    A_LOGICAL      = 114,   /* something logical */\r\n    A_MAXIMIZE     = 115,   /* objective has to be maximized */\r\n    A_MINIMIZE     = 116,   /* objective has to be minimized */\r\n    A_NONE         = 117,   /* nothing */\r\n    A_NUMERIC      = 118,   /* something numeric */\r\n    A_OUTPUT       = 119,   /* output table */\r\n    A_PARAMETER    = 120,   /* model parameter */\r\n    A_PRINTF       = 121,   /* printf statement */\r\n    A_SET          = 122,   /* model set */\r\n    A_SOLVE        = 123,   /* solve statement */\r\n    A_SYMBOLIC     = 124,   /* something symbolic */\r\n    A_TABLE        = 125,   /* data table */\r\n    A_TUPLE        = 126,   /* n-tuple */\r\n    A_VARIABLE     = 127;   /* model variable */\r\n\r\n/* size limit is not necessary\r\n var\r\n    MAX_LENGTH = 100;\r\n maximal length of any symbolic value (this includes symbolic names,\r\n numeric and string literals, and all symbolic values that may appear\r\n during the evaluation phase) */\r\n\r\nvar CONTEXT_SIZE = 60;\r\n/* size of the context queue, in characters */\r\n\r\nvar OUTBUF_SIZE = 1024;\r\n/* size of the output buffer, in characters */\r\n\r\nvar\r\n    T_EOF          = 201,   /* end of file */\r\n    T_NAME         = 202,   /* symbolic name (model section only) */\r\n    T_SYMBOL       = 203,   /* symbol (data section only) */\r\n    T_NUMBER       = 204,   /* numeric literal */\r\n    T_STRING       = 205,   /* string literal */\r\n    T_AND          = 206,   /* and && */\r\n    T_BY           = 207,   /* by */\r\n    T_CROSS        = 208,   /* cross */\r\n    T_DIFF         = 209,   /* diff */\r\n    T_DIV          = 210,   /* div */\r\n    T_ELSE         = 211,   /* else */\r\n    T_IF           = 212,   /* if */\r\n    T_IN           = 213,   /* in */\r\n    T_INFINITY     = 214,   /* Infinity */\r\n    T_INTER        = 215,   /* inter */\r\n    T_LESS         = 216,   /* less */\r\n    T_MOD          = 217,   /* mod */\r\n    T_NOT          = 218,   /* not ! */\r\n    T_OR           = 219,   /* or || */\r\n    T_SPTP         = 220,   /* s.t. */\r\n    T_SYMDIFF      = 221,   /* symdiff */\r\n    T_THEN         = 222,   /* then */\r\n    T_UNION        = 223,   /* union */\r\n    T_WITHIN       = 224,   /* within */\r\n    T_PLUS         = 225,   /* + */\r\n    T_MINUS        = 226,   /* - */\r\n    T_ASTERISK     = 227,   /* * */\r\n    T_SLASH        = 228,   /* / */\r\n    T_POWER        = 229,   /* ^ ** */\r\n    T_LT           = 230,   /* <  */\r\n    T_LE           = 231,   /* <= */\r\n    T_EQ           = 232,   /* = == */\r\n    T_GE           = 233,   /* >= */\r\n    T_GT           = 234,   /* >  */\r\n    T_NE           = 235,   /* <> != */\r\n    T_CONCAT       = 236,   /* & */\r\n    T_BAR          = 237,   /* | */\r\n    T_POINT        = 238,   /* . */\r\n    T_COMMA        = 239,   /* , */\r\n    T_COLON        = 240,   /* : */\r\n    T_SEMICOLON    = 241,   /* ; */\r\n    T_ASSIGN       = 242,   /* := */\r\n    T_DOTS         = 243,   /* .. */\r\n    T_LEFT         = 244,   /* ( */\r\n    T_RIGHT        = 245,   /* ) */\r\n    T_LBRACKET     = 246,   /* [ */\r\n    T_RBRACKET     = 247,   /* ] */\r\n    T_LBRACE       = 248,   /* { */\r\n    T_RBRACE       = 249,   /* } */\r\n    T_APPEND       = 250,   /* >> */\r\n    T_TILDE        = 251,   /* ~ */\r\n    T_INPUT        = 252;   /* <- */\r\n\r\n            /* suffix specified: */\r\nvar\r\n    DOT_NONE       = 0x00,  /* none     (means variable itself) */\r\n    DOT_LB         = 0x01,  /* .lb      (lower bound) */\r\n    DOT_UB         = 0x02,  /* .ub      (upper bound) */\r\n    DOT_STATUS     = 0x03,  /* .status  (status) */\r\n    DOT_VAL        = 0x04,  /* .val     (primal value) */\r\n    DOT_DUAL       = 0x05;  /* .dual    (dual value) */\r\n\r\n        /* operation code: */\r\nvar\r\n    O_NUMBER       = 301,   /* take floating-point number */\r\n    O_STRING       = 302,   /* take character string */\r\n    O_INDEX        = 303,   /* take dummy index */\r\n    O_MEMNUM       = 304,   /* take member of numeric parameter */\r\n    O_MEMSYM       = 305,   /* take member of symbolic parameter */\r\n    O_MEMSET       = 306,   /* take member of set */\r\n    O_MEMVAR       = 307,   /* take member of variable */\r\n    O_MEMCON       = 308,   /* take member of constraint */\r\n    O_TUPLE        = 309,   /* make n-tuple */\r\n    O_MAKE         = 310,   /* make elemental set of n-tuples */\r\n    O_SLICE        = 311,   /* define domain block (dummy op) */\r\n      /* 0-ary operations --------------------*/\r\n    O_IRAND224     = 312,   /* pseudo-random in [0, 2^24-1] */\r\n    O_UNIFORM01    = 313,   /* pseudo-random in [0, 1) */\r\n    O_NORMAL01     = 314,   /* gaussian random, mu = 0, sigma = 1 */\r\n    O_GMTIME       = 315,   /* current calendar time (UTC) */\r\n        /* unary operations --------------------*/\r\n    O_CVTNUM       = 316,   /* conversion to numeric */\r\n    O_CVTSYM       = 317,   /* conversion to symbolic */\r\n    O_CVTLOG       = 318,   /* conversion to logical */\r\n    O_CVTTUP       = 319,   /* conversion to 1-tuple */\r\n    O_CVTLFM       = 320,   /* conversion to linear form */\r\n    O_PLUS         = 321,   /* unary plus */\r\n    O_MINUS        = 322,   /* unary minus */\r\n    O_NOT          = 323,   /* negation (logical \"not\") */\r\n    O_ABS          = 324,   /* absolute value */\r\n    O_CEIL         = 325,   /* round upward (\"ceiling of x\") */\r\n    O_FLOOR        = 326,   /* round downward (\"floor of x\") */\r\n    O_EXP          = 327,   /* base-e exponential */\r\n    O_LOG          = 328,   /* natural logarithm */\r\n    O_LOG10        = 329,   /* common (decimal) logarithm */\r\n    O_SQRT         = 330,   /* square root */\r\n    O_SIN          = 331,   /* trigonometric sine */\r\n    O_COS          = 332,   /* trigonometric cosine */\r\n    O_ATAN         = 333,   /* trigonometric arctangent */\r\n    O_ROUND        = 334,   /* round to nearest integer */\r\n    O_TRUNC        = 335,   /* truncate to nearest integer */\r\n    O_CARD         = 336,   /* cardinality of set */\r\n    O_LENGTH       = 337,   /* length of symbolic value */\r\n        /* binary operations -------------------*/\r\n    O_ADD          = 338,   /* addition */\r\n    O_SUB          = 339,   /* subtraction */\r\n    O_LESS         = 340,   /* non-negative subtraction */\r\n    O_MUL          = 341,   /* multiplication */\r\n    O_DIV          = 342,   /* division */\r\n    O_IDIV         = 343,   /* quotient of exact division */\r\n    O_MOD          = 344,   /* remainder of exact division */\r\n    O_POWER        = 345,   /* exponentiation (raise to power) */\r\n    O_ATAN2        = 346,   /* trigonometric arctangent */\r\n    O_ROUND2       = 347,   /* round to n fractional digits */\r\n    O_TRUNC2       = 348,   /* truncate to n fractional digits */\r\n    O_UNIFORM      = 349,   /* pseudo-random in [a, b) */\r\n    O_NORMAL       = 350,   /* gaussian random, given mu and sigma */\r\n    O_CONCAT       = 351,   /* concatenation */\r\n    O_LT           = 352,   /* comparison on 'less than' */\r\n    O_LE           = 353,   /* comparison on 'not greater than' */\r\n    O_EQ           = 354,   /* comparison on 'equal to' */\r\n    O_GE           = 355,   /* comparison on 'not less than' */\r\n    O_GT           = 356,   /* comparison on 'greater than' */\r\n    O_NE           = 357,   /* comparison on 'not equal to' */\r\n    O_AND          = 358,   /* conjunction (logical \"and\") */\r\n    O_OR           = 359,   /* disjunction (logical \"or\") */\r\n    O_UNION        = 360,   /* union */\r\n    O_DIFF         = 361,   /* difference */\r\n    O_SYMDIFF      = 362,   /* symmetric difference */\r\n    O_INTER        = 363,   /* intersection */\r\n    O_CROSS        = 364,   /* cross (Cartesian) product */\r\n    O_IN           = 365,   /* test on 'x in Y' */\r\n    O_NOTIN        = 366,   /* test on 'x not in Y' */\r\n    O_WITHIN       = 367,   /* test on 'X within Y' */\r\n    O_NOTWITHIN    = 368,   /* test on 'X not within Y' */\r\n    O_SUBSTR       = 369,   /* substring */\r\n    O_STR2TIME     = 370,   /* convert string to time */\r\n    O_TIME2STR     = 371,   /* convert time to string */\r\n        /* ternary operations ------------------*/\r\n    O_DOTS         = 372,   /* build \"arithmetic\" set */\r\n    O_FORK         = 373,   /* if-then-else */\r\n    O_SUBSTR3      = 374,   /* substring */\r\n        /* n-ary operations --------------------*/\r\n    O_MIN          = 375,   /* minimal value (n-ary) */\r\n    O_MAX          = 376,   /* maximal value (n-ary) */\r\n        /* iterated operations -----------------*/\r\n    O_SUM          = 377,   /* summation */\r\n    O_PROD         = 378,   /* multiplication */\r\n    O_MINIMUM      = 379,   /* minimum */\r\n    O_MAXIMUM      = 380,   /* maximum */\r\n    O_FORALL       = 381,   /* conjunction (A-quantification) */\r\n    O_EXISTS       = 382,   /* disjunction (E-quantification) */\r\n    O_SETOF        = 383,   /* compute elemental set */\r\n    O_BUILD        = 384;   /* build elemental set */\r\n\r\n    /**********************************************************************/\r\n    /* * *                      SOLVER INTERFACE                      * * */\r\n    /**********************************************************************/\r\nvar\r\n    MPL_FR         = 401,   /* free (unbounded) */\r\n    MPL_LO         = 402,   /* lower bound */\r\n    MPL_UP         = 403,   /* upper bound */\r\n    MPL_DB         = 404,   /* both lower and upper bounds */\r\n    MPL_FX         = 405,   /* fixed */\r\n    MPL_ST         = 411,   /* constraint */\r\n    MPL_MIN        = 412,   /* objective (minimization) */\r\n    MPL_MAX        = 413,   /* objective (maximization) */\r\n    MPL_NUM        = 421,   /* continuous */\r\n    MPL_INT        = 422,   /* integer */\r\n    MPL_BIN        = 423;   /* binary */\r\n\r\nfunction mpl_internal_create_operands(){\r\n    return {index: {},par: {},set: {},var_: {},con: {},arg: {},loop: {}};\r\n}\r\n\r\n/* glpmpl01.c */\r\n\r\n/**********************************************************************/\r\n/* * *                  PROCESSING MODEL SECTION                  * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_enter_context(mpl){\r\n    var image;\r\n    if (mpl.token == T_EOF)\r\n        image = \"_|_\";\r\n    else if (mpl.token == T_STRING)\r\n        image = \"'...'\";\r\n    else\r\n        image = mpl.image;\r\n    xassert(0 <= mpl.c_ptr && mpl.c_ptr < CONTEXT_SIZE);\r\n    mpl.context[mpl.c_ptr++] = ' ';\r\n    if (mpl.c_ptr == CONTEXT_SIZE) mpl.c_ptr = 0;\r\n    for (var s = 0; s < image.length; s++)\r\n    {   mpl.context[mpl.c_ptr++] = image[s];\r\n        if (mpl.c_ptr == CONTEXT_SIZE) mpl.c_ptr = 0;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_print_context(mpl){\r\n    var c;\r\n    while (mpl.c_ptr > 0)\r\n    {  mpl.c_ptr--;\r\n        c = mpl.context[0];\r\n        xcopyArr(mpl.context, 0, mpl.context, 1, CONTEXT_SIZE-1);\r\n        mpl.context[CONTEXT_SIZE-1] = c;\r\n    }\r\n    xprintf(\"Context: \" + mpl.line + \" > \" +  (mpl.context[0] == ' ' ? \"\" : \"...\") + mpl.context.join('').trim());\r\n}\r\n\r\nfunction mpl_internal_get_char(mpl){\r\n    var c;\r\n    if (mpl.c == MPL_EOF) return;\r\n    if (mpl.c == '\\n'){\r\n        mpl.line++;\r\n        mpl.column = 0;\r\n    }\r\n    c = mpl_internal_read_char(mpl);\r\n    mpl.column++;\r\n    if (c == MPL_EOF)\r\n    {  if (mpl.c == '\\n')\r\n        mpl.line--;\r\n    else\r\n        mpl_internal_warning(mpl, \"final NL missing before end of file\");\r\n    }\r\n    else if (c == '\\n'){\r\n\r\n    }\r\n    else if (isspace(c))\r\n        c = ' ';\r\n    else if (iscntrl(c))\r\n    {  mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"control character \" + c + \" not allowed\");\r\n    }\r\n    mpl.c = c;\r\n}\r\n\r\nfunction mpl_internal_append_char(mpl){\r\n    xassert(0 <= mpl.imlen /*&& mpl.imlen <= MAX_LENGTH*/);\r\n/*\r\n    if (mpl.imlen >= MAX_LENGTH)\r\n    {  switch (mpl.token)\r\n    {  case T_NAME:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbolic name \" + mpl.image + \"... too long\");\r\n            break;\r\n        case T_SYMBOL:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbol \" + mpl.image + \"... too long\");\r\n            break;\r\n        case T_NUMBER:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"numeric literal \" + mpl.image + \"... too long\");\r\n            break;\r\n\r\n        case T_STRING:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"string literal too long\");\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    }\r\n*/\r\n    mpl.image += mpl.c ;\r\n    mpl.imlen++;\r\n    mpl_internal_get_char(mpl);\r\n}\r\n\r\nfunction mpl_internal_get_token(mpl){\r\n\r\n    function sptp(){\r\n        mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"keyword s.t. incomplete\");\r\n    }\r\n\r\n    function err(){\r\n        mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"cannot convert numeric literal \" + mpl.image + \" to floating-point number\");\r\n    }\r\n\r\n    function scanDecimal(){\r\n        /* scan optional decimal exponent */\r\n        if (mpl.c == 'e' || mpl.c == 'E')\r\n        {   mpl_internal_append_char(mpl);\r\n            if (mpl.c == '+' || mpl.c == '-') mpl_internal_append_char(mpl);\r\n            if (!isdigit(mpl.c))\r\n            {  mpl_internal_enter_context(mpl);\r\n                mpl_internal_error(mpl, \"numeric literal \" + mpl.image + \" incomplete\");\r\n            }\r\n            while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n        }\r\n        /* there must be no letter following the numeric literal */\r\n        if (isalpha(mpl.c) || mpl.c == '_')\r\n        {   mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbol \" + mpl.image + mpl.c + \"... should be enclosed in quotes\");\r\n        }\r\n    }\r\n\r\n    /* save the current token */\r\n    mpl.b_token = mpl.token;\r\n    mpl.b_imlen = mpl.imlen;\r\n    mpl.b_image = mpl.image;\r\n    mpl.b_value = mpl.value;\r\n    /* if the next token is already scanned, make it current */\r\n    if (mpl.f_scan)\r\n    {   mpl.f_scan = 0;\r\n        mpl.token = mpl.f_token;\r\n        mpl.imlen = mpl.f_imlen;\r\n        mpl.image = mpl.f_image;\r\n        mpl.value = mpl.f_value;\r\n        return;\r\n    }\r\n    /* nothing has been scanned so far */\r\n    while (true){\r\n        mpl.token = 0;\r\n        mpl.imlen = 0;\r\n        mpl.image = '';\r\n        mpl.value = 0.0;\r\n        /* skip any uninteresting characters */\r\n        while (mpl.c == ' ' || mpl.c == '\\n') mpl_internal_get_char(mpl);\r\n        /* recognize and construct the token */\r\n        if (mpl.c == MPL_EOF)\r\n        {  /* end-of-file reached */\r\n            mpl.token = T_EOF;\r\n        }\r\n        else if (mpl.c == '#')\r\n        {  /* comment; skip anything until end-of-line */\r\n            while (mpl.c != '\\n' && mpl.c != MPL_EOF) mpl_internal_get_char(mpl);\r\n            continue;\r\n        }\r\n        else if (!mpl.flag_d && (isalpha(mpl.c) || mpl.c == '_'))\r\n        {  /* symbolic name or reserved keyword */\r\n            mpl.token = T_NAME;\r\n            while (isalnum(mpl.c) || mpl.c == '_') mpl_internal_append_char(mpl);\r\n            if (mpl.image == \"and\")\r\n                mpl.token = T_AND;\r\n            else if (mpl.image == \"by\")\r\n                mpl.token = T_BY;\r\n            else if (mpl.image == \"cross\")\r\n                mpl.token = T_CROSS;\r\n            else if (mpl.image == \"diff\")\r\n                mpl.token = T_DIFF;\r\n            else if (mpl.image == \"div\")\r\n                mpl.token = T_DIV;\r\n            else if (mpl.image == \"else\")\r\n                mpl.token = T_ELSE;\r\n            else if (mpl.image == \"if\")\r\n                mpl.token = T_IF;\r\n            else if (mpl.image == \"in\")\r\n                mpl.token = T_IN;\r\n            else if (mpl.image == \"Infinity\")\r\n                mpl.token = T_INFINITY;\r\n            else if (mpl.image == \"inter\")\r\n                mpl.token = T_INTER;\r\n            else if (mpl.image == \"less\")\r\n                mpl.token = T_LESS;\r\n            else if (mpl.image == \"mod\")\r\n                mpl.token = T_MOD;\r\n            else if (mpl.image == \"not\")\r\n                mpl.token = T_NOT;\r\n            else if (mpl.image == \"or\")\r\n                mpl.token = T_OR;\r\n            else if (mpl.image == \"s\" && mpl.c == '.')\r\n            {   mpl.token = T_SPTP;\r\n                mpl_internal_append_char(mpl);\r\n                if (mpl.c != 't') sptp();\r\n                mpl_internal_append_char(mpl);\r\n                if (mpl.c != '.') sptp();\r\n                mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.image == \"symdiff\")\r\n                mpl.token = T_SYMDIFF;\r\n            else if (mpl.image == \"then\")\r\n                mpl.token = T_THEN;\r\n            else if (mpl.image == \"union\")\r\n                mpl.token = T_UNION;\r\n            else if (mpl.image == \"within\")\r\n                mpl.token = T_WITHIN;\r\n        }\r\n        else if (!mpl.flag_d && isdigit(mpl.c))\r\n        {   /* numeric literal */\r\n            mpl.token = T_NUMBER;\r\n            /* scan integer part */\r\n            while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n            /* scan optional fractional part */\r\n            var skip = false;\r\n            if (mpl.c == '.')\r\n            {   mpl_internal_append_char(mpl);\r\n                if (mpl.c == '.')\r\n                {  /* hmm, it is not the fractional part, it is dots that\r\n                 follow the integer part */\r\n                    mpl.imlen--;\r\n                    mpl.image = mpl.image.substr(0,mpl.image.length-1);\r\n                    mpl.f_dots = 1;\r\n                    skip = true;\r\n                } else{\r\n                    while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n                }\r\n            }\r\n            if (!skip)\r\n                scanDecimal();\r\n            /* convert numeric literal to floating-point */\r\n            if (str2num(mpl.image, function(v){mpl.value = v})) err();\r\n        }\r\n        else if (mpl.c == '\\'' || mpl.c == '\"')\r\n        {   /* character string */\r\n            var quote = mpl.c;\r\n            var triple = false;\r\n            mpl.token = T_STRING;\r\n            mpl_internal_get_char(mpl);\r\n\r\n\r\n            function eat(){\r\n                for (;;)\r\n                {   if ((mpl.c == '\\n' && !triple) || mpl.c == MPL_EOF)\r\n                    {   mpl_internal_enter_context(mpl);\r\n                        mpl_internal_error(mpl, \"unexpected end of line; string literal incomplete\");\r\n                    }\r\n                    if (mpl.c == quote)\r\n                    {   mpl_internal_get_char(mpl);\r\n                        if (mpl.c == quote)\r\n                        {   if (triple)\r\n                            {   mpl_internal_get_char(mpl);\r\n                                if (mpl.c == quote)\r\n                                {\r\n                                    mpl_internal_get_char(mpl);\r\n                                    break;\r\n                                } else {\r\n                                    mpl.image += '\"\"' ;\r\n                                    mpl.imlen += 2;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (triple)\r\n                            {\r\n                                mpl.image += '\"' ;\r\n                                mpl.imlen++;\r\n                            } else\r\n                                break;\r\n                        }\r\n\r\n                    }\r\n                    mpl_internal_append_char(mpl);\r\n                }\r\n            }\r\n\r\n            if (mpl.c == quote){\r\n                mpl_internal_get_char(mpl);\r\n                if (mpl.c == quote){\r\n                    triple = true;\r\n                    mpl_internal_get_char(mpl);\r\n                    eat();\r\n                } else {\r\n                    // empty string\r\n                }\r\n            } else {\r\n                eat()\r\n            }\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '+'){\r\n            mpl.token = T_PLUS; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '-'){\r\n            mpl.token = T_MINUS; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '*')\r\n        {   mpl.token = T_ASTERISK; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '*'){\r\n                mpl.token = T_POWER; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '/')\r\n        {   mpl.token = T_SLASH; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '*')\r\n            {  /* comment sequence */\r\n                mpl_internal_get_char(mpl);\r\n                for (;;)\r\n                {  if (mpl.c == MPL_EOF)\r\n                {  /* do not call enter_context at this point */\r\n                    mpl_internal_error(mpl, \"unexpected end of file; comment sequence incomplete\");\r\n                }\r\n                else if (mpl.c == '*')\r\n                {  mpl_internal_get_char(mpl);\r\n                    if (mpl.c == '/') break;\r\n                }\r\n                else\r\n                    mpl_internal_get_char(mpl);\r\n                }\r\n                mpl_internal_get_char(mpl);\r\n                continue;\r\n            }\r\n        }\r\n        else if (mpl.c == '^'){\r\n            mpl.token = T_POWER; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '<')\r\n        {   mpl.token = T_LT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_LE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '>'){\r\n                mpl.token = T_NE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '-'){\r\n                mpl.token = T_INPUT; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '=')\r\n        {   mpl.token = T_EQ; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '=') mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '>')\r\n        {   mpl.token = T_GT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_GE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '>'){\r\n                mpl.token = T_APPEND; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '!')\r\n        {   mpl.token = T_NOT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_NE; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '&')\r\n        {   mpl.token = T_CONCAT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '&'){\r\n                mpl.token = T_AND; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '|')\r\n        {   mpl.token = T_BAR; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '|'){\r\n                mpl.token = T_OR; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '.')\r\n        {   mpl.token = T_POINT; mpl_internal_append_char(mpl);\r\n            if (mpl.f_dots)\r\n            {  /* dots; the first dot was read on the previous call to the\r\n             scanner, so the current character is the second dot */\r\n                mpl.token = T_DOTS;\r\n                mpl.imlen = 2;\r\n                mpl.image = \"..\";\r\n                mpl.f_dots = 0;\r\n            }\r\n            else if (mpl.c == '.'){\r\n                mpl.token = T_DOTS; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (isdigit(mpl.c))\r\n            {  /* numeric literal that begins with the decimal point */\r\n                mpl.token = T_NUMBER; mpl_internal_append_char(mpl);\r\n                while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n                scanDecimal();\r\n                /* convert numeric literal to floating-point */\r\n                if (str2num(mpl.image, function(v){mpl.value = v})) err();\r\n            }\r\n        }\r\n        else if (mpl.c == ','){\r\n            mpl.token = T_COMMA; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ':')\r\n        {  mpl.token = T_COLON; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_ASSIGN; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == ';'){\r\n            mpl.token = T_SEMICOLON; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '('){\r\n            mpl.token = T_LEFT; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ')'){\r\n            mpl.token = T_RIGHT; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '['){\r\n            mpl.token = T_LBRACKET; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ']'){\r\n            mpl.token = T_RBRACKET; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '{'){\r\n            mpl.token = T_LBRACE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '}'){\r\n            mpl.token = T_RBRACE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '~'){\r\n            mpl.token = T_TILDE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (isalnum(mpl.c) || strchr(\"+-._\", mpl.c) >= 0)\r\n        {   /* symbol */\r\n            xassert(mpl.flag_d);\r\n            mpl.token = T_SYMBOL;\r\n            while (isalnum(mpl.c) || strchr(\"+-._\", mpl.c) >= 0)\r\n                mpl_internal_append_char(mpl);\r\n            switch (str2num(mpl.image, function(v){mpl.value = v})){\r\n                case 0:\r\n                    mpl.token = T_NUMBER;\r\n                    break;\r\n                case 1:\r\n                    err();\r\n                    break;\r\n                case 2:\r\n                    break;\r\n                default:\r\n                    xassert(mpl != mpl);\r\n            }\r\n        }\r\n        else\r\n        {   mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"character \" + mpl.c + \" not allowed\");\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    /* enter the current token into the context queue */\r\n    mpl_internal_enter_context(mpl);\r\n    /* reset the flag, which may be set by indexing_expression() and\r\n     is used by expression_list() */\r\n    mpl.flag_x = 0;\r\n}\r\n\r\nfunction mpl_internal_unget_token(mpl){\r\n    /* save the current token, which becomes the next one */\r\n    xassert(!mpl.f_scan);\r\n    mpl.f_scan = 1;\r\n    mpl.f_token = mpl.token;\r\n    mpl.f_imlen = mpl.imlen;\r\n    mpl.f_image = mpl.image;\r\n    mpl.f_value = mpl.value;\r\n    /* restore the previous token, which becomes the current one */\r\n    mpl.token = mpl.b_token;\r\n    mpl.imlen = mpl.b_imlen;\r\n    mpl.image = mpl.b_image;\r\n    mpl.value = mpl.b_value;\r\n}\r\n\r\nfunction mpl_internal_is_keyword(mpl, keyword){\r\n    return mpl.token == T_NAME && mpl.image == keyword;\r\n}\r\n\r\nfunction mpl_internal_is_reserved(mpl){\r\n    return mpl.token == T_AND && mpl.image[0] == 'a' ||\r\n        mpl.token == T_BY ||\r\n        mpl.token == T_CROSS ||\r\n        mpl.token == T_DIFF ||\r\n        mpl.token == T_DIV ||\r\n        mpl.token == T_ELSE ||\r\n        mpl.token == T_IF ||\r\n        mpl.token == T_IN ||\r\n        mpl.token == T_INTER ||\r\n        mpl.token == T_LESS ||\r\n        mpl.token == T_MOD ||\r\n        mpl.token == T_NOT && mpl.image[0] == 'n' ||\r\n        mpl.token == T_OR && mpl.image[0] == 'o' ||\r\n        mpl.token == T_SYMDIFF ||\r\n        mpl.token == T_THEN ||\r\n        mpl.token == T_UNION ||\r\n        mpl.token == T_WITHIN;\r\n}\r\n\r\nfunction mpl_internal_make_code(mpl, op, arg, type, dim){\r\n    var code = {};\r\n    var domain;\r\n    var block;\r\n    var e;\r\n    /* generate pseudo-code */\r\n    code.op = op;\r\n    code.vflag = 0; /* is inherited from operand(s) */\r\n    /* copy operands and also make them referring to the pseudo-code\r\n     being generated, because the latter becomes the parent for all\r\n     its operands */\r\n    code.arg = mpl_internal_create_operands();\r\n    code.value = {};\r\n    switch (op)\r\n    {   case O_NUMBER:\r\n        code.arg.num = arg.num;\r\n        break;\r\n        case O_STRING:\r\n            code.arg.str = arg.str;\r\n            break;\r\n        case O_INDEX:\r\n            code.arg.index.slot = arg.index.slot;\r\n            code.arg.index.next = arg.index.next;\r\n            break;\r\n        case O_MEMNUM:\r\n        case O_MEMSYM:\r\n            for (e = arg.par.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.par.par = arg.par.par;\r\n            code.arg.par.list = arg.par.list;\r\n            break;\r\n        case O_MEMSET:\r\n            for (e = arg.set.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.set.set = arg.set.set;\r\n            code.arg.set.list = arg.set.list;\r\n            break;\r\n        case O_MEMVAR:\r\n            for (e = arg.var_.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.var_.var_ = arg.var_.var_;\r\n            code.arg.var_.list = arg.var_.list;\r\n            code.arg.var_.suff = arg.var_.suff;\r\n            break;\r\n        case O_MEMCON:\r\n            for (e = arg.con.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.con.con = arg.con.con;\r\n            code.arg.con.list = arg.con.list;\r\n            code.arg.con.suff = arg.con.suff;\r\n            break;\r\n        case O_TUPLE:\r\n        case O_MAKE:\r\n            for (e = arg.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.list = arg.list;\r\n            break;\r\n        case O_SLICE:\r\n            xassert(arg.slice != null);\r\n            code.arg.slice = arg.slice;\r\n            break;\r\n        case O_IRAND224:\r\n        case O_UNIFORM01:\r\n        case O_NORMAL01:\r\n        case O_GMTIME:\r\n            code.vflag = 1;\r\n            break;\r\n        case O_CVTNUM:\r\n        case O_CVTSYM:\r\n        case O_CVTLOG:\r\n        case O_CVTTUP:\r\n        case O_CVTLFM:\r\n        case O_PLUS:\r\n        case O_MINUS:\r\n        case O_NOT:\r\n        case O_ABS:\r\n        case O_CEIL:\r\n        case O_FLOOR:\r\n        case O_EXP:\r\n        case O_LOG:\r\n        case O_LOG10:\r\n        case O_SQRT:\r\n        case O_SIN:\r\n        case O_COS:\r\n        case O_ATAN:\r\n        case O_ROUND:\r\n        case O_TRUNC:\r\n        case O_CARD:\r\n        case O_LENGTH:\r\n            /* unary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            code.arg.arg.x = arg.arg.x;\r\n            break;\r\n        case O_ADD:\r\n        case O_SUB:\r\n        case O_LESS:\r\n        case O_MUL:\r\n        case O_DIV:\r\n        case O_IDIV:\r\n        case O_MOD:\r\n        case O_POWER:\r\n        case O_ATAN2:\r\n        case O_ROUND2:\r\n        case O_TRUNC2:\r\n        case O_UNIFORM:\r\n            if (op == O_UNIFORM) code.vflag = 1;\r\n        case O_NORMAL:\r\n            if (op == O_NORMAL) code.vflag = 1;\r\n        case O_CONCAT:\r\n        case O_LT:\r\n        case O_LE:\r\n        case O_EQ:\r\n        case O_GE:\r\n        case O_GT:\r\n        case O_NE:\r\n        case O_AND:\r\n        case O_OR:\r\n        case O_UNION:\r\n        case O_DIFF:\r\n        case O_SYMDIFF:\r\n        case O_INTER:\r\n        case O_CROSS:\r\n        case O_IN:\r\n        case O_NOTIN:\r\n        case O_WITHIN:\r\n        case O_NOTWITHIN:\r\n        case O_SUBSTR:\r\n        case O_STR2TIME:\r\n        case O_TIME2STR:\r\n            /* binary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            xassert(arg.arg.y != null);\r\n            xassert(arg.arg.y.up == null);\r\n            arg.arg.y.up = code;\r\n            code.vflag |= arg.arg.y.vflag;\r\n            code.arg.arg.x = arg.arg.x;\r\n            code.arg.arg.y = arg.arg.y;\r\n            break;\r\n        case O_DOTS:\r\n        case O_FORK:\r\n        case O_SUBSTR3:\r\n            /* ternary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            xassert(arg.arg.y != null);\r\n            xassert(arg.arg.y.up == null);\r\n            arg.arg.y.up = code;\r\n            code.vflag |= arg.arg.y.vflag;\r\n            if (arg.arg.z != null)\r\n            {  xassert(arg.arg.z.up == null);\r\n                arg.arg.z.up = code;\r\n                code.vflag |= arg.arg.z.vflag;\r\n            }\r\n            code.arg.arg.x = arg.arg.x;\r\n            code.arg.arg.y = arg.arg.y;\r\n            code.arg.arg.z = arg.arg.z;\r\n            break;\r\n        case O_MIN:\r\n        case O_MAX:\r\n            /* n-ary operation */\r\n            for (e = arg.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.list = arg.list;\r\n            break;\r\n        case O_SUM:\r\n        case O_PROD:\r\n        case O_MINIMUM:\r\n        case O_MAXIMUM:\r\n        case O_FORALL:\r\n        case O_EXISTS:\r\n        case O_SETOF:\r\n        case O_BUILD:\r\n            /* iterated operation */\r\n            domain = arg.loop.domain;\r\n            xassert(domain != null);\r\n            if (domain.code != null)\r\n            {  xassert(domain.code.up == null);\r\n                domain.code.up = code;\r\n                code.vflag |= domain.code.vflag;\r\n            }\r\n            for (block = domain.list; block != null; block =\r\n                block.next)\r\n            {  xassert(block.code != null);\r\n                xassert(block.code.up == null);\r\n                block.code.up = code;\r\n                code.vflag |= block.code.vflag;\r\n            }\r\n            if (arg.loop.x != null)\r\n            {  xassert(arg.loop.x.up == null);\r\n                arg.loop.x.up = code;\r\n                code.vflag |= arg.loop.x.vflag;\r\n            }\r\n            code.arg.loop.domain = arg.loop.domain;\r\n            code.arg.loop.x = arg.loop.x;\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    /* set other attributes of the pseudo-code */\r\n    code.type = type;\r\n    code.dim = dim;\r\n    code.up = null;\r\n    code.valid = 0;\r\n    code.value = {};\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_unary(mpl, op, x, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    arg.arg.x = x;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_binary(mpl, op, x, y, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    xassert(y != null);\r\n    arg.arg.x = x;\r\n    arg.arg.y = y;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_ternary(mpl, op, x, y, z, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    xassert(y != null);\r\n    /* third operand can be null */\r\n    arg.arg.x = x;\r\n    arg.arg.y = y;\r\n    arg.arg.z = z;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_numeric_literal(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_NUMBER);\r\n    arg.num = mpl.value;\r\n    code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);\r\n    mpl_internal_get_token(mpl /* <numeric literal> */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_string_literal(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_STRING);\r\n    arg.str = mpl.image;\r\n    code = mpl_internal_make_code(mpl, O_STRING, arg, A_SYMBOLIC, 0);\r\n    mpl_internal_get_token(mpl /* <string literal> */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_expand_arg_list(mpl, list, x){\r\n    var tail = {}, temp;\r\n    xassert(x != null);\r\n    /* create new operands list entry */\r\n    tail.x = x;\r\n    tail.next = null;\r\n    /* and append it to the operands list */\r\n    if (list == null)\r\n        list = tail;\r\n    else\r\n    {   for (temp = list; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return list;\r\n}\r\n\r\nfunction mpl_internal_arg_list_len(mpl, list){\r\n    var temp;\r\n    var len;\r\n\r\n    len = 0;\r\n    for (temp = list; temp != null; temp = temp.next) len++;\r\n    return len;\r\n}\r\n\r\nfunction mpl_internal_subscript_list(mpl){\r\n    var x;\r\n    var list = null;\r\n    for (;;)\r\n    {   /* parse subscript expression */\r\n        x = mpl_internal_expression_5(mpl);\r\n        /* convert it to symbolic type, if necessary */\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n        /* check that now the expression is of symbolic type */\r\n        if (x.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"subscript expression has invalid type\");\r\n        xassert(x.dim == 0);\r\n        /* and append it to the subscript list */\r\n        list = mpl_internal_expand_arg_list(mpl, list, x);\r\n        /* check a token that follows the subscript expression */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RBRACKET)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in subscript list\");\r\n    }\r\n    return list;\r\n}\r\n\r\nfunction mpl_internal_object_reference(mpl){\r\n    var slot, set, par, var_, con, list, code, name, dim, suff;\r\n    var arg = mpl_internal_create_operands();\r\n    /* find the object in the symbolic name table */\r\n    xassert(mpl.token == T_NAME);\r\n    var node = mpl.tree[mpl.image];\r\n    if (node == null)\r\n        mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n    /* check the object type and obtain its dimension */\r\n    switch (node.type)\r\n    {  case A_INDEX:\r\n        /* dummy index */\r\n        slot = node.link;\r\n        name = slot.name;\r\n        dim = 0;\r\n        break;\r\n        case A_SET:\r\n            /* model set */\r\n            set = node.link;\r\n            name = set.name;\r\n            dim = set.dim;\r\n            /* if a set object is referenced in its own declaration and\r\n             the dimen attribute is not specified yet, use dimen 1 by\r\n             default */\r\n            if (set.dimen == 0) set.dimen = 1;\r\n            break;\r\n        case A_PARAMETER:\r\n            /* model parameter */\r\n            par = node.link;\r\n            name = par.name;\r\n            dim = par.dim;\r\n            break;\r\n        case A_VARIABLE:\r\n            /* model variable */\r\n            var_ = node.link;\r\n            name = var_.name;\r\n            dim = var_.dim;\r\n            break;\r\n        case A_CONSTRAINT:\r\n            /* model constraint or objective */\r\n            con = node.link;\r\n            name = con.name;\r\n            dim = con.dim;\r\n            break;\r\n        default:\r\n            xassert(node != node);\r\n    }\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional subscript list */\r\n    if (mpl.token == T_LBRACKET)\r\n    {  /* subscript list is specified */\r\n        if (dim == 0)\r\n            mpl_internal_error(mpl, name + \" cannot be subscripted\");\r\n        mpl_internal_get_token(mpl /* [ */);\r\n        list = mpl_internal_subscript_list(mpl);\r\n        if (dim != mpl_internal_arg_list_len(mpl, list))\r\n            mpl_internal_error(mpl, name + \" must have \" + dim + \" subscript\" + (dim == 1 ? \"\" : \"s\") + \" rather than \" + mpl_internal_arg_list_len(mpl, list));\r\n        xassert(mpl.token == T_RBRACKET);\r\n        mpl_internal_get_token(mpl /* ] */);\r\n    }\r\n    else\r\n    {  /* subscript list is not specified */\r\n        if (dim != 0)\r\n            mpl_internal_error(mpl, name + \" must be subscripted\");\r\n        list = null;\r\n    }\r\n    /* parse optional suffix */\r\n    if (!mpl.flag_s && node.type == A_VARIABLE)\r\n        suff = DOT_NONE;\r\n    else\r\n        suff = DOT_VAL;\r\n    if (mpl.token == T_POINT)\r\n    {  mpl_internal_get_token(mpl /* . */);\r\n        if (mpl.token != T_NAME)\r\n            mpl_internal_error(mpl, \"invalid use of period\");\r\n        if (!(node.type == A_VARIABLE ||\r\n            node.type == A_CONSTRAINT))\r\n            mpl_internal_error(mpl, name + \" cannot have a suffix\");\r\n        if (mpl.image == \"lb\")\r\n            suff = DOT_LB;\r\n        else if (mpl.image == \"ub\")\r\n            suff = DOT_UB;\r\n        else if (mpl.image == \"status\")\r\n            suff = DOT_STATUS;\r\n        else if (mpl.image == \"val\")\r\n            suff = DOT_VAL;\r\n        else if (mpl.image == \"dual\")\r\n            suff = DOT_DUAL;\r\n        else\r\n            mpl_internal_error(mpl, \"suffix .\" + mpl.image + \" invalid\");\r\n        mpl_internal_get_token(mpl /* suffix */);\r\n    }\r\n    /* generate pseudo-code to take value of the object */\r\n    switch (node.type)\r\n    {  case A_INDEX:\r\n        arg.index.slot = slot;\r\n        arg.index.next = slot.list;\r\n        code = mpl_internal_make_code(mpl, O_INDEX, arg, A_SYMBOLIC, 0);\r\n        slot.list = code;\r\n        break;\r\n        case A_SET:\r\n            arg.set.set = set;\r\n            arg.set.list = list;\r\n            code = mpl_internal_make_code(mpl, O_MEMSET, arg, A_ELEMSET, set.dimen);\r\n            break;\r\n        case A_PARAMETER:\r\n            arg.par.par = par;\r\n            arg.par.list = list;\r\n            if (par.type == A_SYMBOLIC)\r\n                code = mpl_internal_make_code(mpl, O_MEMSYM, arg, A_SYMBOLIC, 0);\r\n            else\r\n                code = mpl_internal_make_code(mpl, O_MEMNUM, arg, A_NUMERIC, 0);\r\n            break;\r\n        case A_VARIABLE:\r\n            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL\r\n                || suff == DOT_DUAL))\r\n                mpl_internal_error(mpl, \"invalid reference to status, primal value, or dual value of variable \" + var_.name + \" above solve statement\");\r\n            arg.var_.var_ = var_;\r\n            arg.var_.list = list;\r\n            arg.var_.suff = suff;\r\n            code = mpl_internal_make_code(mpl, O_MEMVAR, arg, suff == DOT_NONE ?\r\n                A_FORMULA : A_NUMERIC, 0);\r\n            break;\r\n        case A_CONSTRAINT:\r\n            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL\r\n                || suff == DOT_DUAL))\r\n                mpl_internal_error(mpl, \"invalid reference to status, primal value, o\"+\r\n                    \"r dual value of \" + (con.type == A_CONSTRAINT ? \"constraint\" : \"objective\") +\r\n                    \" \" + con.name + \" above solve statement\");\r\n            arg.con.con = con;\r\n            arg.con.list = list;\r\n            arg.con.suff = suff;\r\n            code = mpl_internal_make_code(mpl, O_MEMCON, arg, A_NUMERIC, 0);\r\n            break;\r\n        default:\r\n            xassert(node != node);\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_numeric_argument(mpl, func){\r\n    var x = mpl_internal_expression_5(mpl);\r\n    /* convert the argument to numeric type, if necessary */\r\n    if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n    /* check that now the argument is of numeric type */\r\n    if (x.type != A_NUMERIC)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim == 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_symbolic_argument(mpl, func){\r\n    var x = mpl_internal_expression_5(mpl);\r\n    /* convert the argument to symbolic type, if necessary */\r\n    if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n    /* check that now the argument is of symbolic type */\r\n    if (x.type != A_SYMBOLIC)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim == 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_elemset_argument(mpl, func){\r\n    var x = mpl_internal_expression_9(mpl);\r\n    if (x.type != A_ELEMSET)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim > 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_function_reference(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var op;\r\n    var func;\r\n    /* determine operation code */\r\n    xassert(mpl.token == T_NAME);\r\n    if (mpl.image == \"abs\")\r\n        op = O_ABS;\r\n    else if (mpl.image == \"ceil\")\r\n        op = O_CEIL;\r\n    else if (mpl.image == \"floor\")\r\n        op = O_FLOOR;\r\n    else if (mpl.image == \"exp\")\r\n        op = O_EXP;\r\n    else if (mpl.image == \"log\")\r\n        op = O_LOG;\r\n    else if (mpl.image == \"log10\")\r\n        op = O_LOG10;\r\n    else if (mpl.image == \"sqrt\")\r\n        op = O_SQRT;\r\n    else if (mpl.image == \"sin\")\r\n        op = O_SIN;\r\n    else if (mpl.image == \"cos\")\r\n        op = O_COS;\r\n    else if (mpl.image == \"atan\")\r\n        op = O_ATAN;\r\n    else if (mpl.image == \"min\")\r\n        op = O_MIN;\r\n    else if (mpl.image == \"max\")\r\n        op = O_MAX;\r\n    else if (mpl.image == \"round\")\r\n        op = O_ROUND;\r\n    else if (mpl.image == \"trunc\")\r\n        op = O_TRUNC;\r\n    else if (mpl.image == \"Irand224\")\r\n        op = O_IRAND224;\r\n    else if (mpl.image == \"Uniform01\")\r\n        op = O_UNIFORM01;\r\n    else if (mpl.image == \"Uniform\")\r\n        op = O_UNIFORM;\r\n    else if (mpl.image == \"Normal01\")\r\n        op = O_NORMAL01;\r\n    else if (mpl.image == \"Normal\")\r\n        op = O_NORMAL;\r\n    else if (mpl.image == \"card\")\r\n        op = O_CARD;\r\n    else if (mpl.image == \"length\")\r\n        op = O_LENGTH;\r\n    else if (mpl.image == \"substr\")\r\n        op = O_SUBSTR;\r\n    else if (mpl.image == \"str2time\")\r\n        op = O_STR2TIME;\r\n    else if (mpl.image == \"time2str\")\r\n        op = O_TIME2STR;\r\n    else if (mpl.image == \"gmtime\")\r\n        op = O_GMTIME;\r\n    else\r\n        mpl_internal_error(mpl, \"function \" + mpl.image + \" unknown\");\r\n    /* save symbolic name of the function */\r\n    func = mpl.image;\r\n    xassert(func.length < 16);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* check the left parenthesis that follows the function name */\r\n    xassert(mpl.token == T_LEFT);\r\n    mpl_internal_get_token(mpl /* ( */);\r\n    /* parse argument list */\r\n    if (op == O_MIN || op == O_MAX)\r\n    {  /* min and max allow arbitrary number of arguments */\r\n        arg.list = null;\r\n        /* parse argument list */\r\n        for (;;)\r\n        {  /* parse argument and append it to the operands list */\r\n            arg.list = mpl_internal_expand_arg_list(mpl, arg.list,\r\n                mpl_internal_numeric_argument(mpl, func));\r\n            /* check a token that follows the argument */\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RIGHT)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in argument list for \" + func);\r\n        }\r\n    }\r\n    else if (op == O_IRAND224 || op == O_UNIFORM01 || op ==\r\n        O_NORMAL01 || op == O_GMTIME)\r\n    {  /* Irand224, Uniform01, Normal01, gmtime need no arguments */\r\n        if (mpl.token != T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs no arguments\");\r\n    }\r\n    else if (op == O_UNIFORM || op == O_NORMAL)\r\n    {  /* Uniform and Normal need two arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_ATAN || op == O_ROUND || op == O_TRUNC)\r\n    {  /* atan, round, and trunc need one or two arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* parse the second argument, if specified */\r\n        if (mpl.token == T_COMMA)\r\n        {  switch (op)\r\n        {  case O_ATAN:  op = O_ATAN2;  break;\r\n            case O_ROUND: op = O_ROUND2; break;\r\n            case O_TRUNC: op = O_TRUNC2; break;\r\n            default: xassert(op != op);\r\n        }\r\n            mpl_internal_get_token(mpl /* , */);\r\n            arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        }\r\n        /* check a token that follows the last argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs one or two arguments\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_SUBSTR)\r\n    {  /* substr needs two or three arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two or three arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        /* parse the third argument, if specified */\r\n        if (mpl.token == T_COMMA)\r\n        {  op = O_SUBSTR3;\r\n            mpl_internal_get_token(mpl /* , */);\r\n            arg.arg.z = mpl_internal_numeric_argument(mpl, func);\r\n        }\r\n        /* check a token that follows the last argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two or three arguments\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_STR2TIME)\r\n    {  /* str2time needs two arguments, both symbolic */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_TIME2STR)\r\n    {  /* time2str needs two arguments, numeric and symbolic */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else\r\n    {  /* other functions need one argument */\r\n        if (op == O_CARD)\r\n            arg.arg.x = mpl_internal_elemset_argument(mpl, func);\r\n        else if (op == O_LENGTH)\r\n            arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        else\r\n            arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs one argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    /* make pseudo-code to call the built-in function */\r\n    if (op == O_SUBSTR || op == O_SUBSTR3 || op == O_TIME2STR)\r\n        code = mpl_internal_make_code(mpl, op, arg, A_SYMBOLIC, 0);\r\n    else\r\n        code = mpl_internal_make_code(mpl, op, arg, A_NUMERIC, 0);\r\n    /* the reference ends with the right parenthesis */\r\n    xassert(mpl.token == T_RIGHT);\r\n    mpl_internal_get_token(mpl /* ) */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_append_block(mpl, domain, block){\r\n    var temp;\r\n\r\n    xassert(domain != null);\r\n    xassert(block != null);\r\n    xassert(block.next == null);\r\n    if (domain.list == null)\r\n        domain.list = block;\r\n    else\r\n    {   for (temp = domain.list; temp.next != null; temp = temp.next){}\r\n        temp.next = block;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_append_slot(mpl, block, name, code){\r\n    var slot = {}, temp;\r\n    xassert(block != null);\r\n    slot.name = name;\r\n    slot.code = code;\r\n    slot.value = null;\r\n    slot.list = null;\r\n    slot.next = null;\r\n    if (block.list == null)\r\n        block.list = slot;\r\n    else\r\n    {  for (temp = block.list; temp.next != null; temp = temp.next){}\r\n        temp.next = slot;\r\n    }\r\n    return slot;\r\n}\r\n\r\nfunction mpl_internal_expression_list(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var max_dim = 20;\r\n    /* maximal number of components allowed within parentheses */\r\n    var list = new Array(max_dim + 1);\r\n    xfillObjArr(list, 0, max_dim + 1);\r\n    var flag_x, next_token, dim, j, slice = 0;\r\n    xassert(mpl.token == T_LEFT);\r\n    /* the flag, which allows recognizing undeclared symbolic names\r\n     as dummy indices, will be automatically reset by get_token(),\r\n     so save it before scanning the next token */\r\n    flag_x = mpl.flag_x;\r\n    mpl_internal_get_token(mpl /* ( */);\r\n    /* parse <expression list> */\r\n    for (dim = 1; ; dim++)\r\n    {   if (dim > max_dim)\r\n        mpl_internal_error(mpl, \"too many components within parentheses\");\r\n\r\n        function expr(){\r\n            /* current component of <expression list> is expression */\r\n            code = mpl_internal_expression_13(mpl);\r\n            /* if the current expression is followed by comma or it is\r\n             not the very first expression, entire <expression list>\r\n             is n-tuple or slice, in which case the current expression\r\n             should be converted to symbolic type, if necessary */\r\n            if (mpl.token == T_COMMA || dim > 1)\r\n            {  if (code.type == A_NUMERIC)\r\n                code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\r\n                /* now the expression must be of symbolic type */\r\n                if (code.type != A_SYMBOLIC)\r\n                    mpl_internal_error(mpl, \"component expression has invalid type\");\r\n                xassert(code.dim == 0);\r\n            }\r\n            list[dim].name = null;\r\n            list[dim].code = code;\r\n        }\r\n\r\n        /* current component of <expression list> can be either dummy\r\n         index or expression */\r\n        if (mpl.token == T_NAME)\r\n        {  /* symbolic name is recognized as dummy index only if:\r\n         the flag, which allows that, is set, and\r\n         the name is followed by comma or right parenthesis, and\r\n         the name is undeclared */\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (!(flag_x &&\r\n                (next_token == T_COMMA || next_token == T_RIGHT) &&\r\n                mpl.tree[mpl.image] == null))\r\n            {  /* this is not dummy index */\r\n                expr();\r\n            } else {\r\n                /* all dummy indices within the same slice must have unique\r\n                 symbolic names */\r\n                for (j = 1; j < dim; j++)\r\n                {  if (list[j].name != null && list[j].name == mpl.image)\r\n                    mpl_internal_error(mpl, \"duplicate dummy index \" + mpl.image + \" not allowed\");\r\n                }\r\n                /* current component of <expression list> is dummy index */\r\n                list[dim].name = mpl.image;\r\n                list[dim].code = null;\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                /* <expression list> is a slice, because at least one dummy\r\n                 index has appeared */\r\n                slice = 1;\r\n                /* note that the context ( <dummy index> ) is not allowed,\r\n                 i.e. in this case <primary expression> is considered as\r\n                 a parenthesized expression */\r\n                if (dim == 1 && mpl.token == T_RIGHT)\r\n                    mpl_internal_error(mpl, list[dim].name + \" not defined\");\r\n            }\r\n        }\r\n        else\r\n            expr();\r\n\r\n        /* check a token that follows the current component */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RIGHT)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"right parenthesis missing where expected\");\r\n    }\r\n    /* generate pseudo-code for <primary expression> */\r\n    if (dim == 1 && !slice)\r\n    {  /* <primary expression> is a parenthesized expression */\r\n        code = list[1].code;\r\n    }\r\n    else if (!slice)\r\n    {  /* <primary expression> is a n-tuple */\r\n        arg.list = null;\r\n        for (j = 1; j <= dim; j++)\r\n            arg.list = mpl_internal_expand_arg_list(mpl, arg.list, list[j].code);\r\n        code = mpl_internal_make_code(mpl, O_TUPLE, arg, A_TUPLE, dim);\r\n    }\r\n    else\r\n    {  /* <primary expression> is a slice */\r\n        arg.slice = {};\r\n        for (j = 1; j <= dim; j++)\r\n            mpl_internal_append_slot(mpl, arg.slice, list[j].name, list[j].code);\r\n        /* note that actually pseudo-codes with op = O_SLICE are never\r\n         evaluated */\r\n        code = mpl_internal_make_code(mpl, O_SLICE, arg, A_TUPLE, dim);\r\n    }\r\n    mpl_internal_get_token(mpl /* ) */);\r\n    /* if <primary expression> is a slice, there must be the keyword\r\n     'in', which follows the right parenthesis */\r\n    if (slice && mpl.token != T_IN)\r\n        mpl_internal_error(mpl, \"keyword in missing where expected\");\r\n    /* if the slice flag is set and there is the keyword 'in', which\r\n     follows <primary expression>, the latter must be a slice */\r\n    if (flag_x && mpl.token == T_IN && !slice)\r\n    {  if (dim == 1)\r\n        mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    else\r\n        mpl_internal_error(mpl, \"0-ary slice not allowed\");\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_literal_set(mpl, code){\r\n    var arg = mpl_internal_create_operands();\r\n    var j;\r\n    xassert(code != null);\r\n    arg.list = null;\r\n    /* parse <member list> */\r\n    for (j = 1; ; j++)\r\n    {  /* all member expressions must be n-tuples; so, if the current\r\n     expression is not n-tuple, convert it to 1-tuple */\r\n        if (code.type == A_NUMERIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\r\n        if (code.type == A_SYMBOLIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTTUP, code, A_TUPLE, 1);\r\n        /* now the expression must be n-tuple */\r\n        if (code.type != A_TUPLE)\r\n            mpl_internal_error(mpl, \"member expression has invalid type\");\r\n        /* all member expressions must have identical dimension */\r\n        if (arg.list != null && arg.list.x.dim != code.dim)\r\n            mpl_internal_error(mpl, \"member \" + (j-1) + \" has \" + arg.list.x.dim + \" component\"\r\n                + (arg.list.x.dim == 1 ? \"\" : \"s\") + \" while member \" + j + \" has \"\r\n                + code.dim + \" component\" + (code.dim == 1 ? \"\" : \"s\"));\r\n        /* append the current expression to the member list */\r\n        arg.list = mpl_internal_expand_arg_list(mpl, arg.list, code);\r\n        /* check a token that follows the current expression */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RBRACE)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in literal set\");\r\n        /* parse the next expression that follows the comma */\r\n        code = mpl_internal_expression_5(mpl);\r\n    }\r\n    /* generate pseudo-code for <literal set> */\r\n    code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, arg.list.x.dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_indexing_expression(mpl){\r\n    var domain;\r\n    var block;\r\n    var slot;\r\n    var code;\r\n    xassert(mpl.token == T_LBRACE);\r\n    mpl_internal_get_token(mpl /* { */);\r\n    if (mpl.token == T_RBRACE)\r\n        mpl_internal_error(mpl, \"empty indexing expression not allowed\");\r\n    /* create domain to be constructed */\r\n    domain = {};\r\n    /* parse either <member list> or <indexing list> that follows the\r\n     left brace */\r\n    for (;;)\r\n    {  /* domain block for <indexing element> is not created yet */\r\n        block = null;\r\n        /* pseudo-code for <basic expression> is not generated yet */\r\n        code = null;\r\n        /* check a token, which <indexing element> begins with */\r\n        if (mpl.token == T_NAME)\r\n        {  /* it is a symbolic name */\r\n            var next_token;\r\n            var name;\r\n            /* symbolic name is recognized as dummy index only if it is\r\n             followed by the keyword 'in' and not declared */\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (next_token == T_IN &&\r\n                mpl.tree[mpl.image] == null)\r\n            {\r\n                /* create domain block with one slot, which is assigned the\r\n                 dummy index */\r\n                block = {};\r\n                name = mpl.image;\r\n                mpl_internal_append_slot(mpl, block, name, null);\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                /* the keyword 'in' is already checked above */\r\n                xassert(mpl.token == T_IN);\r\n                mpl_internal_get_token(mpl /* in */);\r\n                /* <basic expression> that follows the keyword 'in' will be\r\n                 parsed below */\r\n            }\r\n\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* it is the left parenthesis; parse expression that begins\r\n         with this parenthesis (the flag is set in order to allow\r\n         recognizing slices; see the routine expression_list) */\r\n            mpl.flag_x = 1;\r\n            code = mpl_internal_expression_9(mpl);\r\n            if (code.op == O_SLICE)\r\n            {\r\n                /* this is a slice; besides the corresponding domain block\r\n                 is already created by expression_list() */\r\n                block = code.arg.slice;\r\n                code = null; /* <basic expression> is not parsed yet */\r\n                /* the keyword 'in' following the slice is already checked\r\n                 by expression_list() */\r\n                xassert(mpl.token == T_IN);\r\n                mpl_internal_get_token(mpl /* in */);\r\n                /* <basic expression> that follows the keyword 'in' will be\r\n                 parsed below */\r\n            }\r\n        }\r\n\r\n        /* parse expression that follows either the keyword 'in' (in\r\n         which case it can be <basic expression) or the left brace\r\n         (in which case it can be <basic expression> as well as the\r\n         very first <member expression> in <literal set>); note that\r\n         this expression can be already parsed above */\r\n        if (code == null) code = mpl_internal_expression_9(mpl);\r\n        /* check the type of the expression just parsed */\r\n        if (code.type != A_ELEMSET)\r\n        {  /* it is not <basic expression> and therefore it can only\r\n         be the very first <member expression> in <literal set>;\r\n         however, then there must be no dummy index neither slice\r\n         between the left brace and this expression */\r\n            if (block != null)\r\n                mpl_internal_error(mpl, \"domain expression has invalid type\");\r\n            /* parse the rest part of <literal set> and make this set\r\n             be <basic expression>, i.e. the construction {a, b, c}\r\n             is parsed as it were written as {A}, where A = {a, b, c}\r\n             is a temporary elemental set */\r\n            code = mpl_internal_literal_set(mpl, code);\r\n        }\r\n        /* now pseudo-code for <basic set> has been built */\r\n        xassert(code != null);\r\n        xassert(code.type == A_ELEMSET);\r\n        xassert(code.dim > 0);\r\n        /* if domain block for the current <indexing element> is still\r\n         not created, create it for fake slice of the same dimension\r\n         as <basic set> */\r\n        if (block == null)\r\n        {  var j;\r\n            block = {};\r\n            for (j = 1; j <= code.dim; j++)\r\n                mpl_internal_append_slot(mpl, block, null, null);\r\n        }\r\n        /* number of indexing positions in <indexing element> must be\r\n         the same as dimension of n-tuples in basic set */\r\n        {  var dim = 0;\r\n            for (slot = block.list; slot != null; slot = slot.next)\r\n                dim++;\r\n            if (dim != code.dim)\r\n                mpl_internal_error(mpl, dim + \" \" + (dim == 1 ? \"index\" : \"indices\") + \" specified for set of dimension \" + code.dim);\r\n        }\r\n        /* store pseudo-code for <basic set> in the domain block */\r\n        xassert(block.code == null);\r\n        block.code = code;\r\n        /* and append the domain block to the domain */\r\n        mpl_internal_append_block(mpl, domain, block);\r\n        /* the current <indexing element> has been completely parsed;\r\n         include all its dummy indices into the symbolic name table\r\n         to make them available for referencing from expressions;\r\n         implicit declarations of dummy indices remain valid while\r\n         the corresponding domain scope is valid */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n            if (slot.name != null)\r\n            {  var node;\r\n                xassert(mpl.tree[slot.name] == null);\r\n                mpl.tree[slot.name] = node = {type: A_INDEX, link: slot};\r\n            }\r\n        /* check a token that follows <indexing element> */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_COLON || mpl.token == T_RBRACE)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    }\r\n    /* parse <logical expression> that follows the colon */\r\n    if (mpl.token == T_COLON)\r\n    {  mpl_internal_get_token(mpl /* : */);\r\n        code = mpl_internal_expression_13(mpl);\r\n        /* convert the expression to logical type, if necessary */\r\n        if (code.type == A_SYMBOLIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTNUM, code, A_NUMERIC, 0);\r\n        if (code.type == A_NUMERIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTLOG, code, A_LOGICAL, 0);\r\n        /* now the expression must be of logical type */\r\n        if (code.type != A_LOGICAL)\r\n            mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n        xassert(code.dim == 0);\r\n        domain.code = code;\r\n        /* the right brace must follow the logical expression */\r\n        if (mpl.token != T_RBRACE)\r\n            mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    }\r\n    mpl_internal_get_token(mpl /* } */);\r\n    return domain;\r\n}\r\n\r\nfunction mpl_internal_close_scope(mpl, domain){\r\n    var block;\r\n    var slot;\r\n    var node;\r\n    xassert(domain != null);\r\n    /* remove all dummy indices from the symbolic names table */\r\n    for (block = domain.list; block != null; block = block.next)\r\n    {  for (slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.name != null)\r\n    {   node = mpl.tree[slot.name];\r\n        xassert(node != null);\r\n        xassert(node.type == A_INDEX);\r\n        delete mpl.tree[slot.name];\r\n    }\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_link_up(code)\r\n{     /* if we have something like sum{(i+1,j,k-1) in E} x[i,j,k],\r\n where i and k are dummy indices defined out of the iterated\r\n expression, we should link up pseudo-code for computing i+1\r\n and k-1 to pseudo-code for computing the iterated expression;\r\n this is needed to invalidate current value of the iterated\r\n expression once i or k have been changed */\r\n    var block;\r\n    var slot;\r\n    for (block = code.arg.loop.domain.list; block != null;\r\n         block = block.next)\r\n    {  for (slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.code != null)\r\n    {  xassert(slot.code.up == null);\r\n        slot.code.up = code;\r\n    }\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_iterated_expression(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var op;\r\n    var opstr; // 8\r\n    /* determine operation code */\r\n    xassert(mpl.token == T_NAME);\r\n    if (mpl.image == \"sum\")\r\n        op = O_SUM;\r\n    else if (mpl.image == \"prod\")\r\n        op = O_PROD;\r\n    else if (mpl.image == \"min\")\r\n        op = O_MINIMUM;\r\n    else if (mpl.image == \"max\")\r\n        op = O_MAXIMUM;\r\n    else if (mpl.image == \"forall\")\r\n        op = O_FORALL;\r\n    else if (mpl.image == \"exists\")\r\n        op = O_EXISTS;\r\n    else if (mpl.image == \"setof\")\r\n        op = O_SETOF;\r\n    else\r\n        mpl_internal_error(mpl, \"operator \" + mpl.image + \" unknown\");\r\n    opstr = mpl.image;\r\n    xassert(opstr.length < 8);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* check the left brace that follows the operator name */\r\n    xassert(mpl.token == T_LBRACE);\r\n    /* parse indexing expression that controls iterating */\r\n    arg.loop.domain = mpl_internal_indexing_expression(mpl);\r\n\r\n    function err(){\r\n        mpl_internal_error(mpl, \"integrand following \" + opstr + \"{...} has invalid type\");\r\n    }\r\n\r\n    /* parse \"integrand\" expression and generate pseudo-code */\r\n    switch (op)\r\n    {  case O_SUM:\r\n        case O_PROD:\r\n        case O_MINIMUM:\r\n        case O_MAXIMUM:\r\n            arg.loop.x = mpl_internal_expression_3(mpl);\r\n            /* convert the integrand to numeric type, if necessary */\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x,\r\n                    A_NUMERIC, 0);\r\n            /* now the integrand must be of numeric type or linear form\r\n             (the latter is only allowed for the sum operator) */\r\n            if (!(arg.loop.x.type == A_NUMERIC ||\r\n                op == O_SUM && arg.loop.x.type == A_FORMULA))\r\n                err();\r\n            xassert(arg.loop.x.dim == 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, arg.loop.x.type, 0);\r\n            break;\r\n        case O_FORALL:\r\n        case O_EXISTS:\r\n            arg.loop.x = mpl_internal_expression_12(mpl);\r\n            /* convert the integrand to logical type, if necessary */\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x,\r\n                    A_NUMERIC, 0);\r\n            if (arg.loop.x.type == A_NUMERIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTLOG, arg.loop.x,\r\n                    A_LOGICAL, 0);\r\n            /* now the integrand must be of logical type */\r\n            if (arg.loop.x.type != A_LOGICAL) err();\r\n            xassert(arg.loop.x.dim == 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, A_LOGICAL, 0);\r\n            break;\r\n        case O_SETOF:\r\n            arg.loop.x = mpl_internal_expression_5(mpl);\r\n            /* convert the integrand to 1-tuple, if necessary */\r\n            if (arg.loop.x.type == A_NUMERIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTSYM, arg.loop.x,\r\n                    A_SYMBOLIC, 0);\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTTUP, arg.loop.x,\r\n                    A_TUPLE, 1);\r\n            /* now the integrand must be n-tuple */\r\n            if (arg.loop.x.type != A_TUPLE) err();\r\n            xassert(arg.loop.x.dim > 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, A_ELEMSET, arg.loop.x.dim);\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    /* close the scope of the indexing expression */\r\n    mpl_internal_close_scope(mpl, arg.loop.domain);\r\n    mpl_internal_link_up(code);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_domain_arity(mpl, domain){\r\n    var arity = 0;\r\n\r\n    for (var block = domain.list; block != null; block = block.next)\r\n        for (var slot = block.list; slot != null; slot = slot.next)\r\n            if (slot.code == null) arity++;\r\n    return arity;\r\n}\r\n\r\nfunction mpl_internal_set_expression(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_LBRACE);\r\n    mpl_internal_get_token(mpl /* { */);\r\n    /* check a token that follows the left brace */\r\n    if (mpl.token == T_RBRACE)\r\n    {  /* it is the right brace, so the resultant is an empty set of\r\n     dimension 1 */\r\n        arg.list = null;\r\n        /* generate pseudo-code to build the resultant set */\r\n        code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, 1);\r\n        mpl_internal_get_token(mpl /* } */);\r\n    }\r\n    else\r\n    {  /* the next token begins an indexing expression */\r\n        mpl_internal_unget_token(mpl);\r\n        arg.loop.domain = mpl_internal_indexing_expression(mpl);\r\n        arg.loop.x = null; /* integrand is not used */\r\n        /* close the scope of the indexing expression */\r\n        mpl_internal_close_scope(mpl, arg.loop.domain);\r\n        /* generate pseudo-code to build the resultant set */\r\n        code = mpl_internal_make_code(mpl, O_BUILD, arg, A_ELEMSET,\r\n            mpl_internal_domain_arity(mpl, arg.loop.domain));\r\n        mpl_internal_link_up(code);\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_branched_expression(mpl){\r\n    var x, y, z;\r\n    xassert(mpl.token == T_IF);\r\n    mpl_internal_get_token(mpl /* if */);\r\n    /* parse <logical expression> that follows 'if' */\r\n    x = mpl_internal_expression_13(mpl);\r\n    /* convert the expression to logical type, if necessary */\r\n    if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n    if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n    /* now the expression must be of logical type */\r\n    if (x.type != A_LOGICAL)\r\n        mpl_internal_error(mpl, \"expression following if has invalid type\");\r\n    xassert(x.dim == 0);\r\n    /* the keyword 'then' must follow the logical expression */\r\n    if (mpl.token != T_THEN)\r\n        mpl_internal_error(mpl, \"keyword then missing where expected\");\r\n    mpl_internal_get_token(mpl /* then */);\r\n    /* parse <expression> that follows 'then' and check its type */\r\n    y = mpl_internal_expression_9(mpl);\r\n    if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC ||\r\n        y.type == A_ELEMSET || y.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following then has invalid type\");\r\n    /* if the expression that follows the keyword 'then' is elemental\r\n     set, the keyword 'else' cannot be omitted; otherwise else-part\r\n     is optional */\r\n    if (mpl.token != T_ELSE)\r\n    {  if (y.type == A_ELEMSET)\r\n        mpl_internal_error(mpl, \"keyword else missing where expected\");\r\n        z = null;\r\n    } else {\r\n        mpl_internal_get_token(mpl /* else */);\r\n        /* parse <expression> that follow 'else' and check its type */\r\n        z = mpl_internal_expression_9(mpl);\r\n        if (!(z.type == A_NUMERIC || z.type == A_SYMBOLIC ||\r\n            z.type == A_ELEMSET || z.type == A_FORMULA))\r\n            mpl_internal_error(mpl, \"expression following else has invalid type\");\r\n        /* convert to identical types, if necessary */\r\n        if (y.type == A_FORMULA || z.type == A_FORMULA)\r\n        {  if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n            if (y.type == A_NUMERIC)\r\n                y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n            if (z.type == A_SYMBOLIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\r\n            if (z.type == A_NUMERIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTLFM, z, A_FORMULA, 0);\r\n        }\r\n        if (y.type == A_SYMBOLIC || z.type == A_SYMBOLIC)\r\n        {  if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n            if (z.type == A_NUMERIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTSYM, z, A_SYMBOLIC, 0);\r\n        }\r\n        /* now both expressions must have identical types */\r\n        if (y.type != z.type)\r\n            mpl_internal_error(mpl, \"expressions following then and else have incompatible types\");\r\n        /* and identical dimensions */\r\n        if (y.dim != z.dim)\r\n            mpl_internal_error(mpl, \"expressions following then and else have different\" +\r\n                \" dimensions \" + y.dim + \" and \" + z.dim + \", respectively\");\r\n    }\r\n\r\n    /* generate pseudo-code to perform branching */\r\n    return mpl_internal_make_ternary(mpl, O_FORK, x, y, z, y.type, y.dim);\r\n}\r\n\r\nfunction mpl_internal_primary_expression(mpl){\r\n    var code;\r\n    if (mpl.token == T_NUMBER)\r\n    {  /* parse numeric literal */\r\n        code = mpl_internal_numeric_literal(mpl);\r\n    }\r\n    else if (mpl.token == T_INFINITY)\r\n    {  /* parse \"infinity\" */\r\n        var arg = mpl_internal_create_operands();\r\n        arg.num = DBL_MAX;\r\n        code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);\r\n        mpl_internal_get_token(mpl /* Infinity */);\r\n    }\r\n    else if (mpl.token == T_STRING)\r\n    {  /* parse string literal */\r\n        code = mpl_internal_string_literal(mpl);\r\n    }\r\n    else if (mpl.token == T_NAME)\r\n    {   var next_token;\r\n        mpl_internal_get_token(mpl /* <symbolic name> */);\r\n        next_token = mpl.token;\r\n        mpl_internal_unget_token(mpl);\r\n        /* check a token that follows <symbolic name> */\r\n        switch (next_token)\r\n        {  case T_LBRACKET:\r\n            /* parse reference to subscripted object */\r\n            code = mpl_internal_object_reference(mpl);\r\n            break;\r\n            case T_LEFT:\r\n                /* parse reference to built-in function */\r\n                code = mpl_internal_function_reference(mpl);\r\n                break;\r\n            case T_LBRACE:\r\n                /* parse iterated expression */\r\n                code = mpl_internal_iterated_expression(mpl);\r\n                break;\r\n            default:\r\n                /* parse reference to unsubscripted object */\r\n                code = mpl_internal_object_reference(mpl);\r\n                break;\r\n        }\r\n    }\r\n    else if (mpl.token == T_LEFT)\r\n    {  /* parse parenthesized expression */\r\n        code = mpl_internal_expression_list(mpl);\r\n    }\r\n    else if (mpl.token == T_LBRACE)\r\n    {  /* parse set expression */\r\n        code = mpl_internal_set_expression(mpl);\r\n    }\r\n    else if (mpl.token == T_IF)\r\n    {  /* parse conditional expression */\r\n        code = mpl_internal_branched_expression(mpl);\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n    {  /* other reserved keywords cannot be used here */\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    }\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in expression\");\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_error_preceding(mpl, opstr){\r\n    mpl_internal_error(mpl, \"operand preceding \" + opstr + \" has invalid type\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_error_following(mpl, opstr)\r\n{     mpl_internal_error(mpl, \"operand following \" + opstr + \" has invalid type\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_error_dimension(mpl, opstr, dim1, dim2)\r\n{     mpl_internal_error(mpl, \"operands preceding and following \" + opstr + \" have different di\"+\r\n    \"mensions \" + dim1 + \" and \" + dim2 + \", respectively\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_expression_0(mpl){\r\n    return mpl_internal_primary_expression(mpl);\r\n}\r\n\r\nfunction mpl_internal_expression_1(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_0(mpl);\r\n    if (mpl.token == T_POWER)\r\n    {   var opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* ^ | ** */);\r\n        if (mpl.token == T_PLUS || mpl.token == T_MINUS)\r\n            y = mpl_internal_expression_2(mpl);\r\n        else\r\n            y = mpl_internal_expression_1(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_POWER, x, y, A_NUMERIC, 0);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_2(mpl){\r\n    var x;\r\n    if (mpl.token == T_PLUS)\r\n    {  mpl_internal_get_token(mpl /* + */);\r\n        x = mpl_internal_expression_1(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"+\");\r\n        x = mpl_internal_make_unary(mpl, O_PLUS, x, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_MINUS)\r\n    {  mpl_internal_get_token(mpl /* - */);\r\n        x = mpl_internal_expression_1(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"-\");\r\n        x = mpl_internal_make_unary(mpl, O_MINUS, x, x.type, 0);\r\n    }\r\n    else\r\n        x = mpl_internal_expression_1(mpl);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_3(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_2(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_ASTERISK)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"*\");\r\n        mpl_internal_get_token(mpl /* * */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"*\");\r\n        if (x.type == A_FORMULA && y.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"multiplication of linear forms not allowed\");\r\n        if (x.type == A_NUMERIC && y.type == A_NUMERIC)\r\n            x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_NUMERIC, 0);\r\n        else\r\n            x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_FORMULA, 0);\r\n    }\r\n    else if (mpl.token == T_SLASH)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"/\");\r\n        mpl_internal_get_token(mpl /* / */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"/\");\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_NUMERIC, 0);\r\n        else\r\n            x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_FORMULA, 0);\r\n    }\r\n    else if (mpl.token == T_DIV)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"div\");\r\n        mpl_internal_get_token(mpl /* div */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"div\");\r\n        x = mpl_internal_make_binary(mpl, O_IDIV, x, y, A_NUMERIC, 0);\r\n    }\r\n    else if (mpl.token == T_MOD)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"mod\");\r\n        mpl_internal_get_token(mpl /* mod */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"mod\");\r\n        x = mpl_internal_make_binary(mpl, O_MOD, x, y, A_NUMERIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_4(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_3(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_PLUS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"+\");\r\n        mpl_internal_get_token(mpl /* + */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"+\");\r\n        if (x.type == A_NUMERIC && y.type == A_FORMULA)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\r\n        if (x.type == A_FORMULA && y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n        x = mpl_internal_make_binary(mpl, O_ADD, x, y, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_MINUS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"-\");\r\n        mpl_internal_get_token(mpl /* - */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"-\");\r\n        if (x.type == A_NUMERIC && y.type == A_FORMULA)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\r\n        if (x.type == A_FORMULA && y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n        x = mpl_internal_make_binary(mpl, O_SUB, x, y, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_LESS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"less\");\r\n        mpl_internal_get_token(mpl /* less */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"less\");\r\n        x = mpl_internal_make_binary(mpl, O_LESS, x, y, A_NUMERIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_5(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_4(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_CONCAT)\r\n    {  if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n        if (x.type != A_SYMBOLIC)\r\n            mpl_internal_error_preceding(mpl, \"&\");\r\n        mpl_internal_get_token(mpl /* & */);\r\n        y = mpl_internal_expression_4(mpl);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n        if (y.type != A_SYMBOLIC)\r\n            mpl_internal_error_following(mpl, \"&\");\r\n        x = mpl_internal_make_binary(mpl, O_CONCAT, x, y, A_SYMBOLIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_6(mpl){\r\n    var y, z;\r\n    var x = mpl_internal_expression_5(mpl);\r\n    if (mpl.token == T_DOTS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"..\");\r\n        mpl_internal_get_token(mpl /* .. */);\r\n        y = mpl_internal_expression_5(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"..\");\r\n        if (mpl.token == T_BY)\r\n        {  mpl_internal_get_token(mpl /* by */);\r\n            z = mpl_internal_expression_5(mpl);\r\n            if (z.type == A_SYMBOLIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\r\n            if (z.type != A_NUMERIC)\r\n                mpl_internal_error_following(mpl, \"by\");\r\n        }\r\n        else\r\n            z = null;\r\n        x = mpl_internal_make_ternary(mpl, O_DOTS, x, y, z, A_ELEMSET, 1);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_7(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_6(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_CROSS)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"cross\");\r\n        mpl_internal_get_token(mpl /* cross */);\r\n        y = mpl_internal_expression_6(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"cross\");\r\n        x = mpl_internal_make_binary(mpl, O_CROSS, x, y, A_ELEMSET,\r\n            x.dim + y.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_8(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_7(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_INTER)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"inter\");\r\n        mpl_internal_get_token(mpl /* inter */);\r\n        y = mpl_internal_expression_7(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"inter\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"inter\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_INTER, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_9(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_8(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_UNION)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"union\");\r\n        mpl_internal_get_token(mpl /* union */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"union\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"union\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_UNION, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else if (mpl.token == T_DIFF)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"diff\");\r\n        mpl_internal_get_token(mpl /* diff */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"diff\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"diff\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_DIFF, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else if (mpl.token == T_SYMDIFF)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"symdiff\");\r\n        mpl_internal_get_token(mpl /* symdiff */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"symdiff\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"symdiff\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_SYMDIFF, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_10(mpl){\r\n    var y;\r\n    var op = -1;\r\n    var opstr = \"\"; // [16];\r\n    var x = mpl_internal_expression_9(mpl);\r\n    switch (mpl.token)\r\n    {  case T_LT:\r\n        op = O_LT; break;\r\n        case T_LE:\r\n            op = O_LE; break;\r\n        case T_EQ:\r\n            op = O_EQ; break;\r\n        case T_GE:\r\n            op = O_GE; break;\r\n        case T_GT:\r\n            op = O_GT; break;\r\n        case T_NE:\r\n            op = O_NE; break;\r\n        case T_IN:\r\n            op = O_IN; break;\r\n        case T_WITHIN:\r\n            op = O_WITHIN; break;\r\n        case T_NOT:\r\n            opstr = mpl.image;\r\n            mpl_internal_get_token(mpl /* not | ! */);\r\n            if (mpl.token == T_IN)\r\n                op = O_NOTIN;\r\n            else if (mpl.token == T_WITHIN)\r\n                op = O_NOTWITHIN;\r\n            else\r\n                mpl_internal_error(mpl, \"invalid use of \" + opstr);\r\n            opstr += \" \";\r\n            break;\r\n        default:\r\n            return x;\r\n    }\r\n    opstr += mpl.image;\r\n    xassert(opstr.length < 16);\r\n    switch (op)\r\n    {  case O_EQ:\r\n        case O_NE:\r\n        case O_LT:\r\n        case O_LE:\r\n        case O_GT:\r\n        case O_GE:\r\n            if (!(x.type == A_NUMERIC || x.type == A_SYMBOLIC))\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC))\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.type == A_NUMERIC && y.type == A_SYMBOLIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n            if (x.type == A_SYMBOLIC && y.type == A_NUMERIC)\r\n                y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        case O_IN:\r\n        case O_NOTIN:\r\n            if (x.type == A_NUMERIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n            if (x.type == A_SYMBOLIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTTUP, x, A_TUPLE, 1);\r\n            if (x.type != A_TUPLE)\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (y.type != A_ELEMSET)\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.dim != y.dim)\r\n                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        case O_WITHIN:\r\n        case O_NOTWITHIN:\r\n            if (x.type != A_ELEMSET)\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (y.type != A_ELEMSET)\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.dim != y.dim)\r\n                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_11(mpl){\r\n    var x;\r\n    var opstr; //[8];\r\n    if (mpl.token == T_NOT)\r\n    {   opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        mpl_internal_get_token(mpl /* not | ! */);\r\n        x = mpl_internal_expression_10(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_unary(mpl, O_NOT, x, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        x = mpl_internal_expression_10(mpl);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_12(mpl){\r\n    var y;\r\n    var opstr = \"\"; //[8];\r\n    var x = mpl_internal_expression_11(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_AND)\r\n    {   opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* and | && */);\r\n        y = mpl_internal_expression_11(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\r\n        if (y.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_AND, x, y, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_13(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_12(mpl);\r\n    for (;;)\r\n    {   if (mpl.token == T_OR)\r\n    {   var opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* or | || */);\r\n        y = mpl_internal_expression_12(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\r\n        if (y.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_OR, x, y, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_set_statement(mpl){\r\n    var set, node;\r\n    var dimen_used = 0;\r\n    var gadget;\r\n\r\n    function err(){mpl_internal_error(mpl, \"at most one := or default/data allowed\")}\r\n    function err1(){mpl_internal_error(mpl, mpl.image + \" not a plain set\")}\r\n    function err2(){mpl_internal_error(mpl, \"dimension of \" + mpl.image + \" too small\")}\r\n    function err3(){mpl_internal_error(mpl, \"component number must be integer between 1 and \" + gadget.set.dimen)};\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"set\"));\r\n    mpl_internal_get_token(mpl /* set */);\r\n    /* symbolic name must follow the keyword 'set' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model set */\r\n    set = {};\r\n    set.name = mpl.image;\r\n    set.alias = null;\r\n    set.dim = 0;\r\n    set.domain = null;\r\n    set.dimen = 0;\r\n    set.within = null;\r\n    set.assign = null;\r\n    set.option = null;\r\n    set.gadget = null;\r\n    set.data = 0;\r\n    set.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {   set.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  set.domain = mpl_internal_indexing_expression(mpl);\r\n        set.dim = mpl_internal_domain_arity(mpl, set.domain);\r\n    }\r\n    /* include the set name in the symbolic names table */\r\n    {\r\n        node = mpl.tree[set.name] = {};\r\n        node.type = A_SET;\r\n        node.link = set;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"dimen\"))\r\n        {  /* dimension of set members */\r\n            var dimen;\r\n            mpl_internal_get_token(mpl /* dimen */);\r\n            if (!(mpl.token == T_NUMBER &&\r\n                1.0 <= mpl.value && mpl.value <= 20.0 &&\r\n                Math.floor(mpl.value) == mpl.value))\r\n                mpl_internal_error(mpl, \"dimension must be integer between 1 and 20\");\r\n            dimen = (mpl.value + 0.5)|0;\r\n            if (dimen_used)\r\n                mpl_internal_error(mpl, \"at most one dimension attribute allowed\");\r\n            if (set.dimen > 0)\r\n                mpl_internal_error(mpl, \"dimension \" + dimen + \" conflicts with dimension \" + set.dimen + \" already determined\");\r\n            set.dimen = dimen;\r\n            dimen_used = 1;\r\n            mpl_internal_get_token(mpl /* <numeric literal> */);\r\n        }\r\n        else if (mpl.token == T_WITHIN || mpl.token == T_IN)\r\n        {  /* restricting superset */\r\n            var within, temp;\r\n            if (mpl.token == T_IN && !mpl.as_within)\r\n            {   mpl_internal_warning(mpl, \"keyword in understood as within\");\r\n                mpl.as_within = 1;\r\n            }\r\n            mpl_internal_get_token(mpl /* within */);\r\n            /* create new restricting superset list entry and append it\r\n             to the within-list */\r\n            within = {};\r\n            within.code = null;\r\n            within.next = null;\r\n            if (set.within == null)\r\n                set.within = within;\r\n            else\r\n            {   for (temp = set.within; temp.next != null; temp = temp.next){}\r\n                temp.next = within;\r\n            }\r\n            /* parse an expression that follows 'within' */\r\n            within.code = mpl_internal_expression_9(mpl);\r\n            if (within.code.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following within has invalid type\");\r\n            xassert(within.code.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = within.code.dim;\r\n            if (set.dimen != within.code.dim)\r\n                mpl_internal_error(mpl, \"set expression following within must have di\"+\r\n                    \"mension \" + set.dimen + \" rather than \" + within.code.dim);\r\n        }\r\n        else if (mpl.token == T_ASSIGN)\r\n        {  /* assignment expression */\r\n            if (!(set.assign == null && set.option == null &&\r\n                set.gadget == null))\r\n                err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows ':=' */\r\n            set.assign = mpl_internal_expression_9(mpl);\r\n            if (set.assign.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following := has invalid type\");\r\n            xassert(set.assign.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = set.assign.dim;\r\n            if (set.dimen != set.assign.dim)\r\n                mpl_internal_error(mpl, \"set expression following := must have dimens\" +\r\n                    \"ion \" + set.dimen + \" rather than \" + set.assign.dim);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"default\"))\r\n        {  /* expression for default value */\r\n            if (!(set.assign == null && set.option == null)) err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows 'default' */\r\n            set.option = mpl_internal_expression_9(mpl);\r\n            if (set.option.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following default has invalid type\");\r\n            xassert(set.option.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = set.option.dim;\r\n            if (set.dimen != set.option.dim)\r\n                mpl_internal_error(mpl, \"set expression following default must have d\" +\r\n                    \"imension \" + set.dimen + \" rather than \" + set.option.dim);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"data\"))\r\n        {  /* gadget to initialize the set by data from plain set */\r\n            var i = 0, k, fff = new Array(20); //[20];\r\n            if (!(set.assign == null && set.gadget == null)) err();\r\n            mpl_internal_get_token(mpl /* data */);\r\n            set.gadget = gadget = {};\r\n            /* set name must follow the keyword 'data' */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"set name missing where expected\");\r\n            /* find the set in the symbolic name table */\r\n            node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_SET)\r\n                err1();\r\n            gadget.set = node.link;\r\n            if (gadget.set.dim != 0) err1();\r\n            if (gadget.set == set)\r\n                mpl_internal_error(mpl, \"set cannot be initialized by itself\");\r\n            /* check and set dimensions */\r\n            if (set.dim >= gadget.set.dimen)\r\n                err2();\r\n            if (set.dimen == 0)\r\n                set.dimen = gadget.set.dimen - set.dim;\r\n            if (set.dim + set.dimen > gadget.set.dimen)\r\n                err2();\r\n            else if (set.dim + set.dimen < gadget.set.dimen)\r\n                mpl_internal_error(mpl, \"dimension of \" + mpl.image + \" too big\");\r\n            mpl_internal_get_token(mpl /* set name */);\r\n            /* left parenthesis must follow the set name */\r\n            if (mpl.token == T_LEFT)\r\n                mpl_internal_get_token(mpl /* ( */);\r\n            else\r\n                mpl_internal_error(mpl, \"left parenthesis missing where expected\");\r\n            /* parse permutation of component numbers */\r\n            for (k = 0; k < gadget.set.dimen; k++) fff[k] = 0;\r\n            k = 0;\r\n            for (;;)\r\n            {  if (mpl.token != T_NUMBER)\r\n                mpl_internal_error(mpl, \"component number missing where expected\");\r\n                if (str2int(mpl.image, function(v){i = v}) != 0)\r\n                    err3();\r\n                if (!(1 <= i && i <= gadget.set.dimen)) err3();\r\n                if (fff[i-1] != 0)\r\n                    mpl_internal_error(mpl, \"component \" + i + \" multiply specified\");\r\n                gadget.ind[k++] = i; fff[i-1] = 1;\r\n                xassert(k <= gadget.set.dimen);\r\n                mpl_internal_get_token(mpl /* number */);\r\n                if (mpl.token == T_COMMA)\r\n                    mpl_internal_get_token(mpl /* , */);\r\n                else if (mpl.token == T_RIGHT)\r\n                    break;\r\n                else\r\n                    mpl_internal_error(mpl, \"syntax error in data attribute\");\r\n            }\r\n            if (k < gadget.set.dimen)\r\n                mpl_internal_error(mpl, \"there are must be \" + gadget.set.dimen + \" components rather than \" + k);\r\n            mpl_internal_get_token(mpl /* ) */);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in set statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (set.domain != null) mpl_internal_close_scope(mpl, set.domain);\r\n    /* if dimension of set members is still unknown, set it to 1 */\r\n    if (set.dimen == 0) set.dimen = 1;\r\n    /* the set statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_parameter_statement(mpl){\r\n    var par, temp;\r\n    var integer_used = 0, binary_used = 0, symbolic_used = 0;\r\n\r\n    function process_binary(){\r\n        if (binary_used)\r\n            mpl_internal_error(mpl, \"at most one binary allowed\");\r\n        if (par.type == A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"symbolic parameter cannot be binary\");\r\n        par.type = A_BINARY;\r\n        binary_used = 1;\r\n        mpl_internal_get_token(mpl /* binary */);\r\n    }\r\n\r\n    function err(){mpl_internal_error(mpl, \"at most one := or default allowed\")}\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"param\"));\r\n    mpl_internal_get_token(mpl /* param */);\r\n    /* symbolic name must follow the keyword 'param' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model parameter */\r\n    par = {};\r\n    par.name = mpl.image;\r\n    par.alias = null;\r\n    par.dim = 0;\r\n    par.domain = null;\r\n    par.type = A_NUMERIC;\r\n    par.cond = null;\r\n    par.in_ = null;\r\n    par.assign = null;\r\n    par.option = null;\r\n    par.data = 0;\r\n    par.defval = null;\r\n    par.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        par.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  par.domain = mpl_internal_indexing_expression(mpl);\r\n        par.dim = mpl_internal_domain_arity(mpl, par.domain);\r\n    }\r\n    /* include the parameter name in the symbolic names table */\r\n    {   var node = mpl.tree[par.name] = {};\r\n        node.type = A_PARAMETER;\r\n        node.link = par;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"integer\"))\r\n        {  if (integer_used)\r\n            mpl_internal_error(mpl, \"at most one integer allowed\");\r\n            if (par.type == A_SYMBOLIC)\r\n                mpl_internal_error(mpl, \"symbolic parameter cannot be integer\");\r\n            if (par.type != A_BINARY) par.type = A_INTEGER;\r\n            integer_used = 1;\r\n            mpl_internal_get_token(mpl /* integer */);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"binary\"))\r\n            process_binary();\r\n        else if (mpl_internal_is_keyword(mpl, \"logical\"))\r\n        {  if (!mpl.as_binary)\r\n        {   mpl_internal_warning(mpl, \"keyword logical understood as binary\");\r\n            mpl.as_binary = 1;\r\n        }\r\n            process_binary();\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"symbolic\"))\r\n        {  if (symbolic_used)\r\n            mpl_internal_error(mpl, \"at most one symbolic allowed\");\r\n            if (par.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"integer or binary parameter cannot be symbolic\");\r\n            /* the parameter may be referenced from expressions given\r\n             in the same parameter declaration, so its type must be\r\n             completed before parsing that expressions */\r\n            if (!(par.cond == null && par.in_ == null &&\r\n                par.assign == null && par.option == null))\r\n                mpl_internal_error(mpl, \"keyword symbolic must precede any other parameter attributes\");\r\n            par.type = A_SYMBOLIC;\r\n            symbolic_used = 1;\r\n            mpl_internal_get_token(mpl /* symbolic */);\r\n        }\r\n        else if (mpl.token == T_LT || mpl.token == T_LE ||\r\n            mpl.token == T_EQ || mpl.token == T_GE ||\r\n            mpl.token == T_GT || mpl.token == T_NE)\r\n        {  /* restricting condition */\r\n            var opstr; // [8];\r\n            /* create new restricting condition list entry and append\r\n             it to the conditions list */\r\n            var cond = {};\r\n            switch (mpl.token)\r\n            {  case T_LT:\r\n                cond.rho = O_LT; opstr = mpl.image; break;\r\n                case T_LE:\r\n                    cond.rho = O_LE; opstr = mpl.image; break;\r\n                case T_EQ:\r\n                    cond.rho = O_EQ; opstr = mpl.image; break;\r\n                case T_GE:\r\n                    cond.rho = O_GE; opstr = mpl.image; break;\r\n                case T_GT:\r\n                    cond.rho = O_GT; opstr = mpl.image; break;\r\n                case T_NE:\r\n                    cond.rho = O_NE; opstr = mpl.image; break;\r\n                default:\r\n                    xassert(mpl.token != mpl.token);\r\n            }\r\n            xassert(opstr.length < 8);\r\n            cond.code = null;\r\n            cond.next = null;\r\n            if (par.cond == null)\r\n                par.cond = cond;\r\n            else\r\n            {  for (temp = par.cond; temp.next != null; temp = temp.next){}\r\n                temp.next = cond;\r\n            }\r\n            mpl_internal_get_token(mpl /* rho */);\r\n            /* parse an expression that follows relational operator */\r\n            cond.code = mpl_internal_expression_5(mpl);\r\n            if (!(cond.code.type == A_NUMERIC ||\r\n                cond.code.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n            xassert(cond.code.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && cond.code.type ==\r\n                A_SYMBOLIC)\r\n                cond.code = mpl_internal_make_unary(mpl, O_CVTNUM, cond.code,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && cond.code.type !=\r\n                A_SYMBOLIC)\r\n                cond.code = mpl_internal_make_unary(mpl, O_CVTSYM, cond.code,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else if (mpl.token == T_IN || mpl.token == T_WITHIN)\r\n        {  /* restricting superset */\r\n            var in_;\r\n            if (mpl.token == T_WITHIN && !mpl.as_in)\r\n            {   mpl_internal_warning(mpl, \"keyword within understood as in\");\r\n                mpl.as_in = 1;\r\n            }\r\n            mpl_internal_get_token(mpl /* in */);\r\n            /* create new restricting superset list entry and append it\r\n             to the in-list */\r\n            in_ = {};\r\n            in_.code = null;\r\n            in_.next = null;\r\n            if (par.in_ == null)\r\n                par.in_ = in_;\r\n            else\r\n            {  for (temp = par.in_; temp.next != null; temp = temp.next){}\r\n                temp.next = in_;\r\n            }\r\n            /* parse an expression that follows 'in' */\r\n            in_.code = mpl_internal_expression_9(mpl);\r\n            if (in_.code.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following in has invalid type\");\r\n            xassert(in_.code.dim > 0);\r\n            if (in_.code.dim != 1)\r\n                mpl_internal_error(mpl, \"set expression following in must have dimens\"+\r\n                    \"ion 1 rather than \" + in_.code.dim);\r\n        }\r\n        else if (mpl.token == T_ASSIGN)\r\n        {   /* assignment expression */\r\n            if (!(par.assign == null && par.option == null))\r\n                err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows ':=' */\r\n            par.assign = mpl_internal_expression_5(mpl);\r\n            /* the expression must be of numeric/symbolic type */\r\n            if (!(par.assign.type == A_NUMERIC ||\r\n                par.assign.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following := has invalid type\");\r\n            xassert(par.assign.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && par.assign.type ==\r\n                A_SYMBOLIC)\r\n                par.assign = mpl_internal_make_unary(mpl, O_CVTNUM, par.assign,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && par.assign.type !=\r\n                A_SYMBOLIC)\r\n                par.assign = mpl_internal_make_unary(mpl, O_CVTSYM, par.assign,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"default\"))\r\n        {  /* expression for default value */\r\n            if (!(par.assign == null && par.option == null)) err();\r\n            mpl_internal_get_token(mpl /* default */);\r\n            /* parse an expression that follows 'default' */\r\n            par.option = mpl_internal_expression_5(mpl);\r\n            if (!(par.option.type == A_NUMERIC ||\r\n                par.option.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following default has invalid type\");\r\n            xassert(par.option.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && par.option.type ==\r\n                A_SYMBOLIC)\r\n                par.option = mpl_internal_make_unary(mpl, O_CVTNUM, par.option,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && par.option.type !=\r\n                A_SYMBOLIC)\r\n                par.option = mpl_internal_make_unary(mpl, O_CVTSYM, par.option,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in parameter statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (par.domain != null) mpl_internal_close_scope(mpl, par.domain);\r\n    /* the parameter statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return par;\r\n}\r\n\r\nfunction mpl_internal_variable_statement(mpl){\r\n    var integer_used = 0, binary_used = 0;\r\n\r\n    function process_binary(){\r\n        if (binary_used)\r\n            mpl_internal_error(mpl, \"at most one binary allowed\");\r\n        var_.type = A_BINARY;\r\n        binary_used = 1;\r\n        mpl_internal_get_token(mpl /* binary */);\r\n    }\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"var\"));\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"variable statement must precede solve statement\");\r\n    mpl_internal_get_token(mpl /* var */);\r\n    /* symbolic name must follow the keyword 'var' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model variable */\r\n    var var_ = {};\r\n    var_.name = mpl.image;\r\n    var_.alias = null;\r\n    var_.dim = 0;\r\n    var_.domain = null;\r\n    var_.type = A_NUMERIC;\r\n    var_.lbnd = null;\r\n    var_.ubnd = null;\r\n    var_.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        var_.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  var_.domain = mpl_internal_indexing_expression(mpl);\r\n        var_.dim = mpl_internal_domain_arity(mpl, var_.domain);\r\n    }\r\n    /* include the variable name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[var_.name] = {};\r\n        node.type = A_VARIABLE;\r\n        node.link = var_;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"integer\"))\r\n        {  if (integer_used)\r\n            mpl_internal_error(mpl, \"at most one integer allowed\");\r\n            if (var_.type != A_BINARY) var_.type = A_INTEGER;\r\n            integer_used = 1;\r\n            mpl_internal_get_token(mpl /* integer */);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"binary\"))\r\n            process_binary();\r\n        else if (mpl_internal_is_keyword(mpl, \"logical\"))\r\n        {  if (!mpl.as_binary)\r\n        {  mpl_internal_warning(mpl, \"keyword logical understood as binary\");\r\n            mpl.as_binary = 1;\r\n        }\r\n            process_binary();\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"symbolic\"))\r\n            mpl_internal_error(mpl, \"variable cannot be symbolic\");\r\n        else if (mpl.token == T_GE)\r\n        {  /* lower bound */\r\n            if (var_.lbnd != null)\r\n            {  if (var_.lbnd == var_.ubnd)\r\n                mpl_internal_error(mpl, \"both fixed value and lower bound not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"at most one lower bound allowed\");\r\n            }\r\n            mpl_internal_get_token(mpl /* >= */);\r\n            /* parse an expression that specifies the lower bound */\r\n            var_.lbnd = mpl_internal_expression_5(mpl);\r\n            if (var_.lbnd.type == A_SYMBOLIC)\r\n                var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.lbnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following >= has invalid type\");\r\n            xassert(var_.lbnd.dim == 0);\r\n        }\r\n        else if (mpl.token == T_LE)\r\n        {  /* upper bound */\r\n            if (var_.ubnd != null)\r\n            {  if (var_.ubnd == var_.lbnd)\r\n                mpl_internal_error(mpl, \"both fixed value and upper bound not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"at most one upper bound allowed\");\r\n            }\r\n            mpl_internal_get_token(mpl /* <= */);\r\n            /* parse an expression that specifies the upper bound */\r\n            var_.ubnd = mpl_internal_expression_5(mpl);\r\n            if (var_.ubnd.type == A_SYMBOLIC)\r\n                var_.ubnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.ubnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.ubnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following <= has invalid type\");\r\n            xassert(var_.ubnd.dim == 0);\r\n        }\r\n        else if (mpl.token == T_EQ)\r\n        {  /* fixed value */\r\n            var opstr; //[8]\r\n            if (!(var_.lbnd == null && var_.ubnd == null))\r\n            {  if (var_.lbnd == var_.ubnd)\r\n                mpl_internal_error(mpl, \"at most one fixed value allowed\");\r\n            else if (var_.lbnd != null)\r\n                mpl_internal_error(mpl, \"both lower bound and fixed value not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"both upper bound and fixed value not allowed\");\r\n            }\r\n            opstr = mpl.image;\r\n            xassert(opstr.length < 8);\r\n            mpl_internal_get_token(mpl /* = | == */);\r\n            /* parse an expression that specifies the fixed value */\r\n            var_.lbnd = mpl_internal_expression_5(mpl);\r\n            if (var_.lbnd.type == A_SYMBOLIC)\r\n                var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.lbnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n            xassert(var_.lbnd.dim == 0);\r\n            /* indicate that the variable is fixed, not bounded */\r\n            var_.ubnd = var_.lbnd;\r\n        }\r\n        else if (mpl.token == T_LT || mpl.token == T_GT ||\r\n            mpl.token == T_NE)\r\n            mpl_internal_error(mpl, \"strict bound not allowed\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in variable statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (var_.domain != null) mpl_internal_close_scope(mpl, var_.domain);\r\n    /* the variable statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return var_;\r\n}\r\n\r\nfunction mpl_internal_constraint_statement(mpl){\r\n    var first, second, third;\r\n    var rho;\r\n    var opstr; //[8];\r\n\r\n    function err(){mpl_internal_error(mpl, \"syntax error in constraint statement\")}\r\n\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"constraint statement must precede solve statement\");\r\n    if (mpl_internal_is_keyword(mpl, \"subject\"))\r\n    {  mpl_internal_get_token(mpl /* subject */);\r\n        if (!mpl_internal_is_keyword(mpl, \"to\"))\r\n            mpl_internal_error(mpl, \"keyword subject to incomplete\");\r\n        mpl_internal_get_token(mpl /* to */);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"subj\"))\r\n    {  mpl_internal_get_token(mpl /* subj */);\r\n        if (!mpl_internal_is_keyword(mpl, \"to\"))\r\n            mpl_internal_error(mpl, \"keyword subj to incomplete\");\r\n        mpl_internal_get_token(mpl /* to */);\r\n    }\r\n    else if (mpl.token == T_SPTP)\r\n        mpl_internal_get_token(mpl /* s.t. */);\r\n    /* the current token must be symbolic name of constraint */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model constraint */\r\n    var con = {};\r\n    con.name = mpl.image;\r\n    con.alias = null;\r\n    con.dim = 0;\r\n    con.domain = null;\r\n    con.type = A_CONSTRAINT;\r\n    con.code = null;\r\n    con.lbnd = null;\r\n    con.ubnd = null;\r\n    con.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        con.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  con.domain = mpl_internal_indexing_expression(mpl);\r\n        con.dim = mpl_internal_domain_arity(mpl, con.domain);\r\n    }\r\n    /* include the constraint name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[con.name] = {};\r\n        node.type = A_CONSTRAINT;\r\n        node.link = con;\r\n    }\r\n    /* the colon must precede the first expression */\r\n    if (mpl.token != T_COLON)\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    mpl_internal_get_token(mpl /* : */);\r\n    /* parse the first expression */\r\n    first = mpl_internal_expression_5(mpl);\r\n    if (first.type == A_SYMBOLIC)\r\n        first = mpl_internal_make_unary(mpl, O_CVTNUM, first, A_NUMERIC, 0);\r\n    if (!(first.type == A_NUMERIC || first.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n    xassert(first.dim == 0);\r\n    /* relational operator must follow the first expression */\r\n    if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    switch (mpl.token)\r\n    {  case T_LE:\r\n        case T_GE:\r\n        case T_EQ:\r\n            break;\r\n        case T_LT:\r\n        case T_GT:\r\n        case T_NE:\r\n            mpl_internal_error(mpl, \"strict inequality not allowed\");\r\n            break;\r\n        case T_SEMICOLON:\r\n            mpl_internal_error(mpl, \"constraint must be equality or inequality\");\r\n            break;\r\n        default:\r\n            err();\r\n    }\r\n    rho = mpl.token;\r\n    opstr = mpl.image;\r\n    xassert(opstr.length < 8);\r\n    mpl_internal_get_token(mpl /* rho */);\r\n    /* parse the second expression */\r\n    second = mpl_internal_expression_5(mpl);\r\n    if (second.type == A_SYMBOLIC)\r\n        second = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\r\n    if (!(second.type == A_NUMERIC || second.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n    xassert(second.dim == 0);\r\n    /* check a token that follow the second expression */\r\n    if (mpl.token == T_COMMA)\r\n    {  mpl_internal_get_token(mpl /* , */);\r\n        if (mpl.token == T_SEMICOLON) err();\r\n    }\r\n    if (mpl.token == T_LT || mpl.token == T_LE ||\r\n        mpl.token == T_EQ || mpl.token == T_GE ||\r\n        mpl.token == T_GT || mpl.token == T_NE)\r\n    {  /* it is another relational operator, therefore the constraint\r\n     is double inequality */\r\n        if (rho == T_EQ || mpl.token != rho)\r\n            mpl_internal_error(mpl, \"double inequality must be ... <= ... <= ... or \" +\r\n                \"... >= ... >= ...\");\r\n        /* the first expression cannot be linear form */\r\n        if (first.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"leftmost expression in double inequality cannot\" +\r\n                \" be linear form\");\r\n        mpl_internal_get_token(mpl /* rho */);\r\n        /* parse the third expression */\r\n        third = mpl_internal_expression_5(mpl);\r\n        if (third.type == A_SYMBOLIC)\r\n            third = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\r\n        if (!(third.type == A_NUMERIC || third.type == A_FORMULA))\r\n            mpl_internal_error(mpl, \"rightmost expression in double inequality const\" +\r\n                \"raint has invalid type\");\r\n        xassert(third.dim == 0);\r\n        /* the third expression also cannot be linear form */\r\n        if (third.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"rightmost expression in double inequality canno\" +\r\n                \"t be linear form\");\r\n    }\r\n    else\r\n    {  /* the constraint is equality or single inequality */\r\n        third = null;\r\n    }\r\n    /* close the domain scope */\r\n    if (con.domain != null) mpl_internal_close_scope(mpl, con.domain);\r\n    /* convert all expressions to linear form, if necessary */\r\n    if (first.type != A_FORMULA)\r\n        first = mpl_internal_make_unary(mpl, O_CVTLFM, first, A_FORMULA, 0);\r\n    if (second.type != A_FORMULA)\r\n        second = mpl_internal_make_unary(mpl, O_CVTLFM, second, A_FORMULA, 0);\r\n    if (third != null)\r\n        third = mpl_internal_make_unary(mpl, O_CVTLFM, third, A_FORMULA, 0);\r\n    /* arrange expressions in the constraint */\r\n    if (third == null)\r\n    {  /* the constraint is equality or single inequality */\r\n        switch (rho)\r\n        {  case T_LE:\r\n            /* first <= second */\r\n            con.code = first;\r\n            con.lbnd = null;\r\n            con.ubnd = second;\r\n            break;\r\n            case T_GE:\r\n                /* first >= second */\r\n                con.code = first;\r\n                con.lbnd = second;\r\n                con.ubnd = null;\r\n                break;\r\n            case T_EQ:\r\n                /* first = second */\r\n                con.code = first;\r\n                con.lbnd = second;\r\n                con.ubnd = second;\r\n                break;\r\n            default:\r\n                xassert(rho != rho);\r\n        }\r\n    }\r\n    else\r\n    {  /* the constraint is double inequality */\r\n        switch (rho)\r\n        {  case T_LE:\r\n            /* first <= second <= third */\r\n            con.code = second;\r\n            con.lbnd = first;\r\n            con.ubnd = third;\r\n            break;\r\n            case T_GE:\r\n                /* first >= second >= third */\r\n                con.code = second;\r\n                con.lbnd = third;\r\n                con.ubnd = first;\r\n                break;\r\n            default:\r\n                xassert(rho != rho);\r\n        }\r\n    }\r\n    /* the constraint statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        err();\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return con;\r\n}\r\n\r\nfunction mpl_internal_objective_statement(mpl){\r\n    var obj;\r\n    var type;\r\n    if (mpl_internal_is_keyword(mpl, \"minimize\"))\r\n        type = A_MINIMIZE;\r\n    else if (mpl_internal_is_keyword(mpl, \"maximize\"))\r\n        type = A_MAXIMIZE;\r\n    else\r\n        xassert(mpl != mpl);\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"objective statement must precede solve statement\");\r\n    mpl_internal_get_token(mpl /* minimize | maximize */);\r\n    /* symbolic name must follow the verb 'minimize' or 'maximize' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model objective */\r\n    obj = {};\r\n    obj.name = mpl.image;\r\n    obj.alias = null;\r\n    obj.dim = 0;\r\n    obj.domain = null;\r\n    obj.type = type;\r\n    obj.code = null;\r\n    obj.lbnd = null;\r\n    obj.ubnd = null;\r\n    obj.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        obj.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {   obj.domain = mpl_internal_indexing_expression(mpl);\r\n        obj.dim = mpl_internal_domain_arity(mpl, obj.domain);\r\n    }\r\n    /* include the constraint name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[obj.name] = {};\r\n        node.type = A_CONSTRAINT;\r\n        node.link = obj;\r\n    }\r\n    /* the colon must precede the objective expression */\r\n    if (mpl.token != T_COLON)\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    mpl_internal_get_token(mpl /* : */);\r\n    /* parse the objective expression */\r\n    obj.code = mpl_internal_expression_5(mpl);\r\n    if (obj.code.type == A_SYMBOLIC)\r\n        obj.code = mpl_internal_make_unary(mpl, O_CVTNUM, obj.code, A_NUMERIC, 0);\r\n    if (obj.code.type == A_NUMERIC)\r\n        obj.code = mpl_internal_make_unary(mpl, O_CVTLFM, obj.code, A_FORMULA, 0);\r\n    if (obj.code.type != A_FORMULA)\r\n        mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n    xassert(obj.code.dim == 0);\r\n    /* close the domain scope */\r\n    if (obj.domain != null) mpl_internal_close_scope(mpl, obj.domain);\r\n    /* the objective statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in objective statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return obj;\r\n}\r\n\r\nfunction mpl_internal_table_statement(mpl){\r\n    var last_arg, arg;\r\n    var last_fld, fld;\r\n    var last_in, in_;\r\n    var last_out, out;\r\n    var node;\r\n    var nflds;\r\n    var name; // [MAX_LENGTH+1];\r\n    xassert(mpl_internal_is_keyword(mpl, \"table\"));\r\n    mpl_internal_get_token(mpl /* solve */);\r\n    /* symbolic name must follow the keyword table */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create data table */\r\n    var tab = {u: {in_: {}, out: {}}};\r\n    tab.name = mpl.image;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        tab.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    else\r\n        tab.alias = null;\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  /* this is output table */\r\n        tab.type = A_OUTPUT;\r\n        tab.u.out.domain = mpl_internal_indexing_expression(mpl);\r\n        if (!mpl_internal_is_keyword(mpl, \"OUT\"))\r\n            mpl_internal_error(mpl, \"keyword OUT missing where expected\");\r\n        mpl_internal_get_token(mpl /* OUT */);\r\n    }\r\n    else\r\n    {  /* this is input table */\r\n        tab.type = A_INPUT;\r\n        if (!mpl_internal_is_keyword(mpl, \"IN\"))\r\n            mpl_internal_error(mpl, \"keyword IN missing where expected\");\r\n        mpl_internal_get_token(mpl /* IN */);\r\n    }\r\n    /* parse argument list */\r\n    tab.arg = last_arg = null;\r\n    for (;;)\r\n    {  /* create argument list entry */\r\n        arg = {};\r\n        /* parse argument expression */\r\n        if (mpl.token == T_COMMA || mpl.token == T_COLON ||\r\n            mpl.token == T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"argument expression missing where expected\");\r\n        arg.code = mpl_internal_expression_5(mpl);\r\n        /* convert the result to symbolic type, if necessary */\r\n        if (arg.code.type == A_NUMERIC)\r\n            arg.code =\r\n                mpl_internal_make_unary(mpl, O_CVTSYM, arg.code, A_SYMBOLIC, 0);\r\n        /* check that now the result is of symbolic type */\r\n        if (arg.code.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"argument expression has invalid type\");\r\n        /* add the entry to the end of the list */\r\n        arg.next = null;\r\n        if (last_arg == null)\r\n            tab.arg = arg;\r\n        else\r\n            last_arg.next = arg;\r\n        last_arg = arg;\r\n        /* argument expression has been parsed */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_COLON || mpl.token == T_SEMICOLON)\r\n            break;\r\n    }\r\n    xassert(tab.arg != null);\r\n    /* argument list must end with colon */\r\n    if (mpl.token == T_COLON)\r\n        mpl_internal_get_token(mpl /* : */);\r\n    else\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    /* parse specific part of the table statement */\r\n    switch (tab.type)\r\n    {   case A_INPUT:\r\n        /* parse optional set name */\r\n        if (mpl.token == T_NAME)\r\n        {   node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_SET)\r\n                mpl_internal_error(mpl, mpl.image + \" not a set\");\r\n            tab.u.in_.set = node.link;\r\n            if (tab.u.in_.set.assign != null)\r\n                mpl_internal_error(mpl, mpl.image + \" needs no data\");\r\n            if (tab.u.in_.set.dim != 0)\r\n                mpl_internal_error(mpl, mpl.image + \" must be a simple set\");\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            if (mpl.token == T_INPUT)\r\n                mpl_internal_get_token(mpl /* <- */);\r\n            else\r\n                mpl_internal_error(mpl, \"delimiter <- missing where expected\");\r\n        }\r\n        else if (mpl_internal_is_reserved(mpl))\r\n            mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n        else\r\n            tab.u.in_.set = null;\r\n        /* parse field list */\r\n        tab.u.in_.fld = last_fld = null;\r\n        nflds = 0;\r\n        if (mpl.token == T_LBRACKET)\r\n            mpl_internal_get_token(mpl /* [ */);\r\n        else\r\n            mpl_internal_error(mpl, \"field list missing where expected\");\r\n        for (;;)\r\n        {  /* create field list entry */\r\n            fld = {};\r\n            /* parse field name */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl,\r\n                    \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"field name missing where expected\");\r\n            fld.name = mpl.image;\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            /* add the entry to the end of the list */\r\n            fld.next = null;\r\n            if (last_fld == null)\r\n                tab.u.in_.fld = fld;\r\n            else\r\n                last_fld.next = fld;\r\n            last_fld = fld;\r\n            nflds++;\r\n            /* field name has been parsed */\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RBRACKET)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in field list\");\r\n        }\r\n        /* check that the set dimen is equal to the number of fields */\r\n        if (tab.u.in_.set != null && tab.u.in_.set.dimen != nflds)\r\n            mpl_internal_error(mpl, \"there must be \" + tab.u.in_.set.dimen + \" field\" +\r\n                (tab.u.in_.set.dimen == 1 ? \"\" : \"s\") + \" rather than \" + nflds);\r\n        mpl_internal_get_token(mpl /* ] */);\r\n        /* parse optional input list */\r\n        tab.u.in_.list = last_in = null;\r\n        while (mpl.token == T_COMMA)\r\n        {  mpl_internal_get_token(mpl /* , */);\r\n            /* create input list entry */\r\n            in_ = {};\r\n            /* parse parameter name */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"parameter name missing where expected\");\r\n            node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_PARAMETER)\r\n                mpl_internal_error(mpl, mpl.image + \" not a parameter\");\r\n            in_.par = node.link;\r\n            if (in_.par.dim != nflds)\r\n                mpl_internal_error(mpl, mpl.image + \" must have \" + nflds + \" subscript\" + (nflds == 1 ? \"\" : \"s\") + \" rather than \" + in_.par.dim);\r\n            if (in_.par.assign != null)\r\n                mpl_internal_error(mpl, mpl.image + \" needs no data\");\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            /* parse optional field name */\r\n            if (mpl.token == T_TILDE)\r\n            {  mpl_internal_get_token(mpl /* ~ */);\r\n                /* parse field name */\r\n                if (mpl.token == T_NAME){\r\n\r\n                }\r\n                else if (mpl_internal_is_reserved(mpl))\r\n                    mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n                else\r\n                    mpl_internal_error(mpl, \"field name missing where expected\");\r\n                //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                name = mpl.image;\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            }\r\n            else\r\n            {  /* field name is the same as the parameter name */\r\n                //xassert(in_.par.name.length < MAX_LENGTH+1);\r\n                name = in_.par.name;\r\n            }\r\n            /* assign field name */\r\n            in_.name = name;\r\n            /* add the entry to the end of the list */\r\n            in_.next = null;\r\n            if (last_in == null)\r\n                tab.u.in_.list = in_;\r\n            else\r\n                last_in.next = in_;\r\n            last_in = in_;\r\n        }\r\n        break;\r\n        case A_OUTPUT:\r\n            /* parse output list */\r\n            tab.u.out.list = last_out = null;\r\n            for (;;)\r\n            {  /* create output list entry */\r\n                out = {};\r\n                /* parse expression */\r\n                if (mpl.token == T_COMMA || mpl.token == T_SEMICOLON)\r\n                    mpl_internal_error(mpl, \"expression missing where expected\");\r\n                if (mpl.token == T_NAME)\r\n                {  //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                    name = mpl.image;\r\n                }\r\n                else\r\n                    name = '';\r\n                out.code = mpl_internal_expression_5(mpl);\r\n                /* parse optional field name */\r\n                if (mpl.token == T_TILDE)\r\n                {  mpl_internal_get_token(mpl /* ~ */);\r\n                    /* parse field name */\r\n                    if (mpl.token == T_NAME){\r\n\r\n                    }\r\n                    else if (mpl_internal_is_reserved(mpl))\r\n                        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n                    else\r\n                        mpl_internal_error(mpl, \"field name missing where expected\");\r\n                    //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                    name = mpl.image;\r\n                    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                }\r\n                /* assign field name */\r\n                if (name == '')\r\n                    mpl_internal_error(mpl, \"field name required\");\r\n                out.name = name;\r\n                /* add the entry to the end of the list */\r\n                out.next = null;\r\n                if (last_out == null)\r\n                    tab.u.out.list = out;\r\n                else\r\n                    last_out.next = out;\r\n                last_out = out;\r\n                /* output item has been parsed */\r\n                if (mpl.token == T_COMMA)\r\n                    mpl_internal_get_token(mpl /* , */);\r\n                else if (mpl.token == T_SEMICOLON)\r\n                    break;\r\n                else\r\n                    mpl_internal_error(mpl, \"syntax error in output list\");\r\n            }\r\n            /* close the domain scope */\r\n            mpl_internal_close_scope(mpl,tab.u.out.domain);\r\n            break;\r\n        default:\r\n            xassert(tab != tab);\r\n    }\r\n\r\n    /* the table statement must end with semicolon */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in table statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return tab;\r\n}\r\n\r\nfunction mpl_internal_solve_statement(mpl){\r\n    xassert(mpl_internal_is_keyword(mpl, \"solve\"));\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"at most one solve statement allowed\");\r\n    mpl.flag_s = 1;\r\n    mpl_internal_get_token(mpl /* solve */);\r\n    /* semicolon must follow solve statement */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in solve statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return null;\r\n}\r\n\r\nfunction mpl_internal_check_statement(mpl){\r\n    xassert(mpl_internal_is_keyword(mpl, \"check\"));\r\n    /* create check descriptor */\r\n    var chk = {};\r\n    chk.domain = null;\r\n    chk.code = null;\r\n    mpl_internal_get_token(mpl /* check */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  chk.domain = mpl_internal_indexing_expression(mpl);\r\n    }\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse logical expression */\r\n    chk.code = mpl_internal_expression_13(mpl);\r\n    if (chk.code.type != A_LOGICAL)\r\n        mpl_internal_error(mpl, \"expression has invalid type\");\r\n    xassert(chk.code.dim == 0);\r\n    /* close the domain scope */\r\n    if (chk.domain != null) mpl_internal_close_scope(mpl, chk.domain);\r\n    /* the check statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in check statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return chk;\r\n}\r\n\r\nfunction mpl_internal_display_statement(mpl){\r\n    var last_entry;\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"display\"));\r\n    /* create display descriptor */\r\n    var dpy = {};\r\n    dpy.domain = null;\r\n    dpy.list = last_entry = null;\r\n    mpl_internal_get_token(mpl /* display */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n        dpy.domain = mpl_internal_indexing_expression(mpl);\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse display list */\r\n    for (;;)\r\n    {  /* create new display entry */\r\n        var entry = {u: {}};\r\n\r\n        function expr(){\r\n            /* display entry is expression */\r\n            entry.type = A_EXPRESSION;\r\n            entry.u.code = mpl_internal_expression_13(mpl);\r\n        }\r\n\r\n        entry.type = 0;\r\n        entry.next = null;\r\n        /* and append it to the display list */\r\n        if (dpy.list == null)\r\n            dpy.list = entry;\r\n        else\r\n            last_entry.next = entry;\r\n        last_entry = entry;\r\n        /* parse display entry */\r\n        if (mpl.token == T_NAME)\r\n        {   var node;\r\n            var next_token;\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (!(next_token == T_COMMA || next_token == T_SEMICOLON))\r\n            {  /* symbolic name begins expression */\r\n                expr();\r\n            } else {\r\n                /* display entry is dummy index or model object */\r\n                node = mpl.tree[mpl.image];\r\n                if (node == null)\r\n                    mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n                entry.type = node.type;\r\n                switch (node.type)\r\n                {  case A_INDEX:\r\n                    entry.u.slot = node.link;\r\n                    break;\r\n                    case A_SET:\r\n                        entry.u.set = node.link;\r\n                        break;\r\n                    case A_PARAMETER:\r\n                        entry.u.par = node.link;\r\n                        break;\r\n                    case A_VARIABLE:\r\n                        entry.u.var_ = node.link;\r\n                        if (!mpl.flag_s)\r\n                            mpl_internal_error(mpl, \"invalid reference to variable \" + entry.u.var_.name +  \" above solve statement\");\r\n                        break;\r\n                    case A_CONSTRAINT:\r\n                        entry.u.con = node.link;\r\n                        if (!mpl.flag_s)\r\n                            mpl_internal_error(mpl, \"invalid reference to \" + (entry.u.con.type == A_CONSTRAINT ?\"constraint\" : \"objective\") +\r\n                                \" \" + entry.u.con.name + \" above solve statement\");\r\n                        break;\r\n                    default:\r\n                        xassert(node != node);\r\n                }\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            }\r\n        }\r\n        else\r\n            expr();\r\n        /* check a token that follows the entry parsed */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else\r\n            break;\r\n    }\r\n    /* close the domain scope */\r\n    if (dpy.domain != null) mpl_internal_close_scope(mpl, dpy.domain);\r\n    /* the display statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in display statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return dpy;\r\n}\r\n\r\nfunction mpl_internal_printf_statement(mpl){\r\n    var entry, last_entry;\r\n    xassert(mpl_internal_is_keyword(mpl, \"printf\"));\r\n    /* create printf descriptor */\r\n    var prt = {};\r\n    prt.domain = null;\r\n    prt.fmt = null;\r\n    prt.list = last_entry = null;\r\n    mpl_internal_get_token(mpl /* printf */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  prt.domain = mpl_internal_indexing_expression(mpl);\r\n    }\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse expression for format string */\r\n    prt.fmt = mpl_internal_expression_5(mpl);\r\n    /* convert it to symbolic type, if necessary */\r\n    if (prt.fmt.type == A_NUMERIC)\r\n        prt.fmt = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fmt, A_SYMBOLIC, 0);\r\n    /* check that now the expression is of symbolic type */\r\n    if (prt.fmt.type != A_SYMBOLIC)\r\n        mpl_internal_error(mpl, \"format expression has invalid type\");\r\n    /* parse printf list */\r\n    while (mpl.token == T_COMMA)\r\n    {  mpl_internal_get_token(mpl /* , */);\r\n        /* create new printf entry */\r\n        entry = {};\r\n        entry.code = null;\r\n        entry.next = null;\r\n        /* and append it to the printf list */\r\n        if (prt.list == null)\r\n            prt.list = entry;\r\n        else\r\n            last_entry.next = entry;\r\n        last_entry = entry;\r\n        /* parse printf entry */\r\n        entry.code = mpl_internal_expression_9(mpl);\r\n        if (!(entry.code.type == A_NUMERIC ||\r\n            entry.code.type == A_SYMBOLIC ||\r\n            entry.code.type == A_LOGICAL))\r\n            mpl_internal_error(mpl, \"only numeric, symbolic, or logical expression allowed\");\r\n    }\r\n    /* close the domain scope */\r\n    if (prt.domain != null) mpl_internal_close_scope(mpl, prt.domain);\r\n    /* parse optional redirection */\r\n    prt.fname = null; prt.app = 0;\r\n    if (mpl.token == T_GT || mpl.token == T_APPEND)\r\n    {  prt.app = (mpl.token == T_APPEND);\r\n        mpl_internal_get_token(mpl /* > or >> */);\r\n        /* parse expression for file name string */\r\n        prt.fname = mpl_internal_expression_5(mpl);\r\n        /* convert it to symbolic type, if necessary */\r\n        if (prt.fname.type == A_NUMERIC)\r\n            prt.fname = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fname,\r\n                A_SYMBOLIC, 0);\r\n        /* check that now the expression is of symbolic type */\r\n        if (prt.fname.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"file name expression has invalid type\");\r\n    }\r\n    /* the printf statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in printf statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return prt;\r\n}\r\n\r\nfunction mpl_internal_for_statement(mpl){\r\n    var stmt, last_stmt;\r\n    xassert(mpl_internal_is_keyword(mpl, \"for\"));\r\n    /* create for descriptor */\r\n    var fur = {};\r\n    fur.domain = null;\r\n    fur.list = last_stmt = null;\r\n    mpl_internal_get_token(mpl /* for */);\r\n    /* parse indexing expression */\r\n    if (mpl.token != T_LBRACE)\r\n        mpl_internal_error(mpl, \"indexing expression missing where expected\");\r\n    fur.domain = mpl_internal_indexing_expression(mpl);\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse for statement body */\r\n    if (mpl.token != T_LBRACE)\r\n    {  /* parse simple statement */\r\n        fur.list = mpl_internal_simple_statement(mpl, 1);\r\n    }\r\n    else\r\n    {  /* parse compound statement */\r\n        mpl_internal_get_token(mpl /* { */);\r\n        while (mpl.token != T_RBRACE)\r\n        {  /* parse statement */\r\n            stmt = mpl_internal_simple_statement(mpl, 1);\r\n            /* and append it to the end of the statement list */\r\n            if (last_stmt == null)\r\n                fur.list = stmt;\r\n            else\r\n                last_stmt.next = stmt;\r\n            last_stmt = stmt;\r\n        }\r\n        mpl_internal_get_token(mpl /* } */);\r\n    }\r\n    /* close the domain scope */\r\n    xassert(fur.domain != null);\r\n    mpl_internal_close_scope(mpl, fur.domain);\r\n    /* the for statement has been completely parsed */\r\n    return fur;\r\n}\r\n\r\nfunction mpl_internal_end_statement(mpl){\r\n    if (!mpl.flag_d && mpl_internal_is_keyword(mpl, \"end\") ||\r\n        mpl.flag_d && mpl_internal_is_literal(mpl, \"end\"))\r\n    {\r\n        mpl_internal_get_token(mpl /* end */);\r\n        if (mpl.token == T_SEMICOLON)\r\n            mpl_internal_get_token(mpl /* ; */);\r\n        else\r\n            mpl_internal_warning(mpl, \"no semicolon following end statement; missing\" +\r\n                \" semicolon inserted\");\r\n    }\r\n    else\r\n        mpl_internal_warning(mpl, \"unexpected end of file; missing end statement inserted\");\r\n    if (mpl.token != T_EOF)\r\n        mpl_internal_warning(mpl, \"some text detected beyond end statement; text ignored\");\r\n}\r\n\r\nfunction mpl_internal_simple_statement(mpl, spec){\r\n    var stmt = {u: {}};\r\n    stmt.line = mpl.line;\r\n    stmt.column = mpl.column;\r\n    stmt.next = null;\r\n    if (mpl_internal_is_keyword(mpl, \"set\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"set statement not allowed here\");\r\n        stmt.type = A_SET;\r\n        stmt.u.set = mpl_internal_set_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"param\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"parameter statement not allowed here\");\r\n        stmt.type = A_PARAMETER;\r\n        stmt.u.par = mpl_internal_parameter_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"var\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"variable statement not allowed here\");\r\n        stmt.type = A_VARIABLE;\r\n        stmt.u.var_ = mpl_internal_variable_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"subject\") ||\r\n        mpl_internal_is_keyword(mpl, \"subj\") ||\r\n        mpl.token == T_SPTP)\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"constraint statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_constraint_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"minimize\") ||\r\n        mpl_internal_is_keyword(mpl, \"maximize\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"objective statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_objective_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"table\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"table statement not allowed here\");\r\n        stmt.type = A_TABLE;\r\n        stmt.u.tab = mpl_internal_table_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"solve\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"solve statement not allowed here\");\r\n        stmt.type = A_SOLVE;\r\n        stmt.u.slv = mpl_internal_solve_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"check\"))\r\n    {  stmt.type = A_CHECK;\r\n        stmt.u.chk = mpl_internal_check_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"display\"))\r\n    {  stmt.type = A_DISPLAY;\r\n        stmt.u.dpy = mpl_internal_display_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"printf\"))\r\n    {  stmt.type = A_PRINTF;\r\n        stmt.u.prt = mpl_internal_printf_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"for\"))\r\n    {  stmt.type = A_FOR;\r\n        stmt.u.fur = mpl_internal_for_statement(mpl);\r\n    }\r\n    else if (mpl.token == T_NAME)\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"constraint statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_constraint_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in model section\");\r\n    return stmt;\r\n}\r\n\r\nfunction mpl_internal_model_section(mpl){\r\n    var stmt, last_stmt;\r\n    xassert(mpl.model == null);\r\n    last_stmt = null;\r\n    while (!(mpl.token == T_EOF || mpl_internal_is_keyword(mpl, \"data\") ||\r\n        mpl_internal_is_keyword(mpl, \"end\")))\r\n    {  /* parse statement */\r\n        stmt = mpl_internal_simple_statement(mpl, 0);\r\n        /* and append it to the end of the statement list */\r\n        if (last_stmt == null)\r\n            mpl.model = stmt;\r\n        else\r\n            last_stmt.next = stmt;\r\n        last_stmt = stmt;\r\n    }\r\n}\r\n\r\n/* glpmpl02.c */\r\n\r\n/**********************************************************************/\r\n/* * *                  PROCESSING DATA SECTION                   * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_expand_slice\r\n    (   mpl,\r\n        slice,           /* destroyed */\r\n        sym             /* destroyed */\r\n        ){\r\n    var temp;\r\n    /* create a new component */\r\n    var tail = {};\r\n    tail.sym = sym;\r\n    tail.next = null;\r\n    /* and append it to the component list */\r\n    if (slice == null)\r\n        slice = tail;\r\n    else\r\n    {  for (temp = slice; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_slice_dimen\r\n    (   mpl,\r\n        slice            /* not changed */\r\n        ){\r\n    var temp;\r\n\r\n    var dim = 0;\r\n    for (temp = slice; temp != null; temp = temp.next) dim++;\r\n    return dim;\r\n}\r\n\r\nfunction mpl_internal_slice_arity\r\n    (   mpl,\r\n        slice            /* not changed */\r\n        ){\r\n    var temp;\r\n\r\n    var arity = 0;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n        if (temp.sym == null) arity++;\r\n    return arity;\r\n}\r\n\r\nfunction mpl_internal_fake_slice(mpl, dim){\r\n    var slice = null;\r\n    while (dim-- > 0) slice = mpl_internal_expand_slice(mpl, slice, null);\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_delete_slice\r\n    (   mpl,\r\n        slice            /* destroyed */\r\n        ){\r\n    var temp;\r\n    while (slice != null)\r\n    {  temp = slice;\r\n        slice = temp.next;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_is_number(mpl){\r\n    return mpl.token == T_NUMBER;\r\n}\r\n\r\nfunction mpl_internal_is_symbol(mpl){\r\n    return mpl.token == T_NUMBER ||\r\n        mpl.token == T_SYMBOL ||\r\n        mpl.token == T_STRING;\r\n}\r\n\r\nfunction mpl_internal_is_literal(mpl, literal){\r\n    return mpl_internal_is_symbol(mpl) && mpl.image == literal;\r\n}\r\n\r\nfunction mpl_internal_read_number(mpl){\r\n    xassert(mpl_internal_is_number(mpl));\r\n    var num = mpl.value;\r\n    mpl_internal_get_token(mpl /* <number> */);\r\n    return num;\r\n}\r\n\r\nfunction mpl_internal_read_symbol(mpl){\r\n    var sym;\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    if (mpl_internal_is_number(mpl))\r\n        sym = mpl_internal_create_symbol_num(mpl, mpl.value);\r\n    else\r\n        sym = mpl_internal_create_symbol_str(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbol> */);\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_read_slice(mpl, name, dim){\r\n    var slice;\r\n    var close;\r\n    xassert(name != null);\r\n    switch (mpl.token)\r\n    {  case T_LBRACKET:\r\n        close = T_RBRACKET;\r\n        break;\r\n        case T_LEFT:\r\n            xassert(dim > 0);\r\n            close = T_RIGHT;\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    if (dim == 0)\r\n        mpl_internal_error(mpl, name + \" cannot be subscripted\");\r\n    mpl_internal_get_token(mpl /* ( | [ */);\r\n    /* read slice components */\r\n    slice = null;\r\n    for (;;)\r\n    {  /* the current token must be a symbol or asterisk */\r\n        if (mpl_internal_is_symbol(mpl))\r\n            slice = mpl_internal_expand_slice(mpl, slice, mpl_internal_read_symbol(mpl));\r\n        else if (mpl.token == T_ASTERISK)\r\n        {  slice = mpl_internal_expand_slice(mpl, slice, null);\r\n            mpl_internal_get_token(mpl /* * */);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"number, symbol, or asterisk missing where expected\");\r\n        /* check a token that follows the symbol */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == close)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in slice\");\r\n    }\r\n    /* number of slice components must be the same as the appropriate\r\n     dimension */\r\n    if (mpl_internal_slice_dimen(mpl, slice) != dim)\r\n    {  switch (close)\r\n    {  case T_RBRACKET:\r\n            mpl_internal_error(mpl, name + \" must have \" + dim +\r\n                \" subscript\" + (dim == 1 ? \"\" : \"s\") + \", not \" + mpl_internal_slice_dimen(mpl, slice));\r\n            break;\r\n        case T_RIGHT:\r\n            mpl_internal_error(mpl, name + \" has dimension \" + dim + \", not \" + mpl_internal_slice_dimen(mpl, slice));\r\n            break;\r\n        default:\r\n            xassert(close != close);\r\n    }\r\n    }\r\n    mpl_internal_get_token(mpl /* ) | ] */);\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_select_set\r\n    (   mpl,\r\n        name              /* not changed */\r\n        ){\r\n    var set;\r\n    var node;\r\n    xassert(name != null);\r\n    node = mpl.tree[name];\r\n    if (node == null || node.type != A_SET)\r\n        mpl_internal_error(mpl, name + \" not a set\");\r\n    set = node.link;\r\n    if (set.assign != null || set.gadget != null)\r\n        mpl_internal_error(mpl, name + \" needs no data\");\r\n    set.data = 1;\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_simple_format\r\n    (   mpl,\r\n        set,               /* not changed */\r\n        memb,           /* modified */\r\n        slice            /* not changed */\r\n        ){\r\n    var tuple;\r\n    var temp;\r\n    var sym, with_ = null;\r\n    xassert(set != null);\r\n    xassert(memb != null);\r\n    xassert(slice != null);\r\n    xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(memb.value.set.dim == set.dimen);\r\n    if (mpl_internal_slice_arity(mpl, slice) > 0) xassert(mpl_internal_is_symbol(mpl));\r\n    /* read symbols and construct complete n-tuple */\r\n    tuple = null;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n    {  if (temp.sym == null)\r\n    {  /* substitution is needed; read symbol */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n        {  var lack = mpl_internal_slice_arity(mpl, temp);\r\n            /* with cannot be null due to assertion above */\r\n            xassert(with_ != null);\r\n            if (lack == 1)\r\n                mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n            else\r\n                mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n        }\r\n        sym = mpl_internal_read_symbol(mpl);\r\n        if (with_ == null) with_ = sym;\r\n    }\r\n    else\r\n    {  /* copy symbol from the slice */\r\n        sym = mpl_internal_copy_symbol(mpl, temp.sym);\r\n    }\r\n        /* append the symbol to the n-tuple */\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, sym);\r\n        /* skip optional comma *between* <symbols> */\r\n        if (temp.next != null && mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    /* add constructed n-tuple to elemental set */\r\n    mpl_internal_check_then_add(mpl, memb.value.set, tuple);\r\n}\r\n\r\nfunction mpl_internal_matrix_format\r\n    (   mpl,\r\n        set,               /* not changed */\r\n        memb,           /* modified */\r\n        slice,           /* not changed */\r\n        tr\r\n        ){\r\n    var list, col, temp;\r\n    var tuple;\r\n    var row;\r\n    xassert(set != null);\r\n    xassert(memb != null);\r\n    xassert(slice != null);\r\n    xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(memb.value.set.dim == set.dimen);\r\n    xassert(mpl_internal_slice_arity(mpl, slice) == 2);\r\n    /* read the matrix heading that contains column symbols (there\r\n     may be no columns at all) */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* read column symbol and append it to the column list */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number, symbol, or := missing where expected\");\r\n        list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));\r\n    }\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* read zero or more rows that contain matrix data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read row symbol (if the matrix has no columns, row symbols\r\n     are just ignored) */\r\n        row = mpl_internal_read_symbol(mpl);\r\n        /* read the matrix row accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  var which = 0;\r\n            /* check indicator */\r\n            if (mpl_internal_is_literal(mpl, \"+\")){\r\n\r\n            }\r\n            else if (mpl_internal_is_literal(mpl, \"-\"))\r\n            {  mpl_internal_get_token(mpl /* - */);\r\n                continue;\r\n            }\r\n            else\r\n            {  var lack = mpl_internal_slice_dimen(mpl, col);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n            }\r\n            /* construct complete n-tuple */\r\n            tuple = null;\r\n            for (temp = slice; temp != null; temp = temp.next)\r\n            {  if (temp.sym == null)\r\n            {  /* substitution is needed */\r\n                switch (++which)\r\n                {  case 1:\r\n                    /* substitute in the first null position */\r\n                    tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                        mpl_internal_copy_symbol(mpl, tr ? col.sym : row));\r\n                    break;\r\n                    case 2:\r\n                        /* substitute in the second null position */\r\n                        tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                            mpl_internal_copy_symbol(mpl, tr ? row : col.sym));\r\n                        break;\r\n                    default:\r\n                        xassert(which != which);\r\n                }\r\n            }\r\n            else\r\n            {  /* copy symbol from the slice */\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                    temp.sym));\r\n            }\r\n            }\r\n            xassert(which == 2);\r\n            /* add constructed n-tuple to elemental set */\r\n            mpl_internal_check_then_add(mpl, memb.value.set, tuple);\r\n            mpl_internal_get_token(mpl /* + */);\r\n        }\r\n    }\r\n    /* delete the column list */\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_set_data(mpl){\r\n    var set;\r\n    var tuple;\r\n    var memb;\r\n    var slice;\r\n    var tr = 0;\r\n\r\n    function err1(){mpl_internal_error(mpl, \"slice currently used must specify 2 asterisks, not \" + mpl_internal_slice_arity(mpl, slice))}\r\n    function err2(){mpl_internal_error(mpl, \"transpose indicator (tr) incomplete\")}\r\n    function left(){\r\n        /* left parenthesis begins the \"transpose\" indicator, which\r\n         is followed by data in the matrix format */\r\n        mpl_internal_get_token(mpl /* ( */);\r\n        if (!mpl_internal_is_literal(mpl, \"tr\"))\r\n            err2();\r\n        if (mpl_internal_slice_arity(mpl, slice) != 2) err1();\r\n        mpl_internal_get_token(mpl /* tr */);\r\n        if (mpl.token != T_RIGHT) err2();\r\n        mpl_internal_get_token(mpl /* ) */);\r\n        /* in this case the colon is optional */\r\n        if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n        /* set the \"transpose\" indicator */\r\n        tr = 1;\r\n        /* read elemental set data in the matrix format */\r\n        mpl_internal_matrix_format(mpl, set, memb, slice, tr);\r\n    }\r\n\r\n    xassert(mpl_internal_is_literal(mpl, \"set\"));\r\n    mpl_internal_get_token(mpl /* set */);\r\n    /* symbolic name of set must follows the keyword 'set' */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n        mpl_internal_error(mpl, \"set name missing where expected\");\r\n    /* select the set to saturate it with data */\r\n    set = mpl_internal_select_set(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* read optional subscript list, which identifies member of the\r\n     set to be read */\r\n    tuple = null;\r\n    if (mpl.token == T_LBRACKET)\r\n    {  /* subscript list is specified */\r\n        if (set.dim == 0)\r\n            mpl_internal_error(mpl, set.name + \" cannot be subscripted\");\r\n        mpl_internal_get_token(mpl /* [ */);\r\n        /* read symbols and construct subscript list */\r\n        for (;;)\r\n        {  if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number or symbol missing where expected\");\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RBRACKET)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in subscript list\");\r\n        }\r\n        if (set.dim != mpl_internal_tuple_dimen(mpl, tuple))\r\n            mpl_internal_error(mpl, set.name + \" must have \" + set.dim + \" subscript\" + (set.dim == 1 ? \"\" : \"s\")\r\n                + \" rather than \" + mpl_internal_tuple_dimen(mpl, tuple));\r\n        mpl_internal_get_token(mpl /* ] */);\r\n    }\r\n    else\r\n    {  /* subscript list is not specified */\r\n        if (set.dim != 0)\r\n            mpl_internal_error(mpl, set.name + \" must be subscripted\");\r\n    }\r\n    /* there must be no member with the same subscript list */\r\n    if (mpl_internal_find_member(mpl, set.array, tuple) != null)\r\n        mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" already defined\");\r\n    /* add new member to the set and assign it empty elemental set */\r\n    memb = mpl_internal_add_member(mpl, set.array, tuple);\r\n    memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);\r\n    /* create an initial fake slice of all asterisks */\r\n    slice = mpl_internal_fake_slice(mpl, set.dimen);\r\n    /* read zero or more data assignments */\r\n    for (;;)\r\n    {  /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* process assignment element */\r\n        if (mpl.token == T_ASSIGN)\r\n        {  /* assignment ligature is non-significant element */\r\n            mpl_internal_get_token(mpl /* := */);\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* left parenthesis begins either new slice or \"transpose\"\r\n         indicator */\r\n            var is_tr;\r\n            mpl_internal_get_token(mpl /* ( */);\r\n            is_tr = mpl_internal_is_literal(mpl, \"tr\");\r\n            mpl_internal_unget_token(mpl /* ( */);\r\n            if (is_tr) {\r\n                left();\r\n            } else {\r\n                /* delete the current slice and read new one */\r\n                mpl_internal_delete_slice(mpl, slice);\r\n                slice = mpl_internal_read_slice(mpl, set.name, set.dimen);\r\n                /* each new slice resets the \"transpose\" indicator */\r\n                tr = 0;\r\n                /* if the new slice is 0-ary, formally there is one 0-tuple\r\n                 (in the simple format) that follows it */\r\n                if (mpl_internal_slice_arity(mpl, slice) == 0)\r\n                    mpl_internal_simple_format(mpl, set, memb, slice);\r\n            }\r\n        }\r\n        else if (mpl_internal_is_symbol(mpl))\r\n        {  /* number or symbol begins data in the simple format */\r\n            mpl_internal_simple_format(mpl, set, memb, slice);\r\n        }\r\n        else if (mpl.token == T_COLON)\r\n        {  /* colon begins data in the matrix format */\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2)\r\n                err1();\r\n            mpl_internal_get_token(mpl /* : */);\r\n            /* read elemental set data in the matrix format */\r\n            mpl_internal_matrix_format(mpl, set, memb, slice, tr);\r\n        }\r\n        else if (mpl.token == T_LEFT){\r\n            left();\r\n        }\r\n        else if (mpl.token == T_SEMICOLON)\r\n        {  /* semicolon terminates the data block */\r\n            mpl_internal_get_token(mpl /* ; */);\r\n            break;\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in set data block\");\r\n    }\r\n    /* delete the current slice */\r\n    mpl_internal_delete_slice(mpl, slice);\r\n}\r\n\r\nfunction mpl_internal_select_parameter(\r\n    mpl,\r\n    name              /* not changed */\r\n    ){\r\n    var par;\r\n    var node;\r\n    xassert(name != null);\r\n    node = mpl.tree[name];\r\n    if (node == null || node.type != A_PARAMETER)\r\n        mpl_internal_error(mpl, name + \" not a parameter\");\r\n    par = node.link;\r\n    if (par.assign != null)\r\n        mpl_internal_error(mpl, name + \" needs no data\");\r\n    if (par.data)\r\n        mpl_internal_error(mpl, name + \" already provided with data\");\r\n    par.data = 1;\r\n    return par;\r\n}\r\n\r\nfunction mpl_internal_set_default(\r\n    mpl,\r\n    par,         /* not changed */\r\n    altval          /* destroyed */\r\n    ){\r\n    xassert(par != null);\r\n    xassert(altval != null);\r\n    if (par.option != null)\r\n        mpl_internal_error(mpl, \"default value for \" + par.name + \" already specified in model section\");\r\n    xassert(par.defval == null);\r\n    par.defval = altval;\r\n}\r\n\r\nfunction mpl_internal_read_value\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        tuple            /* destroyed */\r\n        ){\r\n    var memb;\r\n    xassert(par != null);\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    /* there must be no member with the same n-tuple */\r\n    if (mpl_internal_find_member(mpl, par.array, tuple) != null)\r\n        mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" already defined\");\r\n    /* create new parameter member with given n-tuple */\r\n    memb = mpl_internal_add_member(mpl, par.array, tuple);\r\n    /* read value and assigns it to the new parameter member */\r\n    switch (par.type)\r\n    {  case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            if (!mpl_internal_is_number(mpl))\r\n                mpl_internal_error(mpl, par.name + \" requires numeric data\");\r\n            memb.value.num = mpl_internal_read_number(mpl);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            memb.value.sym = mpl_internal_read_symbol(mpl);\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_plain_format\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        slice            /* not changed */\r\n        )\r\n{\r\n    var tuple;\r\n    var temp;\r\n    var sym, with_ = null;\r\n    xassert(par != null);\r\n    xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    /* read symbols and construct complete subscript list */\r\n    tuple = null;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n    {  if (temp.sym == null)\r\n    {  /* substitution is needed; read symbol */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n        {   var lack = mpl_internal_slice_arity(mpl, temp) + 1;\r\n            xassert(with_ != null);\r\n            xassert(lack > 1);\r\n            mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n        }\r\n        sym = mpl_internal_read_symbol(mpl);\r\n        if (with_ == null) with_ = sym;\r\n    }\r\n    else\r\n    {  /* copy symbol from the slice */\r\n        sym = mpl_internal_copy_symbol(mpl, temp.sym);\r\n    }\r\n        /* append the symbol to the subscript list */\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, sym);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    /* read value and assign it to new parameter member */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n    {  xassert(with_ != null);\r\n        mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n    }\r\n    mpl_internal_read_value(mpl, par, tuple);\r\n}\r\n\r\nfunction mpl_internal_tabular_format\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        slice,           /* not changed */\r\n        tr\r\n        ){\r\n    var list, col, temp;\r\n    var tuple;\r\n    var row;\r\n    xassert(par != null);\r\n    xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(mpl_internal_slice_arity(mpl, slice) == 2);\r\n    /* read the table heading that contains column symbols (the table\r\n     may have no columns) */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* read column symbol and append it to the column list */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number, symbol, or := missing where expected\");\r\n        list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));\r\n    }\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* read zero or more rows that contain tabular data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read row symbol (if the table has no columns, these symbols\r\n     are just ignored) */\r\n        row = mpl_internal_read_symbol(mpl);\r\n        /* read values accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  var which = 0;\r\n            /* if the token is single point, no value is provided */\r\n            if (mpl_internal_is_literal(mpl, \".\"))\r\n            {  mpl_internal_get_token(mpl /* . */);\r\n                continue;\r\n            }\r\n            /* construct complete subscript list */\r\n            tuple = null;\r\n            for (temp = slice; temp != null; temp = temp.next)\r\n            {  if (temp.sym == null)\r\n            {  /* substitution is needed */\r\n                switch (++which)\r\n                {  case 1:\r\n                    /* substitute in the first null position */\r\n                    tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                        mpl_internal_copy_symbol(mpl, tr ? col.sym : row));\r\n                    break;\r\n                    case 2:\r\n                        /* substitute in the second null position */\r\n                        tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                            mpl_internal_copy_symbol(mpl, tr ? row : col.sym));\r\n                        break;\r\n                    default:\r\n                        xassert(which != which);\r\n                }\r\n            }\r\n            else\r\n            {  /* copy symbol from the slice */\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                    temp.sym));\r\n            }\r\n            }\r\n            xassert(which == 2);\r\n            /* read value and assign it to new parameter member */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {  var lack = mpl_internal_slice_dimen(mpl, col);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n            }\r\n            mpl_internal_read_value(mpl, par, tuple);\r\n        }\r\n    }\r\n    /* delete the column list */\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_tabbing_format\r\n    (   mpl,\r\n        altval          /* not changed */\r\n        ){\r\n    var set = null;\r\n    var par;\r\n    var list, col;\r\n    var tuple;\r\n    var next_token, j, dim = 0;\r\n    var last_name = null;\r\n    /* read the optional <prefix> */\r\n    if (mpl_internal_is_symbol(mpl))\r\n    {  mpl_internal_get_token(mpl /* <symbol> */);\r\n        next_token = mpl.token;\r\n        mpl_internal_unget_token(mpl /* <symbol> */);\r\n        if (next_token == T_COLON)\r\n        {  /* select the set to saturate it with data */\r\n            set = mpl_internal_select_set(mpl, mpl.image);\r\n            /* the set must be simple (i.e. not set of sets) */\r\n            if (set.dim != 0)\r\n                mpl_internal_error(mpl, set.name + \" must be a simple set\");\r\n            /* and must not be defined yet */\r\n            if (set.array.head != null)\r\n                mpl_internal_error(mpl, set.name + \" already defined\");\r\n            /* add new (the only) member to the set and assign it empty\r\n             elemental set */\r\n            mpl_internal_add_member(mpl, set.array, null).value.set =\r\n                mpl_internal_create_elemset(mpl, set.dimen);\r\n            last_name = set.name; dim = set.dimen;\r\n            mpl_internal_get_token(mpl /* <symbol> */);\r\n            xassert(mpl.token == T_COLON);\r\n            mpl_internal_get_token(mpl /* : */);\r\n        }\r\n    }\r\n    /* read the table heading that contains parameter names */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* there must be symbolic name of parameter */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"parameter name or := missing where expected\");\r\n        /* select the parameter to saturate it with data */\r\n        par = mpl_internal_select_parameter(mpl, mpl.image);\r\n        /* the parameter must be subscripted */\r\n        if (par.dim == 0)\r\n            mpl_internal_error(mpl, mpl.image + \" not a subscripted parameter\");\r\n        /* the set (if specified) and all the parameters in the data\r\n         block must have identical dimension */\r\n        if (dim != 0 && par.dim != dim)\r\n        {  xassert(last_name != null);\r\n            mpl_internal_error(mpl, last_name + \" has dimension \" + dim + \" while \" + par.name + \" has dimension \" + par.dim);\r\n        }\r\n        /* set default value for the parameter (if specified) */\r\n        if (altval != null)\r\n            mpl_internal_set_default(mpl, par, mpl_internal_copy_symbol(mpl, altval));\r\n        /* append the parameter to the column list */\r\n        list = mpl_internal_expand_slice(mpl, list, par);\r\n        last_name = par.name; dim = par.dim;\r\n        mpl_internal_get_token(mpl /* <symbol> */);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    if (mpl_internal_slice_dimen(mpl, list) == 0)\r\n        mpl_internal_error(mpl, \"at least one parameter name required\");\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* skip optional comma */\r\n    if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    /* read rows that contain tabbing data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read subscript list */\r\n        var lack;\r\n        tuple = null;\r\n        for (j = 1; j <= dim; j++)\r\n        {  /* read j-th subscript */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {   lack = mpl_internal_slice_dimen(mpl, list) + dim - j + 1;\r\n                xassert(tuple != null);\r\n                xassert(lack > 1);\r\n                mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n            }\r\n            /* read and append j-th subscript to the n-tuple */\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));\r\n            /* skip optional comma *between* <symbols> */\r\n            if (j < dim && mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n        }\r\n        /* if the set is specified, add to it new n-tuple, which is a\r\n         copy of the subscript list just read */\r\n        if (set != null)\r\n            mpl_internal_check_then_add(mpl, set.array.head.value.set, mpl_internal_copy_tuple(mpl, tuple));\r\n        /* skip optional comma between <symbol> and <value> */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* read values accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  /* if the token is single point, no value is provided */\r\n            if (mpl_internal_is_literal(mpl, \".\"))\r\n            {  mpl_internal_get_token(mpl /* . */);\r\n                continue;\r\n            }\r\n            /* read value and assign it to new parameter member */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {   lack = mpl_internal_slice_dimen(mpl, col);\r\n                xassert(tuple != null);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n            }\r\n            mpl_internal_read_value(mpl, col.sym, mpl_internal_copy_tuple(mpl, tuple));\r\n            /* skip optional comma preceding the next value */\r\n            if (col.next != null && mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n        }\r\n        /* skip optional comma (only if there is next data group) */\r\n        if (mpl.token == T_COMMA)\r\n        {  mpl_internal_get_token(mpl /* , */);\r\n            if (!mpl_internal_is_symbol(mpl)) mpl_internal_unget_token(mpl /* , */);\r\n        }\r\n    }\r\n    /* delete the column list (it contains parameters, not symbols,\r\n     so nullify it before) */\r\n    for (col = list; col != null; col = col.next) col.sym = null;\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_parameter_data(mpl){\r\n    var par;\r\n    var altval = null;\r\n    var slice;\r\n    var tr = 0;\r\n    xassert(mpl_internal_is_literal(mpl, \"param\"));\r\n    mpl_internal_get_token(mpl /* param */);\r\n    /* read optional default value */\r\n    if (mpl_internal_is_literal(mpl, \"default\"))\r\n    {  mpl_internal_get_token(mpl /* default */);\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"default value missing where expected\");\r\n        altval = mpl_internal_read_symbol(mpl);\r\n        /* if the default value follows the keyword 'param', the next\r\n         token must be only the colon */\r\n        if (mpl.token != T_COLON)\r\n            mpl_internal_error(mpl, \"colon missing where expected\");\r\n    }\r\n    /* being used after the keyword 'param' or the optional default\r\n     value the colon begins data in the tabbing format */\r\n    if (mpl.token == T_COLON)\r\n    {  mpl_internal_get_token(mpl /* : */);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* read parameter data in the tabbing format */\r\n        mpl_internal_tabbing_format(mpl, altval);\r\n        /* the next token must be only semicolon */\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"symbol, number, or semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n        return;\r\n    }\r\n    /* in other cases there must be symbolic name of parameter, which\r\n     follows the keyword 'param' */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n        mpl_internal_error(mpl, \"parameter name missing where expected\");\r\n    /* select the parameter to saturate it with data */\r\n    par = mpl_internal_select_parameter(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbol> */);\r\n    /* read optional default value */\r\n    if (mpl_internal_is_literal(mpl, \"default\"))\r\n    {  mpl_internal_get_token(mpl /* default */);\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"default value missing where expected\");\r\n        altval = mpl_internal_read_symbol(mpl);\r\n        /* set default value for the parameter */\r\n        mpl_internal_set_default(mpl, par, altval);\r\n    }\r\n    /* create initial fake slice of all asterisks */\r\n    slice = mpl_internal_fake_slice(mpl, par.dim);\r\n    /* read zero or more data assignments */\r\n\r\n    function err1(){mpl_internal_error(mpl, par.name + \" not a subscripted parameter\")}\r\n    function err2(){mpl_internal_error(mpl, \"slice currently used must specify 2 asterisks, not \" + mpl_internal_slice_arity(mpl, slice))}\r\n    function err3(){mpl_internal_error(mpl, \"transpose indicator (tr) incomplete\")}\r\n\r\n    for (;;)\r\n    {  /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* process current assignment */\r\n        if (mpl.token == T_ASSIGN)\r\n        {  /* assignment ligature is non-significant element */\r\n            mpl_internal_get_token(mpl /* := */);\r\n        }\r\n        else if (mpl.token == T_LBRACKET)\r\n        {  /* left bracket begins new slice; delete the current slice\r\n         and read new one */\r\n            mpl_internal_delete_slice(mpl, slice);\r\n            slice = mpl_internal_read_slice(mpl, par.name, par.dim);\r\n            /* each new slice resets the \"transpose\" indicator */\r\n            tr = 0;\r\n        }\r\n        else if (mpl_internal_is_symbol(mpl))\r\n        {  /* number or symbol begins data in the plain format */\r\n            mpl_internal_plain_format(mpl, par, slice);\r\n        }\r\n        else if (mpl.token == T_COLON)\r\n        {  /* colon begins data in the tabular format */\r\n            if (par.dim == 0)\r\n                err1();\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2)\r\n                err2();\r\n            mpl_internal_get_token(mpl /* : */);\r\n            /* read parameter data in the tabular format */\r\n            mpl_internal_tabular_format(mpl, par, slice, tr);\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* left parenthesis begins the \"transpose\" indicator, which\r\n         is followed by data in the tabular format */\r\n            mpl_internal_get_token(mpl /* ( */);\r\n            if (!mpl_internal_is_literal(mpl, \"tr\"))\r\n                err3();\r\n            if (par.dim == 0) err1();\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2) err2();\r\n            mpl_internal_get_token(mpl /* tr */);\r\n            if (mpl.token != T_RIGHT) err3();\r\n            mpl_internal_get_token(mpl /* ) */);\r\n            /* in this case the colon is optional */\r\n            if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n            /* set the \"transpose\" indicator */\r\n            tr = 1;\r\n            /* read parameter data in the tabular format */\r\n            mpl_internal_tabular_format(mpl, par, slice, tr);\r\n        }\r\n        else if (mpl.token == T_SEMICOLON)\r\n        {  /* semicolon terminates the data block */\r\n            mpl_internal_get_token(mpl /* ; */);\r\n            break;\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in parameter data block\");\r\n    }\r\n    /* delete the current slice */\r\n    mpl_internal_delete_slice(mpl, slice);\r\n}\r\n\r\nfunction mpl_internal_data_section(mpl){\r\n    while (!(mpl.token == T_EOF || mpl_internal_is_literal(mpl, \"end\")))\r\n    {   if (mpl_internal_is_literal(mpl, \"set\"))\r\n        mpl_internal_set_data(mpl);\r\n    else if (mpl_internal_is_literal(mpl, \"param\"))\r\n        mpl_internal_parameter_data(mpl);\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in data section\");\r\n    }\r\n}\r\n\r\n/* glpmpl03.c */\r\n\r\n/**********************************************************************/\r\n/* * *                   FLOATING-POINT NUMBERS                   * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_fp_add(mpl, x, y){\r\n    if (x > 0.0 && y > 0.0 && x > + 0.999 * DBL_MAX - y ||\r\n        x < 0.0 && y < 0.0 && x < - 0.999 * DBL_MAX - y)\r\n        mpl_internal_error(mpl, x + \" + \" + y + \"; floating-point overflow\");\r\n    return x + y;\r\n}\r\n\r\nfunction mpl_internal_fp_sub(mpl, x, y){\r\n    if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y ||\r\n        x < 0.0 && y > 0.0 && x < - 0.999 * DBL_MAX + y)\r\n        mpl_internal_error(mpl, x + \" - \" + y + \"; floating-point overflow\");\r\n    return x - y;\r\n}\r\n\r\nfunction mpl_internal_fp_less(mpl, x, y){\r\n    if (x < y) return 0.0;\r\n    if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y)\r\n        mpl_internal_error(mpl, x+ \" less \" + y + \"; floating-point overflow\");\r\n    return x - y;\r\n}\r\n\r\nfunction mpl_internal_fp_mul(mpl, x, y){\r\n    if (Math.abs(y) > 1.0 && Math.abs(x) > (0.999 * DBL_MAX) / Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" * \" + y + \"; floating-point overflow\");\r\n    return x * y;\r\n}\r\n\r\nfunction mpl_internal_fp_div(mpl, x, y){\r\n    if (Math.abs(y) < DBL_MIN)\r\n        mpl_internal_error(mpl, x + \" / \" + y + \"; floating-point zero divide\");\r\n    if (Math.abs(y) < 1.0 && Math.abs(x) > (0.999 * DBL_MAX) * Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" / \" + y + \"; floating-point overflow\");\r\n    return x / y;\r\n}\r\n\r\nfunction mpl_internal_fp_idiv(mpl, x, y){\r\n    if (Math.abs(y) < DBL_MIN)\r\n        mpl_internal_error(mpl, x + \" div \" + y + \"; floating-point zero divide\");\r\n    if (Math.abs(y) < 1.0 && Math.abs(x) > (0.999 * DBL_MAX) * Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" div \" + y + \"; floating-point overflow\");\r\n    x /= y;\r\n    return x > 0.0 ? Math.floor(x) : x < 0.0 ? Math.ceil(x) : 0.0;\r\n}\r\n\r\nfunction mpl_internal_fp_mod(mpl, x, y)\r\n{\r\n    var r;\r\n\r\n    if (x == 0.0)\r\n        r = 0.0;\r\n    else if (y == 0.0)\r\n        r = x;\r\n    else\r\n    {  r = Math.abs(x) % Math.abs(y);\r\n        if (r != 0.0)\r\n        {  if (x < 0.0) r = - r;\r\n            if (x > 0.0 && y < 0.0 || x < 0.0 && y > 0.0) r += y;\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction mpl_internal_fp_power(mpl, x, y)\r\n{\r\n    var r;\r\n    if (x == 0.0 && y <= 0.0 || x < 0.0 && y != Math.floor(y))\r\n        mpl_internal_error(mpl, x + \" ** \" + y + \"; result undefined\");\r\n    if (x == 0.0) {\r\n        r = Math.pow(x, y);\r\n    } else {\r\n        if (Math.abs(x) > 1.0 && y > +1.0 &&\r\n            +Math.log(Math.abs(x)) > (0.999 * Math.log(DBL_MAX)) / y ||\r\n            Math.abs(x) < 1.0 && y < -1.0 &&\r\n                +Math.log(Math.abs(x)) < (0.999 * Math.log(DBL_MAX)) / y)\r\n            mpl_internal_error(mpl, x + \" ** \" + y + \"; floating-point overflow\");\r\n        if (Math.abs(x) > 1.0 && y < -1.0 &&\r\n            -Math.log(Math.abs(x)) < (0.999 * Math.log(DBL_MAX)) / y ||\r\n            Math.abs(x) < 1.0 && y > +1.0 &&\r\n                -Math.log(Math.abs(x)) > (0.999 * Math.log(DBL_MAX)) / y)\r\n            r = 0.0;\r\n        else\r\n            r = Math.pow(x, y);\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction mpl_internal_fp_exp(mpl, x)\r\n{\r\n    if (x > 0.999 * Math.log(DBL_MAX))\r\n        mpl_internal_error(mpl, \"exp(\" + x + \"); floating-point overflow\");\r\n    return Math.exp(x);\r\n}\r\n\r\nfunction mpl_internal_fp_log(mpl, x)\r\n{     if (x <= 0.0)\r\n    mpl_internal_error(mpl, \"log(\" + x + \"); non-positive argument\");\r\n    return Math.log(x);\r\n}\r\n\r\nfunction mpl_internal_fp_log10(mpl, x)\r\n{\r\n    if (x <= 0.0)\r\n        mpl_internal_error(mpl, \"log10(\" + x + \"); non-positive argument\");\r\n    return Math.log(x) / Math.LN10;\r\n}\r\n\r\nfunction mpl_internal_fp_sqrt(mpl, x)\r\n{\r\n    if (x < 0.0)\r\n        mpl_internal_error(mpl, \"sqrt(\" + x + \"); negative argument\");\r\n    return Math.sqrt(x);\r\n}\r\n\r\nfunction mpl_internal_fp_sin(mpl, x)\r\n{\r\n    if (!(-1e6 <= x && x <= +1e6))\r\n        mpl_internal_error(mpl, \"sin(\" + x + \"); argument too large\");\r\n    return Math.sin(x);\r\n}\r\n\r\nfunction mpl_internal_fp_cos(mpl, x)\r\n{\r\n    if (!(-1e6 <= x && x <= +1e6))\r\n        mpl_internal_error(mpl, \"cos(\" + x + \"); argument too large\");\r\n    return Math.cos(x);\r\n}\r\n\r\nfunction mpl_internal_fp_atan(mpl, x)\r\n{\r\n\r\n    return Math.atan(x);\r\n}\r\n\r\nfunction mpl_internal_fp_atan2(mpl, y, x)\r\n{\r\n\r\n    return Math.atan2(y, x);\r\n}\r\n\r\nfunction mpl_internal_fp_round(mpl, x, n)\r\n{     var ten_to_n;\r\n    if (n != Math.floor(n))\r\n        mpl_internal_error(mpl, \"round(\" + x + \", \" + n + \"); non-integer second argument\");\r\n    if (n <= DBL_DIG + 2)\r\n    {  ten_to_n = Math.pow(10.0, n);\r\n        if (Math.abs(x) < (0.999 * DBL_MAX) / ten_to_n)\r\n        {  x = Math.floor(x * ten_to_n + 0.5);\r\n            if (x != 0.0) x /= ten_to_n;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_fp_trunc(mpl, x, n)\r\n{     var ten_to_n;\r\n    if (n != Math.floor(n))\r\n        mpl_internal_error(mpl, \"trunc(\" + x + \", \" + n + \"); non-integer second argument\");\r\n    if (n <= DBL_DIG + 2)\r\n    {  ten_to_n = Math.pow(10.0, n);\r\n        if (Math.abs(x) < (0.999 * DBL_MAX) / ten_to_n)\r\n        {  x = (x >= 0.0 ? Math.floor(x * ten_to_n) : Math.ceil(x * ten_to_n));\r\n            if (x != 0.0) x /= ten_to_n;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *              PSEUDO-RANDOM NUMBER GENERATORS               * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_fp_irand224(mpl)\r\n{\r\n    var two_to_the_24 = 0x1000000;\r\n    return rng_unif_rand(mpl.rand, two_to_the_24);\r\n}\r\n\r\nfunction mpl_internal_fp_uniform01(mpl)\r\n{\r\n    var two_to_the_31 = 0x80000000;\r\n    return rng_next_rand(mpl.rand) / two_to_the_31;\r\n}\r\n\r\nfunction mpl_internal_fp_uniform(mpl, a, b){\r\n    var x;\r\n    if (a >= b)\r\n        mpl_internal_error(mpl, \"Uniform(\" + a + \", \" + b + \"); invalid range\");\r\n    x = mpl_internal_fp_uniform01(mpl);\r\n    x = mpl_internal_fp_add(mpl, a * (1.0 - x), b * x);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_fp_normal01(mpl){\r\n    var x, y, r2;\r\n    do\r\n    {  /* choose x, y in uniform square (-1,-1) to (+1,+1) */\r\n        x = -1.0 + 2.0 * mpl_internal_fp_uniform01(mpl);\r\n        y = -1.0 + 2.0 * mpl_internal_fp_uniform01(mpl);\r\n        /* see if it is in the unit circle */\r\n        r2 = x * x + y * y;\r\n    } while (r2 > 1.0 || r2 == 0.0);\r\n    /* Box-Muller transform */\r\n    return y * Math.sqrt(-2.0 * Math.log(r2) / r2);\r\n}\r\n\r\nfunction mpl_internal_fp_normal(mpl, mu, sigma){\r\n    return mpl_internal_fp_add(mpl, mu, mpl_internal_fp_mul(mpl, sigma, mpl_internal_fp_normal01(mpl)));\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                SEGMENTED CHARACTER STRINGS                 * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_compare_strings(mpl, str1, str2)\r\n{\r\n    if (str1 == str2)\r\n        return 0;\r\n    else if (str1 > str2)\r\n        return 1;\r\n    else\r\n        return -1;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                          SYMBOLS                           * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_symbol_num(mpl, num){\r\n    var sym = {};\r\n    sym.num = num;\r\n    sym.str = null;\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_create_symbol_str(mpl, str){\r\n    xassert(str != null);\r\n    var sym = {};\r\n    sym.num = 0.0;\r\n    sym.str = str;\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_copy_symbol(mpl, sym){\r\n    xassert(sym != null);\r\n    var copy = {};\r\n    if (sym.str == null)\r\n    {  copy.num = sym.num;\r\n        copy.str = null;\r\n    }\r\n    else\r\n    {  copy.num = 0.0;\r\n        copy.str = sym.str;\r\n    }\r\n    return copy;\r\n}\r\n\r\nfunction mpl_internal_compare_symbols(mpl, sym1, sym2){\r\n    xassert(sym1 != null);\r\n    xassert(sym2 != null);\r\n    /* let all numeric quantities precede all symbolic quantities */\r\n    if (sym1.str == null && sym2.str == null)\r\n    {  if (sym1.num < sym2.num) return -1;\r\n        if (sym1.num > sym2.num) return +1;\r\n        return 0;\r\n    }\r\n    if (sym1.str == null) return -1;\r\n    if (sym2.str == null) return +1;\r\n    return mpl_internal_compare_strings(mpl, sym1.str, sym2.str);\r\n}\r\n\r\nfunction mpl_internal_format_symbol(mpl, sym){\r\n    xassert(sym != null);\r\n    var buf;\r\n    if (sym.str == null)\r\n        buf = String(sym.num);\r\n    else\r\n    {\r\n        var quoted, j, len;\r\n        var str = sym.str;\r\n        if (!(isalpha(str[0]) || str[0] == '_'))\r\n            quoted = true;\r\n        else\r\n        {   quoted = false;\r\n            for (j = 1; j < str.length; j++)\r\n            {   if (!(isalnum(str[j]) || strchr(\"+-._\", str[j]) >= 0))\r\n            {   quoted = true;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n\r\n        buf = ''; len = 0;\r\n        function safe_append(c){if (len < 255) {buf += c; len++}}\r\n\r\n        if (quoted) safe_append('\\'');\r\n        for (j = 0; j < str.length; j++)\r\n        {  if (quoted && str[j] == '\\'') safe_append('\\'');\r\n            safe_append(str[j]);\r\n        }\r\n        if (quoted) safe_append('\\'');\r\n        if (len == 255) buf = buf.slice(0, 252) + \"...\";\r\n    }\r\n    xassert(buf.length <= 255);\r\n    return buf;\r\n}\r\n\r\nfunction mpl_internal_concat_symbols\r\n    (   mpl,\r\n        sym1,           /* destroyed */\r\n        sym2            /* destroyed */\r\n        ){\r\n    var str1, str2;\r\n    //xassert(MAX_LENGTH >= DBL_DIG + DBL_DIG);\r\n\r\n    if (sym1.str == null)\r\n        str1 = String(sym1.num);\r\n    else\r\n        str1 = sym1.str;\r\n\r\n    if (sym2.str == null)\r\n        str2 = String(sym2.num);\r\n    else\r\n        str2 = sym2.str;\r\n/*\r\n    if (str1.length + str2.length > MAX_LENGTH)\r\n    {   var buf = mpl_internal_format_symbol(mpl, sym1);\r\n        xassert(buf.length < MAX_LENGTH);\r\n        mpl_internal_error(mpl, buf + \" & \" + mpl_internal_format_symbol(mpl, sym2) + \"; resultant symbol exceeds \" + MAX_LENGTH + \" characters\");\r\n    }\r\n*/\r\n    return mpl_internal_create_symbol_str(mpl, str1 + str2);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                          N-TUPLES                          * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_expand_tuple(mpl, tuple, sym){\r\n    var temp;\r\n    xassert(sym != null);\r\n    /* create a new component */\r\n    var tail = {};\r\n    tail.sym = sym;\r\n    tail.next = null;\r\n    /* and append it to the component list */\r\n    if (tuple == null)\r\n        tuple = tail;\r\n    else\r\n    {  for (temp = tuple; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return tuple;\r\n}\r\n\r\nfunction mpl_internal_tuple_dimen(mpl, tuple){\r\n    var dim = 0;\r\n    for (var temp = tuple; temp != null; temp = temp.next) dim++;\r\n    return dim;\r\n}\r\n\r\nfunction mpl_internal_copy_tuple(mpl, tuple){\r\n    var head, tail;\r\n    if (tuple == null)\r\n        head = null;\r\n    else\r\n    {   head = tail = {};\r\n        for (; tuple != null; tuple = tuple.next)\r\n        {  xassert(tuple.sym != null);\r\n            tail.sym = mpl_internal_copy_symbol(mpl, tuple.sym);\r\n            if (tuple.next != null)\r\n                tail = tail.next = {};\r\n        }\r\n        tail.next = null;\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_compare_tuples(mpl, tuple1, tuple2){\r\n    var item1, item2;\r\n    var ret;\r\n    for (item1 = tuple1, item2 = tuple2; item1 != null;\r\n         item1 = item1.next, item2 = item2.next)\r\n    {  xassert(item2 != null);\r\n        xassert(item1.sym != null);\r\n        xassert(item2.sym != null);\r\n        ret = mpl_internal_compare_symbols(mpl, item1.sym, item2.sym);\r\n        if (ret != 0) return ret;\r\n    }\r\n    xassert(item2 == null);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_build_subtuple(mpl, tuple, dim){\r\n    var head = null;\r\n    for (var j = 1, temp = tuple; j <= dim; j++, temp = temp.next)\r\n    {  xassert(temp != null);\r\n        head = mpl_internal_expand_tuple(mpl, head, mpl_internal_copy_symbol(mpl, temp.sym));\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_format_tuple(mpl, c, tuple){\r\n    var temp;\r\n    var j, len = 0;\r\n    var buf = '', str = '', save;\r\n    function safe_append(c){if (len < 255) buf += c; len++}\r\n    var dim = mpl_internal_tuple_dimen(mpl, tuple);\r\n    if (c == '[' && dim > 0) safe_append('[');\r\n    if (c == '(' && dim > 1) safe_append('(');\r\n    for (temp = tuple; temp != null; temp = temp.next)\r\n    {  if (temp != tuple) safe_append(',');\r\n        xassert(temp.sym != null);\r\n        str = mpl_internal_format_symbol(mpl, temp.sym);\r\n        xassert(str.length <= 255);\r\n        for (j = 0; j < str.length; j++) safe_append(str[j]);\r\n    }\r\n    if (c == '[' && dim > 0) safe_append(']');\r\n    if (c == '(' && dim > 1) safe_append(')');\r\n    if (len == 255) buf = buf.slice(0,252) + \"...\";\r\n    xassert(buf.length <= 255);\r\n    return buf;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                       ELEMENTAL SETS                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_elemset(mpl, dim){\r\n    xassert(dim > 0);\r\n    return mpl_internal_create_array(mpl, A_NONE, dim);\r\n}\r\n\r\nfunction mpl_internal_find_tuple(mpl, set, tuple){\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    return mpl_internal_find_member(mpl, set, tuple);\r\n}\r\n\r\nfunction mpl_internal_add_tuple(mpl, set, tuple){\r\n    var memb;\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    memb = mpl_internal_add_member(mpl, set, tuple);\r\n    memb.value.none = null;\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_check_then_add(mpl, set, tuple){\r\n    if (mpl_internal_find_tuple(mpl, set, tuple) != null)\r\n        mpl_internal_error(mpl, \"duplicate tuple \" + mpl_internal_format_tuple(mpl, '(', tuple) + \" detected\");\r\n    return mpl_internal_add_tuple(mpl, set, tuple);\r\n}\r\n\r\nfunction mpl_internal_copy_elemset(mpl, set){\r\n    var copy;\r\n    var memb;\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim > 0);\r\n    copy = mpl_internal_create_elemset(mpl, set.dim);\r\n    for (memb = set.head; memb != null; memb = memb.next)\r\n        mpl_internal_add_tuple(mpl, copy, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    return copy;\r\n}\r\n\r\nfunction mpl_internal_arelset_size(mpl, t0, tf, dt){\r\n    var temp;\r\n    if (dt == 0.0)\r\n        mpl_internal_error(mpl, t0 + \" .. \" + tf + \" by \" + dt + \"; zero stride not allowed\");\r\n    if (tf > 0.0 && t0 < 0.0 && tf > + 0.999 * DBL_MAX + t0)\r\n        temp = +DBL_MAX;\r\n    else if (tf < 0.0 && t0 > 0.0 && tf < - 0.999 * DBL_MAX + t0)\r\n        temp = -DBL_MAX;\r\n    else\r\n        temp = tf - t0;\r\n    if (Math.abs(dt) < 1.0 && Math.abs(temp) > (0.999 * DBL_MAX) * Math.abs(dt))\r\n    {  if (temp > 0.0 && dt > 0.0 || temp < 0.0 && dt < 0.0)\r\n        temp = +DBL_MAX;\r\n    else\r\n        temp = 0.0;\r\n    }\r\n    else\r\n    {  temp = Math.floor(temp / dt) + 1.0;\r\n        if (temp < 0.0) temp = 0.0;\r\n    }\r\n    xassert(temp >= 0.0);\r\n    if (temp > (INT_MAX - 1))\r\n        mpl_internal_error(mpl, t0 + \" .. \" + tf + \" by \" + dt + \"; set too large\");\r\n    return (temp + 0.5)|0;\r\n}\r\n\r\nfunction mpl_internal_arelset_member(mpl, t0, tf, dt, j){\r\n    xassert(1 <= j && j <= mpl_internal_arelset_size(mpl, t0, tf, dt));\r\n    return t0 + (j - 1) * dt;\r\n}\r\n\r\nfunction mpl_internal_create_arelset(mpl, t0, tf, dt){\r\n    var set = mpl_internal_create_elemset(mpl, 1);\r\n    var n = mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n    for (var j = 1; j <= n; j++)\r\n    {\r\n        mpl_internal_add_tuple(mpl, set,\r\n            mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_create_symbol_num(mpl,\r\n                    mpl_internal_arelset_member(mpl, t0, tf, dt, j))));\r\n    }\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_set_union(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    for (var memb = Y.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, X, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return X;\r\n}\r\n\r\nfunction mpl_internal_set_diff(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (var memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_symdiff(mpl, X, Y){\r\n    var memb;\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    /* Z := X \\ Y */\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    /* Z := Z U (Y \\ X) */\r\n    for (memb = Y.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_inter(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (var memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) != null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_cross(mpl, X, Y){\r\n    var memx, memy;\r\n    var tuple, temp;\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim + Y.dim);\r\n    for (memx = X.head; memx != null; memx = memx.next)\r\n    {  for (memy = Y.head; memy != null; memy = memy.next)\r\n    {  tuple = mpl_internal_copy_tuple(mpl, memx.tuple);\r\n        for (temp = memy.tuple; temp != null; temp = temp.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                temp.sym));\r\n        mpl_internal_add_tuple(mpl, Z, tuple);\r\n    }\r\n    }\r\n    return Z;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        LINEAR FORMS                        * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_constant_term(mpl, coef){\r\n    var form;\r\n    if (coef == 0.0)\r\n        form = null;\r\n    else\r\n    {   form = {};\r\n        form.coef = coef;\r\n        form.var_ = null;\r\n        form.next = null;\r\n    }\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_single_variable(mpl, var_){\r\n    xassert(var_ != null);\r\n    var form = {};\r\n    form.coef = 1.0;\r\n    form.var_ = var_;\r\n    form.next = null;\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_copy_formula(mpl, form){\r\n    var head, tail;\r\n    if (form == null)\r\n        head = null;\r\n    else\r\n    {  head = tail = {};\r\n        for (; form != null; form = form.next)\r\n        {  tail.coef = form.coef;\r\n            tail.var_ = form.var_;\r\n            if (form.next != null)\r\n                tail = tail.next = {};\r\n        }\r\n        tail.next = null;\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_linear_comb(mpl, a, fx, b, fy){\r\n    var form = null, term, temp;\r\n    var c0 = 0.0;\r\n    for (term = fx; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, a, term.coef));\r\n    else\r\n        term.var_.temp =\r\n            mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, a, term.coef));\r\n    }\r\n    for (term = fy; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, b, term.coef));\r\n    else\r\n        term.var_.temp =\r\n            mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, b, term.coef));\r\n    }\r\n    for (term = fx; term != null; term = term.next)\r\n    {  if (term.var_ != null && term.var_.temp != 0.0)\r\n    {  temp = {};\r\n        temp.coef = term.var_.temp; temp.var_ = term.var_;\r\n        temp.next = form; form = temp;\r\n        term.var_.temp = 0.0;\r\n    }\r\n    }\r\n    for (term = fy; term != null; term = term.next)\r\n    {  if (term.var_ != null && term.var_.temp != 0.0)\r\n    {  temp = {};\r\n        temp.coef = term.var_.temp; temp.var_ = term.var_;\r\n        temp.next = form; form = temp;\r\n        term.var_.temp = 0.0;\r\n    }\r\n    }\r\n    if (c0 != 0.0)\r\n    {  temp = {};\r\n        temp.coef = c0; temp.var_ = null;\r\n        temp.next = form; form = temp;\r\n    }\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_remove_constant(mpl, form, callback){\r\n    var head = null, temp;\r\n    var coef = 0.0;\r\n    while (form != null)\r\n    {  temp = form;\r\n        form = form.next;\r\n        if (temp.var_ == null)\r\n        {  /* constant term */\r\n            coef = mpl_internal_fp_add(mpl, coef, temp.coef);\r\n        }\r\n        else\r\n        {  /* linear term */\r\n            temp.next = head;\r\n            head = temp;\r\n        }\r\n    }\r\n    callback(coef);\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_reduce_terms(mpl, form){\r\n    var term, next_term;\r\n    var c0 = 0.0;\r\n    for (term = form; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, term.coef);\r\n    else\r\n        term.var_.temp = mpl_internal_fp_add(mpl, term.var_.temp, term.coef);\r\n    }\r\n    next_term = form; form = null;\r\n    for (term = next_term; term != null; term = next_term)\r\n    {  next_term = term.next;\r\n        if (term.var_ == null && c0 != 0.0)\r\n        {  term.coef = c0; c0 = 0.0;\r\n            term.next = form; form = term;\r\n        }\r\n        else if (term.var_ != null && term.var_.temp != 0.0)\r\n        {  term.coef = term.var_.temp; term.var_.temp = 0.0;\r\n            term.next = form; form = term;\r\n        }\r\n    }\r\n    return form;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                       GENERIC VALUES                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_delete_value(mpl, type, value){\r\n    xassert(value != null);\r\n    switch (type)\r\n    {   case A_NONE:\r\n        value.none = null;\r\n        break;\r\n        case A_NUMERIC:\r\n            value.num = 0.0;\r\n            break;\r\n        case A_SYMBOLIC:\r\n            value.sym = null;\r\n            break;\r\n        case A_LOGICAL:\r\n            value.bit = 0;\r\n            break;\r\n        case A_TUPLE:\r\n            value.tuple = null;\r\n            break;\r\n        case A_ELEMSET:\r\n            value.set = null;\r\n            break;\r\n        case A_ELEMVAR:\r\n            value.var_ = null;\r\n            break;\r\n        case A_FORMULA:\r\n            value.form = null;\r\n            break;\r\n        case A_ELEMCON:\r\n            value.con = null;\r\n            break;\r\n        default:\r\n            xassert(type != type);\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                SYMBOLICALLY INDEXED ARRAYS                 * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_array(mpl, type, dim){\r\n    xassert(type == A_NONE || type == A_NUMERIC ||\r\n        type == A_SYMBOLIC || type == A_ELEMSET ||\r\n        type == A_ELEMVAR || type == A_ELEMCON);\r\n    xassert(dim >= 0);\r\n    var array = {};\r\n    array.type = type;\r\n    array.dim = dim;\r\n    array.size = 0;\r\n    array.head = null;\r\n    array.tail = null;\r\n    array.tree = false;\r\n    array.prev = null;\r\n    array.next = mpl.a_list;\r\n    /* include the array in the global array list */\r\n    if (array.next != null) array.next.prev = array;\r\n    mpl.a_list = array;\r\n    return array;\r\n}\r\n\r\nfunction mpl_internal_compare_member_tuples(info, key1, key2){\r\n    /* this is an auxiliary routine used to compare keys, which are\r\n     n-tuples assigned to array members */\r\n    return mpl_internal_compare_tuples(info, key1, key2);\r\n}\r\n\r\nfunction mpl_internal_find_member(mpl, array, tuple){\r\n    var memb;\r\n    xassert(array != null);\r\n    /* the n-tuple must have the same dimension as the array */\r\n    xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);\r\n    /* if the array is large enough, create the search tree and index\r\n     all existing members of the array */\r\n    if (array.size > 30 && !array.tree)\r\n    {\r\n        array.tree = avl_create_tree(mpl_internal_compare_member_tuples, mpl);\r\n        for (memb = array.head; memb != null; memb = memb.next)\r\n            avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);\r\n    }\r\n    /* find a member, which has the given tuple */\r\n    memb = null;\r\n    if (!array.tree)\r\n    {  /* the search tree doesn't exist; use the linear search */\r\n        for (memb = array.head; memb != null; memb = memb.next)\r\n            if (mpl_internal_compare_tuples(mpl, memb.tuple, tuple) == 0) break;\r\n    }\r\n    else\r\n    {  /* the search tree exists; use the binary search */\r\n        var node = avl_find_node(array.tree, tuple);\r\n        memb = (node == null ? null : avl_get_node_link(node));\r\n    }\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_add_member(mpl, array, tuple){\r\n    xassert(array != null);\r\n    /* the n-tuple must have the same dimension as the array */\r\n    xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);\r\n    /* create new member */\r\n    var memb = {};\r\n    memb.tuple = tuple;\r\n    memb.next = null;\r\n    memb.value = {};\r\n    /* and append it to the member list */\r\n    array.size++;\r\n    if (array.head == null)\r\n        array.head = memb;\r\n    else\r\n        array.tail.next = memb;\r\n    array.tail = memb;\r\n    /* if the search tree exists, index the new member */\r\n    if (array.tree != null)\r\n        avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);\r\n    return memb;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                 DOMAINS AND DUMMY INDICES                  * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_assign_dummy_index(mpl, slot, value){\r\n    var leaf, code;\r\n    xassert(slot != null);\r\n    xassert(value != null);\r\n    /* delete the current value assigned to the dummy index */\r\n    if (slot.value != null)\r\n    {  /* if the current value and the new one are identical, actual\r\n     assignment is not needed */\r\n        if (mpl_internal_compare_symbols(mpl, slot.value, value) == 0) return;\r\n        /* delete a symbol, which is the current value */\r\n        slot.value = null;\r\n    }\r\n    /* now walk through all the pseudo-codes with op = O_INDEX, which\r\n     refer to the dummy index to be changed (these pseudo-codes are\r\n     leaves in the forest of *all* expressions in the database) */\r\n    for (leaf = slot.list; leaf != null; leaf = leaf.arg.index.\r\n        next)\r\n    {  xassert(leaf.op == O_INDEX);\r\n        /* invalidate all resultant values, which depend on the dummy\r\n         index, walking from the current leaf toward the root of the\r\n         corresponding expression tree */\r\n        for (code = leaf; code != null; code = code.up)\r\n        {  if (code.valid)\r\n        {  /* invalidate and delete resultant value */\r\n            code.valid = 0;\r\n            mpl_internal_delete_value(mpl, code.type, code.value);\r\n        }\r\n        }\r\n    }\r\n    /* assign new value to the dummy index */\r\n    slot.value = mpl_internal_copy_symbol(mpl, value);\r\n}\r\n\r\nfunction mpl_internal_update_dummy_indices(mpl, block){\r\n    var slot;\r\n    var temp;\r\n    if (block.backup != null)\r\n    {  for (slot = block.list, temp = block.backup; slot != null;\r\n            slot = slot.next, temp = temp.next)\r\n    {   xassert(temp != null);\r\n        xassert(temp.sym != null);\r\n        mpl_internal_assign_dummy_index(mpl, slot, temp.sym);\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_enter_domain_block(mpl, block, tuple, info, func){\r\n    var backup;\r\n    var ret = 0;\r\n    /* check if the given n-tuple is a member of the basic set */\r\n    xassert(block.code != null);\r\n    if (!mpl_internal_is_member(mpl, block.code, tuple))\r\n    {  ret = 1;\r\n        return ret;\r\n    }\r\n    /* save reference to \"backup\" n-tuple, which was used to assign\r\n     current values of the dummy indices (it is sufficient to save\r\n     reference, not value, because that n-tuple is defined in some\r\n     outer level of recursion and therefore cannot be changed on\r\n     this and deeper recursive calls) */\r\n    backup = block.backup;\r\n    /* set up new \"backup\" n-tuple, which defines new values of the\r\n     dummy indices */\r\n    block.backup = tuple;\r\n    /* assign new values to the dummy indices */\r\n    mpl_internal_update_dummy_indices(mpl, block);\r\n    /* call the formal routine that does the rest part of the job */\r\n    func(mpl, info);\r\n    /* restore reference to the former \"backup\" n-tuple */\r\n    block.backup = backup;\r\n    /* restore former values of the dummy indices; note that if the\r\n     domain block just escaped has no other active instances which\r\n     may exist due to recursion (it is indicated by a null pointer\r\n     to the former n-tuple), former values of the dummy indices are\r\n     undefined; therefore in this case the routine keeps currently\r\n     assigned values of the dummy indices that involves keeping all\r\n     dependent temporary results and thereby, if this domain block\r\n     is not used recursively, allows improving efficiency */\r\n    mpl_internal_update_dummy_indices(mpl, block);\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_eval_domain_func(mpl, my_info)\r\n{     /* this routine recursively enters into the domain scope and then\r\n calls the routine func */\r\n    if (my_info.block != null)\r\n    {  /* the current domain block to be entered exists */\r\n        var block;\r\n        var slot;\r\n        var tuple = null, temp = null;\r\n        /* save pointer to the current domain block */\r\n        block = my_info.block;\r\n        /* and get ready to enter the next block (if it exists) */\r\n        my_info.block = block.next;\r\n        /* construct temporary n-tuple, whose components correspond to\r\n         dummy indices (slots) of the current domain; components of\r\n         the temporary n-tuple that correspond to free dummy indices\r\n         are assigned references (not values!) to symbols specified\r\n         in the corresponding components of the given n-tuple, while\r\n         other components that correspond to non-free dummy indices\r\n         are assigned symbolic values computed here */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  /* create component that corresponds to the current slot */\r\n            if (tuple == null)\r\n                tuple = temp = {};\r\n            else\r\n                temp = temp.next = {};\r\n            if (slot.code == null)\r\n            {  /* dummy index is free; take reference to symbol, which\r\n             is specified in the corresponding component of given\r\n             n-tuple */\r\n                xassert(my_info.tuple != null);\r\n                temp.sym = my_info.tuple.sym;\r\n                xassert(temp.sym != null);\r\n                my_info.tuple = my_info.tuple.next;\r\n            }\r\n            else\r\n            {  /* dummy index is non-free; compute symbolic value to be\r\n             temporarily assigned to the dummy index */\r\n                temp.sym = mpl_internal_eval_symbolic(mpl, slot.code);\r\n            }\r\n        }\r\n        temp.next = null;\r\n        /* enter the current domain block */\r\n        if (mpl_internal_enter_domain_block(mpl, block, tuple, my_info,\r\n            mpl_internal_eval_domain_func)) my_info.failure = 1;\r\n        /* delete temporary n-tuple as well as symbols that correspond\r\n         to non-free dummy indices (they were computed here) */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  xassert(tuple != null);\r\n            temp = tuple;\r\n            tuple = tuple.next;\r\n        }\r\n    }\r\n    else\r\n    {  /* there are no more domain blocks, i.e. we have reached the\r\n     domain scope */\r\n        xassert(my_info.tuple == null);\r\n        /* check optional predicate specified for the domain */\r\n        if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl,\r\n            my_info.domain.code))\r\n        {  /* the predicate is false */\r\n            my_info.failure = 2;\r\n        }\r\n        else\r\n        {  /* the predicate is true; do the job */\r\n            my_info.func(mpl, my_info.info);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_within_domain(mpl, domain, tuple, info, func){\r\n    /* this routine performs evaluation within domain scope */\r\n    var my_info = {};\r\n    if (domain == null)\r\n    {   xassert(tuple == null);\r\n        func(mpl, info);\r\n        my_info.failure = 0;\r\n    }\r\n    else\r\n    {   xassert(tuple != null);\r\n        my_info.domain = domain;\r\n        my_info.block = domain.list;\r\n        my_info.tuple = tuple;\r\n        my_info.info = info;\r\n        my_info.func = func;\r\n        my_info.failure = 0;\r\n        /* enter the very first domain block */\r\n        mpl_internal_eval_domain_func(mpl, my_info);\r\n    }\r\n    return my_info.failure;\r\n}\r\n\r\nfunction mpl_internal_loop_domain_func(mpl, my_info){\r\n    /* this routine enumerates all n-tuples in the basic set of the\r\n     current domain block, enters recursively into the domain scope\r\n     for every n-tuple, and then calls the routine func */\r\n    if (my_info.block != null)\r\n    {  /* the current domain block to be entered exists */\r\n        var block;\r\n        var slot;\r\n        var bound;\r\n        /* save pointer to the current domain block */\r\n        block = my_info.block;\r\n        /* and get ready to enter the next block (if it exists) */\r\n        my_info.block = block.next;\r\n        /* compute symbolic values, at which non-free dummy indices of\r\n         the current domain block are bound; since that values don't\r\n         depend on free dummy indices of the current block, they can\r\n         be computed once out of the enumeration loop */\r\n        bound = null;\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  if (slot.code != null)\r\n            bound = mpl_internal_expand_tuple(mpl, bound, mpl_internal_eval_symbolic(mpl,\r\n                slot.code));\r\n        }\r\n        /* start enumeration */\r\n        xassert(block.code != null);\r\n        if (block.code.op == O_DOTS)\r\n        {  /* the basic set is \"arithmetic\", in which case it doesn't\r\n         need to be computed explicitly */\r\n            var tuple;\r\n            var n, j;\r\n            var t0, tf, dt;\r\n            /* compute \"parameters\" of the basic set */\r\n            t0 = mpl_internal_eval_numeric(mpl, block.code.arg.arg.x);\r\n            tf = mpl_internal_eval_numeric(mpl, block.code.arg.arg.y);\r\n            if (block.code.arg.arg.z == null)\r\n                dt = 1.0;\r\n            else\r\n                dt = mpl_internal_eval_numeric(mpl, block.code.arg.arg.z);\r\n            /* determine cardinality of the basic set */\r\n            n = mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n            /* create dummy 1-tuple for members of the basic set */\r\n            tuple = mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_create_symbol_num(mpl, 0.0));\r\n            /* in case of \"arithmetic\" set there is exactly one dummy\r\n             index, which cannot be non-free */\r\n            xassert(bound == null);\r\n            /* walk through 1-tuples of the basic set */\r\n            for (j = 1; j <= n && my_info.looping; j++)\r\n            {  /* construct dummy 1-tuple for the current member */\r\n                tuple.sym.num = mpl_internal_arelset_member(mpl, t0, tf, dt, j);\r\n                /* enter the current domain block */\r\n                mpl_internal_enter_domain_block(mpl, block, tuple, my_info,\r\n                    mpl_internal_loop_domain_func);\r\n            }\r\n        }\r\n        else\r\n        {  /* the basic set is of general kind, in which case it needs\r\n         to be explicitly computed */\r\n            var set;\r\n            var memb;\r\n            var temp1, temp2;\r\n            /* compute the basic set */\r\n            set = mpl_internal_eval_elemset(mpl, block.code);\r\n            /* walk through all n-tuples of the basic set */\r\n            for (memb = set.head; memb != null && my_info.looping;\r\n                 memb = memb.next)\r\n            {  /* all components of the current n-tuple that correspond\r\n             to non-free dummy indices must be feasible; otherwise\r\n             the n-tuple is not in the basic set */\r\n                temp1 = memb.tuple;\r\n                temp2 = bound;\r\n                var found = false;\r\n                for (slot = block.list; slot != null; slot = slot.next)\r\n                {  xassert(temp1 != null);\r\n                    if (slot.code != null)\r\n                    {  /* non-free dummy index */\r\n                        xassert(temp2 != null);\r\n                        if (mpl_internal_compare_symbols(mpl, temp1.sym, temp2.sym)\r\n                            != 0)\r\n                        {  /* the n-tuple is not in the basic set */\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        temp2 = temp2.next;\r\n                    }\r\n                    temp1 = temp1.next;\r\n                }\r\n                if (!found){\r\n                    xassert(temp1 == null);\r\n                    xassert(temp2 == null);\r\n                    /* enter the current domain block */\r\n                    mpl_internal_enter_domain_block(mpl, block, memb.tuple, my_info,\r\n                        mpl_internal_loop_domain_func);\r\n                }\r\n            }\r\n        }\r\n        /* restore pointer to the current domain block */\r\n        my_info.block = block;\r\n    }\r\n    else\r\n    {  /* there are no more domain blocks, i.e. we have reached the\r\n     domain scope */\r\n        /* check optional predicate specified for the domain */\r\n        if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl,\r\n            my_info.domain.code))\r\n        {  /* the predicate is false */\r\n            /* nop */\r\n        }\r\n        else\r\n        {  /* the predicate is true; do the job */\r\n            my_info.looping = !my_info.func(mpl, my_info.info);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_loop_within_domain(mpl, domain, info, func){\r\n    /* this routine performs iterations within domain scope */\r\n    var my_info = {};\r\n    if (domain == null)\r\n        func(mpl, info);\r\n    else\r\n    {   my_info.domain = domain;\r\n        my_info.block = domain.list;\r\n        my_info.looping = 1;\r\n        my_info.info = info;\r\n        my_info.func = func;\r\n        /* enter the very first domain block */\r\n        mpl_internal_loop_domain_func(mpl, my_info);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_out_of_domain(mpl, name, tuple){\r\n    xassert(name != null);\r\n    xassert(tuple != null);\r\n    mpl_internal_error(mpl, name + mpl_internal_format_tuple(mpl, '[', tuple) + \" out of domain\");\r\n}\r\n\r\nfunction mpl_internal_get_domain_tuple(mpl, domain){\r\n    var tuple = null;\r\n    if (domain != null)\r\n    {  for (var block = domain.list; block != null; block = block.next)\r\n    {  for (var slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.code == null)\r\n    {  xassert(slot.value != null);\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n            slot.value));\r\n    }\r\n    }\r\n    }\r\n    }\r\n    return tuple;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                         MODEL SETS                         * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_elem_set(mpl, set, tuple, refer){\r\n    /* elemental set must be within all specified supersets */\r\n    for (var within = set.within, eqno = 1; within != null; within =\r\n        within.next, eqno++)\r\n    {  xassert(within.code != null);\r\n        for (var memb = refer.head; memb != null; memb = memb.next)\r\n        {  if (!mpl_internal_is_member(mpl, within.code, memb.tuple))\r\n        {   var buf = mpl_internal_format_tuple(mpl, '(', memb.tuple);\r\n            xassert(buf.length < 255);\r\n            mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) +\r\n                \" contains \" + buf + \" which not within specified set; see (\" + eqno + \")\");\r\n        }\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_set(mpl, set, tuple){\r\n    var refer;\r\n    /* find member in the set array */\r\n    var memb = mpl_internal_find_member(mpl, set.array, tuple);\r\n\r\n    function add(){\r\n        /* check that the elemental set satisfies to all restrictions,\r\n         assign it to new member, and add the member to the array */\r\n        mpl_internal_check_elem_set(mpl, set, tuple, refer);\r\n        memb = mpl_internal_add_member(mpl, set.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.set = refer;\r\n    }\r\n\r\n\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.set;\r\n    }\r\n    else if (set.assign != null)\r\n    {  /* compute value using assignment expression */\r\n        refer = mpl_internal_eval_elemset(mpl, set.assign);\r\n        add();\r\n    }\r\n    else if (set.option != null)\r\n    {  /* compute default elemental set */\r\n        refer = mpl_internal_eval_elemset(mpl, set.option);\r\n        add();\r\n    }\r\n    else\r\n    {  /* no value (elemental set) is provided */\r\n        mpl_internal_error(mpl, \"no value for \" + set.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_set_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check elemental set being assigned */\r\n        mpl_internal_check_elem_set(mpl, info.set, info.memb.tuple,\r\n            info.memb.value.set);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.refer = mpl_internal_take_member_set(mpl, info.set, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_saturate_set(mpl, set){\r\n    var gadget = set.gadget;\r\n    var data;\r\n    var elem, memb;\r\n    var tuple, work = new Array(20);\r\n    var i;\r\n    xprintf(\"Generating \" + set.name + \"...\");\r\n    mpl_internal_eval_whole_set(mpl, gadget.set);\r\n    /* gadget set must have exactly one member */\r\n    xassert(gadget.set.array != null);\r\n    xassert(gadget.set.array.head != null);\r\n    xassert(gadget.set.array.head == gadget.set.array.tail);\r\n    data = gadget.set.array.head.value.set;\r\n    xassert(data.type == A_NONE);\r\n    xassert(data.dim == gadget.set.dimen);\r\n    /* walk thru all elements of the plain set */\r\n    for (elem = data.head; elem != null; elem = elem.next)\r\n    {  /* create a copy of n-tuple */\r\n        tuple = mpl_internal_copy_tuple(mpl, elem.tuple);\r\n        /* rearrange component of the n-tuple */\r\n        for (i = 0; i < gadget.set.dimen; i++)\r\n            work[i] = null;\r\n        for (i = 0; tuple != null; tuple = tuple.next)\r\n            work[gadget.ind[i++]-1] = tuple;\r\n        xassert(i == gadget.set.dimen);\r\n        for (i = 0; i < gadget.set.dimen; i++)\r\n        {  xassert(work[i] != null);\r\n            work[i].next = work[i+1];\r\n        }\r\n        /* construct subscript list from first set.dim components */\r\n        if (set.dim == 0)\r\n            tuple = null;\r\n        else {\r\n            tuple = work[0]; work[set.dim-1].next = null;\r\n        }\r\n        /* find corresponding member of the set to be initialized */\r\n        memb = mpl_internal_find_member(mpl, set.array, tuple);\r\n        if (memb == null)\r\n        {  /* not found; add new member to the set and assign it empty\r\n         elemental set */\r\n            memb = mpl_internal_add_member(mpl, set.array, tuple);\r\n            memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);\r\n        }\r\n        /* construct new n-tuple from rest set.dimen components */\r\n        tuple = work[set.dim];\r\n        xassert(set.dim + set.dimen == gadget.set.dimen);\r\n        work[gadget.set.dimen-1].next = null;\r\n        /* and add it to the elemental set assigned to the member\r\n         (no check for duplicates is needed) */\r\n        mpl_internal_add_tuple(mpl, memb.value.set, tuple);\r\n    }\r\n    /* the set has been saturated with data */\r\n    set.data = 1;\r\n}\r\n\r\nfunction mpl_internal_eval_member_set(mpl, set, tuple){\r\n    /* this routine evaluates set member */\r\n    var info = {};\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.set = set;\r\n    info.tuple = tuple;\r\n    if (set.gadget != null && set.data == 0)\r\n    {  /* initialize the set with data from a plain set */\r\n        mpl_internal_saturate_set(mpl, set);\r\n    }\r\n    if (set.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting supersets;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = set.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same set during the check */\r\n        set.data = 2;\r\n        /* check elemental sets assigned to array members in the data\r\n         section until the marked member has been reached */\r\n        for (info.memb = set.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, set.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_set_func))\r\n            mpl_internal_out_of_domain(mpl, set.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.set.domain, info.tuple, info,\r\n        mpl_internal_eval_set_func))\r\n        mpl_internal_out_of_domain(mpl, set.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_set_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, info.domain);\r\n    mpl_internal_eval_member_set(mpl, info, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_set(mpl, set){\r\n    mpl_internal_loop_within_domain(mpl, set.domain, set, mpl_internal_whole_set_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL PARAMETERS                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_value_num(mpl, par, tuple, value){\r\n    var cond;\r\n    var eqno;\r\n    /* the value must satisfy to the parameter type */\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        break;\r\n        case A_INTEGER:\r\n            if (value != Math.floor(value))\r\n                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not integer\");\r\n            break;\r\n        case A_BINARY:\r\n            if (!(value == 0.0 || value == 1.0))\r\n                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not binary\");\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    /* the value must satisfy to all specified conditions */\r\n    for (cond = par.cond, eqno = 1; cond != null; cond = cond.next,\r\n        eqno++)\r\n    {   var bound;\r\n        //var rho;\r\n        xassert(cond.code != null);\r\n        bound = mpl_internal_eval_numeric(mpl, cond.code);\r\n\r\n        function err(rho){mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not \" + rho + \" \" + bound + \"; see (\" + eqno + \")\")}\r\n\r\n        switch (cond.rho)\r\n        {   case O_LT:\r\n            if (!(value < bound))\r\n                err(\"<\");\r\n            break;\r\n            case O_LE:\r\n                if (!(value <= bound)) err(\"<=\");\r\n                break;\r\n            case O_EQ:\r\n                if (!(value == bound)) err(\"=\");\r\n                break;\r\n            case O_GE:\r\n                if (!(value >= bound)) err(\">=\");\r\n                break;\r\n            case O_GT:\r\n                if (!(value > bound)) err(\">\");\r\n                break;\r\n            case O_NE:\r\n                if (!(value != bound)) err(\"<>\");\r\n                break;\r\n            default:\r\n                xassert(cond != cond);\r\n        }\r\n    }\r\n    /* the value must be in_ all specified supersets */\r\n    eqno = 1;\r\n    for (var in_ = par.in_; in_ != null; in_ = in_.next, eqno++)\r\n    {\r\n        xassert(in_.code != null);\r\n        xassert(in_.code.dim == 1);\r\n        var dummy = mpl_internal_expand_tuple(mpl, null,\r\n            mpl_internal_create_symbol_num(mpl, value));\r\n        if (!mpl_internal_is_member(mpl, in_.code, dummy))\r\n            mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not in specified set; see (\" + eqno + \")\");\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_num(mpl, par, tuple){\r\n    /* find member in the parameter array */\r\n    var memb = mpl_internal_find_member(mpl, par.array, tuple);\r\n\r\n    function add(value){\r\n        /* check that the value satisfies to all restrictions, assign\r\n         it to new member, and add the member to the array */\r\n        mpl_internal_check_value_num(mpl, par, tuple, value);\r\n        memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.num = value;\r\n        return value;\r\n    }\r\n\r\n    if (memb != null)\r\n    /* member exists, so just take its value */\r\n        return memb.value.num;\r\n    else if (par.assign != null)\r\n    /* compute value using assignment expression */\r\n        return add(mpl_internal_eval_numeric(mpl, par.assign));\r\n    else if (par.option != null)\r\n    /* compute default value */\r\n        return add(mpl_internal_eval_numeric(mpl, par.option));\r\n    else if (par.defval != null)\r\n    {   /* take default value provided in the data section */\r\n        if (par.defval.str != null)\r\n            mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, par.defval) + \" to floating-point number\");\r\n        return add(par.defval.num);\r\n    }\r\n    else\r\n    /* no value is provided */\r\n        return mpl_internal_error(mpl, \"no value for \" + par.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n}\r\n\r\nfunction mpl_internal_eval_num_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check numeric value being assigned */\r\n        mpl_internal_check_value_num(mpl, info.par, info.memb.tuple,\r\n            info.memb.value.num);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.value = mpl_internal_take_member_num(mpl, info.par, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_member_num(mpl, par, tuple){\r\n    /* this routine evaluates numeric parameter member */\r\n    var info = {};\r\n    xassert(par.type == A_NUMERIC || par.type == A_INTEGER ||\r\n        par.type == A_BINARY);\r\n    xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.par = par;\r\n    info.tuple = tuple;\r\n    if (par.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting conditions;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = par.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same parameter during the check */\r\n        par.data = 2;\r\n        /* check values assigned to array members in the data section\r\n         until the marked member has been reached */\r\n        for (info.memb = par.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_num_func))\r\n            mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info,\r\n        mpl_internal_eval_num_func))\r\n        mpl_internal_out_of_domain(mpl, par.name, info.tuple);\r\n    /* bring evaluated value to the calling program */\r\n    return info.value;\r\n}\r\n\r\nfunction mpl_internal_check_value_sym(mpl, par, tuple, value){\r\n    var in_;\r\n    var eqno = 1;\r\n    /* the value must satisfy to all specified conditions */\r\n    for (var cond = par.cond; cond != null; cond = cond.next,\r\n        eqno++)\r\n    {\r\n        var buf; // 255\r\n        xassert(cond.code != null);\r\n        var bound = mpl_internal_eval_symbolic(mpl, cond.code);\r\n        switch (cond.rho)\r\n        {\r\n            case O_LT:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) < 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not < \" + buf);\r\n                }\r\n                break;\r\n            case O_LE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) <= 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not <= \" + buf);\r\n                }\r\n                break;\r\n            case O_EQ:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) == 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not = \" + buf);\r\n                }\r\n                break;\r\n            case O_GE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) >= 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not >= \" + buf);\r\n                }\r\n                break;\r\n            case O_GT:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) > 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not > \" + buf);\r\n                }\r\n                break;\r\n            case O_NE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) != 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" <> \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not > \" + buf);\r\n                }\r\n                break;\r\n            default:\r\n                xassert(cond != cond);\r\n        }\r\n    }\r\n    /* the value must be in all specified supersets */\r\n    eqno = 1;\r\n    for (in_ = par.in_; in_ != null; in_ = in_.next, eqno++)\r\n    {\r\n        xassert(in_.code != null);\r\n        xassert(in_.code.dim == 1);\r\n        var dummy = mpl_internal_expand_tuple(mpl, null, mpl_internal_copy_symbol(mpl,\r\n            value));\r\n        if (!mpl_internal_is_member(mpl, in_.code, dummy))\r\n            mpl_internal_error(mpl, par.name, mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + mpl_internal_format_symbol(mpl, value) + \" not in specified set; see (\" + eqno + \")\");\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_sym(mpl, par, tuple){\r\n    /* find member in the parameter array */\r\n    var memb = mpl_internal_find_member(mpl, par.array, tuple);\r\n\r\n    function add(value){\r\n        /* check that the value satisfies to all restrictions, assign\r\n         it to new member, and add the member to the array */\r\n        mpl_internal_check_value_sym(mpl, par, tuple, value);\r\n        memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.sym = mpl_internal_copy_symbol(mpl, value);\r\n        return value;\r\n    }\r\n\r\n    if (memb != null)\r\n    {  /* member exists, so just take its value */\r\n        return mpl_internal_copy_symbol(mpl, memb.value.sym);\r\n    }\r\n    else if (par.assign != null)\r\n    /* compute value using assignment expression */\r\n        return add(mpl_internal_eval_symbolic(mpl, par.assign));\r\n    else if (par.option != null)\r\n    /* compute default value */\r\n        return add(mpl_internal_eval_symbolic(mpl, par.option));\r\n    else if (par.defval != null)\r\n    /* take default value provided in the data section */\r\n        return(mpl_internal_copy_symbol(mpl, par.defval));\r\n    else\r\n    /* no value is provided */\r\n        return mpl_internal_error(mpl, \"no value for \" + par.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n}\r\n\r\nfunction mpl_internal_eval_sym_func(mpl, info)\r\n{     /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check symbolic value being assigned */\r\n        mpl_internal_check_value_sym(mpl, info.par, info.memb.tuple,\r\n            info.memb.value.sym);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.value = mpl_internal_take_member_sym(mpl, info.par, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_member_sym(mpl, par, tuple){\r\n    /* this routine evaluates symbolic parameter member */\r\n    var info = {};\r\n    xassert(par.type == A_SYMBOLIC);\r\n    xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.par = par;\r\n    info.tuple = tuple;\r\n    if (par.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting conditions;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = par.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same parameter during the check */\r\n        par.data = 2;\r\n        /* check values assigned to array members in the data section\r\n         until the marked member has been reached */\r\n        for (info.memb = par.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_sym_func))\r\n            mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info,\r\n        mpl_internal_eval_sym_func))\r\n        mpl_internal_out_of_domain(mpl, par.name, info.tuple);\r\n    /* bring evaluated value to the calling program */\r\n    return info.value;\r\n}\r\n\r\nfunction mpl_internal_whole_par_func(mpl, par){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, par.domain);\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            mpl_internal_eval_member_num(mpl, par, tuple);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            mpl_internal_eval_member_sym(mpl, par, tuple);\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_par(mpl, par){\r\n    mpl_internal_loop_within_domain(mpl, par.domain, par, mpl_internal_whole_par_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL VARIABLES                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_take_member_var(mpl, var_, tuple){\r\n    var refer;\r\n    /* find member in the variable array */\r\n    var memb = mpl_internal_find_member(mpl, var_.array, tuple);\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.var_;\r\n    }\r\n    else\r\n    {  /* member is referenced for the first time and therefore does\r\n     not exist; create new elemental variable, assign it to new\r\n     member, and add the member to the variable array */\r\n        memb = mpl_internal_add_member(mpl, var_.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        refer = memb.value.var_ = {};\r\n        refer.j = 0;\r\n        refer.var_ = var_;\r\n        refer.memb = memb;\r\n        /* compute lower bound */\r\n        if (var_.lbnd == null)\r\n            refer.lbnd = 0.0;\r\n        else\r\n            refer.lbnd = mpl_internal_eval_numeric(mpl, var_.lbnd);\r\n        /* compute upper bound */\r\n        if (var_.ubnd == null)\r\n            refer.ubnd = 0.0;\r\n        else if (var_.ubnd == var_.lbnd)\r\n            refer.ubnd = refer.lbnd;\r\n        else\r\n            refer.ubnd = mpl_internal_eval_numeric(mpl, var_.ubnd);\r\n        /* nullify working quantity */\r\n        refer.temp = 0.0;\r\n        /* solution has not been obtained by the solver yet */\r\n        refer.stat = 0;\r\n        refer.prim = refer.dual = 0.0;\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_var_func(mpl, info)\r\n{\r\n    /* this is auxiliary routine to work within domain scope */\r\n    info.refer = mpl_internal_take_member_var(mpl, info.var_, info.tuple);\r\n}\r\n\r\nfunction mpl_internal_eval_member_var(mpl, var_, tuple){\r\n    /* this routine evaluates variable member */\r\n    var info = {};\r\n    xassert(var_.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.var_ = var_;\r\n    info.tuple = tuple;\r\n    /* evaluate member, which has given n-tuple */\r\n    if (mpl_internal_eval_within_domain(mpl, info.var_.domain, info.tuple, info, mpl_internal_eval_var_func))\r\n        mpl_internal_out_of_domain(mpl, var_.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_var_func(mpl, var_){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, var_.domain);\r\n    mpl_internal_eval_member_var(mpl, var_, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_var(mpl, var_){\r\n    mpl_internal_loop_within_domain(mpl, var_.domain, var_, mpl_internal_whole_var_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *              MODEL CONSTRAINTS AND OBJECTIVES              * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_take_member_con(mpl, con, tuple){\r\n    var refer, temp = null;\r\n    /* find member in the constraint array */\r\n    var memb = mpl_internal_find_member(mpl, con.array, tuple);\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.con;\r\n    }\r\n    else\r\n    {  /* member is referenced for the first time and therefore does\r\n     not exist; create new elemental constraint, assign it to new\r\n     member, and add the member to the constraint array */\r\n        memb = mpl_internal_add_member(mpl, con.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        refer = memb.value.con = {};\r\n        refer.i = 0;\r\n        refer.con = con;\r\n        refer.memb = memb;\r\n        /* compute linear form */\r\n        xassert(con.code != null);\r\n        refer.form = mpl_internal_eval_formula(mpl, con.code);\r\n        /* compute lower and upper bounds */\r\n        if (con.lbnd == null && con.ubnd == null)\r\n        {  /* objective has no bounds */\r\n\r\n            xassert(con.type == A_MINIMIZE || con.type == A_MAXIMIZE);\r\n            /* carry the constant term to the right-hand side */\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = refer.ubnd = - temp;\r\n        }\r\n        else if (con.lbnd != null && con.ubnd == null)\r\n        {  /* constraint a * x + b >= c * y + d is transformed to the\r\n         standard form a * x - c * y >= d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.lbnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = - temp;\r\n            refer.ubnd = 0.0;\r\n        }\r\n        else if (con.lbnd == null && con.ubnd != null)\r\n        {  /* constraint a * x + b <= c * y + d is transformed to the\r\n         standard form a * x - c * y <= d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.ubnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = 0.0;\r\n            refer.ubnd = - temp;\r\n        }\r\n        else if (con.lbnd == con.ubnd)\r\n        {  /* constraint a * x + b = c * y + d is transformed to the\r\n         standard form a * x - c * y = d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.lbnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = refer.ubnd = - temp;\r\n        }\r\n        else\r\n        {  /* ranged constraint c <= a * x + b <= d is transformed to\r\n         the standard form c - b <= a * x <= d - b */\r\n            var temp1 = null, temp2 = null;\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.lbnd), function(v){temp1 = v}) == null);\r\n            xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.ubnd), function(v){temp2 = v}) == null);\r\n            refer.lbnd = mpl_internal_fp_sub(mpl, temp1, temp);\r\n            refer.ubnd = mpl_internal_fp_sub(mpl, temp2, temp);\r\n        }\r\n        /* solution has not been obtained by the solver yet */\r\n        refer.stat = 0;\r\n        refer.prim = refer.dual = 0.0;\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_con_func(mpl, info)\r\n{     /* this is auxiliary routine to work within domain scope */\r\n    info.refer = mpl_internal_take_member_con(mpl, info.con, info.tuple);\r\n}\r\n\r\nfunction mpl_internal_eval_member_con(mpl, con, tuple){\r\n    /* this routine evaluates constraint member */\r\n    var info = {};\r\n    xassert(con.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.con = con;\r\n    info.tuple = tuple;\r\n    /* evaluate member, which has given n-tuple */\r\n    if (mpl_internal_eval_within_domain(mpl, info.con.domain, info.tuple, info,\r\n        mpl_internal_eval_con_func))\r\n        mpl_internal_out_of_domain(mpl, con.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_con_func(mpl, con){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, con.domain);\r\n    mpl_internal_eval_member_con(mpl, con, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_con(mpl, con){\r\n    mpl_internal_loop_within_domain(mpl, con.domain, con, mpl_internal_whole_con_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        PSEUDO-CODE                         * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_iter_num_func(mpl, info){\r\n    /* this is auxiliary routine used to perform iterated operation\r\n     on numeric \"integrand\" within domain scope */\r\n    var temp = mpl_internal_eval_numeric(mpl, info.code.arg.loop.x);\r\n    switch (info.code.op)\r\n    {  case O_SUM:\r\n        /* summation over domain */\r\n        info.value = mpl_internal_fp_add(mpl, info.value, temp);\r\n        break;\r\n        case O_PROD:\r\n            /* multiplication over domain */\r\n            info.value = mpl_internal_fp_mul(mpl, info.value, temp);\r\n            break;\r\n        case O_MINIMUM:\r\n            /* minimum over domain */\r\n            if (info.value > temp) info.value = temp;\r\n            break;\r\n        case O_MAXIMUM:\r\n            /* maximum over domain */\r\n            if (info.value < temp) info.value = temp;\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_numeric(mpl, code){\r\n    var value, tuple, e, sym, str, temp, info;\r\n    xassert(code != null);\r\n    xassert(code.type == A_NUMERIC);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return code.value.num;\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_NUMBER:\r\n        /* take floating-point number */\r\n        value = code.arg.num;\r\n        break;\r\n        case O_MEMNUM:\r\n            /* take member of numeric parameter */\r\n        {\r\n            tuple = null;\r\n            for (e = code.arg.par.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            value = mpl_internal_eval_member_num(mpl, code.arg.par.par, tuple);\r\n        }\r\n            break;\r\n        case O_MEMVAR:\r\n            /* take computed value of elemental variable */\r\n        {\r\n            var var_;\r\n            tuple = null;\r\n            for (e = code.arg.var_.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple);\r\n            switch (code.arg.var_.suff)\r\n            {  case DOT_LB:\r\n                if (var_.var_.lbnd == null)\r\n                    value = -DBL_MAX;\r\n                else\r\n                    value = var_.lbnd;\r\n                break;\r\n                case DOT_UB:\r\n                    if (var_.var_.ubnd == null)\r\n                        value = +DBL_MAX;\r\n                    else\r\n                        value = var_.ubnd;\r\n                    break;\r\n                case DOT_STATUS:\r\n                    value = var_.stat;\r\n                    break;\r\n                case DOT_VAL:\r\n                    value = var_.prim;\r\n                    break;\r\n                case DOT_DUAL:\r\n                    value = var_.dual;\r\n                    break;\r\n                default:\r\n                    xassert(code != code);\r\n            }\r\n        }\r\n            break;\r\n        case O_MEMCON:\r\n            /* take computed value of elemental constraint */\r\n        {\r\n            var con;\r\n            tuple = null;\r\n            for (e = code.arg.con.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            con = mpl_internal_eval_member_con(mpl, code.arg.con.con, tuple);\r\n            switch (code.arg.con.suff)\r\n            {  case DOT_LB:\r\n                if (con.con.lbnd == null)\r\n                    value = -DBL_MAX;\r\n                else\r\n                    value = con.lbnd;\r\n                break;\r\n                case DOT_UB:\r\n                    if (con.con.ubnd == null)\r\n                        value = +DBL_MAX;\r\n                    else\r\n                        value = con.ubnd;\r\n                    break;\r\n                case DOT_STATUS:\r\n                    value = con.stat;\r\n                    break;\r\n                case DOT_VAL:\r\n                    value = con.prim;\r\n                    break;\r\n                case DOT_DUAL:\r\n                    value = con.dual;\r\n                    break;\r\n                default:\r\n                    xassert(code != code);\r\n            }\r\n        }\r\n            break;\r\n        case O_IRAND224:\r\n            /* pseudo-random in [0, 2^24-1] */\r\n            value = mpl_internal_fp_irand224(mpl);\r\n            break;\r\n        case O_UNIFORM01:\r\n            /* pseudo-random in [0, 1) */\r\n            value = mpl_internal_fp_uniform01(mpl);\r\n            break;\r\n        case O_NORMAL01:\r\n            /* gaussian random, mu = 0, sigma = 1 */\r\n            value = mpl_internal_fp_normal01(mpl);\r\n            break;\r\n        case O_GMTIME:\r\n            /* current calendar time */\r\n            value = mpl_internal_fn_gmtime(mpl);\r\n            break;\r\n        case O_CVTNUM:\r\n            /* conversion to numeric */\r\n        {\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                value = sym.num;\r\n            else\r\n            {  if (str2num(sym.str, function(v){value= v}))\r\n                mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, sym) + \" to floating-point number\");\r\n            }\r\n        }\r\n            break;\r\n        case O_PLUS:\r\n            /* unary plus */\r\n            value = + mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_MINUS:\r\n            /* unary minus */\r\n            value = - mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_ABS:\r\n            /* absolute value */\r\n            value = Math.abs(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_CEIL:\r\n            /* round upward (\"ceiling of x\") */\r\n            value = Math.ceil(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_FLOOR:\r\n            /* round downward (\"floor of x\") */\r\n            value = Math.floor(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_EXP:\r\n            /* base-e exponential */\r\n            value = mpl_internal_fp_exp(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_LOG:\r\n            /* natural logarithm */\r\n            value = mpl_internal_fp_log(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_LOG10:\r\n            /* common (decimal) logarithm */\r\n            value = mpl_internal_fp_log10(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_SQRT:\r\n            /* square root */\r\n            value = mpl_internal_fp_sqrt(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_SIN:\r\n            /* trigonometric sine */\r\n            value = mpl_internal_fp_sin(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_COS:\r\n            /* trigonometric cosine */\r\n            value = mpl_internal_fp_cos(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ATAN:\r\n            /* trigonometric arctangent (one argument) */\r\n            value = mpl_internal_fp_atan(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ATAN2:\r\n            /* trigonometric arctangent (two arguments) */\r\n            value = mpl_internal_fp_atan2(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_ROUND:\r\n            /* round to nearest integer */\r\n            value = mpl_internal_fp_round(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0.0);\r\n            break;\r\n        case O_ROUND2:\r\n            /* round to n fractional digits */\r\n            value = mpl_internal_fp_round(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_TRUNC:\r\n            /* truncate to nearest integer */\r\n            value = mpl_internal_fp_trunc(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0.0);\r\n            break;\r\n        case O_TRUNC2:\r\n            /* truncate to n fractional digits */\r\n            value = mpl_internal_fp_trunc(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_ADD:\r\n            /* addition */\r\n            value = mpl_internal_fp_add(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SUB:\r\n            /* subtraction */\r\n            value = mpl_internal_fp_sub(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_LESS:\r\n            /* non-negative subtraction */\r\n            value = mpl_internal_fp_less(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MUL:\r\n            /* multiplication */\r\n            value = mpl_internal_fp_mul(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DIV:\r\n            /* division */\r\n            value = mpl_internal_fp_div(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_IDIV:\r\n            /* quotient of exact division */\r\n            value = mpl_internal_fp_idiv(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MOD:\r\n            /* remainder of exact division */\r\n            value = mpl_internal_fp_mod(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_POWER:\r\n            /* exponentiation (raise to power) */\r\n            value = mpl_internal_fp_power(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_UNIFORM:\r\n            /* pseudo-random in [a, b) */\r\n            value = mpl_internal_fp_uniform(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_NORMAL:\r\n            /* gaussian random, given mu and sigma */\r\n            value = mpl_internal_fp_normal(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_CARD:\r\n        {\r\n            var set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = set.size;\r\n        }\r\n            break;\r\n        case O_LENGTH:\r\n        {\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                str = String(sym.num);\r\n            else\r\n                str = sym.str;\r\n            value = str.length;\r\n        }\r\n            break;\r\n        case O_STR2TIME:\r\n        {\r\n            var fmt;\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                str = String(sym.num);\r\n            else\r\n                str = sym.str;\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            if (sym.str == null)\r\n                fmt = String(sym.num);\r\n            else\r\n                fmt = sym.str;\r\n            value = mpl_internal_fn_str2time(mpl, str, fmt);\r\n        }\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = 0.0;\r\n            else\r\n                value = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_MIN:\r\n            /* minimal value (n-ary) */\r\n        {\r\n            value = +DBL_MAX;\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  temp = mpl_internal_eval_numeric(mpl, e.x);\r\n                if (value > temp) value = temp;\r\n            }\r\n        }\r\n            break;\r\n        case O_MAX:\r\n            /* maximal value (n-ary) */\r\n        {\r\n            value = -DBL_MAX;\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  temp = mpl_internal_eval_numeric(mpl, e.x);\r\n                if (value < temp) value = temp;\r\n            }\r\n        }\r\n            break;\r\n        case O_SUM:\r\n            /* summation over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 0.0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_PROD:\r\n            /* multiplication over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 1.0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_MINIMUM:\r\n            /* minimum over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = +DBL_MAX;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            if (info.value == +DBL_MAX)\r\n                mpl_internal_error(mpl, \"min{} over empty set; result undefined\");\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_MAXIMUM:\r\n            /* maximum over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = -DBL_MAX;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            if (info.value == -DBL_MAX)\r\n                mpl_internal_error(mpl, \"max{} over empty set; result undefined\");\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.num = value;\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_eval_symbolic(mpl, code){\r\n    var value, str;\r\n    xassert(code != null);\r\n    xassert(code.type == A_SYMBOLIC);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_symbol(mpl, code.value.sym);\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_STRING:\r\n        /* take character string */\r\n        value = mpl_internal_create_symbol_str(mpl, code.arg.str);\r\n        break;\r\n        case O_INDEX:\r\n            /* take dummy index */\r\n            xassert(code.arg.index.slot.value != null);\r\n            value = mpl_internal_copy_symbol(mpl, code.arg.index.slot.value);\r\n            break;\r\n        case O_MEMSYM:\r\n            /* take member of symbolic parameter */\r\n        {   var tuple;\r\n            var e;\r\n            tuple = null;\r\n            for (e = code.arg.par.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            value = mpl_internal_eval_member_sym(mpl, code.arg.par.par, tuple);\r\n        }\r\n            break;\r\n        case O_CVTSYM:\r\n            /* conversion to symbolic */\r\n            value = mpl_internal_create_symbol_num(mpl, mpl_internal_eval_numeric(mpl,\r\n                code.arg.arg.x));\r\n            break;\r\n        case O_CONCAT:\r\n            /* concatenation */\r\n            value = mpl_internal_concat_symbols(mpl,\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = mpl_internal_create_symbol_num(mpl, 0.0);\r\n            else\r\n                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SUBSTR:\r\n        case O_SUBSTR3:\r\n        {  var pos, len;\r\n            value = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (value.str == null)\r\n                str = String(value.num);\r\n            else\r\n                str = value.str;\r\n            if (code.op == O_SUBSTR)\r\n            {  pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n                if (pos != Math.floor(pos))\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \"); non-integer second argument\");\r\n                if (pos < 1 || pos > str.length + 1)\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \"); substring out of range\");\r\n            }\r\n            else\r\n            {   pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n                len = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n                if (pos != Math.floor(pos) || len != Math.floor(len))\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \", \" + len + \"); non-integer second and/or third argument\");\r\n                if (pos < 1 || len < 0 || pos + len > str.length + 1)\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \", \" + len + \"); substring out of range\");\r\n                //str[pos + len - 1] = '\\0';\r\n            }\r\n            value = mpl_internal_create_symbol_str(mpl, str.slice(pos-1, pos+len-1));\r\n        }\r\n            break;\r\n        case O_TIME2STR:\r\n        {   var num;\r\n            var sym;\r\n            var fmt; //[MAX_LENGTH+1], fmt[MAX_LENGTH+1];\r\n            num = mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            if (sym.str == null)\r\n                fmt = String(sym.num);\r\n            else\r\n                fmt = sym.str;\r\n            str = mpl_internal_fn_time2str(mpl, num, fmt);\r\n            value = mpl_internal_create_symbol_str(mpl, str);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.sym = mpl_internal_copy_symbol(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_log_func(mpl, info){\r\n    /* this is auxiliary routine used to perform iterated operation\r\n     on logical \"integrand\" within domain scope */\r\n    var ret = 0;\r\n    switch (info.code.op)\r\n    {  case O_FORALL:\r\n        /* conjunction over domain */\r\n        info.value &= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);\r\n        if (!info.value) ret = 1;\r\n        break;\r\n        case O_EXISTS:\r\n            /* disjunction over domain */\r\n            info.value |= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);\r\n            if (info.value) ret = 1;\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_eval_logical(mpl, code){\r\n    var value, sym1, sym2, tuple, set, memb, info;\r\n    xassert(code.type == A_LOGICAL);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return code.value.bit;\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_CVTLOG:\r\n        /* conversion to logical */\r\n        value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) != 0.0);\r\n        break;\r\n        case O_NOT:\r\n            /* negation (logical \"not\") */\r\n            value = !mpl_internal_eval_logical(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_LT:\r\n            /* comparison on 'less than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) <\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) < 0);\r\n            }\r\n            break;\r\n        case O_LE:\r\n            /* comparison on 'not greater than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) <=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) <= 0);\r\n            }\r\n            break;\r\n        case O_EQ:\r\n            /* comparison on 'equal to' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) ==\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) == 0);\r\n            }\r\n            break;\r\n        case O_GE:\r\n            /* comparison on 'not less than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) >=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) >= 0);\r\n            }\r\n            break;\r\n        case O_GT:\r\n            /* comparison on 'greater than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) >\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) > 0);\r\n            }\r\n            break;\r\n        case O_NE:\r\n            /* comparison on 'not equal to' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) !=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) != 0);\r\n            }\r\n            break;\r\n        case O_AND:\r\n            /* conjunction (logical \"and\") */\r\n            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) &&\r\n                mpl_internal_eval_logical(mpl, code.arg.arg.y);\r\n            break;\r\n        case O_OR:\r\n            /* disjunction (logical \"or\") */\r\n            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) ||\r\n                mpl_internal_eval_logical(mpl, code.arg.arg.y);\r\n            break;\r\n        case O_IN:\r\n            /* test on 'x in Y' */\r\n        {\r\n            tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n        }\r\n            break;\r\n        case O_NOTIN:\r\n            /* test on 'x not in Y' */\r\n        {\r\n            tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);\r\n            value = !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n        }\r\n            break;\r\n        case O_WITHIN:\r\n            /* test on 'X within Y' */\r\n        {\r\n            set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = 1;\r\n            for (memb = set.head; memb != null; memb = memb.next)\r\n            {  if (!mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n            break;\r\n        case O_NOTWITHIN:\r\n            /* test on 'X not within Y' */\r\n        {\r\n            set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = 1;\r\n            for (memb = set.head; memb != null; memb = memb.next)\r\n            {  if (mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n            break;\r\n        case O_FORALL:\r\n            /* conjunction (A-quantification) */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 1;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_log_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_EXISTS:\r\n            /* disjunction (E-quantification) */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_log_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.bit = value;\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_eval_tuple(mpl, code){\r\n    var value;\r\n    xassert(code != null);\r\n    xassert(code.type == A_TUPLE);\r\n    xassert(code.dim > 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_tuple(mpl, code.value.tuple);\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_TUPLE:\r\n        /* make n-tuple */\r\n    {\r\n        value = null;\r\n        for (var e = code.arg.list; e != null; e = e.next)\r\n            value = mpl_internal_expand_tuple(mpl, value, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n    }\r\n        break;\r\n        case O_CVTTUP:\r\n            /* convert to 1-tuple */\r\n            value = mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.x));\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.tuple = mpl_internal_copy_tuple(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_set_func(mpl, info)\r\n{     /* this is auxiliary routine used to perform iterated operation\r\n on n-tuple \"integrand\" within domain scope */\r\n    var tuple;\r\n    switch (info.code.op)\r\n    {  case O_SETOF:\r\n        /* compute next n-tuple and add it to the set; in this case\r\n         duplicate n-tuples are silently ignored */\r\n        tuple = mpl_internal_eval_tuple(mpl, info.code.arg.loop.x);\r\n        if (mpl_internal_find_tuple(mpl, info.value, tuple) == null)\r\n            mpl_internal_add_tuple(mpl, info.value, tuple);\r\n        break;\r\n        case O_BUILD:\r\n            /* construct next n-tuple using current values assigned to\r\n             *free* dummy indices as its components and add it to the\r\n             set; in this case duplicate n-tuples cannot appear */\r\n            mpl_internal_add_tuple(mpl, info.value, mpl_internal_get_domain_tuple(mpl,\r\n                info.code.arg.loop.domain));\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_elemset(mpl, code){\r\n    var value, e, info;\r\n    xassert(code != null);\r\n    xassert(code.type == A_ELEMSET);\r\n    xassert(code.dim > 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_elemset(mpl, code.value.set);\r\n\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_MEMSET:\r\n        /* take member of set */\r\n    {   var tuple;\r\n        tuple = null;\r\n        for (e = code.arg.set.list; e != null; e = e.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        value = mpl_internal_copy_elemset(mpl,\r\n            mpl_internal_eval_member_set(mpl, code.arg.set.set, tuple));\r\n    }\r\n        break;\r\n        case O_MAKE:\r\n            /* make elemental set of n-tuples */\r\n        {\r\n            value = mpl_internal_create_elemset(mpl, code.dim);\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n                mpl_internal_check_then_add(mpl, value, mpl_internal_eval_tuple(mpl, e.x));\r\n        }\r\n            break;\r\n        case O_UNION:\r\n            /* union of two elemental sets */\r\n            value = mpl_internal_set_union(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DIFF:\r\n            /* difference between two elemental sets */\r\n            value = mpl_internal_set_diff(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SYMDIFF:\r\n            /* symmetric difference between two elemental sets */\r\n            value = mpl_internal_set_symdiff(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_INTER:\r\n            /* intersection of two elemental sets */\r\n            value = mpl_internal_set_inter(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_CROSS:\r\n            /* cross (Cartesian) product of two elemental sets */\r\n            value = mpl_internal_set_cross(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DOTS:\r\n            /* build \"arithmetic\" elemental set */\r\n            value = mpl_internal_create_arelset(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y),\r\n                code.arg.arg.z == null ? 1.0 : mpl_internal_eval_numeric(mpl,\r\n                    code.arg.arg.z));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_elemset(mpl, code.arg.arg.y);\r\n            else\r\n                value = mpl_internal_eval_elemset(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SETOF:\r\n            /* compute elemental set */\r\n        {   info ={};\r\n            info.code = code;\r\n            info.value = mpl_internal_create_elemset(mpl, code.dim);\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_set_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_BUILD:\r\n            /* build elemental set identical to domain set */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = mpl_internal_create_elemset(mpl, code.dim);\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_set_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.set = mpl_internal_copy_elemset(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_null_func(mpl, info){\r\n    /* this is dummy routine used to enter the domain scope */\r\n\r\n    xassert(info == null);\r\n}\r\n\r\nfunction mpl_internal_is_member(mpl, code, tuple){\r\n    var value, e, temp, j;\r\n    xassert(code != null);\r\n    xassert(code.type == A_ELEMSET);\r\n    xassert(code.dim > 0);\r\n    xassert(tuple != null);\r\n    switch (code.op)\r\n    {  case O_MEMSET:\r\n        /* check if given n-tuple is member of elemental set, which\r\n         is assigned to member of model set */\r\n    {\r\n        var set;\r\n        /* evaluate reference to elemental set */\r\n        temp = null;\r\n        for (e = code.arg.set.list; e != null; e = e.next)\r\n            temp = mpl_internal_expand_tuple(mpl, temp, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        set = mpl_internal_eval_member_set(mpl, code.arg.set.set, temp);\r\n        /* check if the n-tuple is contained in the set array */\r\n        temp = mpl_internal_build_subtuple(mpl, tuple, set.dim);\r\n        value = (mpl_internal_find_tuple(mpl, set, temp) != null);\r\n    }\r\n        break;\r\n        case O_MAKE:\r\n            /* check if given n-tuple is member of literal set */\r\n        {\r\n            var that;\r\n            value = 0;\r\n            temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  that = mpl_internal_eval_tuple(mpl, e.x);\r\n                value = (mpl_internal_compare_tuples(mpl, temp, that) == 0);\r\n                if (value) break;\r\n            }\r\n        }\r\n            break;\r\n        case O_UNION:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) ||\r\n                mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_DIFF:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) &&\r\n                !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_SYMDIFF:\r\n        {   var in1 = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);\r\n            var in2 = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            value = (in1 && !in2) || (!in1 && in2);\r\n        }\r\n            break;\r\n        case O_INTER:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) &&\r\n                mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_CROSS:\r\n        {\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);\r\n            if (value)\r\n            {  for (j = 1; j <= code.arg.arg.x.dim; j++)\r\n            {  xassert(tuple != null);\r\n                tuple = tuple.next;\r\n            }\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            }\r\n        }\r\n            break;\r\n        case O_DOTS:\r\n            /* check if given 1-tuple is member of \"arithmetic\" set */\r\n        {\r\n            var x, t0, tf, dt;\r\n            xassert(code.dim == 1);\r\n            /* compute \"parameters\" of the \"arithmetic\" set */\r\n            t0 = mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            tf = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n            if (code.arg.arg.z == null)\r\n                dt = 1.0;\r\n            else\r\n                dt = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n            /* make sure the parameters are correct */\r\n            mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n            /* if component of 1-tuple is symbolic, not numeric, the\r\n             1-tuple cannot be member of \"arithmetic\" set */\r\n            xassert(tuple.sym != null);\r\n            if (tuple.sym.str != null)\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            /* determine numeric value of the component */\r\n            x = tuple.sym.num;\r\n            /* if the component value is out of the set range, the\r\n             1-tuple is not in the set */\r\n            if (dt > 0.0 && !(t0 <= x && x <= tf) ||\r\n                dt < 0.0 && !(tf <= x && x <= t0))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            /* estimate ordinal number of the 1-tuple in the set */\r\n            j = ((((x - t0) / dt) + 0.5)|0) + 1;\r\n            /* perform the main check */\r\n            value = (mpl_internal_arelset_member(mpl, t0, tf, dt, j) == x);\r\n        }\r\n            break;\r\n        case O_FORK:\r\n            /* check if given n-tuple is member of conditional set */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            else\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.z, tuple);\r\n            break;\r\n        case O_SETOF:\r\n            /* check if given n-tuple is member of computed set */\r\n            /* it is not clear how to efficiently perform the check not\r\n             computing the entire elemental set :+( */\r\n            mpl_internal_error(mpl, \"implementation restriction; in/within setof{} not allowed\");\r\n            break;\r\n        case O_BUILD:\r\n            /* check if given n-tuple is member of domain set */\r\n        {\r\n            temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);\r\n            /* try to enter the domain scope; if it is successful,\r\n             the n-tuple is in the domain set */\r\n            value = (mpl_internal_eval_within_domain(mpl, code.arg.loop.domain,\r\n                temp, null, mpl_internal_null_func) == 0);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_form_func(mpl, info)\r\n{     /* this is auxiliary routine used to perform iterated operation\r\n on linear form \"integrand\" within domain scope */\r\n    switch (info.code.op)\r\n    {  case O_SUM:\r\n        /* summation over domain */\r\n        /* the routine linear_comb needs to look through all terms\r\n         of both linear forms to reduce identical terms, so using\r\n         it here is not a good idea (for example, evaluation of\r\n         sum{i in 1..n} x[i] required quadratic time); the better\r\n         idea is to gather all terms of the integrand in one list\r\n         and reduce identical terms only once after all terms of\r\n         the resultant linear form have been evaluated */\r\n    {   var term;\r\n        var form = mpl_internal_eval_formula(mpl, info.code.arg.loop.x);\r\n        if (info.value == null)\r\n        {  xassert(info.tail == null);\r\n            info.value = form;\r\n        }\r\n        else\r\n        {  xassert(info.tail != null);\r\n            info.tail.next = form;\r\n        }\r\n        for (term = form; term != null; term = term.next)\r\n            info.tail = term;\r\n    }\r\n        break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_formula(mpl, code){\r\n    var value;\r\n    xassert(code != null);\r\n    xassert(code.type == A_FORMULA);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_formula(mpl, code.value.form);\r\n\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_MEMVAR:\r\n        /* take member of variable */\r\n    {\r\n        var e;\r\n        var tuple = null;\r\n        for (e = code.arg.var_.list; e != null; e = e.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        xassert(code.arg.var_.suff == DOT_NONE);\r\n        value = mpl_internal_single_variable(mpl,\r\n            mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple));\r\n    }\r\n        break;\r\n        case O_CVTLFM:\r\n            /* convert to linear form */\r\n            value = mpl_internal_constant_term(mpl, mpl_internal_eval_numeric(mpl,\r\n                code.arg.arg.x));\r\n            break;\r\n        case O_PLUS:\r\n            /* unary plus */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                0.0, mpl_internal_constant_term(mpl, 0.0),\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_MINUS:\r\n            /* unary minus */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                0.0, mpl_internal_constant_term(mpl, 0.0),\r\n                -1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ADD:\r\n            /* addition */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SUB:\r\n            /* subtraction */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                -1.0, mpl_internal_eval_formula(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MUL:\r\n            /* multiplication */\r\n            xassert(code.arg.arg.x != null);\r\n            xassert(code.arg.arg.y != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n            {  xassert(code.arg.arg.y.type == A_FORMULA);\r\n                value = mpl_internal_linear_comb(mpl,\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                    mpl_internal_eval_formula(mpl, code.arg.arg.y),\r\n                    0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            }\r\n            else\r\n            {  xassert(code.arg.arg.x.type == A_FORMULA);\r\n                xassert(code.arg.arg.y.type == A_NUMERIC);\r\n                value = mpl_internal_linear_comb(mpl,\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y),\r\n                    mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                    0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            }\r\n            break;\r\n        case O_DIV:\r\n            /* division */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                mpl_internal_fp_div(mpl, 1.0, mpl_internal_eval_numeric(mpl, code.arg.arg.y)),\r\n                mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_formula(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = mpl_internal_constant_term(mpl, 0.0);\r\n            else\r\n                value = mpl_internal_eval_formula(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SUM:\r\n            /* summation over domain */\r\n        {   var info = {};\r\n            info.code = code;\r\n            info.value = mpl_internal_constant_term(mpl, 0.0);\r\n            info.tail = null;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_form_func);\r\n            value = mpl_internal_reduce_terms(mpl, info.value);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.form = mpl_internal_copy_formula(mpl, value);\r\n    return value;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        DATA TABLES                         * * */\r\n/**********************************************************************/\r\n\r\nvar mpl_tab_num_args = exports[\"mpl_tab_num_args\"] = function(dca){\r\n    /* returns the number of arguments */\r\n    return dca.na;\r\n};\r\n\r\nvar mpl_tab_get_arg = exports[\"mpl_tab_get_arg\"] = function(dca, k){\r\n    /* returns pointer to k-th argument */\r\n    xassert(1 <= k && k <= dca.na);\r\n    return dca.arg[k];\r\n};\r\n\r\nvar mpl_tab_get_args = exports[\"mpl_tab_get_args\"] = function(dca, k){\r\n    return dca.arg;\r\n};\r\n\r\nvar mpl_tab_num_flds = exports[\"mpl_tab_num_flds\"] = function (dca){\r\n    /* returns the number of fields */\r\n    return dca.nf;\r\n};\r\n\r\nvar mpl_tab_get_name = exports[\"mpl_tab_get_name\"] = function(dca, k)\r\n{     /* returns pointer to name of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    return dca.name[k];\r\n};\r\n\r\nvar mpl_tab_get_type = exports[\"mpl_tab_get_type\"] = function(dca, k)\r\n{     /* returns type of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    return dca.type[k];\r\n};\r\n\r\nvar mpl_tab_get_num = exports[\"mpl_tab_get_num\"] = function(dca, k){\r\n    /* returns numeric value of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == 'N');\r\n    return dca.num[k];\r\n};\r\n\r\nvar mpl_tab_get_str = exports[\"mpl_tab_get_str\"] = function(dca, k){\r\n    /* returns pointer to string value of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == 'S');\r\n    xassert(dca.str[k] != null);\r\n    return dca.str[k];\r\n};\r\n\r\nvar mpl_tab_set_num = exports[\"mpl_tab_set_num\"] = function(dca, k, num){\r\n    /* assign numeric value to k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == '?');\r\n    dca.type[k] = 'N';\r\n    dca.num[k] = num;\r\n};\r\n\r\nvar mpl_tab_set_str = exports[\"mpl_tab_set_str\"] = function(dca, k, str){\r\n    /* assign string value to k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == '?');\r\n    //xassert(str.length <= MAX_LENGTH);\r\n    xassert(dca.str[k] != null);\r\n    dca.type[k] = 'S';\r\n    dca.str[k] = str;\r\n};\r\n\r\nfunction mpl_internal_write_func(mpl, tab){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var dca = mpl.dca;\r\n    var out;\r\n    var sym;\r\n    var k;\r\n    /* evaluate field values */\r\n    k = 0;\r\n    for (out = tab.u.out.list; out != null; out = out.next)\r\n    {  k++;\r\n        switch (out.code.type)\r\n        {  case A_NUMERIC:\r\n            dca.type[k] = 'N';\r\n            dca.num[k] = mpl_internal_eval_numeric(mpl, out.code);\r\n            dca.str[k][0] = '\\0';\r\n            break;\r\n            case A_SYMBOLIC:\r\n                sym = mpl_internal_eval_symbolic(mpl, out.code);\r\n                if (sym.str == null)\r\n                {  dca.type[k] = 'N';\r\n                    dca.num[k] = sym.num;\r\n                    dca.str[k][0] = '\\0';\r\n                }\r\n                else\r\n                {  dca.type[k] = 'S';\r\n                    dca.num[k] = 0.0;\r\n                    dca.str[k] = sym.str;\r\n                }\r\n                break;\r\n            default:\r\n                xassert(out != out);\r\n        }\r\n    }\r\n    /* write record to output table */\r\n    mpl_tab_drv_write(mpl);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_table(mpl, tab){\r\n    /* execute table statement */\r\n    var arg;\r\n    var fld;\r\n    var in_;\r\n    var out;\r\n    var dca;\r\n    var set;\r\n    var k;\r\n    var buf; // [MAX_LENGTH+1];\r\n    /* allocate table driver communication area */\r\n    xassert(mpl.dca == null);\r\n    mpl.dca = dca = {};\r\n    dca.id = 0;\r\n    dca.link = null;\r\n    dca.na = 0;\r\n    dca.arg = null;\r\n    dca.nf = 0;\r\n    dca.name = null;\r\n    dca.type = null;\r\n    dca.num = null;\r\n    dca.str = null;\r\n    /* allocate arguments */\r\n    xassert(dca.na == 0);\r\n    for (arg = tab.arg; arg != null; arg = arg.next)\r\n        dca.na++;\r\n    dca.arg = new Array(1+dca.na);\r\n    for (k = 1; k <= dca.na; k++) dca.arg[k] = null;\r\n    /* evaluate argument values */\r\n    k = 0;\r\n    for (arg = tab.arg; arg != null; arg = arg.next)\r\n    {\r\n        k++;\r\n        xassert(arg.code.type == A_SYMBOLIC);\r\n        var sym = mpl_internal_eval_symbolic(mpl, arg.code);\r\n        if (sym.str == null)\r\n            buf = String(sym.num);\r\n        else\r\n            buf = sym.str;\r\n        dca.arg[k] = buf;\r\n    }\r\n    /* perform table input/output */\r\n    switch (tab.type)    {\r\n        case A_INPUT:\r\n            /* read data from input table */\r\n            /* add the only member to the control set and assign it empty\r\n             elemental set */\r\n            set = tab.u.in_.set;\r\n            if (set != null)\r\n            {  if (set.data)\r\n                mpl_internal_error(mpl, set.name + \" already provided with data\");\r\n                xassert(set.array.head == null);\r\n                mpl_internal_add_member(mpl, set.array, null).value.set =\r\n                    mpl_internal_create_elemset(mpl, set.dimen);\r\n                set.data = 1;\r\n            }\r\n            /* check parameters specified in the input list */\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n            {  if (in_.par.data)\r\n                mpl_internal_error(mpl, in_.par.name + \" already provided with data\");\r\n                in_.par.data = 1;\r\n            }\r\n            /* allocate and initialize fields */\r\n            xassert(dca.nf == 0);\r\n            for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n                dca.nf++;\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n                dca.nf++;\r\n            dca.name = new Array(1+dca.nf);\r\n            dca.type = new Array(1+dca.nf);\r\n            dca.num = new Float64Array(1+dca.nf);\r\n            dca.str = new Array(1+dca.nf);\r\n            k = 0;\r\n            for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n            {   k++;\r\n                dca.name[k] = fld.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n            {   k++;\r\n                dca.name[k] = in_.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            /* open input table */\r\n            mpl_tab_drv_open(mpl, 'R');\r\n            /* read and process records */\r\n            for (;;)\r\n            {   var tup;\r\n                /* reset field types */\r\n                for (k = 1; k <= dca.nf; k++)\r\n                    dca.type[k] = '?';\r\n                /* read next record */\r\n                if (mpl_tab_drv_read(mpl)) break;\r\n                /* all fields must be set by the driver */\r\n                for (k = 1; k <= dca.nf; k++)\r\n                {  if (dca.type[k] == '?')\r\n                    mpl_internal_error(mpl, \"field \" + dca.name[k] + \" missing in input table\");\r\n                }\r\n                /* construct n-tuple */\r\n                tup = null;\r\n                k = 0;\r\n                for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n                {  k++;\r\n                    xassert(k <= dca.nf);\r\n                    switch (dca.type[k])\r\n                    {  case 'N':\r\n                        tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_num(mpl,\r\n                            dca.num[k]));\r\n                        break;\r\n                        case 'S':\r\n                            //xassert(dca.str[k].length <= MAX_LENGTH);\r\n                            tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_str(mpl, dca.str[k]));\r\n                            break;\r\n                        default:\r\n                            xassert(dca != dca);\r\n                    }\r\n                }\r\n                /* add n-tuple just read to the control set */\r\n                if (tab.u.in_.set != null)\r\n                    mpl_internal_check_then_add(mpl, tab.u.in_.set.array.head.value.set,\r\n                        mpl_internal_copy_tuple(mpl, tup));\r\n                /* assign values to the parameters in the input list */\r\n                for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n                {   var memb;\r\n                    k++;\r\n                    xassert(k <= dca.nf);\r\n                    /* there must be no member with the same n-tuple */\r\n                    if (mpl_internal_find_member(mpl, in_.par.array, tup) != null)\r\n                        mpl_internal_error(mpl, in_.par.name + mpl_internal_format_tuple(mpl, '[', tup) + \" already defined\");\r\n                    /* create new parameter member with given n-tuple */\r\n                    memb = mpl_internal_add_member(mpl, in_.par.array, mpl_internal_copy_tuple(mpl, tup))\r\n                    ;\r\n                    /* assign value to the parameter member */\r\n                    switch (in_.par.type)\r\n                    {  case A_NUMERIC:\r\n                        case A_INTEGER:\r\n                        case A_BINARY:\r\n                            if (dca.type[k] != 'N')\r\n                                mpl_internal_error(mpl, in_.par.name + \" requires numeric data\");\r\n                            memb.value.num = dca.num[k];\r\n                            break;\r\n                        case A_SYMBOLIC:\r\n                            switch (dca.type[k])\r\n                            {  case 'N':\r\n                                memb.value.sym = mpl_internal_create_symbol_num(mpl,\r\n                                    dca.num[k]);\r\n                                break;\r\n                                case 'S':\r\n                                    //xassert(dca.str[k].length <= MAX_LENGTH);\r\n                                    memb.value.sym = mpl_internal_create_symbol_str(mpl, dca.str[k]);\r\n                                    break;\r\n                                default:\r\n                                    xassert(dca != dca);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            xassert(in_ != in_);\r\n                    }\r\n                }\r\n            }\r\n            /* close input table */\r\n            mpl.dca = null;\r\n            break;\r\n        case A_OUTPUT:\r\n            /* write data to output table */\r\n            /* allocate and initialize fields */\r\n            xassert(dca.nf == 0);\r\n            for (out = tab.u.out.list; out != null; out = out.next)\r\n                dca.nf++;\r\n            dca.name = new Array(1+dca.nf);\r\n            dca.type = new Array(1+dca.nf);\r\n            dca.num = new Float64Array(1+dca.nf);\r\n            dca.str = new Array(1+dca.nf);\r\n            k = 0;\r\n            for (out = tab.u.out.list; out != null; out = out.next)\r\n            {  k++;\r\n                dca.name[k] = out.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            /* open output table */\r\n            mpl_tab_drv_open(mpl, 'W');\r\n            /* evaluate fields and write records */\r\n            mpl_internal_loop_within_domain(mpl, tab.u.out.domain, tab, mpl_internal_write_func);\r\n            /* close output table */\r\n            mpl_tab_drv_flush(mpl);\r\n            mpl.dca = null;\r\n            break;\r\n        default:\r\n            xassert(tab != tab);\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL STATEMENTS                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_func(mpl, chk){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (!mpl_internal_eval_logical(mpl, chk.code))\r\n        mpl_internal_error(mpl, \"check\" + mpl_internal_format_tuple(mpl, '[', mpl_internal_get_domain_tuple(mpl, chk.domain)) + \" failed\");\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_check(mpl, chk){\r\n    mpl_internal_loop_within_domain(mpl, chk.domain, chk, mpl_internal_check_func);\r\n\r\n}\r\n\r\nfunction mpl_internal_display_set(mpl, set, memb){\r\n    /* display member of model set */\r\n    var s = memb.value.set;\r\n    var m;\r\n    mpl_internal_write_text(mpl, set.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + (s.head == null ? \" is empty\" : \":\"));\r\n    for (m = s.head; m != null; m = m.next)\r\n        mpl_internal_write_text(mpl, \"   \" + mpl_internal_format_tuple(mpl, '(', m.tuple));\r\n}\r\n\r\nfunction mpl_internal_display_par(mpl, par, memb){\r\n    /* display member of model parameter */\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \" = \" + memb.value.num);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \" = \" + mpl_internal_format_symbol(mpl, memb.value.sym));\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_var(mpl, var_, memb, suff){\r\n    /* display member of model variable */\r\n    if (suff == DOT_NONE || suff == DOT_VAL)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".val = \" +\r\n            memb.value.var_.prim);\r\n    else if (suff == DOT_LB)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".lb = \" +\r\n            (memb.value.var_.var_.lbnd == null ? -DBL_MAX : memb.value.var_.lbnd));\r\n    else if (suff == DOT_UB)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".ub = \" +\r\n            (memb.value.var_.var_.ubnd == null ? +DBL_MAX : memb.value.var_.ubnd));\r\n    else if (suff == DOT_STATUS)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".status = \" +\r\n            memb.value.var_.stat);\r\n    else if (suff == DOT_DUAL)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".dual = \" +\r\n            memb.value.var_.dual);\r\n    else\r\n        xassert(suff != suff);\r\n}\r\n\r\nfunction mpl_internal_display_con(mpl, con, memb, suff){\r\n    /* display member of model constraint */\r\n    if (suff == DOT_NONE || suff == DOT_VAL)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".val = \" +\r\n            memb.value.con.prim);\r\n    else if (suff == DOT_LB)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".lb = \" +\r\n            (memb.value.con.con.lbnd == null ? -DBL_MAX : memb.value.con.lbnd));\r\n    else if (suff == DOT_UB)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".ub = \" +\r\n            (memb.value.con.con.ubnd == null ? +DBL_MAX : memb.value.con.ubnd));\r\n    else if (suff == DOT_STATUS)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".status = \" +\r\n            memb.value.con.stat);\r\n    else if (suff == DOT_DUAL)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".dual = \" +\r\n            memb.value.con.dual);\r\n    else\r\n        xassert(suff != suff);\r\n}\r\n\r\nfunction mpl_internal_display_memb(mpl, code){\r\n    /* display member specified by pseudo-code */\r\n    var memb = {value:{}};\r\n    var e;\r\n    xassert(code.op == O_MEMNUM || code.op == O_MEMSYM\r\n        || code.op == O_MEMSET || code.op == O_MEMVAR\r\n        || code.op == O_MEMCON);\r\n    memb.tuple = null;\r\n    for (e = code.arg.par.list || code.arg.var_.list; e != null; e = e.next)\r\n        memb.tuple = mpl_internal_expand_tuple(mpl, memb.tuple, mpl_internal_eval_symbolic(mpl,\r\n            e.x));\r\n    switch (code.op)\r\n    {  case O_MEMNUM:\r\n        memb.value.num = mpl_internal_eval_member_num(mpl, code.arg.par.par,\r\n            memb.tuple);\r\n        mpl_internal_display_par(mpl, code.arg.par.par, memb);\r\n        break;\r\n        case O_MEMSYM:\r\n            memb.value.sym = mpl_internal_eval_member_sym(mpl, code.arg.par.par,\r\n                memb.tuple);\r\n            mpl_internal_display_par(mpl, code.arg.par.par, memb);\r\n            break;\r\n        case O_MEMSET:\r\n            memb.value.set = mpl_internal_eval_member_set(mpl, code.arg.set.set,\r\n                memb.tuple);\r\n            mpl_internal_display_set(mpl, code.arg.set.set, memb);\r\n            break;\r\n        case O_MEMVAR:\r\n            memb.value.var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_,\r\n                memb.tuple);\r\n            mpl_internal_display_var\r\n                (mpl, code.arg.var_.var_, memb, code.arg.var_.suff);\r\n            break;\r\n        case O_MEMCON:\r\n            memb.value.con = mpl_internal_eval_member_con(mpl, code.arg.con.con,\r\n                memb.tuple);\r\n            mpl_internal_display_con\r\n                (mpl, code.arg.con.con, memb, code.arg.con.suff);\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_code(mpl, code){\r\n    /* display value of expression */\r\n    switch (code.type)\r\n    {  case A_NUMERIC:\r\n        /* numeric value */\r\n    {\r\n        var num = mpl_internal_eval_numeric(mpl, code);\r\n        mpl_internal_write_text(mpl, String(num));\r\n    }\r\n        break;\r\n        case A_SYMBOLIC:\r\n            /* symbolic value */\r\n        {\r\n            var sym = mpl_internal_eval_symbolic(mpl, code);\r\n            mpl_internal_write_text(mpl, mpl_internal_format_symbol(mpl, sym));\r\n        }\r\n            break;\r\n        case A_LOGICAL:\r\n            /* logical value */\r\n        {\r\n            var bit = mpl_internal_eval_logical(mpl, code);\r\n            mpl_internal_write_text(mpl, bit ? \"true\" : \"false\");\r\n        }\r\n            break;\r\n        case A_TUPLE:\r\n            /* n-tuple */\r\n        {\r\n            var tuple = mpl_internal_eval_tuple(mpl, code);\r\n            mpl_internal_write_text(mpl, mpl_internal_format_tuple(mpl, '(', tuple));\r\n        }\r\n            break;\r\n        case A_ELEMSET:\r\n            /* elemental set */\r\n        {   var set = mpl_internal_eval_elemset(mpl, code);\r\n            if (set.head == 0)\r\n                mpl_internal_write_text(mpl, \"set is empty\");\r\n            for (var memb = set.head; memb != null; memb = memb.next)\r\n                mpl_internal_write_text(mpl, \"   \" + mpl_internal_format_tuple(mpl, '(', memb.tuple));\r\n        }\r\n            break;\r\n        case A_FORMULA:\r\n            /* linear form */\r\n        {   var term;\r\n            var form = mpl_internal_eval_formula(mpl, code);\r\n            if (form == null)\r\n                mpl_internal_write_text(mpl, \"linear form is empty\");\r\n            for (term = form; term != null; term = term.next)\r\n            {  if (term.var_ == null)\r\n                mpl_internal_write_text(mpl, \"   \" + term.coef);\r\n            else\r\n                mpl_internal_write_text(mpl, \"   \" + term.coef + \" \" + term.var_.var_.name + mpl_internal_format_tuple(mpl, '[', term.var_.memb.tuple));\r\n            }\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_func(mpl, dpy){\r\n    var memb;\r\n    /* this is auxiliary routine to work within domain scope */\r\n    for (var entry = dpy.list; entry != null; entry = entry.next)\r\n    {  if (entry.type == A_INDEX)\r\n    {  /* dummy index */\r\n        var slot = entry.u.slot;\r\n        mpl_internal_write_text(mpl, slot.name + \" = \" + mpl_internal_format_symbol(mpl, slot.value));\r\n    }\r\n    else if (entry.type == A_SET)\r\n    {  /* model set */\r\n        var set = entry.u.set;\r\n        if (set.assign != null)\r\n        {  /* the set has assignment expression; evaluate all its\r\n         members over entire domain */\r\n            mpl_internal_eval_whole_set(mpl, set);\r\n        }\r\n        else\r\n        {  /* the set has no assignment expression; refer to its\r\n         any existing member ignoring resultant value to check\r\n         the data provided the data section */\r\n            if (set.gadget != null && set.data == 0)\r\n            {  /* initialize the set with data from a plain set */\r\n                mpl_internal_saturate_set(mpl, set);\r\n            }\r\n            if (set.array.head != null)\r\n                mpl_internal_eval_member_set(mpl, set, set.array.head.tuple);\r\n        }\r\n        /* display all members of the set array */\r\n        if (set.array.head == null)\r\n            mpl_internal_write_text(mpl, set.name + \" has empty content\");\r\n        for (memb = set.array.head; memb != null; memb =\r\n            memb.next) mpl_internal_display_set(mpl, set, memb);\r\n    }\r\n    else if (entry.type == A_PARAMETER)\r\n    {  /* model parameter */\r\n        var par = entry.u.par;\r\n        if (par.assign != null)\r\n        {  /* the parameter has an assignment expression; evaluate\r\n         all its member over entire domain */\r\n            mpl_internal_eval_whole_par(mpl, par);\r\n        }\r\n        else\r\n        {  /* the parameter has no assignment expression; refer to\r\n         its any existing member ignoring resultant value to\r\n         check the data provided in the data section */\r\n            if (par.array.head != null)\r\n            {  if (par.type != A_SYMBOLIC)\r\n                mpl_internal_eval_member_num(mpl, par, par.array.head.tuple);\r\n            else\r\n                mpl_internal_eval_member_sym(mpl, par, par.array.head.tuple);\r\n            }\r\n        }\r\n        /* display all members of the parameter array */\r\n        if (par.array.head == null)\r\n            mpl_internal_write_text(mpl, par.name + \" has empty content\");\r\n        for (memb = par.array.head; memb != null; memb =\r\n            memb.next) mpl_internal_display_par(mpl, par, memb);\r\n    }\r\n    else if (entry.type == A_VARIABLE)\r\n    {  /* model variable */\r\n        var var_ = entry.u.var_;\r\n        xassert(mpl.flag_p);\r\n        /* display all members of the variable array */\r\n        if (var_.array.head == null)\r\n            mpl_internal_write_text(mpl, var_.name + \" has empty content\");\r\n        for (memb = var_.array.head; memb != null; memb = memb.next)\r\n            mpl_internal_display_var(mpl, var_, memb, DOT_NONE);\r\n    }\r\n    else if (entry.type == A_CONSTRAINT)\r\n    {  /* model constraint */\r\n        var con = entry.u.con;\r\n        xassert(mpl.flag_p);\r\n        /* display all members of the constraint array */\r\n        if (con.array.head == null)\r\n            mpl_internal_write_text(mpl, con.name + \" has empty content\");\r\n        for (memb = con.array.head; memb != null; memb = memb.next)\r\n            mpl_internal_display_con(mpl, con, memb, DOT_NONE);\r\n    }\r\n    else if (entry.type == A_EXPRESSION)\r\n    {  /* expression */\r\n        var code = entry.u.code;\r\n        if (code.op == O_MEMNUM || code.op == O_MEMSYM ||\r\n            code.op == O_MEMSET || code.op == O_MEMVAR ||\r\n            code.op == O_MEMCON)\r\n            mpl_internal_display_memb(mpl, code);\r\n        else\r\n            mpl_internal_display_code(mpl, code);\r\n    }\r\n    else\r\n        xassert(entry != entry);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_display(mpl, dpy){\r\n    mpl_internal_loop_within_domain(mpl, dpy.domain, dpy, mpl_internal_display_func);\r\n}\r\n\r\nfunction mpl_internal_print_char(mpl, c){\r\n    if (mpl.prt_fp == null)\r\n        mpl_internal_write_char(mpl, c);\r\n    else\r\n        mpl.prt_fp(c);\r\n}\r\n\r\nfunction mpl_internal_print_text(mpl, buf){\r\n    xassert(buf.length < OUTBUF_SIZE);\r\n    for (var c = 0; c < buf.length; c++) mpl_internal_print_char(mpl, buf[c]);\r\n}\r\n\r\nfunction mpl_internal_printf_func(mpl, prt){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var entry;\r\n    var fmt;\r\n    var from;\r\n    var c;\r\n    var value;\r\n    /* evaluate format control string */\r\n    var sym = mpl_internal_eval_symbolic(mpl, prt.fmt);\r\n    if (sym.str == null)\r\n        fmt = String(sym.num);\r\n    else\r\n        fmt = sym.str;\r\n    /* scan format control string and perform formatting output */\r\n    entry = prt.list;\r\n    for (c = 0; c < fmt.length; c++)\r\n    {  if (fmt[c] == '%')\r\n    {  /* scan format specifier */\r\n        from = c++;\r\n        if (fmt[c] == '%')\r\n        {  mpl_internal_print_char(mpl, '%');\r\n            continue;\r\n        }\r\n        if (entry == null) break;\r\n        /* scan optional flags */\r\n        while (fmt[c] == '-' || fmt[c] == '+' || fmt[c] == ' ' || fmt[c] == '#' || fmt[c] == '0') c++;\r\n        /* scan optional minimum field width */\r\n        while (isdigit(fmt[c])) c++;\r\n        /* scan optional precision */\r\n        if (fmt[c] == '.')\r\n        {  c++;\r\n            while (isdigit(fmt[c])) c++;\r\n        }\r\n        /* scan conversion specifier and perform formatting */\r\n        // save = (c+1);  *(c+1) = '\\0';\r\n        if (fmt[c] == 'd' || fmt[c] == 'i' || fmt[c] == 'e' || fmt[c] == 'E' ||\r\n            fmt[c] == 'f' || fmt[c] == 'F' || fmt[c] == 'g' || fmt[c] == 'G')\r\n        {  /* the specifier requires numeric value */\r\n            xassert(entry != null);\r\n            switch (entry.code.type)\r\n            {  case A_NUMERIC:\r\n                value = mpl_internal_eval_numeric(mpl, entry.code);\r\n                break;\r\n                case A_SYMBOLIC:\r\n                    sym = mpl_internal_eval_symbolic(mpl, entry.code);\r\n                    if (sym.str != null)\r\n                        mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, sym) + \" to floating-point number\");\r\n                    value = sym.num;\r\n                    break;\r\n                case A_LOGICAL:\r\n                    if (mpl_internal_eval_logical(mpl, entry.code))\r\n                        value = 1.0;\r\n                    else\r\n                        value = 0.0;\r\n                    break;\r\n                default:\r\n                    xassert(entry != entry);\r\n            }\r\n            if (fmt[c] == 'd' || fmt[c] == 'i')\r\n            {  var int_max = INT_MAX;\r\n                if (!(-int_max <= value && value <= +int_max))\r\n                    mpl_internal_error(mpl, \"cannot convert \" + value + \" to integer\");\r\n                mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), Math.floor(value + 0.5)|0));\r\n            }\r\n            else\r\n                mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), value));\r\n        }\r\n        else if (fmt[c] == 's')\r\n        {  /* the specifier requires symbolic value */\r\n            switch (entry.code.type)\r\n            {   case A_NUMERIC:\r\n                value = String(mpl_internal_eval_numeric(mpl, entry.code));\r\n                break;\r\n                case A_LOGICAL:\r\n                    if (mpl_internal_eval_logical(mpl, entry.code))\r\n                        value = \"T\";\r\n                    else\r\n                        value = \"F\";\r\n                    break;\r\n                case A_SYMBOLIC:\r\n                    sym = mpl_internal_eval_symbolic(mpl, entry.code);\r\n                    if (sym.str == null)\r\n                        value = String(sym.num);\r\n                    else\r\n                        value = sym.str;\r\n                    break;\r\n                default:\r\n                    xassert(entry != entry);\r\n            }\r\n            mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), value));\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"format specifier missing or invalid\");\r\n        //*(c+1) = save;\r\n        entry = entry.next;\r\n    }\r\n    else if (fmt[c] == '\\\\')\r\n    {  /* write some control character */\r\n        c++;\r\n        if (fmt[c] == 't')\r\n            mpl_internal_print_char(mpl, '\\t');\r\n        else if (fmt[c] == 'n')\r\n            mpl_internal_print_char(mpl, '\\n');\r\n        else if (fmt[c] == '\\0')\r\n        {  /* format string ends with backslash */\r\n            mpl_internal_error(mpl, \"invalid use of escape character \\\\ in format control string\");\r\n        }\r\n        else\r\n            mpl_internal_print_char(mpl, fmt[c]);\r\n    }\r\n    else\r\n    {  /* write character without formatting */\r\n        mpl_internal_print_char(mpl, fmt[c]);\r\n    }\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_printf(mpl, prt){\r\n    if (prt.fname == null)\r\n    {\r\n        mpl.prt_file = null;\r\n    }\r\n    else\r\n    {   /* evaluate file name string */\r\n        var sym = mpl_internal_eval_symbolic(mpl, prt.fname);\r\n        if (sym.str == null)\r\n            mpl.prt_file = sym.num;\r\n        else\r\n            mpl.prt_file = sym.str;\r\n    }\r\n    mpl_internal_loop_within_domain(mpl, prt.domain, prt, mpl_internal_printf_func);\r\n}\r\n\r\nfunction mpl_internal_for_func(mpl, fur){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var save = mpl.stmt;\r\n    for (var stmt = fur.list; stmt != null; stmt = stmt.next)\r\n        mpl_internal_execute_statement(mpl, stmt);\r\n    mpl.stmt = save;\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_for(mpl, fur){\r\n    mpl_internal_loop_within_domain(mpl, fur.domain, fur, mpl_internal_for_func);\r\n}\r\n\r\nfunction mpl_internal_execute_statement(mpl, stmt){\r\n    mpl.stmt = stmt;\r\n    switch (stmt.type)\r\n    {   case A_SET:\r\n        case A_PARAMETER:\r\n        case A_VARIABLE:\r\n            break;\r\n        case A_CONSTRAINT:\r\n            xprintf(\"Generating \" + stmt.u.con.name + \"...\");\r\n            mpl_internal_eval_whole_con(mpl, stmt.u.con);\r\n            break;\r\n        case A_TABLE:\r\n            switch (stmt.u.tab.type)\r\n            {  case A_INPUT:\r\n                xprintf(\"Reading \" + stmt.u.tab.name + \"...\");\r\n                break;\r\n                case A_OUTPUT:\r\n                    xprintf(\"Writing \" + stmt.u.tab.name + \"...\");\r\n                    break;\r\n                default:\r\n                    xassert(stmt != stmt);\r\n            }\r\n            mpl_internal_execute_table(mpl, stmt.u.tab);\r\n            break;\r\n        case A_SOLVE:\r\n            break;\r\n        case A_CHECK:\r\n            xprintf(\"Checking (line \" + stmt.line + \")...\");\r\n            mpl_internal_execute_check(mpl, stmt.u.chk);\r\n            break;\r\n        case A_DISPLAY:\r\n            mpl_internal_write_text(mpl, \"Display statement at line \" + stmt.line);\r\n            mpl_internal_execute_display(mpl, stmt.u.dpy);\r\n            break;\r\n        case A_PRINTF:\r\n            mpl_internal_execute_printf(mpl, stmt.u.prt);\r\n            break;\r\n        case A_FOR:\r\n            mpl_internal_execute_for(mpl, stmt.u.fur);\r\n            break;\r\n        default:\r\n            xassert(stmt != stmt);\r\n    }\r\n}\r\n\r\n/* glpmpl04.c */\r\n\r\n/**********************************************************************/\r\n/* * *              GENERATING AND POSTSOLVING MODEL              * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_alloc_content(mpl){\r\n    var stmt;\r\n    /* walk through all model statements */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  switch (stmt.type)\r\n    {  case A_SET:\r\n            /* model set */\r\n            xassert(stmt.u.set.array == null);\r\n            stmt.u.set.array = mpl_internal_create_array(mpl, A_ELEMSET,\r\n                stmt.u.set.dim);\r\n            break;\r\n        case A_PARAMETER:\r\n            /* model parameter */\r\n            xassert(stmt.u.par.array == null);\r\n            switch (stmt.u.par.type)\r\n            {  case A_NUMERIC:\r\n                case A_INTEGER:\r\n                case A_BINARY:\r\n                    stmt.u.par.array = mpl_internal_create_array(mpl, A_NUMERIC,\r\n                        stmt.u.par.dim);\r\n                    break;\r\n                case A_SYMBOLIC:\r\n                    stmt.u.par.array = mpl_internal_create_array(mpl, A_SYMBOLIC,\r\n                        stmt.u.par.dim);\r\n                    break;\r\n                default:\r\n                    xassert(stmt != stmt);\r\n            }\r\n            break;\r\n        case A_VARIABLE:\r\n            /* model variable */\r\n            xassert(stmt.u.var_.array == null);\r\n            stmt.u.var_.array = mpl_internal_create_array(mpl, A_ELEMVAR,\r\n                stmt.u.var_.dim);\r\n            break;\r\n        case A_CONSTRAINT:\r\n            /* model constraint/objective */\r\n            xassert(stmt.u.con.array == null);\r\n            stmt.u.con.array = mpl_internal_create_array(mpl, A_ELEMCON,\r\n                stmt.u.con.dim);\r\n            break;\r\n        case A_TABLE:\r\n        case A_SOLVE:\r\n        case A_CHECK:\r\n        case A_DISPLAY:\r\n        case A_PRINTF:\r\n        case A_FOR:\r\n            /* functional statements have no content array */\r\n            break;\r\n        default:\r\n            xassert(stmt != stmt);\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_generate_model(mpl){\r\n    var stmt;\r\n\r\n    xassert(!mpl.flag_p);\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {   mpl_internal_execute_statement(mpl, stmt);\r\n        if (mpl.stmt.type == A_SOLVE) break;\r\n    }\r\n    mpl.stmt = stmt;\r\n}\r\n\r\nfunction mpl_internal_build_problem(mpl){\r\n    var stmt;\r\n\r\n    var memb;\r\n    var v;\r\n    var c;\r\n    var t;\r\n    var i, j;\r\n    xassert(mpl.m == 0);\r\n    xassert(mpl.n == 0);\r\n    xassert(mpl.row == null);\r\n    xassert(mpl.col == null);\r\n    /* check that all elemental variables has zero column numbers */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n            xassert(memb.value.var_.j == 0);\r\n    }\r\n    }\r\n    /* assign row numbers to elemental constraints and objectives */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_CONSTRAINT)\r\n    {  c = stmt.u.con;\r\n        for (memb = c.array.head; memb != null; memb = memb.next)\r\n        {  xassert(memb.value.con.i == 0);\r\n            memb.value.con.i = ++mpl.m;\r\n            /* walk through linear form and mark elemental variables,\r\n             which are referenced at least once */\r\n            for (t = memb.value.con.form; t != null; t = t.next)\r\n            {  xassert(t.var_ != null);\r\n                t.var_.memb.value.var_.j = -1;\r\n            }\r\n        }\r\n    }\r\n    }\r\n    /* assign column numbers to marked elemental variables */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n            if (memb.value.var_.j != 0) memb.value.var_.j =\r\n                ++mpl.n;\r\n    }\r\n    }\r\n    /* build list of rows */\r\n    mpl.row = new Array(1+mpl.m);\r\n    for (i = 1; i <= mpl.m; i++) mpl.row[i] = null;\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_CONSTRAINT)\r\n    {  c = stmt.u.con;\r\n        for (memb = c.array.head; memb != null; memb = memb.next)\r\n        {  i = memb.value.con.i;\r\n            xassert(1 <= i && i <= mpl.m);\r\n            xassert(mpl.row[i] == null);\r\n            mpl.row[i] = memb.value.con;\r\n        }\r\n    }\r\n    }\r\n    for (i = 1; i <= mpl.m; i++) xassert(mpl.row[i] != null);\r\n    /* build list of columns */\r\n    mpl.col = new Array(1+mpl.n);\r\n    for (j = 1; j <= mpl.n; j++) mpl.col[j] = null;\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n        {  j = memb.value.var_.j;\r\n            if (j == 0) continue;\r\n            xassert(1 <= j && j <= mpl.n);\r\n            xassert(mpl.col[j] == null);\r\n            mpl.col[j] = memb.value.var_;\r\n        }\r\n    }\r\n    }\r\n    for (j = 1; j <= mpl.n; j++) xassert(mpl.col[j] != null);\r\n}\r\n\r\nfunction mpl_internal_postsolve_model(mpl){\r\n    var stmt;\r\n\r\n    xassert(!mpl.flag_p);\r\n    mpl.flag_p = 1;\r\n    for (stmt = mpl.stmt; stmt != null; stmt = stmt.next)\r\n        mpl_internal_execute_statement(mpl, stmt);\r\n    mpl.stmt = null;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        INPUT/OUTPUT                        * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_open_input(mpl, name, callback){\r\n    mpl.line = 0;\r\n    mpl.column = 0;\r\n    mpl.c = '\\n';\r\n    mpl.token = 0;\r\n    mpl.imlen = 0;\r\n    mpl.image = '';\r\n    mpl.value = 0.0;\r\n    mpl.b_token = T_EOF;\r\n    mpl.b_imlen = 0;\r\n    mpl.b_image = '';\r\n    mpl.b_value = 0.0;\r\n    mpl.f_dots = 0;\r\n    mpl.f_scan = 0;\r\n    mpl.f_token = 0;\r\n    mpl.f_imlen = 0;\r\n    mpl.f_image = '';\r\n    mpl.f_value = 0.0;\r\n    xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);\r\n    mpl.c_ptr = 0;\r\n    xassert(mpl.in_fp == null);\r\n    mpl.in_fp = callback;\r\n    mpl.in_file = name || 'input';\r\n    /* scan the very first character */\r\n    mpl_internal_get_char(mpl);\r\n    /* scan the very first token */\r\n    mpl_internal_get_token(mpl);\r\n}\r\n\r\nfunction mpl_internal_read_char(mpl){\r\n    var c;\r\n    xassert(mpl.in_fp != null);\r\n    c = mpl.in_fp();\r\n    if (c < 0)\r\n    {\r\n        c = MPL_EOF;\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction mpl_internal_close_input(mpl){\r\n    xassert(mpl.in_fp != null);\r\n    mpl.in_fp = null;\r\n}\r\n\r\nfunction mpl_internal_open_output(mpl, name, callback){\r\n    xassert(mpl.out_fp == null);\r\n    if (callback == null)\r\n    {\r\n        mpl.out_fp = function(data){xprintf(data)};\r\n    }\r\n    else\r\n    {   mpl.out_fp = callback;\r\n        mpl.out_file = name;\r\n    }\r\n    mpl.out_buffer = '';\r\n}\r\n\r\nfunction mpl_internal_write_char(mpl, c){\r\n    xassert(mpl.out_fp != null);\r\n    if (c == '\\n'){\r\n        mpl.out_fp(mpl.out_buffer, mpl.prt_file);\r\n        mpl.out_buffer = '';\r\n    } else\r\n        mpl.out_buffer += c;\r\n}\r\n\r\nfunction mpl_internal_write_text(mpl, str){\r\n    xassert(mpl.out_fp != null);\r\n    mpl.out_fp(str, mpl.prt_file);\r\n}\r\n\r\nfunction mpl_internal_flush_output(mpl){\r\n    xassert(mpl.out_fp != null);\r\n    if (mpl.out_buffer.length > 0){\r\n        mpl.out_fp(mpl.out_buffer, mpl.prt_file);\r\n        mpl.out_buffer = '';\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      SOLVER INTERFACE                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_error(mpl, msg){\r\n    var error;\r\n    switch (mpl.phase)\r\n    {  case 1:\r\n        case 2:\r\n            /* translation phase */\r\n            error = new Error(mpl.in_file + \":\" + mpl.line + \": \" + msg);\r\n            error[\"line\"] = mpl.line;\r\n            error[\"column\"] = mpl.column;\r\n            mpl_internal_print_context(mpl);\r\n            break;\r\n        case 3:\r\n            /* generation/postsolve phase */\r\n            var line = (mpl.stmt == null ? 0 : mpl.stmt.line);\r\n            var column = (mpl.stmt == null ? 0 : mpl.stmt.column);\r\n            error = new Error(line + \": \" + msg);\r\n            error[\"line\"] = line;\r\n            error[\"column\"] = column;\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    mpl.phase = 4;\r\n    throw error;\r\n}\r\n\r\nfunction mpl_internal_warning(mpl, msg){\r\n    switch (mpl.phase)\r\n    {  case 1:\r\n        case 2:\r\n            /* translation phase */\r\n            xprintf(mpl.in_file + \":\" + mpl.line + \": warning: \" + msg);\r\n            break;\r\n        case 3:\r\n            /* generation/postsolve phase */\r\n            xprintf(mpl.mod_file + \":\" + (mpl.stmt == null ? 0 : mpl.stmt.line) + \": warning: \" + msg);\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n}\r\n\r\nvar mpl_initialize = exports[\"mpl_initialize\"] = function(){\r\n    var mpl = {};\r\n    /* scanning segment */\r\n    mpl.line = 0;\r\n    mpl.column = 0;\r\n    mpl.c = 0;\r\n    mpl.token = 0;\r\n    mpl.imlen = 0;\r\n    mpl.image = '';\r\n    mpl.value = 0.0;\r\n    mpl.b_token = 0;\r\n    mpl.b_imlen = 0;\r\n    mpl.b_image = '';\r\n    mpl.b_value = 0.0;\r\n    mpl.f_dots = 0;\r\n    mpl.f_scan = 0;\r\n    mpl.f_token = 0;\r\n    mpl.f_imlen = 0;\r\n    mpl.f_image = '';\r\n    mpl.f_value = 0.0;\r\n    mpl.context = new Array(CONTEXT_SIZE);\r\n    xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);\r\n    mpl.c_ptr = 0;\r\n    mpl.flag_d = 0;\r\n    /* translating segment */\r\n    //mpl.pool = dmp_create_poolx(0);\r\n    mpl.tree = {};\r\n    mpl.model = null;\r\n    mpl.flag_x = 0;\r\n    mpl.as_within = 0;\r\n    mpl.as_in = 0;\r\n    mpl.as_binary = 0;\r\n    mpl.flag_s = 0;\r\n    /* common segment\r\n     mpl.strings = {};\r\n     mpl.symbols = {};\r\n     mpl.tuples = {};\r\n     mpl.arrays = {};\r\n     mpl.members = {};\r\n     mpl.elemvars = {};\r\n     mpl.formulae = {};\r\n     mpl.elemcons = {};*/\r\n    mpl.a_list = null;\r\n    mpl.sym_buf = '';\r\n    mpl.tup_buf = '';\r\n\r\n    /* generating/postsolving segment */\r\n    mpl.rand = rng_create_rand();\r\n    mpl.flag_p = 0;\r\n    mpl.stmt = null;\r\n    mpl.dca = null;\r\n    mpl.m = 0;\r\n    mpl.n = 0;\r\n    mpl.row = null;\r\n    mpl.col = null;\r\n    /* input/output segment */\r\n    mpl.in_fp = null;\r\n    mpl.in_file = null;\r\n    mpl.out_fp = null;\r\n    mpl.out_file = null;\r\n    mpl.prt_fp = null;\r\n    mpl.prt_file = null;\r\n    /* solver interface segment */\r\n    mpl.phase = 0;\r\n    mpl.mod_file = null;\r\n    mpl.mpl_buf = '';\r\n    return mpl;\r\n};\r\n\r\nvar mpl_read_model = exports[\"mpl_read_model\"] = function(mpl, name, callback, skip_data){\r\n\r\n    function skip(){\r\n        xprintf(mpl.line + \" line\" + (mpl.line == 1 ? \"\" : \"s\") + \" were read\");\r\n        mpl_internal_close_input(mpl);\r\n        /* return to the calling program */\r\n        return mpl.phase;\r\n    }\r\n\r\n    if (mpl.phase != 0)\r\n        xerror(\"mpl_read_model: invalid call sequence\");\r\n    if (callback == null)\r\n        xerror(\"mpl_read_model: no input specified\");\r\n    /* translate model section */\r\n    mpl.phase = 1;\r\n    xprintf(\"Reading model section from \" + name + \" ...\");\r\n    mpl_internal_open_input(mpl, name, callback);\r\n    mpl_internal_model_section(mpl);\r\n    if (mpl.model == null)\r\n        mpl_internal_error(mpl, \"empty model section not allowed\");\r\n    /* save name of the input text file containing model section for\r\n     error diagnostics during the generation phase */\r\n    mpl.mod_file = mpl.in_file;\r\n\r\n    /* allocate content arrays for all model objects */\r\n    mpl_internal_alloc_content(mpl);\r\n    /* optional data section may begin with the keyword 'data' */\r\n    if (mpl_internal_is_keyword(mpl, \"data\"))\r\n    {  if (skip_data)\r\n    {  mpl_internal_warning(mpl, \"data section ignored\");\r\n        return skip();\r\n    }\r\n        mpl.flag_d = 1;\r\n        mpl_internal_get_token(mpl /* data */);\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n        /* translate data section */\r\n        mpl.phase = 2;\r\n        xprintf(\"Reading data section from \" + name + \" ...\");\r\n        mpl_internal_data_section(mpl);\r\n    }\r\n    /* process end statement */\r\n    mpl_internal_end_statement(mpl);\r\n    return skip();\r\n};\r\n\r\nvar mpl_read_data = exports[\"mpl_read_data\"] = function(mpl, name, callback){\r\n    if (!(mpl.phase == 1 || mpl.phase == 2))\r\n        xerror(\"mpl_read_data: invalid call sequence\");\r\n    if (callback == null)\r\n        xerror(\"mpl_read_data: no input specified\");\r\n    /* process data section */\r\n    mpl.phase = 2;\r\n    xprintf(\"Reading data section from \" + name + \" ...\");\r\n    mpl.flag_d = 1;\r\n    mpl_internal_open_input(mpl, name, callback);\r\n    /* in this case the keyword 'data' is optional */\r\n    if (mpl_internal_is_literal(mpl, \"data\"))\r\n    {  mpl_internal_get_token(mpl /* data */);\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n    }\r\n    mpl_internal_data_section(mpl);\r\n    /* process end statement */\r\n    mpl_internal_end_statement(mpl);\r\n    xprintf(mpl.line + \" line\" + (mpl.line == 1 ? \"\" : \"s\") + \" were read\");\r\n    mpl_internal_close_input(mpl);\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\nvar mpl_generate = exports[\"mpl_generate\"] = function(mpl, name, callback, tablecb){\r\n    if (!(mpl.phase == 1 || mpl.phase == 2))\r\n        xerror(\"mpl_generate: invalid call sequence\");\r\n    /* generate model */\r\n    mpl.phase = 3;\r\n    mpl.tablecb = tablecb;\r\n    mpl_internal_open_output(mpl, name, callback);\r\n    mpl_internal_generate_model(mpl);\r\n    mpl_internal_flush_output(mpl);\r\n    /* build problem instance */\r\n    mpl_internal_build_problem(mpl);\r\n    /* generation phase has been finished */\r\n    xprintf(\"Model has been successfully generated\");\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\nvar mpl_get_prob_name = exports[\"mpl_get_prob_name\"] = function(mpl){\r\n    return mpl.mod_file;\r\n};\r\n\r\nvar mpl_get_num_rows = exports[\"mpl_get_num_rows\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_num_rows: invalid call sequence\");\r\n    return mpl.m;\r\n};\r\n\r\nvar mpl_get_num_cols = exports[\"mpl_get_num_cols\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_num_cols: invalid call sequence\");\r\n    return mpl.n;\r\n};\r\n\r\nvar mpl_get_row_name = exports[\"mpl_get_row_name\"] = function(mpl, i){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_name: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_name: i = \" + i + \"; row number out of range\");\r\n    var name = mpl.row[i].con.name;\r\n    var len = name.length;\r\n    xassert(len <= 255);\r\n    name += mpl_internal_format_tuple(mpl, '[', mpl.row[i].memb.tuple).slice(0, 255);\r\n    if (name.length == 255) name = name.slice(0,252) + '...';\r\n    xassert(name.length <= 255);\r\n    return name;\r\n};\r\n\r\nvar mpl_get_row_kind = exports[\"mpl_get_row_kind\"] = function(mpl, i){\r\n    var kind;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_kind: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_kind: i = \" + i + \"; row number out of range\");\r\n    switch (mpl.row[i].con.type)\r\n    {  case A_CONSTRAINT:\r\n        kind = MPL_ST; break;\r\n        case A_MINIMIZE:\r\n            kind = MPL_MIN; break;\r\n        case A_MAXIMIZE:\r\n            kind = MPL_MAX; break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar mpl_get_row_bnds = exports[\"mpl_get_row_bnds\"] = function(mpl, i, callback){\r\n    var con;\r\n    var type;\r\n    var lb, ub;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_bnds: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_bnds: i = \" + i + \"; row number out of range\");\r\n    con = mpl.row[i];\r\n    lb = (con.con.lbnd == null ? -DBL_MAX : con.lbnd);\r\n    ub = (con.con.ubnd == null ? +DBL_MAX : con.ubnd);\r\n    if (lb == -DBL_MAX && ub == +DBL_MAX){\r\n        type = MPL_FR; lb = ub = 0.0;\r\n    }\r\n    else if (ub == +DBL_MAX){\r\n        type = MPL_LO; ub = 0.0;\r\n    }\r\n    else if (lb == -DBL_MAX){\r\n        type = MPL_UP; lb = 0.0;\r\n    }\r\n    else if (con.con.lbnd != con.con.ubnd)\r\n        type = MPL_DB;\r\n    else\r\n        type = MPL_FX;\r\n    callback(lb, ub);\r\n    return type;\r\n};\r\n\r\nvar mpl_get_mat_row = exports[\"mpl_get_mat_row\"] = function(mpl, i, ndx, val){\r\n    var term;\r\n    var len = 0;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_mat_row: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_mat_row: i = \" + i + \"; row number out of range\");\r\n    for (term = mpl.row[i].form; term != null; term = term.next)\r\n    {  xassert(term.var_ != null);\r\n        len++;\r\n        xassert(len <= mpl.n);\r\n        if (ndx != null) ndx[len] = term.var_.j;\r\n        if (val != null) val[len] = term.coef;\r\n    }\r\n    return len;\r\n};\r\n\r\nvar mpl_get_row_c0 = exports[\"mpl_get_row_c0\"] = function(mpl, i){\r\n    var con;\r\n    var c0;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_c0: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_c0: i = \" + i + \"; row number out of range\");\r\n    con = mpl.row[i];\r\n    if (con.con.lbnd == null && con.con.ubnd == null)\r\n        c0 = - con.lbnd;\r\n    else\r\n        c0 = 0.0;\r\n    return c0;\r\n};\r\n\r\nvar mpl_get_col_name = exports[\"mpl_get_col_name\"] = function(mpl, j){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_name: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_name: j = \" + j + \"; column number out of range\");\r\n    var name = mpl.col[j].var_.name;\r\n    var len = name.length;\r\n    xassert(len <= 255);\r\n    name += mpl_internal_format_tuple(mpl, '[', mpl.col[j].memb.tuple);\r\n    if (name.length == 255) name = name.slice(0,252) + '...';\r\n    xassert(name.length <= 255);\r\n    return name;\r\n};\r\n\r\nvar mpl_get_col_kind = exports[\"mpl_get_col_kind\"] = function(mpl, j){\r\n    var kind;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_kind: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_kind: j = \" + j + \"; column number out of range\");\r\n    switch (mpl.col[j].var_.type)\r\n    {  case A_NUMERIC:\r\n        kind = MPL_NUM; break;\r\n        case A_INTEGER:\r\n            kind = MPL_INT; break;\r\n        case A_BINARY:\r\n            kind = MPL_BIN; break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar mpl_get_col_bnds = exports[\"mpl_get_col_bnds\"] = function(mpl, j, callback){\r\n    var var_;\r\n    var type;\r\n    var lb, ub;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_bnds: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_bnds: j = \" + j + \"; column number out of range\");\r\n    var_ = mpl.col[j];\r\n    lb = (var_.var_.lbnd == null ? -DBL_MAX : var_.lbnd);\r\n    ub = (var_.var_.ubnd == null ? +DBL_MAX : var_.ubnd);\r\n    if (lb == -DBL_MAX && ub == +DBL_MAX){\r\n        type = MPL_FR; lb = ub = 0.0;\r\n    }\r\n    else if (ub == +DBL_MAX){\r\n        type = MPL_LO; ub = 0.0;\r\n    }\r\n    else if (lb == -DBL_MAX){\r\n        type = MPL_UP; lb = 0.0;\r\n    }\r\n    else if (var_.var_.lbnd != var_.var_.ubnd)\r\n        type = MPL_DB;\r\n    else\r\n        type = MPL_FX;\r\n    callback(lb, ub);\r\n    return type;\r\n};\r\n\r\nvar mpl_has_solve_stmt = exports[\"mpl_has_solve_stmt\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_has_solve_stmt: invalid call sequence\");\r\n    return mpl.flag_s;\r\n};\r\n\r\nvar mpl_put_row_soln = exports[\"mpl_put_row_soln\"] = function(mpl, i, stat, prim, dual){\r\n    /* store row (constraint/objective) solution components */\r\n    xassert(mpl.phase == 3);\r\n    xassert(1 <= i && i <= mpl.m);\r\n    mpl.row[i].stat = stat;\r\n    mpl.row[i].prim = prim;\r\n    mpl.row[i].dual = dual;\r\n};\r\n\r\nvar mpl_put_col_soln = exports[\"mpl_put_col_soln\"] = function (mpl, j, stat, prim, dual){\r\n    /* store column (variable) solution components */\r\n    xassert(mpl.phase == 3);\r\n    xassert(1 <= j && j <= mpl.n);\r\n    mpl.col[j].stat = stat;\r\n    mpl.col[j].prim = prim;\r\n    mpl.col[j].dual = dual;\r\n};\r\n\r\nvar mpl_postsolve = exports[\"mpl_postsolve\"] = function(mpl){\r\n    if (!(mpl.phase == 3 && !mpl.flag_p))\r\n        xerror(\"mpl_postsolve: invalid call sequence\");\r\n    /* perform postsolving */\r\n    mpl_internal_postsolve_model(mpl);\r\n    mpl_internal_flush_output(mpl);\r\n    /* postsolving phase has been finished */\r\n    xprintf(\"Model has been successfully processed\");\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\n/* glpmpl05.c */\r\n\r\nfunction mpl_internal_fn_gmtime(mpl){\r\n    /* obtain the current calendar time (UTC) */\r\n    return Math.round(Date.now() / 1000);\r\n}\r\n\r\nvar mpl_internal_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\r\nvar mpl_internal_moon = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n\r\nfunction mpl_internal_mulstr(v, n){\r\n    var ret = '';\r\n    while (n > 0) {\r\n        ret += v;\r\n        n--;\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_error1(mpl, str, s, fmt, f, msg){\r\n    xprintf(\"Input string passed to str2time:\");\r\n    xprintf(str);\r\n    xprintf(mpl_internal_mulstr('^', s + 1));\r\n    xprintf(\"Format string passed to str2time:\\n\");\r\n    xprintf(fmt);\r\n    xprintf(mpl_internal_mulstr('^', f + 1));\r\n    mpl_internal_error(mpl, msg);\r\n}\r\n\r\nfunction mpl_internal_fn_str2time(mpl, str, fmt){\r\n    /* convert character string to the calendar time */\r\n    var j, year, month, day, hh, mm, ss, zone;\r\n    var s, f;\r\n\r\n    function err1(){mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset value incomplete or invalid\")}\r\n    function err2(){mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset value out of range\")}\r\n    function test(){\r\n        /* check a matching character in the input string */\r\n        if (str[s] != fmt[f])\r\n            mpl_internal_error1(mpl, str, s, fmt, f, \"character mismatch\");\r\n        s++;\r\n    }\r\n\r\n    year = month = day = hh = mm = ss = -1;\r\n    zone = INT_MAX;\r\n    s = 0;\r\n    for (f = 0; f < fmt.length; f++)\r\n    {  if (fmt[f] == '%')\r\n    {  f++;\r\n        if (fmt[f] == 'b' || fmt[f] == 'h')\r\n        {  /* the abbreviated month name */\r\n            var k;\r\n            var name;\r\n            if (month >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            for (month = 1; month <= 12; month++)\r\n            {  name = mpl_internal_moon[month-1];\r\n                var b = false;\r\n                for (k = 0; k <= 2; k++)\r\n                {  if (s[k].toUpperCase() != name[k].toUpperCase())\r\n                {b = true; break}\r\n                }\r\n                if (b) continue;\r\n                s += 3;\r\n                for (k = 3; name[k] != '\\0'; k++)\r\n                {  if (str[s].toUpperCase() != name[k].toUpperCase()) break;\r\n                    s++;\r\n                }\r\n                break;\r\n            }\r\n            if (month > 12)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"abbreviated month name missing or invalid\");\r\n        }\r\n        else if (fmt[f] == 'd')\r\n        {  /* the day of the month as a decimal number (01..31) */\r\n            if (day >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day missing or invalid\");\r\n            day = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                day = 10 * day + ((str[s++]) - '0');\r\n            if (!(1 <= day && day <= 31))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day out of range\");\r\n        }\r\n        else if (fmt[f] == 'H')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         (00..23) */\r\n            if (hh >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour missing or invalid\")\r\n                ;\r\n            hh = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                hh = 10 * hh + ((str[s++]) - '0');\r\n            if (!(0 <= hh && hh <= 23))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour out of range\");\r\n        }\r\n        else if (fmt[f] == 'm')\r\n        {  /* the month as a decimal number (01..12) */\r\n            if (month >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month multiply specified\"\r\n                );\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month missing or invalid\"\r\n                );\r\n            month = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                month = 10 * month + ((str[s++]) - '0');\r\n            if (!(1 <= month && month <= 12))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month out of range\");\r\n        }\r\n        else if (fmt[f] == 'M')\r\n        {  /* the minute as a decimal number (00..59) */\r\n            if (mm >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute missing or invalid\");\r\n            mm = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                mm = 10 * mm + ((str[s++]) - '0');\r\n            if (!(0 <= mm && mm <= 59))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute out of range\");\r\n        }\r\n        else if (fmt[f] == 'S')\r\n        {  /* the second as a decimal number (00..60) */\r\n            if (ss >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second missing or invalid\");\r\n            ss = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                ss = 10 * ss + ((str[s++]) - '0');\r\n            if (!(0 <= ss && ss <= 60))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second out of range\");\r\n        }\r\n        else if (fmt[f] == 'y')\r\n        {  /* the year without a century as a decimal number\r\n         (00..99); the values 00 to 68 mean the years 2000 to\r\n         2068 while the values 69 to 99 mean the years 1969 to\r\n         1999 */\r\n            if (year >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year missing or invalid\")\r\n                ;\r\n            year = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                year = 10 * year + ((str[s++]) - '0');\r\n            year += (year >= 69 ? 1900 : 2000);\r\n        }\r\n        else if (fmt[f] == 'Y')\r\n        {  /* the year as a decimal number, using the Gregorian\r\n         calendar */\r\n            if (year >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year missing or invalid\")\r\n                ;\r\n            year = 0;\r\n            for (j = 1; j <= 4; j++)\r\n            {  if (!('0' <= str[s] && str[s] <= '9')) break;\r\n                year = 10 * year + ((str[s++]) - '0');\r\n            }\r\n            if (!(1 <= year && year <= 4000))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year out of range\");\r\n        }\r\n        else if (fmt[f] == 'z')\r\n        {  /* time zone offset in the form zhhmm */\r\n            var z;\r\n            if (zone != INT_MAX)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (str[s] == 'Z')\r\n            {   z = hh = mm = 0; s++;\r\n\r\n            } else {\r\n                if (str[s] == '+'){\r\n                    z = +1; s++;\r\n                }\r\n                else if (str[s] == '-'){\r\n                    z = -1; s++;\r\n                }\r\n                else\r\n                    mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset sign missing\");\r\n                hh = 0;\r\n                for (j = 1; j <= 2; j++)\r\n                {  if (!('0' <= str[s] && str[s] <= '9'))\r\n                    err1();\r\n                    hh = 10 * hh + ((str[s++]) - '0');\r\n                }\r\n                if (hh > 23)\r\n                    err2();\r\n                if (str[s] == ':')\r\n                {  s++;\r\n                    if (!('0' <= str[s] && str[s] <= '9')) err1();\r\n                }\r\n                mm = 0;\r\n                if (('0' <= str[s] && str[s] <= '9')){\r\n                    for (j = 1; j <= 2; j++)\r\n                    {  if (!('0' <= str[s] && str[s] <= '9')) err1();\r\n                        mm = 10 * mm + ((str[s++]) - '0');\r\n                    }\r\n                    if (mm > 59) err2();\r\n                }\r\n            }\r\n            zone = z * (60 * hh + mm);\r\n        }\r\n        else if (fmt[f] == '%')\r\n        {  /* literal % character */\r\n            test();\r\n        }\r\n        else\r\n            mpl_internal_error1(mpl, str, s, fmt, f, \"invalid conversion specifier\");\r\n    }\r\n    else if (fmt[f] == ' '){\r\n\r\n    }\r\n    else\r\n        test()\r\n    }\r\n    if (year < 0) year = 1970;\r\n    if (month < 0) month = 1;\r\n    if (day < 0) day = 1;\r\n    if (hh < 0) hh = 0;\r\n    if (mm < 0) mm = 0;\r\n    if (ss < 0) ss = 0;\r\n    if (zone == INT_MAX) zone = 0;\r\n    j = jday(day, month, year);\r\n    xassert(j >= 0);\r\n    return (((j - jday(1, 1, 1970)) * 24.0 + hh) * 60.0 + mm) * 60.0 + ss - 60.0 * zone;\r\n}\r\n\r\nfunction mpl_internal_error2(mpl, fmt, f, msg)\r\n{\r\n    xprintf(\"Format string passed to time2str:\");\r\n    xprintf(fmt);\r\n    xprintf(mpl_internal_mulstr('^', f));\r\n    mpl_internal_error(mpl, msg);\r\n}\r\n\r\nfunction mpl_internal_weekday(j){\r\n    /* determine weekday number (1 = Mon, ..., 7 = Sun) */\r\n    return (j + jday(1, 1, 1970)) % 7 + 1;\r\n}\r\n\r\nfunction mpl_internal_firstday(year){\r\n    /* determine the first day of the first week for a specified year\r\n     according to ISO 8601 */\r\n    var j;\r\n    /* if 1 January is Monday, Tuesday, Wednesday or Thursday, it is\r\n     in week 01; if 1 January is Friday, Saturday or Sunday, it is\r\n     in week 52 or 53 of the previous year */\r\n    j = jday(1, 1, year) - jday(1, 1, 1970);\r\n    switch (mpl_internal_weekday(j))\r\n    {  case 1: /* 1 Jan is Mon */ j += 0; break;\r\n        case 2: /* 1 Jan is Tue */ j -= 1; break;\r\n        case 3: /* 1 Jan is Wed */ j -= 2; break;\r\n        case 4: /* 1 Jan is Thu */ j -= 3; break;\r\n        case 5: /* 1 Jan is Fri */ j += 3; break;\r\n        case 6: /* 1 Jan is Sat */ j += 2; break;\r\n        case 7: /* 1 Jan is Sun */ j += 1; break;\r\n        default: xassert(j != j);\r\n    }\r\n    /* the first day of the week must be Monday */\r\n    xassert(mpl_internal_weekday(j) == 1);\r\n    return j;\r\n}\r\n\r\nfunction mpl_internal_fn_time2str(mpl, t, fmt){\r\n    /* convert the calendar time to character string */\r\n    var j, year = 0, month = 0, day = 0, hh, mm, ss, len;\r\n    var temp;\r\n    var f;\r\n    var str = '', buf;\r\n    if (!(-62135596800.0 <= t && t <= 64092211199.0))\r\n        mpl_internal_error(mpl, \"time2str(\" + t + \",...); argument out of range\");\r\n    t = Math.floor(t + 0.5);\r\n    temp = Math.abs(t) / 86400.0;\r\n    j = Math.floor(temp);\r\n    if (t < 0.0)\r\n    {  if (temp == Math.floor(temp))\r\n        j = - j;\r\n    else\r\n        j = - (j + 1);\r\n    }\r\n    xassert(jdate(j + jday(1, 1, 1970), function(d,m,y){day=d;month=m;year=y}) == 0);\r\n    ss = (t - 86400.0 * j)|0;\r\n    xassert(0 <= ss && ss < 86400);\r\n    mm = ss / 60; ss %= 60;\r\n    hh = mm / 60; mm %= 60;\r\n    len = 0;\r\n    for (f = 0; f < fmt.length; f++)\r\n    {  if (fmt[f] == '%')\r\n    {  f++;\r\n        if (fmt[f] == 'a')\r\n        {  /* the abbreviated weekday name */\r\n            buf = mpl_internal_week[mpl_internal_weekday(j)-1].slice(0,3);\r\n        }\r\n        else if (fmt[f] == 'A')\r\n        {  /* the full weekday name */\r\n            buf = mpl_internal_week[mpl_internal_weekday(j)-1];\r\n        }\r\n        else if (fmt[f] == 'b' || fmt[f] == 'h')\r\n        {  /* the abbreviated month name */\r\n            buf = mpl_internal_moon[month-1].slice(0, 3);\r\n        }\r\n        else if (fmt[f] == 'B')\r\n        {  /* the full month name */\r\n            buf = mpl_internal_moon[month-1];\r\n        }\r\n        else if (fmt[f] == 'C')\r\n        {  /* the century of the year */\r\n            buf = String(Math.floor(year / 100));\r\n        }\r\n        else if (fmt[f] == 'd')\r\n        {  /* the day of the month as a decimal number (01..31) */\r\n            buf = String(day);\r\n        }\r\n        else if (fmt[f] == 'D')\r\n        {  /* the date using the format %m/%d/%y */\r\n            buf = month + \"/\" + day + \"/\" + (year % 100);\r\n        }\r\n        else if (fmt[f] == 'e')\r\n        {  /* the day of the month like with %d, but padded with\r\n         blank (1..31) */\r\n            buf = String(day);\r\n        }\r\n        else if (fmt[f] == 'F')\r\n        {  /* the date using the format %Y-%m-%d */\r\n            sprintf(buf, year + \"-\" + month + \"-\" + day);\r\n        }\r\n        else if (fmt[f] == 'g')\r\n        {  /* the year corresponding to the ISO week number, but\r\n         without the century (range 00 through 99); this has\r\n         the same format and value as %y, except that if the\r\n         ISO week number (see %V) belongs to the previous or\r\n         next year, that year is used instead */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = year - 1;\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = year;\r\n            else\r\n                iso = year + 1;\r\n            buf = String(iso % 100);\r\n        }\r\n        else if (fmt[f] == 'G')\r\n        {  /* the year corresponding to the ISO week number; this\r\n         has the same format and value as %Y, excepth that if\r\n         the ISO week number (see %V) belongs to the previous\r\n         or next year, that year is used instead */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = year - 1;\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = year;\r\n            else\r\n                iso = year + 1;\r\n            buf = String(iso);\r\n        }\r\n        else if (fmt[f] == 'H')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         (00..23) */\r\n            buf = String(hh);\r\n        }\r\n        else if (fmt[f] == 'I')\r\n        {  /* the hour as a decimal number, using a 12-hour clock\r\n         (01..12) */\r\n            buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\r\n        }\r\n        else if (fmt[f] == 'j')\r\n        {  /* the day of the year as a decimal number (001..366) */\r\n            buf  = String(jday(day, month, year) - jday(1, 1, year) + 1);\r\n        }\r\n        else if (fmt[f] == 'k')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         like %H, but padded with blank (0..23) */\r\n            buf = String(hh);\r\n        }\r\n        else if (fmt[f] == 'l')\r\n        {  /* the hour as a decimal number, using a 12-hour clock\r\n         like %I, but padded with blank (1..12) */\r\n            buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\r\n        }\r\n        else if (fmt[f] == 'm')\r\n        {  /* the month as a decimal number (01..12) */\r\n            buf = String(month);\r\n        }\r\n        else if (fmt[f] == 'M')\r\n        {  /* the minute as a decimal number (00..59) */\r\n            buf = String(mm);\r\n        }\r\n        else if (fmt[f] == 'p')\r\n        {  /* either AM or PM, according to the given time value;\r\n         noon is treated as PM and midnight as AM */\r\n            buf = (hh <= 11 ? \"AM\" : \"PM\");\r\n        }\r\n        else if (fmt[f] == 'P')\r\n        {  /* either am or pm, according to the given time value;\r\n         noon is treated as pm and midnight as am */\r\n            buf = (hh <= 11 ? \"am\" : \"pm\");\r\n        }\r\n        else if (fmt[f] == 'r')\r\n        {  /* the calendar time using the format %I:%M:%S %p */\r\n            buf = (hh == 0 ? 12 : hh <= 12 ? hh : hh - 12) + \":\" + mm + \":\" + ss + \" \" + (hh <= 11 ? \"AM\" : \"PM\");\r\n        }\r\n        else if (fmt[f] == 'R')\r\n        {  /* the hour and minute using the format %H:%M */\r\n            buf = hh + \":\" + mm;\r\n        }\r\n        else if (fmt[f] == 'S')\r\n        {  /* the second as a decimal number (00..59) */\r\n            buf = String(ss);\r\n        }\r\n        else if (fmt[f] == 'T')\r\n        {  /* the time of day using the format %H:%M:%S */\r\n            buf = hh + \":\" + mm + \":\" + ss;\r\n        }\r\n        else if (fmt[f] == 'u')\r\n        {  /* the day of the week as a decimal number (1..7),\r\n         Monday being 1 */\r\n            buf = String(mpl_internal_weekday(j));\r\n        }\r\n        else if (fmt[f] == 'U')\r\n        {  /* the week number of the current year as a decimal\r\n         number (range 00 through 53), starting with the first\r\n         Sunday as the first day of the first week; days\r\n         preceding the first Sunday in the year are considered\r\n         to be in week 00 */\r\n            /* sun = the first Sunday of the year */\r\n            var sun = jday(1, 1, year) - jday(1, 1, 1970);\r\n            sun += (7 - mpl_internal_weekday(sun));\r\n            buf = String((j + 7 - sun) / 7);\r\n        }\r\n        else if (fmt[f] == 'V')\r\n        {  /* the ISO week number as a decimal number (range 01\r\n         through 53); ISO weeks start with Monday and end with\r\n         Sunday; week 01 of a year is the first week which has\r\n         the majority of its days in that year; week 01 of\r\n         a year can contain days from the previous year; the\r\n         week before week 01 of a year is the last week (52 or\r\n         53) of the previous year even if it contains days\r\n         from the new year */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = j - mpl_internal_firstday(year - 1);\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = j - mpl_internal_firstday(year);\r\n            else\r\n                iso = j - mpl_internal_firstday(year + 1);\r\n            buf = String(iso / 7 + 1);\r\n        }\r\n        else if (fmt[f] == 'w')\r\n        {  /* the day of the week as a decimal number (0..6),\r\n         Sunday being 0 */\r\n            buf = String(mpl_internal_weekday(j) % 7);\r\n        }\r\n        else if (fmt[f] == 'W')\r\n        {  /* the week number of the current year as a decimal\r\n         number (range 00 through 53), starting with the first\r\n         Monday as the first day of the first week; days\r\n         preceding the first Monday in the year are considered\r\n         to be in week 00 */\r\n            /* mon = the first Monday of the year */\r\n            var mon = jday(1, 1, year) - jday(1, 1, 1970);\r\n            mon += (8 - mpl_internal_weekday(mon)) % 7;\r\n            buf = String((j + 7 - mon) / 7);\r\n        }\r\n        else if (fmt[f] == 'y')\r\n        {  /* the year without a century as a decimal number\r\n         (00..99) */\r\n            buf = String(year % 100);\r\n        }\r\n        else if (fmt[f] == 'Y')\r\n        {  /* the year as a decimal number, using the Gregorian\r\n         calendar */\r\n            buf = String(year);\r\n        }\r\n        else if (fmt[f] == '%')\r\n        {  /* a literal % character */\r\n            buf = '%';\r\n        }\r\n        else\r\n            mpl_internal_error2(mpl, fmt, f, \"invalid conversion specifier\");\r\n    }\r\n    else{\r\n        buf = fmt[f];\r\n        //buf[1] = '\\0';\r\n    }\r\n/*\r\n        if (len + buf.length > MAX_LENGTH)\r\n            mpl_internal_error(mpl, \"time2str; output string length exceeds \" + MAX_LENGTH + \" charaters\");\r\n*/\r\n        str += buf;\r\n        len += buf.length;\r\n    }\r\n    return str;\r\n}\r\n\r\n/* glpmpl06.c */\r\n\r\n/*****************************************\r\n Driver API\r\n *****************************************/\r\n\r\nvar MPL_DRIVERS = {};\r\n\r\nfunction mpl_tab_drv_open(mpl, mode){\r\n    var dca = mpl.dca;\r\n    xassert(dca.id == 0);\r\n    xassert(dca.link == null);\r\n    xassert(dca.na >= 1);\r\n\r\n    var Driver = MPL_DRIVERS[dca.arg[1].toLowerCase()];\r\n    if (Driver)\r\n        dca.link = new Driver(dca, mode, mpl.tablecb);\r\n    else\r\n        mpl_internal_error(mpl, \"Invalid table driver '\" + dca.arg[1] + \"'\");\r\n    if (dca.link == null)\r\n        mpl_internal_error(mpl, \"error on opening table \" + mpl.stmt.u.tab.name);\r\n}\r\n\r\nfunction mpl_tab_drv_read(mpl){\r\n    var dca = mpl.dca;\r\n    var ret = dca.link[\"readRecord\"](dca);\r\n    if (ret > 0)\r\n        mpl_internal_error(mpl, \"error on reading data from table \" + mpl.stmt.u.tab.name);\r\n    return ret;\r\n}\r\n\r\nfunction mpl_tab_drv_write(mpl){\r\n    var dca = mpl.dca;\r\n    var ret = dca.link[\"writeRecord\"](dca);\r\n    if (ret)\r\n        mpl_internal_error(mpl, \"error on writing data to table \" + mpl.stmt.u.tab.name);\r\n}\r\n\r\nfunction mpl_tab_drv_flush(mpl){\r\n    var dca = mpl.dca;\r\n    dca.link[\"flush\"](dca);\r\n}\r\n\r\nvar mpl_tab_drv_register = exports[\"mpl_tab_drv_register\"] = function (name, driver){\r\n    MPL_DRIVERS[name.toLowerCase()] = driver;\r\n};\r\n\r\n/*****************************************\r\n    CSV Driver\r\n *****************************************/\r\n\r\nfunction CSVDriver(dca, mode, tablecb){\r\n    /* open csv data file */\r\n    /* create control structure */\r\n    this.mode = mode;\r\n    this.fname = null;\r\n    this.count = 0;\r\n    this.c = '\\n';\r\n    this.what = 0;\r\n    this.field = '';\r\n    this.nf = 0;\r\n    this.ref = [];\r\n    this.tablecb = tablecb;\r\n\r\n    this.CSV_EOF   = 0;  /* end-of-file */\r\n    this.CSV_EOR   = 1;  /* end-of-record */\r\n    this.CSV_NUM   = 2;  /* floating-point number */\r\n    this.CSV_STR   = 3;  /* character string */\r\n\r\n\r\n    /* try to open the csv data file */\r\n    if (mpl_tab_num_args(dca) < 2)\r\n        xerror(\"csv_driver: file name not specified\\n\");\r\n    this.fname = mpl_tab_get_arg(dca, 2);\r\n    var k;\r\n    if (mode == 'R')\r\n    {   /* open the file for reading */\r\n\r\n        if (tablecb){\r\n            this.data = tablecb(dca.arg, mode);\r\n            this.cursor = 0;\r\n        } else\r\n            xerror(\"csv_driver: unable to open \" + this.fname);\r\n        this.nskip = 0;\r\n        /* skip fake new-line */\r\n        this.readField();\r\n        xassert(this.what == this.CSV_EOR);\r\n        /* read field names */\r\n        xassert(this.nf == 0);\r\n        for (;;)\r\n        {  this.readField();\r\n            if (this.what == this.CSV_EOR)\r\n                break;\r\n            if (this.what != this.CSV_STR)\r\n                xerror(this.fname + \":\" + this.count + \": invalid field name\\n\");\r\n            this.nf++;\r\n            /* find corresponding field in the table statement */\r\n            for (k = mpl_tab_num_flds(dca); k >= 1; k--)\r\n            {  if (mpl_tab_get_name(dca, k) == this.field)\r\n                break;\r\n            }\r\n            this.ref[this.nf] = k;\r\n        }\r\n        /* find dummy RECNO field in the table statement */\r\n        for (k = mpl_tab_num_flds(dca); k >= 1; k--)\r\n            if (mpl_tab_get_name(dca, k) == \"RECNO\") break;\r\n        this.ref[0] = k;\r\n    }\r\n    else if (mode == 'W')\r\n    {   this.data = '';\r\n        /* write field names */\r\n        var nf = mpl_tab_num_flds(dca);\r\n        for (k = 1; k <= nf; k++)\r\n            this.data += mpl_tab_get_name(dca, k) + ((k < nf)?',':'\\n');\r\n        this.count++;\r\n    }\r\n    else\r\n        xassert(mode != mode);\r\n}\r\n\r\nCSVDriver.prototype.readField = function(){\r\n    /* read field from csv data file */\r\n    /* check for end of file */\r\n    if (this.c == XEOF)\r\n    {   this.what = this.CSV_EOF;\r\n        this.field = \"EOF\";\r\n        return;\r\n    }\r\n    /* check for end of record */\r\n    if (this.c == '\\n')\r\n    {   this.what = this.CSV_EOR;\r\n        this.field = \"EOR\";\r\n        this.readChar();\r\n        if (this.c == ',')\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\\n\");\r\n        if (this.c == '\\n')\r\n            xerror(this.fname + \":\" + this.count + \": empty record not allowed\\n\");\r\n\r\n        /* skip comment records; may appear only before the very first\r\n         record containing field names */\r\n        if (this.c == '#' && this.count == 1)\r\n        {  while (this.c == '#')\r\n        {  while (this.c != '\\n')\r\n            this.readChar();\r\n            this.readChar();\r\n            this.nskip++;\r\n        }\r\n        }\r\n\r\n        return;\r\n    }\r\n    /* skip comma before next field */\r\n    if (this.c == ',')\r\n        this.readChar();\r\n    /* read field */\r\n    if (this.c == '\\'' || this.c == '\"')\r\n    {  /* read a field enclosed in quotes */\r\n        var quote = this.c;\r\n        this.field = '';\r\n        this.what = this.CSV_STR;\r\n        /* skip opening quote */\r\n        this.readChar();\r\n        /* read field characters within quotes */\r\n        for (;;)\r\n        {  /* check for closing quote and read it */\r\n            if (this.c == quote)\r\n            {  this.readChar();\r\n                if (this.c == quote){\r\n\r\n                }\r\n                else if (this.c == ',' || this.c == '\\n')\r\n                    break;\r\n                else\r\n                    xerror(this.fname + \":\" + this.count + \": invalid field\");\r\n            }\r\n            /* add the current character to the field */\r\n            this.field += this.c;\r\n            /* read the next character */\r\n            this.readChar();\r\n        }\r\n        /* the field has been read */\r\n        if (this.field.length == 0)\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\");\r\n    }\r\n    else\r\n    {  /* read a field not enclosed in quotes */\r\n        this.field = '';\r\n        var temp;\r\n        this.what = this.CSV_NUM;\r\n        while (!(this.c == ',' || this.c == '\\n'))\r\n        {  /* quotes within the field are not allowed */\r\n            if (this.c == '\\'' || this.c == '\"')\r\n                xerror(this.fname + \":\" + this.count + \": invalid use of single or double quote within field\");\r\n            /* add the current character to the field */\r\n            this.field += this.c;\r\n            /* read the next character */\r\n            this.readChar();\r\n        }\r\n        /* the field has been read */\r\n        if (this.field.length == 0)\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\");\r\n        /* check the field type */\r\n        if (str2num(this.field, function(v){temp=v})) this.what = this.CSV_STR;\r\n    }\r\n};\r\n\r\nCSVDriver.prototype.readChar = function (){\r\n    /* read character from csv data file */\r\n    var c;\r\n    xassert(this.c != XEOF);\r\n    if (this.c == '\\n') this.count++;\r\n    while (true){\r\n        if (this.cursor < this.data.length)\r\n            c = this.data[this.cursor++];\r\n        else\r\n            c = XEOF;\r\n        if (c == '\\r')\r\n            continue;\r\n        else if (c == '\\n'){\r\n\r\n        }\r\n        else if (iscntrl(c))\r\n        {   xerror(this.fname +\":\" + this.count +\": invalid control character \" + c);\r\n        }\r\n        break;\r\n    }\r\n    this.c = c;\r\n};\r\n\r\nCSVDriver.prototype[\"readRecord\"] = function(dca){\r\n    /* read next record from csv data file */\r\n    var k, ret = 0;\r\n    xassert(this.mode == 'R');\r\n\r\n    /* read dummy RECNO field */\r\n    if (this.ref[0] > 0)\r\n        mpl_tab_set_num(dca, this.ref[0], this.count-this.nskip-1);\r\n    /* read fields */\r\n    for (k = 1; k <= this.nf; k++)\r\n    {  this.readField();\r\n        if (this.what == this.CSV_EOF)\r\n        {  /* end-of-file reached */\r\n            xassert(k == 1);\r\n            return XEOF;\r\n        }\r\n        else if (this.what == this.CSV_EOR)\r\n        {  /* end-of-record reached */\r\n            var lack = this.nf - k + 1;\r\n            if (lack == 1)\r\n                xerror(this.fname + \":\" + this.count + \": one field missing\");\r\n            else\r\n                xerror(this.fname + \":\" + this.count + \": \" + lack + \" fields missing\");\r\n        }\r\n        else if (this.what == this.CSV_NUM)\r\n        {  /* floating-point number */\r\n            if (this.ref[k] > 0)\r\n            {   var num = 0;\r\n                xassert(str2num(this.field, function(v){num=v}) == 0);\r\n                mpl_tab_set_num(dca, this.ref[k], num);\r\n            }\r\n        }\r\n        else if (this.what == this.CSV_STR)\r\n        {  /* character string */\r\n            if (this.ref[k] > 0)\r\n                mpl_tab_set_str(dca, this.ref[k], this.field);\r\n        }\r\n        else\r\n            xassert(this != this);\r\n    }\r\n    /* now there must be NL */\r\n    this.readField();\r\n    xassert(this.what != this.CSV_EOF);\r\n    if (this.what != this.CSV_EOR)\r\n        xerror(this.fname + \":\" + this.count + \": too many fields\");\r\n    return ret;\r\n};\r\n\r\nCSVDriver.prototype[\"writeRecord\"] = function(dca){\r\n    /* write next record to csv data file */\r\n    var k, nf, ret = 0;\r\n    var c, n;\r\n    xassert(this.mode == 'W');\r\n    nf = mpl_tab_num_flds(dca);\r\n    for (k = 1; k <= nf; k++)\r\n    {  switch (mpl_tab_get_type(dca, k))\r\n    {  case 'N':\r\n            this.data += mpl_tab_get_num(dca, k);\r\n            break;\r\n        case 'S':\r\n            this.data += '\"';\r\n            for (c = mpl_tab_get_str(dca, k), n = 0; c.length > n; n++){\r\n                if (c[n] == '\"')\r\n                    this.data += '\"\"';\r\n                else\r\n                    this.data += c[n];\r\n            }\r\n            this.data += '\"';\r\n            break;\r\n        default:\r\n            xassert(dca != dca);\r\n    }\r\n        this.data += (k < nf)?',':'\\n';\r\n    }\r\n    this.count++;\r\n    return ret;\r\n};\r\n\r\nCSVDriver.prototype[\"flush\"] = function(dca){\r\n    this.tablecb(dca.arg, this.mode, this.data);\r\n};\r\n\r\nmpl_tab_drv_register(\"CSV\", CSVDriver);\r\n\r\n/*****************************************\r\n JSON Driver\r\n *****************************************/\r\n\r\nfunction JSONDriver(dca, mode, tablecb){\r\n    this.mode = mode;\r\n    this.fname = null;\r\n\r\n    if (mpl_tab_num_args(dca) < 2)\r\n        xerror(\"json driver: file name not specified\");\r\n    this.fname = mpl_tab_get_arg(dca, 2);\r\n    var k;\r\n    if (mode == 'R')\r\n    {\r\n        this.ref = {};\r\n        if (tablecb){\r\n            this.data = tablecb(dca.arg, mode);\r\n            if (typeof this.data == 'string')\r\n                this.data = JSON.parse(this.data);\r\n            this.cursor = 1;\r\n        } else\r\n            xerror(\"json driver: unable to open \" + this.fname);\r\n\r\n        for (var i = 0, meta = this.data[0]; i < meta.length; i++)\r\n            this.ref[meta[i]] = i;\r\n    }\r\n    else if (mode == 'W')\r\n    {   this.tablecb = tablecb;\r\n        var names = [];\r\n        this.data = [names];\r\n        var nf = mpl_tab_num_flds(dca);\r\n        for (k = 1; k <= nf; k++)\r\n            names.push(mpl_tab_get_name(dca, k));\r\n    }\r\n    else\r\n        xassert(mode != mode);\r\n}\r\n\r\nJSONDriver.prototype[\"writeRecord\"] = function(dca){\r\n    var k;\r\n    xassert(this.mode == 'W');\r\n    var nf = mpl_tab_num_flds(dca);\r\n    var line = [];\r\n    for (k = 1; k <= nf; k++){\r\n        switch (mpl_tab_get_type(dca, k)){\r\n            case 'N':\r\n                line.push(mpl_tab_get_num(dca, k));\r\n                break;\r\n            case 'S':\r\n                line.push(mpl_tab_get_str(dca, k));\r\n                break;\r\n            default:\r\n                xassert(dca != dca);\r\n        }\r\n    }\r\n    this.data.push(line);\r\n    return 0;\r\n};\r\n\r\nJSONDriver.prototype[\"readRecord\"] = function(dca){\r\n    /* read next record from csv data file */\r\n    var ret = 0;\r\n    xassert(this.mode == 'R');\r\n\r\n    /* read fields */\r\n    var line = this.data[this.cursor++];\r\n    if (line == null) return XEOF;\r\n\r\n    for (var k = 1; k <= mpl_tab_num_flds(dca); k++){\r\n        var index = this.ref[mpl_tab_get_name(dca, k)];\r\n        if (index != null){\r\n            var value = line[index];\r\n            switch (typeof value){\r\n                case 'number':\r\n                    mpl_tab_set_num(dca, k, value);\r\n                    break;\r\n                case 'boolean':\r\n                    mpl_tab_set_num(dca, k, Number(value));\r\n                    break;\r\n                case 'string':\r\n                    mpl_tab_set_str(dca, k, value);\r\n                    break;\r\n                default:\r\n                    xerror('Unexpected data type ' + value + \" in \" + this.fname);\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n};\r\n\r\nJSONDriver.prototype[\"flush\"] = function(dca){\r\n    this.tablecb(dca.arg, this.mode, this.data);\r\n};\r\n\r\nmpl_tab_drv_register(\"JSON\", JSONDriver);function npp_error(){\r\n\r\n}\r\n\r\n\r\nfunction npp_create_wksp(){\r\n    /* create LP/MIP preprocessor workspace */\r\n    var npp = {};\r\n    npp.orig_dir = 0;\r\n    npp.orig_m = npp.orig_n = npp.orig_nnz = 0;\r\n    npp.name = npp.obj = null;\r\n    npp.c0 = 0.0;\r\n    npp.nrows = npp.ncols = 0;\r\n    npp.r_head = npp.r_tail = null;\r\n    npp.c_head = npp.c_tail = null;\r\n    npp.top = null;\r\n    npp.m = npp.n = npp.nnz = 0;\r\n    npp.row_ref = npp.col_ref = null;\r\n    npp.sol = npp.scaling = 0;\r\n    npp.p_stat = npp.d_stat = npp.t_stat = npp.i_stat = 0;\r\n    npp.r_stat = null;\r\n    /*npp.r_prim =*/ npp.r_pi = null;\r\n    npp.c_stat = null;\r\n    npp.c_value = /*npp.c_dual =*/ null;\r\n    return npp;\r\n}\r\n\r\nfunction npp_insert_row(npp, row, where){\r\n    /* insert row to the row list */\r\n    if (where == 0)\r\n    {  /* insert row to the beginning of the row list */\r\n        row.prev = null;\r\n        row.next = npp.r_head;\r\n        if (row.next == null)\r\n            npp.r_tail = row;\r\n        else\r\n            row.next.prev = row;\r\n        npp.r_head = row;\r\n    }\r\n    else\r\n    {  /* insert row to the end of the row list */\r\n        row.prev = npp.r_tail;\r\n        row.next = null;\r\n        if (row.prev == null)\r\n            npp.r_head = row;\r\n        else\r\n            row.prev.next = row;\r\n        npp.r_tail = row;\r\n    }\r\n}\r\n\r\nfunction npp_remove_row(npp, row){\r\n    /* remove row from the row list */\r\n    if (row.prev == null)\r\n        npp.r_head = row.next;\r\n    else\r\n        row.prev.next = row.next;\r\n    if (row.next == null)\r\n        npp.r_tail = row.prev;\r\n    else\r\n        row.next.prev = row.prev;\r\n}\r\n\r\nfunction npp_activate_row(npp, row){\r\n    /* make row active */\r\n    if (!row.temp)\r\n    {  row.temp = 1;\r\n        /* move the row to the beginning of the row list */\r\n        npp_remove_row(npp, row);\r\n        npp_insert_row(npp, row, 0);\r\n    }\r\n}\r\n\r\nfunction npp_deactivate_row(npp, row){\r\n    /* make row inactive */\r\n    if (row.temp)\r\n    {  row.temp = 0;\r\n        /* move the row to the end of the row list */\r\n        npp_remove_row(npp, row);\r\n        npp_insert_row(npp, row, 1);\r\n    }\r\n}\r\n\r\nfunction npp_insert_col(npp, col, where){\r\n    /* insert column to the column list */\r\n    if (where == 0)\r\n    {  /* insert column to the beginning of the column list */\r\n        col.prev = null;\r\n        col.next = npp.c_head;\r\n        if (col.next == null)\r\n            npp.c_tail = col;\r\n        else\r\n            col.next.prev = col;\r\n        npp.c_head = col;\r\n    }\r\n    else\r\n    {  /* insert column to the end of the column list */\r\n        col.prev = npp.c_tail;\r\n        col.next = null;\r\n        if (col.prev == null)\r\n            npp.c_head = col;\r\n        else\r\n            col.prev.next = col;\r\n        npp.c_tail = col;\r\n    }\r\n}\r\n\r\nfunction npp_remove_col(npp, col){\r\n    /* remove column from the column list */\r\n    if (col.prev == null)\r\n        npp.c_head = col.next;\r\n    else\r\n        col.prev.next = col.next;\r\n    if (col.next == null)\r\n        npp.c_tail = col.prev;\r\n    else\r\n        col.next.prev = col.prev;\r\n}\r\n\r\nfunction npp_activate_col(npp, col){\r\n    /* make column active */\r\n    if (!col.temp)\r\n    {  col.temp = 1;\r\n        /* move the column to the beginning of the column list */\r\n        npp_remove_col(npp, col);\r\n        npp_insert_col(npp, col, 0);\r\n    }\r\n}\r\n\r\nfunction npp_deactivate_col(npp, col){\r\n    /* make column inactive */\r\n    if (col.temp)\r\n    {  col.temp = 0;\r\n        /* move the column to the end of the column list */\r\n        npp_remove_col(npp, col);\r\n        npp_insert_col(npp, col, 1);\r\n    }\r\n}\r\n\r\nfunction npp_add_row(npp){\r\n    /* add new row to the current problem */\r\n    var row = {};\r\n    row.i = ++(npp.nrows);\r\n    row.name = null;\r\n    row.lb = -DBL_MAX;\r\n    row.ub = +DBL_MAX;\r\n    row.ptr = null;\r\n    row.temp = 0;\r\n    npp_insert_row(npp, row, 1);\r\n    return row;\r\n}\r\n\r\nfunction npp_add_col(npp){\r\n    /* add new column to the current problem */\r\n    var col = {};\r\n    col.j = ++(npp.ncols);\r\n    col.name = null;\r\n    col.is_int = 0;\r\n    col.lb = col.ub = col.coef = 0.0;\r\n    col.ptr = null;\r\n    col.temp = 0;\r\n    col.ll = {};\r\n    col.uu = {};\r\n    npp_insert_col(npp, col, 1);\r\n    return col;\r\n}\r\n\r\nfunction npp_add_aij(row, col, val){\r\n    /* add new element to the constraint matrix */\r\n    var aij = {};\r\n    aij.row = row;\r\n    aij.col = col;\r\n    aij.val = val;\r\n    aij.r_prev = null;\r\n    aij.r_next = row.ptr;\r\n    aij.c_prev = null;\r\n    aij.c_next = col.ptr;\r\n    if (aij.r_next != null)\r\n        aij.r_next.r_prev = aij;\r\n    if (aij.c_next != null)\r\n        aij.c_next.c_prev = aij;\r\n    row.ptr = col.ptr = aij;\r\n    return aij;\r\n}\r\n\r\nfunction npp_row_nnz(row){\r\n    /* count number of non-zero coefficients in row */\r\n    var nnz = 0;\r\n    for (var aij = row.ptr; aij != null; aij = aij.r_next)\r\n        nnz++;\r\n    return nnz;\r\n}\r\n\r\nfunction npp_col_nnz(col){\r\n    /* count number of non-zero coefficients in column */\r\n    var nnz = 0;\r\n    for (var aij = col.ptr; aij != null; aij = aij.c_next)\r\n        nnz++;\r\n    return nnz;\r\n}\r\n\r\nfunction npp_push_tse(npp, func){\r\n    /* push new entry to the transformation stack */\r\n    var tse;\r\n    tse = {};\r\n    tse.func = func;\r\n    tse.info = {};\r\n    tse.link = npp.top;\r\n    npp.top = tse;\r\n    return tse.info;\r\n}\r\n\r\nfunction npp_erase_row(row){\r\n    /* erase row content to make it empty */\r\n    var aij;\r\n    while (row.ptr != null)\r\n    {  aij = row.ptr;\r\n        row.ptr = aij.r_next;\r\n        if (aij.c_prev == null)\r\n            aij.col.ptr = aij.c_next;\r\n        else\r\n            aij.c_prev.c_next = aij.c_next;\r\n        if (aij.c_next != null)\r\n            aij.c_next.c_prev = aij.c_prev;\r\n    }\r\n}\r\n\r\nfunction npp_del_row(npp, row){\r\n    /* remove row from the current problem */\r\n    npp_erase_row(row);\r\n    npp_remove_row(npp, row);\r\n}\r\n\r\nfunction npp_del_col(npp, col){\r\n    /* remove column from the current problem */\r\n    var aij;\r\n    while (col.ptr != null)\r\n    {  aij = col.ptr;\r\n        col.ptr = aij.c_next;\r\n        if (aij.r_prev == null)\r\n            aij.row.ptr = aij.r_next;\r\n        else\r\n            aij.r_prev.r_next = aij.r_next;\r\n        if (aij.r_next != null)\r\n            aij.r_next.r_prev = aij.r_prev;\r\n    }\r\n    npp_remove_col(npp, col);\r\n}\r\n\r\nfunction npp_del_aij(aij){\r\n    /* remove element from the constraint matrix */\r\n    if (aij.r_prev == null)\r\n        aij.row.ptr = aij.r_next;\r\n    else\r\n        aij.r_prev.r_next = aij.r_next;\r\n    if (aij.r_next != null)\r\n        aij.r_next.r_prev = aij.r_prev;\r\n    if (aij.c_prev == null)\r\n        aij.col.ptr = aij.c_next;\r\n    else\r\n        aij.c_prev.c_next = aij.c_next;\r\n    if (aij.c_next != null)\r\n        aij.c_next.c_prev = aij.c_prev;\r\n}\r\n\r\nfunction npp_load_prob(npp, orig, names, sol, scaling){\r\n    /* load original problem into the preprocessor workspace */\r\n    var m = orig.m;\r\n    var n = orig.n;\r\n    var link;\r\n    var i, j;\r\n    var dir;\r\n    xassert(names == GLP_OFF || names == GLP_ON);\r\n    xassert(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP);\r\n    xassert(scaling == GLP_OFF || scaling == GLP_ON);\r\n    if (sol == GLP_MIP) xassert(!scaling);\r\n    npp.orig_dir = orig.dir;\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    npp.orig_m = m;\r\n    npp.orig_n = n;\r\n    npp.orig_nnz = orig.nnz;\r\n    if (names && orig.name != null)\r\n        npp.name = orig.name;\r\n    if (names && orig.obj != null)\r\n        npp.obj = orig.obj;\r\n    npp.c0 = dir * orig.c0;\r\n    /* load rows */\r\n    link = new Array(1+m);\r\n    for (i = 1; i <= m; i++)\r\n    {  var rrr = orig.row[i];\r\n        var row;\r\n        link[i] = row = npp_add_row(npp);\r\n        xassert(row.i == i);\r\n        if (names && rrr.name != null)\r\n            row.name = rrr.name;\r\n        if (!scaling)\r\n        {  if (rrr.type == GLP_FR){\r\n            row.lb = -DBL_MAX; row.ub = +DBL_MAX;\r\n        }\r\n        else if (rrr.type == GLP_LO){\r\n            row.lb = rrr.lb; row.ub = +DBL_MAX;\r\n        }\r\n        else if (rrr.type == GLP_UP){\r\n            row.lb = -DBL_MAX; row.ub = rrr.ub;\r\n        }\r\n        else if (rrr.type == GLP_DB){\r\n            row.lb = rrr.lb; row.ub = rrr.ub;\r\n        }\r\n        else if (rrr.type == GLP_FX)\r\n            row.lb = row.ub = rrr.lb;\r\n        else\r\n            xassert(rrr != rrr);\r\n        }\r\n        else\r\n        {  var rii = rrr.rii;\r\n            if (rrr.type == GLP_FR){\r\n                row.lb = -DBL_MAX; row.ub = +DBL_MAX;\r\n            }\r\n            else if (rrr.type == GLP_LO){\r\n                row.lb = rrr.lb * rii; row.ub = +DBL_MAX;\r\n            }\r\n            else if (rrr.type == GLP_UP){\r\n                row.lb = -DBL_MAX; row.ub = rrr.ub * rii;\r\n            }\r\n            else if (rrr.type == GLP_DB){\r\n                row.lb = rrr.lb * rii; row.ub = rrr.ub * rii;\r\n            }\r\n            else if (rrr.type == GLP_FX)\r\n                row.lb = row.ub = rrr.lb * rii;\r\n            else\r\n                xassert(rrr != rrr);\r\n        }\r\n    }\r\n    /* load columns and constraint coefficients */\r\n    for (j = 1; j <= n; j++)\r\n    {  var ccc = orig.col[j];\r\n        var aaa;\r\n        var col;\r\n        col = npp_add_col(npp);\r\n        xassert(col.j == j);\r\n        if (names && ccc.name != null)\r\n            col.name =  ccc.name;\r\n        if (sol == GLP_MIP)\r\n            col.is_int = Number(ccc.kind == GLP_IV);\r\n        if (!scaling){\r\n            if (ccc.type == GLP_FR){\r\n                col.lb = -DBL_MAX; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_LO){\r\n                col.lb = ccc.lb; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_UP){\r\n                col.lb = -DBL_MAX; col.ub = ccc.ub;\r\n            }\r\n            else if (ccc.type == GLP_DB){\r\n                col.lb = ccc.lb; col.ub = ccc.ub;\r\n            }\r\n            else if (ccc.type == GLP_FX)\r\n                col.lb = col.ub = ccc.lb;\r\n            else\r\n                xassert(ccc != ccc);\r\n            col.coef = dir * ccc.coef;\r\n            for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_add_aij(link[aaa.row.i], col, aaa.val);\r\n        }\r\n        else\r\n        {  var sjj = ccc.sjj;\r\n            if (ccc.type == GLP_FR){\r\n                col.lb = -DBL_MAX; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_LO){\r\n                col.lb = ccc.lb / sjj; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_UP){\r\n                col.lb = -DBL_MAX; col.ub = ccc.ub / sjj;\r\n            }\r\n            else if (ccc.type == GLP_DB){\r\n                col.lb = ccc.lb / sjj; col.ub = ccc.ub / sjj;\r\n            }\r\n            else if (ccc.type == GLP_FX)\r\n                col.lb = col.ub = ccc.lb / sjj;\r\n            else\r\n                xassert(ccc != ccc);\r\n            col.coef = dir * ccc.coef * sjj;\r\n            for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_add_aij(link[aaa.row.i], col,\r\n                    aaa.row.rii * aaa.val * sjj);\r\n        }\r\n    }\r\n    /* keep solution indicator and scaling option */\r\n    npp.sol = sol;\r\n    npp.scaling = scaling;\r\n}\r\n\r\nfunction npp_build_prob(npp, prob){\r\n    /* build resultant (preprocessed) problem */\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, type, len, ind;\r\n    var dir, val;\r\n    glp_erase_prob(prob);\r\n    glp_set_prob_name(prob, npp.name);\r\n    glp_set_obj_name(prob, npp.obj);\r\n    glp_set_obj_dir(prob, npp.orig_dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    glp_set_obj_coef(prob, 0, dir * npp.c0);\r\n    /* build rows */\r\n    for (row = npp.r_head; row != null; row = row.next)\r\n    {  row.temp = i = glp_add_rows(prob, 1);\r\n        glp_set_row_name(prob, i, row.name);\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (row.ub == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (row.lb == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (row.lb != row.ub)\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_row_bnds(prob, i, type, row.lb, row.ub);\r\n    }\r\n    /* build columns and the constraint matrix */\r\n    ind = new Int32Array(1+prob.m);\r\n    val = new Float64Array(1+prob.m);\r\n    for (col = npp.c_head; col != null; col = col.next)\r\n    {  j = glp_add_cols(prob, 1);\r\n        glp_set_col_name(prob, j, col.name);\r\n        glp_set_col_kind(prob, j, col.is_int ? GLP_IV : GLP_CV);\r\n        if (col.lb == -DBL_MAX && col.ub == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (col.ub == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (col.lb == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (col.lb != col.ub)\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_col_bnds(prob, j, type, col.lb, col.ub);\r\n        glp_set_obj_coef(prob, j, dir * col.coef);\r\n        len = 0;\r\n        for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n        {  len++;\r\n            ind[len] = aij.row.temp;\r\n            val[len] = aij.val;\r\n        }\r\n        glp_set_mat_col(prob, j, len, ind, val);\r\n    }\r\n    /* resultant problem has been built */\r\n    npp.m = prob.m;\r\n    npp.n = prob.n;\r\n    npp.nnz = prob.nnz;\r\n    npp.row_ref = new Int32Array(1+npp.m);\r\n    npp.col_ref = new Int32Array(1+npp.n);\r\n    for (row = npp.r_head, i = 0; row != null; row = row.next)\r\n        npp.row_ref[++i] = row.i;\r\n    for (col = npp.c_head, j = 0; col != null; col = col.next)\r\n        npp.col_ref[++j] = col.j;\r\n    /* transformed problem segment is no longer needed */\r\n    npp.name = npp.obj = null;\r\n    npp.c0 = 0.0;\r\n    npp.r_head = npp.r_tail = null;\r\n    npp.c_head = npp.c_tail = null;\r\n}\r\n\r\nfunction npp_postprocess(npp, prob){\r\n    /* postprocess solution from the resultant problem */\r\n    var row;\r\n    var col;\r\n    var tse;\r\n    var i, j, k;\r\n    var dir;\r\n    xassert(npp.orig_dir == prob.dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    xassert(npp.m == prob.m);\r\n    xassert(npp.n == prob.n);\r\n    xassert(npp.nnz == prob.nnz);\r\n    /* copy solution status */\r\n    if (npp.sol == GLP_SOL)\r\n    {  npp.p_stat = prob.pbs_stat;\r\n        npp.d_stat = prob.dbs_stat;\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n        npp.t_stat = prob.ipt_stat;\r\n    else if (npp.sol == GLP_MIP)\r\n        npp.i_stat = prob.mip_stat;\r\n    else\r\n        xassert(npp != npp);\r\n    /* allocate solution arrays */\r\n    if (npp.sol == GLP_SOL)\r\n    {  if (npp.r_stat == null)\r\n        npp.r_stat = new Int8Array(1+npp.nrows);\r\n        for (i = 1; i <= npp.nrows; i++)\r\n            npp.r_stat[i] = 0;\r\n        if (npp.c_stat == null)\r\n            npp.c_stat = new Int8Array(1+npp.ncols);\r\n        for (j = 1; j <= npp.ncols; j++)\r\n            npp.c_stat[j] = 0;\r\n    }\r\n    if (npp.c_value == null)\r\n        npp.c_value = new Float64Array(1+npp.ncols);\r\n    for (j = 1; j <= npp.ncols; j++)\r\n        npp.c_value[j] = DBL_MAX;\r\n    if (npp.sol != GLP_MIP)\r\n    {  if (npp.r_pi == null)\r\n        npp.r_pi = new Float64Array(1+npp.nrows);\r\n        for (i = 1; i <= npp.nrows; i++)\r\n            npp.r_pi[i] = DBL_MAX;\r\n    }\r\n    /* copy solution components from the resultant problem */\r\n    if (npp.sol == GLP_SOL)\r\n    {  for (i = 1; i <= npp.m; i++)\r\n    {  row = prob.row[i];\r\n        k = npp.row_ref[i];\r\n        npp.r_stat[k] = row.stat;\r\n        /*npp.r_prim[k] = row.prim;*/\r\n        npp.r_pi[k] = dir * row.dual;\r\n    }\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_stat[k] = col.stat;\r\n            npp.c_value[k] = col.prim;\r\n            /*npp.c_dual[k] = dir * col.dual;*/\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n    {  for (i = 1; i <= npp.m; i++)\r\n    {  row = prob.row[i];\r\n        k = npp.row_ref[i];\r\n        /*npp.r_prim[k] = row.pval;*/\r\n        npp.r_pi[k] = dir * row.dval;\r\n    }\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_value[k] = col.pval;\r\n            /*npp.c_dual[k] = dir * col.dval;*/\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_MIP)\r\n    {\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_value[k] = col.mipx;\r\n        }\r\n    }\r\n    else\r\n        xassert(npp != npp);\r\n    /* perform postprocessing to construct solution to the original\r\n     problem */\r\n    for (tse = npp.top; tse != null; tse = tse.link)\r\n    {  xassert(tse.func != null);\r\n        xassert(tse.func(npp, tse.info) == 0);\r\n    }\r\n}\r\n\r\nfunction npp_unload_sol(npp, orig){\r\n    /* store solution to the original problem */\r\n    var row;\r\n    var col;\r\n    var i, j;\r\n    var dir;\r\n    var aij, temp;\r\n    xassert(npp.orig_dir == orig.dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    xassert(npp.orig_m == orig.m);\r\n    xassert(npp.orig_n == orig.n);\r\n    xassert(npp.orig_nnz == orig.nnz);\r\n    if (npp.sol == GLP_SOL)\r\n    {  /* store basic solution */\r\n        orig.valid = 0;\r\n        orig.pbs_stat = npp.p_stat;\r\n        orig.dbs_stat = npp.d_stat;\r\n        orig.obj_val = orig.c0;\r\n        orig.some = 0;\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            row.stat = npp.r_stat[i];\r\n            if (!npp.scaling)\r\n            {  /*row.prim = npp.r_prim[i];*/\r\n                row.dual = dir * npp.r_pi[i];\r\n            }\r\n            else\r\n            {  /*row.prim = npp.r_prim[i] / row.rii;*/\r\n                row.dual = dir * npp.r_pi[i] * row.rii;\r\n            }\r\n            if (row.stat == GLP_BS)\r\n                row.dual = 0.0;\r\n            else if (row.stat == GLP_NL)\r\n            {  xassert(row.type == GLP_LO || row.type == GLP_DB);\r\n                row.prim = row.lb;\r\n            }\r\n            else if (row.stat == GLP_NU)\r\n            {  xassert(row.type == GLP_UP || row.type == GLP_DB);\r\n                row.prim = row.ub;\r\n            }\r\n            else if (row.stat == GLP_NF)\r\n            {  xassert(row.type == GLP_FR);\r\n                row.prim = 0.0;\r\n            }\r\n            else if (row.stat == GLP_NS)\r\n            {  xassert(row.type == GLP_FX);\r\n                row.prim = row.lb;\r\n            }\r\n            else\r\n                xassert(row != row);\r\n        }\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            col.stat = npp.c_stat[j];\r\n            if (!npp.scaling)\r\n            {  col.prim = npp.c_value[j];\r\n                /*col.dual = dir * npp.c_dual[j];*/\r\n            }\r\n            else\r\n            {  col.prim = npp.c_value[j] * col.sjj;\r\n                /*col.dual = dir * npp.c_dual[j] / col.sjj;*/\r\n            }\r\n            if (col.stat == GLP_BS)\r\n                col.dual = 0.0;\r\n            else if (col.stat == GLP_NL)\r\n            {  xassert(col.type == GLP_LO || col.type == GLP_DB);\r\n                col.prim = col.lb;\r\n            }\r\n            else if (col.stat == GLP_NU)\r\n            {  xassert(col.type == GLP_UP || col.type == GLP_DB);\r\n                col.prim = col.ub;\r\n            }\r\n            else if (col.stat == GLP_NF)\r\n            {  xassert(col.type == GLP_FR);\r\n                col.prim = 0.0;\r\n            }\r\n            else if (col.stat == GLP_NS)\r\n            {  xassert(col.type == GLP_FX);\r\n                col.prim = col.lb;\r\n            }\r\n            else\r\n                xassert(col != col);\r\n            orig.obj_val += col.coef * col.prim;\r\n        }\r\n        /* compute primal values of inactive rows */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            if (row.stat == GLP_BS)\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.prim;\r\n                row.prim = temp;\r\n            }\r\n        }\r\n        /* compute reduced costs of active columns */\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {\r\n                temp = col.coef;\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    temp -= aij.val * aij.row.dual;\r\n                col.dual = temp;\r\n            }\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n    {  /* store interior-point solution */\r\n        orig.ipt_stat = npp.t_stat;\r\n        orig.ipt_obj = orig.c0;\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            if (!npp.scaling)\r\n            {  /*row.pval = npp.r_prim[i];*/\r\n                row.dval = dir * npp.r_pi[i];\r\n            }\r\n            else\r\n            {  /*row.pval = npp.r_prim[i] / row.rii;*/\r\n                row.dval = dir * npp.r_pi[i] * row.rii;\r\n            }\r\n        }\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            if (!npp.scaling)\r\n            {  col.pval = npp.c_value[j];\r\n                /*col.dval = dir * npp.c_dual[j];*/\r\n            }\r\n            else\r\n            {  col.pval = npp.c_value[j] * col.sjj;\r\n                /*col.dval = dir * npp.c_dual[j] / col.sjj;*/\r\n            }\r\n            orig.ipt_obj += col.coef * col.pval;\r\n        }\r\n        /* compute row primal values */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.pval;\r\n                row.pval = temp;\r\n            }\r\n        }\r\n        /* compute column dual values */\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            {\r\n                temp = col.coef;\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    temp -= aij.val * aij.row.dval;\r\n                col.dval = temp;\r\n            }\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_MIP)\r\n    {  /* store MIP solution */\r\n        xassert(!npp.scaling);\r\n        orig.mip_stat = npp.i_stat;\r\n        orig.mip_obj = orig.c0;\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            col.mipx = npp.c_value[j];\r\n            if (col.kind == GLP_IV)\r\n                xassert(col.mipx == Math.floor(col.mipx));\r\n            orig.mip_obj += col.coef * col.mipx;\r\n        }\r\n        /* compute row primal values */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.mipx;\r\n                row.mipx = temp;\r\n            }\r\n        }\r\n    }\r\n    else\r\n        xassert(npp != npp);\r\n}\r\n\r\n\r\nfunction npp_free_row(npp, p){\r\n    /* process free (unbounded) row */\r\n    var info;\r\n    /* the row must be free */\r\n    xassert(p.lb == -DBL_MAX && p.ub == +DBL_MAX);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover free (unbounded) row */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            if (npp.sol != GLP_MIP)\r\n                npp.r_pi[info.p] = 0.0;\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n}\r\n\r\nfunction npp_geq_row(npp, p){\r\n    /* process row of 'not less than' type */\r\n    var info;\r\n    var s;\r\n    /* the row must have lower bound */\r\n    xassert(p.lb != -DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* create column for surplus variable */\r\n    s = npp_add_col(npp);\r\n    s.lb = 0.0;\r\n    s.ub = (p.ub == +DBL_MAX ? +DBL_MAX : p.ub - p.lb);\r\n    /* and add it to the transformed problem */\r\n    npp_add_aij(p, s, -1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function rcv_geq_row(npp, info){\r\n            /* recover row of 'not less than' type */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL ||\r\n                npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else if (npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.s = s.j;\r\n    /* replace the row by equality constraint */\r\n    p.ub = p.lb;\r\n}\r\n\r\nfunction npp_leq_row(npp, p){\r\n    /* process row of 'not greater than' type */\r\n    var info;\r\n    var s;\r\n    /* the row must have upper bound */\r\n    xassert(p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* create column for slack variable */\r\n    s = npp_add_col(npp);\r\n    s.lb = 0.0;\r\n    s.ub = (p.lb == -DBL_MAX ? +DBL_MAX : p.ub - p.lb);\r\n    /* and add it to the transformed problem */\r\n    npp_add_aij(p, s, +1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row of 'not greater than' type */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL ||\r\n                npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            else if (npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.s = s.j;\r\n    /* replace the row by equality constraint */\r\n    p.lb = p.ub;\r\n}\r\n\r\nfunction npp_free_col(npp, q){\r\n    /* process free (unbounded) column */\r\n    var info;\r\n    var s;\r\n    var aij;\r\n    /* the column must be free */\r\n    xassert(q.lb == -DBL_MAX && q.ub == +DBL_MAX);\r\n    /* variable x[q] becomes s' */\r\n    q.lb = 0.0; q.ub = +DBL_MAX;\r\n    /* create variable s'' */\r\n    s = npp_add_col(npp);\r\n    s.is_int = q.is_int;\r\n    s.lb = 0.0; s.ub = +DBL_MAX;\r\n    /* duplicate objective coefficient */\r\n    s.coef = -q.coef;\r\n    /* duplicate column of the constraint matrix */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n        npp_add_aij(aij.row, s, -aij.val);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover free (unbounded) column */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NF;\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] -= npp.c_value[info.s];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = s.j;\r\n}\r\n\r\nfunction npp_lbnd_col(npp, q){\r\n    /* process column with (non-zero) lower bound */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must have non-zero lower bound */\r\n    xassert(q.lb != 0.0);\r\n    xassert(q.lb != -DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with (non-zero) lower bound */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS ||\r\n                npp.c_stat[info.q] == GLP_NL ||\r\n                npp.c_stat[info.q] == GLP_NU)\r\n                npp.c_stat[info.q] = npp.c_stat[info.q];\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] = info.bnd + npp.c_value[info.q];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.bnd = q.lb;\r\n    /* substitute x[q] into objective row */\r\n    npp.c0 += q.coef * q.lb;\r\n    /* substitute x[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.lb;\r\n        }\r\n    }\r\n    /* column x[q] becomes column s */\r\n    if (q.ub != +DBL_MAX)\r\n        q.ub -= q.lb;\r\n    q.lb = 0.0;\r\n}\r\n\r\nfunction npp_ubnd_col(npp, q){\r\n    /* process column with upper bound */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must have upper bound */\r\n    xassert(q.ub != +DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with upper bound */\r\n            if (npp.sol == GLP_BS)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NU;\r\n            else if (npp.c_stat[info.q] == GLP_NU)\r\n                npp.c_stat[info.q] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] = info.bnd - npp.c_value[info.q];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.bnd = q.ub;\r\n    /* substitute x[q] into objective row */\r\n    npp.c0 += q.coef * q.ub;\r\n    q.coef = -q.coef;\r\n    /* substitute x[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.ub);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.ub;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.ub;\r\n        }\r\n        aij.val = -aij.val;\r\n    }\r\n    /* column x[q] becomes column s */\r\n    if (q.lb != -DBL_MAX)\r\n        q.ub -= q.lb;\r\n    else\r\n        q.ub = +DBL_MAX;\r\n    q.lb = 0.0;\r\n}\r\n\r\nfunction npp_dbnd_col(npp, q){\r\n    /* process non-negative column with upper bound */\r\n    var info;\r\n    var p;\r\n    var s;\r\n    /* the column must be non-negative with upper bound */\r\n    xassert(q.lb == 0.0);\r\n    xassert(q.ub > 0.0);\r\n    xassert(q.ub != +DBL_MAX);\r\n    /* create variable s */\r\n    s = npp_add_col(npp);\r\n    s.is_int = q.is_int;\r\n    s.lb = 0.0; s.ub = +DBL_MAX;\r\n    /* create equality constraint (2) */\r\n    p = npp_add_row(npp);\r\n    p.lb = p.ub = q.ub;\r\n    npp_add_aij(p, q, +1.0);\r\n    npp_add_aij(p, s, +1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover non-negative column with upper bound */\r\n            if (npp.sol == GLP_BS)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NU;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n            {  if (npp.c_stat[info.s] == GLP_BS ||\r\n                npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = s.j;\r\n    /* remove upper bound of x[q] */\r\n    q.ub = +DBL_MAX;\r\n}\r\n\r\nfunction npp_fixed_col(npp, q){\r\n    /* process fixed column */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must be fixed */\r\n    xassert(q.lb == q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover fixed column */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.c_stat[info.q] = GLP_NS;\r\n            npp.c_value[info.q] = info.s;\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = q.lb;\r\n    /* substitute x[q] = s[q] into objective row */\r\n    npp.c0 += q.coef * q.lb;\r\n    /* substitute x[q] = s[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.lb;\r\n        }\r\n    }\r\n    /* remove the column from the problem */\r\n    npp_del_col(npp, q);\r\n}\r\n\r\nfunction npp_make_equality(npp, p){\r\n    /* process row with almost identical bounds */\r\n    var info;\r\n    var b, eps, nint;\r\n    /* the row must be double-sided inequality */\r\n    xassert(p.lb != -DBL_MAX);\r\n    xassert(p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* check row bounds */\r\n    eps = 1e-9 + 1e-12 * Math.abs(p.lb);\r\n    if (p.ub - p.lb > eps) return 0;\r\n    /* row bounds are very close to each other */\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row with almost identical bounds */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.r_pi[info.p] >= 0.0)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    /* compute right-hand side */\r\n    b = 0.5 * (p.ub + p.lb);\r\n    nint = Math.floor(b + 0.5);\r\n    if (Math.abs(b - nint) <= eps) b = nint;\r\n    /* replace row p by almost equivalent equality constraint */\r\n    p.lb = p.ub = b;\r\n    return 1;\r\n}\r\n\r\nfunction npp_make_fixed(npp, q){\r\n    /* process column with almost identical bounds */\r\n    var info;\r\n    var aij;\r\n    var lfe;\r\n    var s, eps, nint;\r\n    /* the column must be double-bounded */\r\n    xassert(q.lb != -DBL_MAX);\r\n    xassert(q.ub != +DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* check column bounds */\r\n    eps = 1e-9 + 1e-12 * Math.abs(q.lb);\r\n    if (q.ub - q.lb > eps) return 0;\r\n    /* column bounds are very close to each other */\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with almost identical bounds */\r\n            var lfe;\r\n            var lambda;\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.q] == GLP_NS)\r\n            {  /* compute multiplier for column q with formula (6) */\r\n                lambda = info.c;\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                    lambda -= lfe.val * npp.r_pi[lfe.ref];\r\n                /* assign status to non-basic column */\r\n                if (lambda >= 0.0)\r\n                    npp.c_stat[info.q] = GLP_NL;\r\n                else\r\n                    npp.c_stat[info.q] = GLP_NU;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q] (needed for basic solution\r\n     only) */\r\n    if (npp.sol == GLP_SOL)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {   lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* compute column fixed value */\r\n    s = 0.5 * (q.ub + q.lb);\r\n    nint = Math.floor(s + 0.5);\r\n    if (Math.abs(s - nint) <= eps) s = nint;\r\n    /* make column q fixed */\r\n    q.lb = q.ub = s;\r\n    return 1;\r\n}\r\n\r\nfunction npp_empty_row(npp, p){\r\n    /* process empty row */\r\n    var eps = 1e-3;\r\n    /* the row must be empty */\r\n    xassert(p.ptr == null);\r\n    /* check primal feasibility */\r\n    if (p.lb > +eps || p.ub < -eps)\r\n        return 1;\r\n    /* replace the row by equivalent free (unbounded) row */\r\n    p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n    /* and process it */\r\n    npp_free_row(npp, p);\r\n    return 0;\r\n}\r\n\r\nfunction npp_empty_col(npp, q){\r\n    /* process empty column */\r\n    var info;\r\n    var eps = 1e-3;\r\n    /* the column must be empty */\r\n    xassert(q.ptr == null);\r\n    /* check dual feasibility */\r\n    if (q.coef > +eps && q.lb == -DBL_MAX)\r\n        return 1;\r\n    if (q.coef < -eps && q.ub == +DBL_MAX)\r\n        return 1;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover empty column */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.c_stat[info.q] = info.stat;\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    /* fix the column */\r\n\r\n    function lo(){  \r\n        /* column with lower bound */\r\n        info.stat = GLP_NL;\r\n        q.ub = q.lb;\r\n    }\r\n\r\n    function up(){\r\n        /* column with upper bound */\r\n        info.stat = GLP_NU;\r\n        q.lb = q.ub;\r\n    }\r\n    \r\n    if (q.lb == -DBL_MAX && q.ub == +DBL_MAX)\r\n    {  /* free column */\r\n        info.stat = GLP_NF;\r\n        q.lb = q.ub = 0.0;\r\n    }\r\n    else if (q.ub == +DBL_MAX)\r\n        lo();   \r\n    else if (q.lb == -DBL_MAX)\r\n        up();\r\n    else if (q.lb != q.ub)\r\n    {  /* double-bounded column */\r\n        if (q.coef >= +DBL_EPSILON) \r\n            lo();\r\n        else if (q.coef <= -DBL_EPSILON) \r\n            up();\r\n        else if (Math.abs(q.lb) <= Math.abs(q.ub)) \r\n            lo();\r\n        else \r\n            up();\r\n    }\r\n    else\r\n    {  /* fixed column */\r\n        info.stat = GLP_NS;\r\n    }\r\n    /* process fixed column */\r\n    npp_fixed_col(npp, q);\r\n    return 0;\r\n}\r\n\r\nfunction npp_implied_value(npp, q, s){\r\n    /* process implied column value */\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* check integrality */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(s + 0.5);\r\n        if (Math.abs(s - nint) <= 1e-5)\r\n            s = nint;\r\n        else\r\n            return 2;\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.lb));\r\n        if (s < q.lb - eps) return 1;\r\n        /* if s[q] is close to l[q], fix column at its lower bound\r\n         rather than at the implied value */\r\n        if (s < q.lb + 1e-3 * eps)\r\n        {  q.ub = q.lb;\r\n            return 0;\r\n        }\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.ub));\r\n        if (s > q.ub + eps) return 1;\r\n        /* if s[q] is close to u[q], fix column at its upper bound\r\n         rather than at the implied value */\r\n        if (s > q.ub - 1e-3 * eps)\r\n        {  q.lb = q.ub;\r\n            return 0;\r\n        }\r\n    }\r\n    /* fix column at the implied value */\r\n    q.lb = q.ub = s;\r\n    return 0;\r\n}\r\n\r\nfunction npp_eq_singlet(npp, p){\r\n    /* process row singleton (equality constraint) */\r\n    var info;\r\n    var q;\r\n    var aij;\r\n    var lfe;\r\n    var ret;\r\n    var s;\r\n    /* the row must be singleton equality constraint */\r\n    xassert(p.lb == p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next == null);\r\n    /* compute and process implied column value */\r\n    aij = p.ptr;\r\n    q = aij.col;\r\n    s = p.lb / aij.val;\r\n    ret = npp_implied_value(npp, q, s);\r\n    xassert(0 <= ret && ret <= 2);\r\n    if (ret != 0) return ret;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row singleton (equality constraint) */\r\n            var lfe;\r\n            var temp;\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* column q must be already recovered as GLP_NS */\r\n                if (npp.c_stat[info.q] != GLP_NS)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                npp.r_stat[info.p] = GLP_NS;\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute multiplier for row p with formula (3) */\r\n                temp = info.c;\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                    temp -= lfe.val * npp.r_pi[lfe.ref];\r\n                npp.r_pi[info.p] = temp / info.apq;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = aij.val;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q], i != p (not needed for MIP\r\n     solution) */\r\n    if (npp.sol != GLP_MIP)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  if (aij.row == p) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n    return 0;\r\n}\r\n\r\nfunction npp_implied_lower(npp, q, l){\r\n    /* process implied column lower bound */\r\n    var ret;\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* implied lower bound must be finite */\r\n    xassert(l != -DBL_MAX);\r\n    /* if column is integral, round up l'[q] */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(l + 0.5);\r\n        if (Math.abs(l - nint) <= 1e-5)\r\n            l = nint;\r\n        else\r\n            l = Math.ceil(l);\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-3 : 1e-3 + 1e-6 * Math.abs(q.lb));\r\n        if (l < q.lb + eps)\r\n        {  ret = 0; /* redundant */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.ub));\r\n        if (l > q.ub + eps)\r\n        {  ret = 4; /* infeasible */\r\n            return ret;\r\n        }\r\n        /* if l'[q] is close to u[q], fix column at its upper bound */\r\n        if (l > q.ub - 1e-3 * eps)\r\n        {  q.lb = q.ub;\r\n            ret = 3; /* fixed */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if column lower bound changes significantly */\r\n    if (q.lb == -DBL_MAX)\r\n        ret = 2; /* significantly */\r\n    else if (q.is_int && l > q.lb + 0.5)\r\n        ret = 2; /* significantly */\r\n    else if (l > q.lb + 0.30 * (1.0 + Math.abs(q.lb)))\r\n        ret = 2; /* significantly */\r\n    else\r\n        ret = 1; /* not significantly */\r\n    /* set new column lower bound */\r\n    q.lb = l;\r\n    return ret;\r\n}\r\n\r\nfunction npp_implied_upper(npp, q, u){\r\n    var ret;\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* implied upper bound must be finite */\r\n    xassert(u != +DBL_MAX);\r\n    /* if column is integral, round down u'[q] */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(u + 0.5);\r\n        if (Math.abs(u - nint) <= 1e-5)\r\n            u = nint;\r\n        else\r\n            u = Math.floor(u);\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-3 : 1e-3 + 1e-6 * Math.abs(q.ub));\r\n        if (u > q.ub - eps)\r\n        {  ret = 0; /* redundant */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.lb));\r\n        if (u < q.lb - eps)\r\n        {  ret = 4; /* infeasible */\r\n            return ret;\r\n        }\r\n        /* if u'[q] is close to l[q], fix column at its lower bound */\r\n        if (u < q.lb + 1e-3 * eps)\r\n        {  q.ub = q.lb;\r\n            ret = 3; /* fixed */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if column upper bound changes significantly */\r\n    if (q.ub == +DBL_MAX)\r\n        ret = 2; /* significantly */\r\n    else if (q.is_int && u < q.ub - 0.5)\r\n        ret = 2; /* significantly */\r\n    else if (u < q.ub - 0.30 * (1.0 + Math.abs(q.ub)))\r\n        ret = 2; /* significantly */\r\n    else\r\n        ret = 1; /* not significantly */\r\n    /* set new column upper bound */\r\n    q.ub = u;\r\n    return ret;\r\n}\r\n\r\nfunction npp_ineq_singlet(npp, p){\r\n    /* process row singleton (inequality constraint) */\r\n    var info;\r\n    var q;\r\n    var apq, aij;\r\n    var lfe;\r\n    var lb_changed, ub_changed;\r\n    var ll, uu;\r\n    /* the row must be singleton inequality constraint */\r\n    xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next == null);\r\n    /* compute implied column bounds */\r\n    apq = p.ptr;\r\n    q = apq.col;\r\n    xassert(q.lb < q.ub);\r\n    if (apq.val > 0.0)\r\n    {  ll = (p.lb == -DBL_MAX ? -DBL_MAX : p.lb / apq.val);\r\n        uu = (p.ub == +DBL_MAX ? +DBL_MAX : p.ub / apq.val);\r\n    }\r\n    else\r\n    {  ll = (p.ub == +DBL_MAX ? -DBL_MAX : p.ub / apq.val);\r\n        uu = (p.lb == -DBL_MAX ? +DBL_MAX : p.lb / apq.val);\r\n    }\r\n    /* process implied column lower bound */\r\n    if (ll == -DBL_MAX)\r\n        lb_changed = 0;\r\n    else\r\n    {  lb_changed = npp_implied_lower(npp, q, ll);\r\n        xassert(0 <= lb_changed && lb_changed <= 4);\r\n        if (lb_changed == 4) return 4; /* infeasible */\r\n    }\r\n    /* process implied column upper bound */\r\n    if (uu == +DBL_MAX)\r\n        ub_changed = 0;\r\n    else if (lb_changed == 3)\r\n    {  /* column was fixed on its upper bound due to l'[q] = u[q] */\r\n        /* note that L[p] < U[p], so l'[q] = u[q] < u'[q] */\r\n        ub_changed = 0;\r\n    }\r\n    else\r\n    {  ub_changed = npp_implied_upper(npp, q, uu);\r\n        xassert(0 <= ub_changed && ub_changed <= 4);\r\n        if (ub_changed == 4) return 4; /* infeasible */\r\n    }\r\n    /* if neither lower nor upper column bound was changed, the row\r\n     is originally redundant and can be replaced by free row */\r\n    if (!lb_changed && !ub_changed)\r\n    {  p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n        npp_free_row(npp, p);\r\n        return 0;\r\n    }\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row singleton (inequality constraint) */\r\n            var lfe;\r\n            var lambda;\r\n            if (npp.sol == GLP_MIP) return 0;\r\n            /* compute lambda~[q] in solution to the transformed problem\r\n             with formula (8) */\r\n            lambda = info.c;\r\n            for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                lambda -= lfe.val * npp.r_pi[lfe.ref];\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* recover basic solution */\r\n\r\n                function nl(){  /* column q is non-basic with lower bound active */\r\n                    if (info.lb_changed)\r\n                    {  /* it is implied bound, so actually row p is active\r\n                     while column q is basic */\r\n                        npp.r_stat[info.p] =\r\n                            (info.apq > 0.0 ? GLP_NL : GLP_NU);\r\n                        npp.c_stat[info.q] = GLP_BS;\r\n                        npp.r_pi[info.p] = lambda / info.apq;\r\n                    }\r\n                    else\r\n                    {  /* it is original bound, so row p is inactive */\r\n                        npp.r_stat[info.p] = GLP_BS;\r\n                        npp.r_pi[info.p] = 0.0;\r\n                    }\r\n                    return 0;\r\n                }\r\n\r\n                function nu(){\r\n                    /* column q is non-basic with upper bound active */\r\n                    if (info.ub_changed)\r\n                    {  /* it is implied bound, so actually row p is active\r\n                     while column q is basic */\r\n                        npp.r_stat[info.p] =\r\n                            (info.apq > 0.0 ? GLP_NU : GLP_NL);\r\n                        npp.c_stat[info.q] = GLP_BS;\r\n                        npp.r_pi[info.p] = lambda / info.apq;\r\n                    }\r\n                    else\r\n                    {  /* it is original bound, so row p is inactive */\r\n                        npp.r_stat[info.p] = GLP_BS;\r\n                        npp.r_pi[info.p] = 0.0;\r\n                    }\r\n                    return 0;\r\n                }\r\n\r\n\r\n                if (npp.c_stat[info.q] == GLP_BS)\r\n                {  /* column q is basic, so row p is inactive */\r\n                    npp.r_stat[info.p] = GLP_BS;\r\n                    npp.r_pi[info.p] = 0.0;\r\n                }\r\n                else if (npp.c_stat[info.q] == GLP_NL)\r\n                    nl();\r\n                else if (npp.c_stat[info.q] == GLP_NU)\r\n                    nu();\r\n                else if (npp.c_stat[info.q] == GLP_NS)\r\n                {  /* column q is non-basic and fixed; note, however, that in\r\n                 in the original problem it is non-fixed */\r\n                    if (lambda > +1e-7)\r\n                    {  if (info.apq > 0.0 && info.lb != -DBL_MAX ||\r\n                        info.apq < 0.0 && info.ub != +DBL_MAX ||\r\n                        !info.lb_changed)\r\n                    {  /* either corresponding bound of row p exists or\r\n                     column q remains non-basic with its original lower\r\n                     bound active */\r\n                        npp.c_stat[info.q] = GLP_NL;\r\n                        return nl();\r\n                    }\r\n                    }\r\n                    if (lambda < -1e-7)\r\n                    {  if (info.apq > 0.0 && info.ub != +DBL_MAX ||\r\n                        info.apq < 0.0 && info.lb != -DBL_MAX ||\r\n                        !info.ub_changed)\r\n                    {  /* either corresponding bound of row p exists or\r\n                     column q remains non-basic with its original upper\r\n                     bound active */\r\n                        npp.c_stat[info.q] = GLP_NU;\r\n                        return nu();\r\n                    }\r\n                    }\r\n                    /* either lambda~[q] is close to zero, or corresponding\r\n                     bound of row p does not exist, because lambda~[q] has\r\n                     wrong sign due to round-off errors; in the latter case\r\n                     lambda~[q] is also assumed to be close to zero; so, we\r\n                     can make row p active on its existing bound and column q\r\n                     basic; pi[p] will have wrong sign, but it also will be\r\n                     close to zero (rarus casus of dual degeneracy) */\r\n                    if (info.lb != -DBL_MAX && info.ub == +DBL_MAX)\r\n                    {  /* row lower bound exists, but upper bound doesn't */\r\n                        npp.r_stat[info.p] = GLP_NL;\r\n                    }\r\n                    else if (info.lb == -DBL_MAX && info.ub != +DBL_MAX)\r\n                    {  /* row upper bound exists, but lower bound doesn't */\r\n                        npp.r_stat[info.p] = GLP_NU;\r\n                    }\r\n                    else if (info.lb != -DBL_MAX && info.ub != +DBL_MAX)\r\n                    {  /* both row lower and upper bounds exist */\r\n                        /* to choose proper active row bound we should not use\r\n                         lambda~[q], because its value being close to zero is\r\n                         unreliable; so we choose that bound which provides\r\n                         primal feasibility for original constraint (1) */\r\n                        if (info.apq * npp.c_value[info.q] <=\r\n                            0.5 * (info.lb + info.ub))\r\n                            npp.r_stat[info.p] = GLP_NL;\r\n                        else\r\n                            npp.r_stat[info.p] = GLP_NU;\r\n                    }\r\n                    else\r\n                    {  npp_error();\r\n                        return 1;\r\n                    }\r\n                    npp.c_stat[info.q] = GLP_BS;\r\n                    npp.r_pi[info.p] = lambda / info.apq;\r\n                }\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            if (npp.sol == GLP_IPT)\r\n            {  /* recover interior-point solution */\r\n                if (lambda > +DBL_EPSILON && info.lb_changed ||\r\n                    lambda < -DBL_EPSILON && info.ub_changed)\r\n                {  /* actually row p has corresponding active bound */\r\n                    npp.r_pi[info.p] = lambda / info.apq;\r\n                }\r\n                else\r\n                {  /* either bounds of column q are both inactive or its\r\n                 original bound is active */\r\n                    npp.r_pi[info.p] = 0.0;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = apq.val;\r\n    info.c = q.coef;\r\n    info.lb = p.lb;\r\n    info.ub = p.ub;\r\n    info.lb_changed = lb_changed;\r\n    info.ub_changed = ub_changed;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q], i != p (not needed for MIP\r\n     solution) */\r\n    if (npp.sol != GLP_MIP)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n    return lb_changed >= ub_changed ? lb_changed : ub_changed;\r\n}\r\n\r\nfunction npp_implied_slack(npp, q){\r\n    /* process column singleton (implied slack variable) */\r\n    var info;\r\n    var p;\r\n    var aij;\r\n    var lfe;\r\n    /* the column must be non-integral non-fixed singleton */\r\n    xassert(!q.is_int);\r\n    xassert(q.lb < q.ub);\r\n    xassert(q.ptr != null && q.ptr.c_next == null);\r\n    /* corresponding row must be equality constraint */\r\n    aij = q.ptr;\r\n    p = aij.row;\r\n    xassert(p.lb == p.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column singleton (implied slack variable) */\r\n            var temp;\r\n            var lfe;\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* assign statuses to row p and column q */\r\n                if (npp.r_stat[info.p] == GLP_BS ||\r\n                    npp.r_stat[info.p] == GLP_NF)\r\n                    npp.c_stat[info.q] = npp.r_stat[info.p];\r\n                else if (npp.r_stat[info.p] == GLP_NL)\r\n                    npp.c_stat[info.q] =\r\n                        (info.apq > 0.0 ? GLP_NU : GLP_NL);\r\n                else if (npp.r_stat[info.p] == GLP_NU)\r\n                    npp.c_stat[info.q] =\r\n                        (info.apq > 0.0 ? GLP_NL : GLP_NU);\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                npp.r_stat[info.p] = GLP_NS;\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute multiplier for row p */\r\n                npp.r_pi[info.p] += info.c / info.apq;\r\n            }\r\n            /* compute value of column q */\r\n            temp = info.b;\r\n            for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                temp -= lfe.val * npp.c_value[lfe.ref];\r\n            npp.c_value[info.q] = temp / info.apq;\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = aij.val;\r\n    info.b = p.lb;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save row coefficients a[p,j], j != q, and substitute x[q]\r\n     into the objective row */\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.col == q) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.col.j;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n        aij.col.coef -= info.c * (aij.val / info.apq);\r\n    }\r\n    npp.c0 += info.c * (info.b / info.apq);\r\n    /* compute new row bounds */\r\n    if (info.apq > 0.0)\r\n    {  p.lb = (q.ub == +DBL_MAX ?\r\n        -DBL_MAX : info.b - info.apq * q.ub);\r\n        p.ub = (q.lb == -DBL_MAX ?\r\n            +DBL_MAX : info.b - info.apq * q.lb);\r\n    }\r\n    else\r\n    {  p.lb = (q.lb == -DBL_MAX ?\r\n        -DBL_MAX : info.b - info.apq * q.lb);\r\n        p.ub = (q.ub == +DBL_MAX ?\r\n            +DBL_MAX : info.b - info.apq * q.ub);\r\n    }\r\n    /* remove the column from the problem */\r\n    npp_del_col(npp, q);\r\n}\r\n\r\nfunction npp_implied_free(npp, q){\r\n    /* process column singleton (implied free variable) */\r\n    var info;\r\n    var p;\r\n    var apq, aij;\r\n    var alfa, beta, l, u, pi, eps;\r\n    /* the column must be non-fixed singleton */\r\n    xassert(q.lb < q.ub);\r\n    xassert(q.ptr != null && q.ptr.c_next == null);\r\n    /* corresponding row must be inequality constraint */\r\n    apq = q.ptr;\r\n    p = apq.row;\r\n    xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* compute alfa */\r\n    alfa = p.lb;\r\n    if (alfa != -DBL_MAX)\r\n    {  for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        if (aij.val > 0.0)\r\n        {  if (aij.col.ub == +DBL_MAX)\r\n        {  alfa = -DBL_MAX;\r\n            break;\r\n        }\r\n            alfa -= aij.val * aij.col.ub;\r\n        }\r\n        else /* < 0.0 */\r\n        {  if (aij.col.lb == -DBL_MAX)\r\n        {  alfa = -DBL_MAX;\r\n            break;\r\n        }\r\n            alfa -= aij.val * aij.col.lb;\r\n        }\r\n    }\r\n    }\r\n    /* compute beta */\r\n    beta = p.ub;\r\n    if (beta != +DBL_MAX)\r\n    {  for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        if (aij.val > 0.0)\r\n        {  if (aij.col.lb == -DBL_MAX)\r\n        {  beta = +DBL_MAX;\r\n            break;\r\n        }\r\n            beta -= aij.val * aij.col.lb;\r\n        }\r\n        else /* < 0.0 */\r\n        {  if (aij.col.ub == +DBL_MAX)\r\n        {  beta = +DBL_MAX;\r\n            break;\r\n        }\r\n            beta -= aij.val * aij.col.ub;\r\n        }\r\n    }\r\n    }\r\n    /* compute implied column lower bound l'[q] */\r\n    if (apq.val > 0.0)\r\n        l = (alfa == -DBL_MAX ? -DBL_MAX : alfa / apq.val);\r\n    else /* < 0.0 */\r\n        l = (beta == +DBL_MAX ? -DBL_MAX : beta / apq.val);\r\n    /* compute implied column upper bound u'[q] */\r\n    if (apq.val > 0.0)\r\n        u = (beta == +DBL_MAX ? +DBL_MAX : beta / apq.val);\r\n    else\r\n        u = (alfa == -DBL_MAX ? +DBL_MAX : alfa / apq.val);\r\n    /* check if column lower bound l[q] can be active */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(q.lb);\r\n        if (l < q.lb - eps) return 1; /* yes, it can */\r\n    }\r\n    /* check if column upper bound u[q] can be active */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(q.ub);\r\n        if (u > q.ub + eps) return 1; /* yes, it can */\r\n    }\r\n    /* okay; make column q free (unbounded) */\r\n    q.lb = -DBL_MAX; q.ub = +DBL_MAX;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column singleton (implied free variable) */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  xassert(info.stat == GLP_NL || info.stat == GLP_NU);\r\n                npp.r_stat[info.p] = info.stat;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.stat = -1;\r\n    /* compute row multiplier pi[p] */\r\n    pi = q.coef / apq.val;\r\n    /* check dual feasibility for row p */\r\n\r\n    function nl(){\r\n        info.stat = GLP_NL;\r\n        p.ub = p.lb;\r\n    }\r\n\r\n    function nu(){\r\n        info.stat = GLP_NU;\r\n        p.lb = p.ub;\r\n    }\r\n\r\n    if (pi > +DBL_EPSILON)\r\n    {  /* lower bound L[p] must be active */\r\n        if (p.lb != -DBL_MAX)\r\n            nl();\r\n        else\r\n        {  if (pi > +1e-5) return 2; /* dual infeasibility */\r\n            /* take a chance on U[p] */\r\n            xassert(p.ub != +DBL_MAX);\r\n            nu();\r\n        }\r\n    }\r\n    else if (pi < -DBL_EPSILON)\r\n    {  /* upper bound U[p] must be active */\r\n        if (p.ub != +DBL_MAX)\r\n            nu();\r\n        else\r\n        {  if (pi < -1e-5) return 2; /* dual infeasibility */\r\n            /* take a chance on L[p] */\r\n            xassert(p.lb != -DBL_MAX);\r\n            nl();\r\n        }\r\n    }\r\n    else\r\n    {  /* any bound (either L[p] or U[p]) can be made active  */\r\n        if (p.ub == +DBL_MAX)\r\n        {  xassert(p.lb != -DBL_MAX);\r\n           nl();\r\n        }\r\n        else if (p.lb == -DBL_MAX)\r\n        {  xassert(p.ub != +DBL_MAX);\r\n            nu();\r\n        } else {\r\n            if (Math.abs(p.lb) <= Math.abs(p.ub)) nl(); else nu();\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction npp_eq_doublet(npp, p){\r\n    /* process row doubleton (equality constraint) */\r\n    var info;\r\n    var i;\r\n    var q, r;\r\n    var apq, apr, aiq, air, next;\r\n    var lfe;\r\n    var gamma;\r\n    /* the row must be doubleton equality constraint */\r\n    xassert(p.lb == p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next != null &&\r\n        p.ptr.r_next.r_next == null);\r\n    /* choose column to be eliminated */\r\n    {  var a1, a2;\r\n        a1 = p.ptr; a2 = a1.r_next;\r\n        if (Math.abs(a2.val) < 0.001 * Math.abs(a1.val))\r\n        {  /* only first column can be eliminated, because second one\r\n         has too small constraint coefficient */\r\n            apq = a1; apr = a2;\r\n        }\r\n        else if (Math.abs(a1.val) < 0.001 * Math.abs(a2.val))\r\n        {  /* only second column can be eliminated, because first one\r\n         has too small constraint coefficient */\r\n            apq = a2; apr = a1;\r\n        }\r\n        else\r\n        {  /* both columns are appropriate; choose that one which is\r\n         shorter to minimize fill-in */\r\n            if (npp_col_nnz(a1.col) <= npp_col_nnz(a2.col))\r\n            {  /* first column is shorter */\r\n                apq = a1; apr = a2;\r\n            }\r\n            else\r\n            {  /* second column is shorter */\r\n                apq = a2; apr = a1;\r\n            }\r\n        }\r\n    }\r\n    /* now columns q and r have been chosen */\r\n    q = apq.col; r = apr.col;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row doubleton (equality constraint) */\r\n            var lfe;\r\n            var gamma, temp;\r\n            /* we assume that processing row p is followed by processing\r\n             column q as singleton of type \"implied slack variable\", in\r\n             which case row p must always be active equality constraint */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] != GLP_NS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute value of multiplier for row p; see (14) */\r\n                temp = npp.r_pi[info.p];\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                {  gamma = lfe.val / info.apq; /* a[i,q] / a[p,q] */\r\n                    temp -= gamma * npp.r_pi[lfe.ref];\r\n                }\r\n                npp.r_pi[info.p] = temp;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.apq = apq.val;\r\n    info.ptr = null;\r\n    /* transform each row i (i != p), where a[i,q] != 0, to eliminate\r\n     column q */\r\n    for (aiq = q.ptr; aiq != null; aiq = next)\r\n    {  next = aiq.c_next;\r\n        if (aiq == apq) continue; /* skip row p */\r\n        i = aiq.row; /* row i to be transformed */\r\n        /* save constraint coefficient a[i,q] */\r\n        if (npp.sol != GLP_MIP)\r\n        {  lfe = {};\r\n            lfe.ref = i.i;\r\n            lfe.val = aiq.val;\r\n            lfe.next = info.ptr;\r\n            info.ptr = lfe;\r\n        }\r\n        /* find coefficient a[i,r] in row i */\r\n        for (air = i.ptr; air != null; air = air.r_next)\r\n            if (air.col == r) break;\r\n        /* if a[i,r] does not exist, create a[i,r] = 0 */\r\n        if (air == null)\r\n            air = npp_add_aij(i, r, 0.0);\r\n        /* compute gamma[i] = a[i,q] / a[p,q] */\r\n        gamma = aiq.val / apq.val;\r\n        /* (row i) := (row i) - gamma[i] * (row p); see (3)-(6) */\r\n        /* new a[i,q] is exact zero due to elimnation; remove it from\r\n         row i */\r\n        npp_del_aij(aiq);\r\n        /* compute new a[i,r] */\r\n        air.val -= gamma * apr.val;\r\n        /* if new a[i,r] is close to zero due to numeric cancelation,\r\n         remove it from row i */\r\n        if (Math.abs(air.val) <= 1e-10)\r\n            npp_del_aij(air);\r\n        /* compute new lower and upper bounds of row i */\r\n        if (i.lb == i.ub)\r\n            i.lb = i.ub = (i.lb - gamma * p.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= gamma * p.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= gamma * p.lb;\r\n        }\r\n    }\r\n    return q;\r\n}\r\n\r\nfunction npp_forcing_row(npp, p, at){\r\n    /* process forcing row */\r\n    var info;\r\n    var col = null;\r\n    var j;\r\n    var apj, aij;\r\n    var lfe;\r\n    var big;\r\n    xassert(at == 0 || at == 1);\r\n    /* determine maximal magnitude of the row coefficients */\r\n    big = 1.0;\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n        if (big < Math.abs(apj.val)) big = Math.abs(apj.val);\r\n    /* if there are too small coefficients in the row, transformation\r\n     should not be applied */\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n        if (Math.abs(apj.val) < 1e-7 * big) return 1;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover forcing row */\r\n            var col, piv;\r\n            var lfe;\r\n            var d, big, temp;\r\n            if (npp.sol == GLP_MIP) return 0;\r\n            /* initially solution to the original problem is the same as\r\n             to the transformed problem, where row p is inactive constraint\r\n             with pi[p] = 0, and all columns are non-basic */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] != GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n                for (col = info.ptr; col != null; col = col.next)\r\n                {  if (npp.c_stat[col.j] != GLP_NS)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                    npp.c_stat[col.j] = col.stat; /* original status */\r\n                }\r\n            }\r\n            /* compute reduced costs d[j] for all columns with formula (10)\r\n             and store them in col.c instead objective coefficients */\r\n            for (col = info.ptr; col != null; col = col.next)\r\n            {  d = col.c;\r\n                for (lfe = col.ptr; lfe != null; lfe = lfe.next)\r\n                    d -= lfe.val * npp.r_pi[lfe.ref];\r\n                col.c = d;\r\n            }\r\n            /* consider columns j, whose multipliers lambda[j] has wrong\r\n             sign in solution to the transformed problem (where lambda[j] =\r\n             d[j]), and choose column q, whose multipler lambda[q] reaches\r\n             zero last on changing row multiplier pi[p]; see (14) */\r\n            piv = null; big = 0.0;\r\n            for (col = info.ptr; col != null; col = col.next)\r\n            {  d = col.c; /* d[j] */\r\n                temp = Math.abs(d / col.a);\r\n                if (col.stat == GLP_NL)\r\n                {  /* column j has active lower bound */\r\n                    if (d < 0.0 && big < temp){\r\n                        piv = col; big = temp;\r\n                    }\r\n                }\r\n                else if (col.stat == GLP_NU)\r\n                {  /* column j has active upper bound */\r\n                    if (d > 0.0 && big < temp){\r\n                        piv = col; big = temp;\r\n                    }\r\n                }\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n            }\r\n            /* if column q does not exist, no correction is needed */\r\n            if (piv != null)\r\n            {  /* correct solution; row p becomes active constraint while\r\n             column q becomes basic */\r\n                if (npp.sol == GLP_SOL)\r\n                {  npp.r_stat[info.p] = info.stat;\r\n                    npp.c_stat[piv.j] = GLP_BS;\r\n                }\r\n                /* assign new value to row multiplier pi[p] = d[p] / a[p,q] */\r\n                npp.r_pi[info.p] = piv.c / piv.a;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    if (p.lb == p.ub)\r\n    {  /* equality constraint */\r\n        info.stat = GLP_NS;\r\n    }\r\n    else if (at == 0)\r\n    {  /* inequality constraint; case L[p] = U'[p] */\r\n        info.stat = GLP_NL;\r\n        xassert(p.lb != -DBL_MAX);\r\n    }\r\n    else /* at == 1 */\r\n    {  /* inequality constraint; case U[p] = L'[p] */\r\n        info.stat = GLP_NU;\r\n        xassert(p.ub != +DBL_MAX);\r\n    }\r\n    info.ptr = null;\r\n    /* scan the forcing row, fix columns at corresponding bounds, and\r\n     save column information (the latter is not needed for MIP) */\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n    {  /* column j has non-zero coefficient in the forcing row */\r\n        j = apj.col;\r\n        /* it must be non-fixed */\r\n        xassert(j.lb < j.ub);\r\n        /* allocate stack entry to save column information */\r\n        if (npp.sol != GLP_MIP)\r\n        {  col = {};\r\n            col.j = j.j;\r\n            col.stat = -1; /* will be set below */\r\n            col.a = apj.val;\r\n            col.c = j.coef;\r\n            col.ptr = null;\r\n            col.next = info.ptr;\r\n            info.ptr = col;\r\n        }\r\n        /* fix column j */\r\n        if (at == 0 && apj.val < 0.0 || at != 0 && apj.val > 0.0)\r\n        {  /* at its lower bound */\r\n            if (npp.sol != GLP_MIP)\r\n                col.stat = GLP_NL;\r\n            xassert(j.lb != -DBL_MAX);\r\n            j.ub = j.lb;\r\n        }\r\n        else\r\n        {  /* at its upper bound */\r\n            if (npp.sol != GLP_MIP)\r\n                col.stat = GLP_NU;\r\n            xassert(j.ub != +DBL_MAX);\r\n            j.lb = j.ub;\r\n        }\r\n        /* save column coefficients a[i,j], i != p */\r\n        if (npp.sol != GLP_MIP)\r\n        {  for (aij = j.ptr; aij != null; aij = aij.c_next)\r\n        {  if (aij == apj) continue; /* skip a[p,j] */\r\n            lfe = {};\r\n            lfe.ref = aij.row.i;\r\n            lfe.val = aij.val;\r\n            lfe.next = col.ptr;\r\n            col.ptr = lfe;\r\n        }\r\n        }\r\n    }\r\n    /* make the row free (unbounded) */\r\n    p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n    return 0;\r\n}\r\n\r\nfunction npp_analyze_row(npp, p){\r\n    /* perform general row analysis */\r\n    var aij;\r\n    var ret = 0x00;\r\n    var l, u, eps;\r\n    xassert(npp == npp);\r\n    /* compute implied lower bound L'[p]; see (3) */\r\n    l = 0.0;\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.val > 0.0)\r\n    {  if (aij.col.lb == -DBL_MAX)\r\n    {  l = -DBL_MAX;\r\n        break;\r\n    }\r\n        l += aij.val * aij.col.lb;\r\n    }\r\n    else /* aij.val < 0.0 */\r\n    {  if (aij.col.ub == +DBL_MAX)\r\n    {  l = -DBL_MAX;\r\n        break;\r\n    }\r\n        l += aij.val * aij.col.ub;\r\n    }\r\n    }\r\n    /* compute implied upper bound U'[p]; see (4) */\r\n    u = 0.0;\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.val > 0.0)\r\n    {  if (aij.col.ub == +DBL_MAX)\r\n    {  u = +DBL_MAX;\r\n        break;\r\n    }\r\n        u += aij.val * aij.col.ub;\r\n    }\r\n    else /* aij.val < 0.0 */\r\n    {  if (aij.col.lb == -DBL_MAX)\r\n    {  u = +DBL_MAX;\r\n        break;\r\n    }\r\n        u += aij.val * aij.col.lb;\r\n    }\r\n    }\r\n    /* column bounds are assumed correct, so L'[p] <= U'[p] */\r\n    /* check if row lower bound is consistent */\r\n    if (p.lb != -DBL_MAX)\r\n    {  eps = 1e-3 + 1e-6 * Math.abs(p.lb);\r\n        if (p.lb - eps > u)\r\n        {  ret = 0x33;\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if row upper bound is consistent */\r\n    if (p.ub != +DBL_MAX)\r\n    {  eps = 1e-3 + 1e-6 * Math.abs(p.ub);\r\n        if (p.ub + eps < l)\r\n        {  ret = 0x33;\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if row lower bound can be active/forcing */\r\n    if (p.lb != -DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(p.lb);\r\n        if (p.lb - eps > l)\r\n        {  if (p.lb + eps <= u)\r\n            ret |= 0x01;\r\n        else\r\n            ret |= 0x02;\r\n        }\r\n    }\r\n    /* check if row upper bound can be active/forcing */\r\n    if (p.ub != +DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(p.ub);\r\n        if (p.ub + eps < u)\r\n        {  /* check if the upper bound is forcing */\r\n            if (p.ub - eps >= l)\r\n                ret |= 0x10;\r\n            else\r\n                ret |= 0x20;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction npp_inactive_bound(npp, p, which){\r\n    /* remove row lower/upper inactive bound */\r\n    var info;\r\n    if (npp.sol == GLP_SOL)\r\n    {  /* create transformation stack entry */\r\n        info = npp_push_tse(npp,\r\n            function (npp, info){\r\n                /* recover row status */\r\n                if (npp.sol != GLP_SOL)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                if (npp.r_stat[info.p] == GLP_BS)\r\n                    npp.r_stat[info.p] = GLP_BS;\r\n                else\r\n                    npp.r_stat[info.p] = info.stat;\r\n                return 0;\r\n            }\r\n        );\r\n        info.p = p.i;\r\n        if (p.ub == +DBL_MAX)\r\n            info.stat = GLP_NL;\r\n        else if (p.lb == -DBL_MAX)\r\n            info.stat = GLP_NU;\r\n        else if (p.lb != p.ub)\r\n            info.stat = (which == 0 ? GLP_NU : GLP_NL);\r\n        else\r\n            info.stat = GLP_NS;\r\n    }\r\n    /* remove row inactive bound */\r\n    if (which == 0)\r\n    {  xassert(p.lb != -DBL_MAX);\r\n        p.lb = -DBL_MAX;\r\n    }\r\n    else if (which == 1)\r\n    {  xassert(p.ub != +DBL_MAX);\r\n        p.ub = +DBL_MAX;\r\n    }\r\n    else\r\n        xassert(which != which);\r\n}\r\n\r\nfunction npp_implied_bounds(npp, p){\r\n    var apj, apk;\r\n    var big, eps, temp;\r\n    var skip = false;\r\n    xassert(npp == npp);\r\n    /* initialize implied bounds for all variables and determine\r\n     maximal magnitude of row coefficients a[p,j] */\r\n    big = 1.0;\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n    {  apj.col.ll.ll = -DBL_MAX; apj.col.uu.uu = +DBL_MAX;\r\n        if (big < Math.abs(apj.val)) big = Math.abs(apj.val);\r\n    }\r\n    eps = 1e-6 * big;\r\n    /* process row lower bound (assuming that it can be active) */\r\n    if (p.lb != -DBL_MAX){\r\n        apk = null;\r\n\r\n        for (apj = p.ptr; apj != null; apj = apj.r_next){\r\n            if (apj.val > 0.0 && apj.col.ub == +DBL_MAX || apj.val < 0.0 && apj.col.lb == -DBL_MAX){\r\n                if (apk == null)\r\n                    apk = apj;\r\n                else {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!skip){\r\n            /* if a[p,k] = null then |J'| = 0 else J' = { k } */\r\n            temp = p.lb;\r\n            for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n            {  if (apj == apk){\r\n                /* skip a[p,k] */\r\n            }\r\n            else if (apj.val > 0.0)\r\n                temp -= apj.val * apj.col.ub;\r\n            else /* apj.val < 0.0 */\r\n                temp -= apj.val * apj.col.lb;\r\n            }\r\n            /* compute column implied bounds */\r\n            if (apk == null)\r\n            {  /* temp = L[p] - U'[p] */\r\n                for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n                {  if (apj.val >= +eps)\r\n                {  /* l'[j] := u[j] + (L[p] - U'[p]) / a[p,j] */\r\n                    apj.col.ll.ll = apj.col.ub + temp / apj.val;\r\n                }\r\n                else if (apj.val <= -eps)\r\n                {  /* u'[j] := l[j] + (L[p] - U'[p]) / a[p,j] */\r\n                    apj.col.uu.uu = apj.col.lb + temp / apj.val;\r\n                }\r\n                }\r\n            }\r\n            else\r\n            {  /* temp = L[p,k] */\r\n                if (apk.val >= +eps)\r\n                {  /* l'[k] := L[p,k] / a[p,k] */\r\n                    apk.col.ll.ll = temp / apk.val;\r\n                }\r\n                else if (apk.val <= -eps)\r\n                {  /* u'[k] := L[p,k] / a[p,k] */\r\n                    apk.col.uu.uu = temp / apk.val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    skip = false;\r\n    /* process row upper bound (assuming that it can be active) */\r\n    if (p.ub != +DBL_MAX)\r\n    {  apk = null;\r\n        for (apj = p.ptr; apj != null; apj = apj.r_next){\r\n            if (apj.val > 0.0 && apj.col.lb == -DBL_MAX || apj.val < 0.0 && apj.col.ub == +DBL_MAX){\r\n                if (apk == null)\r\n                    apk = apj;\r\n                else {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!skip){\r\n            /* if a[p,k] = null then |J''| = 0 else J'' = { k } */\r\n            temp = p.ub;\r\n            for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n            {  if (apj == apk){\r\n                /* skip a[p,k] */\r\n            }\r\n            else if (apj.val > 0.0)\r\n                temp -= apj.val * apj.col.lb;\r\n            else /* apj.val < 0.0 */\r\n                temp -= apj.val * apj.col.ub;\r\n            }\r\n            /* compute column implied bounds */\r\n            if (apk == null)\r\n            {  /* temp = U[p] - L'[p] */\r\n                for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n                {  if (apj.val >= +eps)\r\n                {  /* u'[j] := l[j] + (U[p] - L'[p]) / a[p,j] */\r\n                    apj.col.uu.uu = apj.col.lb + temp / apj.val;\r\n                }\r\n                else if (apj.val <= -eps)\r\n                {  /* l'[j] := u[j] + (U[p] - L'[p]) / a[p,j] */\r\n                    apj.col.ll.ll = apj.col.ub + temp / apj.val;\r\n                }\r\n                }\r\n            }\r\n            else\r\n            {  /* temp = U[p,k] */\r\n                if (apk.val >= +eps)\r\n                {  /* u'[k] := U[p,k] / a[p,k] */\r\n                    apk.col.uu.uu = temp / apk.val;\r\n                }\r\n                else if (apk.val <= -eps)\r\n                {  /* l'[k] := U[p,k] / a[p,k] */\r\n                    apk.col.ll.ll = temp / apk.val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction npp_binarize_prob(npp){\r\n    /* binarize MIP problem */\r\n    var info;\r\n    var row;\r\n    var col, bin;\r\n    var aij;\r\n    var u, n, k, temp, nfails, nvars, nbins, nrows;\r\n    /* new variables will be added to the end of the column list, so\r\n     we go from the end to beginning of the column list */\r\n    nfails = nvars = nbins = nrows = 0;\r\n    for (col = npp.c_tail; col != null; col = col.prev)\r\n    {  /* skip continuous variable */\r\n        if (!col.is_int) continue;\r\n        /* skip fixed variable */\r\n        if (col.lb == col.ub) continue;\r\n        /* skip binary variable */\r\n        if (col.lb == 0.0 && col.ub == 1.0) continue;\r\n        /* check if the transformation is applicable */\r\n        if (col.lb < -1e6 || col.ub > +1e6 ||\r\n            col.ub - col.lb > 4095.0)\r\n        {  /* unfortunately, not */\r\n            nfails++;\r\n            continue;\r\n        }\r\n        /* process integer non-binary variable x[q] */\r\n        nvars++;\r\n        /* make x[q] non-negative, if its lower bound is non-zero */\r\n        if (col.lb != 0.0)\r\n            npp_lbnd_col(npp, col);\r\n        /* now 0 <= x[q] <= u[q] */\r\n        xassert(col.lb == 0.0);\r\n        u = col.ub|0;\r\n        xassert(col.ub == u);\r\n        /* if x[q] is binary, further processing is not needed */\r\n        if (u == 1) continue;\r\n        /* determine smallest n such that u <= 2^n - 1 (thus, n is the\r\n         number of binary variables needed) */\r\n        n = 2; temp = 4;\r\n        while (u >= temp){\r\n            n++; temp += temp;\r\n        }\r\n        nbins += n;\r\n        /* create transformation stack entry */\r\n        info = npp_push_tse(npp,\r\n            function (npp, info)\r\n            {     /* recovery binarized variable */\r\n                var k, temp;\r\n                /* compute value of x[q]; see formula (3) */\r\n                var sum = npp.c_value[info.q];\r\n                for (k = 1, temp = 2; k < info.n; k++, temp += temp)\r\n                    sum += temp * npp.c_value[info.j + (k-1)];\r\n                npp.c_value[info.q] = sum;\r\n                return 0;\r\n            }\r\n        );\r\n        info.q = col.j;\r\n        info.j = 0; /* will be set below */\r\n        info.n = n;\r\n        /* if u < 2^n - 1, we need one additional row for (4) */\r\n        if (u < temp - 1)\r\n        {  row = npp_add_row(npp); nrows++;\r\n            row.lb = -DBL_MAX; row.ub = u;\r\n        }\r\n        else\r\n            row = null;\r\n        /* in the transformed problem variable x[q] becomes binary\r\n         variable x[0], so its objective and constraint coefficients\r\n         are not changed */\r\n        col.ub = 1.0;\r\n        /* include x[0] into constraint (4) */\r\n        if (row != null)\r\n            npp_add_aij(row, col, 1.0);\r\n        /* add other binary variables x[1], ..., x[n-1] */\r\n        for (k = 1, temp = 2; k < n; k++, temp += temp)\r\n        {  /* add new binary variable x[k] */\r\n            bin = npp_add_col(npp);\r\n            bin.is_int = 1;\r\n            bin.lb = 0.0; bin.ub = 1.0;\r\n            bin.coef = temp * col.coef;\r\n            /* store column reference number for x[1] */\r\n            if (info.j == 0)\r\n                info.j = bin.j;\r\n            else\r\n                xassert(info.j + (k-1) == bin.j);\r\n            /* duplicate constraint coefficients for x[k]; this also\r\n             automatically includes x[k] into constraint (4) */\r\n            for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                npp_add_aij(aij.row, bin, temp * aij.val);\r\n        }\r\n    }\r\n    if (nvars > 0)\r\n        xprintf(nvars + \" integer variable(s) were replaced by \" + nbins + \" binary ones\");\r\n    if (nrows > 0)\r\n        xprintf(nrows + \" row(s) were added due to binarization\");\r\n    if (nfails > 0)\r\n        xprintf(\"Binarization failed for \" + nfails + \" integer variable(s)\");\r\n    return nfails;\r\n}\r\n\r\nfunction copy_form(row, s){\r\n    /* copy linear form */\r\n    var aij;\r\n    var ptr, e;\r\n    ptr = null;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  e = {};\r\n        e.aj = s * aij.val;\r\n        e.xj = aij.col;\r\n        e.next = ptr;\r\n        ptr = e;\r\n    }\r\n    return ptr;\r\n}\r\n\r\nfunction npp_is_packing(npp, row){\r\n    /* test if constraint is packing inequality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (!(row.lb == -DBL_MAX && row.ub != +DBL_MAX))\r\n        return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.ub != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction hidden_packing(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] <= b;\r\n 0 - specified row is NOT hidden packing inequality;\r\n 1 - specified row is packing inequality;\r\n 2 - specified row is hidden packing inequality. */\r\n    var e, ej, ek;\r\n    var neg;\r\n    var eps;\r\n    xassert(npp == npp);\r\n    /* a[j] must be non-zero, x[j] must be binary, for all j in J */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  xassert(e.aj != 0.0);\r\n        xassert(e.xj.is_int);\r\n        xassert(e.xj.lb == 0.0 && e.xj.ub == 1.0);\r\n    }\r\n    /* check if the specified inequality constraint already has the\r\n     form of packing inequality */\r\n    neg = 0; /* neg is |Jn| */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj == +1.0){\r\n        \r\n    }\r\n    else if (e.aj == -1.0)\r\n        neg++;\r\n    else\r\n        break;\r\n    }\r\n    if (e == null)\r\n    {  /* all coefficients a[j] are +1 or -1; check rhs b */\r\n        if (b == (1 - neg))\r\n        {  /* it is packing inequality; no processing is needed */\r\n            return 1;\r\n        }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\r\n     positive; the result is a~[j] = |a[j]| and new rhs b */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0) b -= e.aj;\r\n    /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\r\n    /* if a[j] > b, skip processing--this case must not appear */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (Math.abs(e.aj) > b) return 0;\r\n    /* now 0 < a[j] <= b for all j in J */\r\n    /* find two minimal coefficients a[j] and a[k], j != k */\r\n    ej = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (ej == null || Math.abs(ej.aj) > Math.abs(e.aj)) ej = e;\r\n    xassert(ej != null);\r\n    ek = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e != ej)\r\n            if (ek == null || Math.abs(ek.aj) > Math.abs(e.aj)) ek = e;\r\n    xassert(ek != null);\r\n    /* the specified constraint is equivalent to packing inequality\r\n     iff a[j] + a[k] > b + eps */\r\n    eps = 1e-3 + 1e-6 * Math.abs(b);\r\n    if (Math.abs(ej.aj) + Math.abs(ek.aj) <= b + eps) return 0;\r\n    /* perform back substitution x~[j] = 1 - x[j] and construct the\r\n     final equivalent packing inequality in generalized format */\r\n    b = 1.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n        e.aj = +1.0;\r\n    else /* e.aj < 0.0 */{\r\n        e.aj = -1.0; b -= 1.0\r\n    }\r\n    }\r\n    callback(b);\r\n    return 2;\r\n}\r\n\r\nfunction npp_hidden_packing(npp, row){\r\n    /* identify hidden packing inequality */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, ret, count = 0;\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.ub;\r\n    }\r\n    else\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.lb;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] <= b\" */\r\n        ret = hidden_packing(npp, ptr, b, function(v){b=v});\r\n        xassert(0 <= ret && ret <= 2);\r\n        if (kase == 1 && ret == 1 || ret == 2)\r\n        {  /* the original inequality has been identified as hidden\r\n         packing inequality */\r\n            count++;\r\n            if (GLP_DEBUG){\r\n                xprintf(\"Original constraint:\");\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    xprintf(\" \" + aij.val + \" x\" + aij.col.j);\r\n                if (row.lb != -DBL_MAX) xprintf(\", >= \" + row.lb);\r\n                if (row.ub != +DBL_MAX) xprintf(\", <= \" + row.ub);\r\n                xprintf(\"\");\r\n                xprintf(\"Equivalent packing inequality:\");\r\n                for (e = ptr; e != null; e = e.next)\r\n                    xprintf(\" \" + (e.aj > 0.0 ? \"+\" : \"-\") + \"x\" + e.xj.j);\r\n                xprintf(\", <= \" + b + \"\");\r\n            }\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                else\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = -DBL_MAX; row.ub = b;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing lower bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_implied_packing(row, which, var_, set_){\r\n    var ptr, e, i, k;\r\n    var len = 0;\r\n    var b, eps;\r\n    /* build inequality (3) */\r\n    if (which == 0)\r\n    {  ptr = copy_form(row, -1.0);\r\n        xassert(row.lb != -DBL_MAX);\r\n        b = - row.lb;\r\n    }\r\n    else if (which == 1)\r\n    {  ptr = copy_form(row, +1.0);\r\n        xassert(row.ub != +DBL_MAX);\r\n        b = + row.ub;\r\n    }\r\n    /* remove non-binary variables to build relaxed inequality (5);\r\n     compute its right-hand side b~ with formula (6) */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (!(e.xj.is_int && e.xj.lb == 0.0 && e.xj.ub == 1.0))\r\n    {  /* x[j] is non-binary variable */\r\n        if (e.aj > 0.0)\r\n        {  if (e.xj.lb == -DBL_MAX) return len;\r\n            b -= e.aj * e.xj.lb;\r\n        }\r\n        else /* e.aj < 0.0 */\r\n        {  if (e.xj.ub == +DBL_MAX) return len;\r\n            b -= e.aj * e.xj.ub;\r\n        }\r\n        /* a[j] = 0 means that variable x[j] is removed */\r\n        e.aj = 0.0;\r\n    }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] to build knapsack inequality (8);\r\n     compute its right-hand side beta with formula (11) */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0.0) b -= e.aj;\r\n    /* if beta is close to zero, the knapsack inequality is either\r\n     infeasible or forcing inequality; this must never happen, so\r\n     we skip further analysis */\r\n    if (b < 1e-3) return len;\r\n    /* build set P as well as sets Jp and Jn, and determine x[k] as\r\n     explained above in comments to the routine */\r\n    eps = 1e-3 + 1e-6 * b;\r\n    i = k = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  /* note that alfa[j] = |a[j]| */\r\n        if (Math.abs(e.aj) > 0.5 * (b + eps))\r\n        {  /* alfa[j] > (b + eps) / 2; include x[j] in set P, i.e. in\r\n         set Jp or Jn */\r\n            var_[++len] = e.xj;\r\n            set_[len] = (e.aj > 0.0 ? 0 : 1);\r\n            /* alfa[i] = min alfa[j] over all j included in set P */\r\n            if (i == null || Math.abs(i.aj) > Math.abs(e.aj)) i = e;\r\n        }\r\n        else if (Math.abs(e.aj) >= 1e-3)\r\n        {  /* alfa[k] = max alfa[j] over all j not included in set P;\r\n         we skip coefficient a[j] if it is close to zero to avoid\r\n         numerically unreliable results */\r\n            if (k == null || Math.abs(k.aj) < Math.abs(e.aj)) k = e;\r\n        }\r\n    }\r\n    /* if alfa[k] satisfies to condition (13) for all j in P, include\r\n     x[k] in P */\r\n    if (i != null && k != null && Math.abs(i.aj) + Math.abs(k.aj) > b + eps)\r\n    {  var_[++len] = k.xj;\r\n        set_[len] = (k.aj > 0.0 ? 0 : 1);\r\n    }\r\n    /* trivial packing inequality being redundant must never appear,\r\n     so we just ignore it */\r\n    if (len < 2) len = 0;\r\n    return len;\r\n\r\n}\r\n\r\nfunction npp_is_covering(npp, row){\r\n    /* test if constraint is covering inequality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (!(row.lb != -DBL_MAX && row.ub == +DBL_MAX))\r\n        return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.lb != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction hidden_covering(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] >= b;\r\n 0 - specified row is NOT hidden covering inequality;\r\n 1 - specified row is covering inequality;\r\n 2 - specified row is hidden covering inequality. */\r\n    var e;\r\n    var neg;\r\n    var eps;\r\n    xassert(npp == npp);\r\n    /* a[j] must be non-zero, x[j] must be binary, for all j in J */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  xassert(e.aj != 0.0);\r\n        xassert(e.xj.is_int);\r\n        xassert(e.xj.lb == 0.0 && e.xj.ub == 1.0);\r\n    }\r\n    /* check if the specified inequality constraint already has the\r\n     form of covering inequality */\r\n    neg = 0; /* neg is |Jn| */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj == +1.0){\r\n\r\n    }\r\n    else if (e.aj == -1.0)\r\n        neg++;\r\n    else\r\n        break;\r\n    }\r\n    if (e == null)\r\n    {  /* all coefficients a[j] are +1 or -1; check rhs b */\r\n        if (b == (1 - neg))\r\n        {  /* it is covering inequality; no processing is needed */\r\n            return 1;\r\n        }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\r\n     positive; the result is a~[j] = |a[j]| and new rhs b */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0) b -= e.aj;\r\n    /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\r\n    /* if b <= 0, skip processing--this case must not appear */\r\n    if (b < 1e-3) return 0;\r\n    /* now a[j] > 0 for all j in J, and b > 0 */\r\n    /* the specified constraint is equivalent to covering inequality\r\n     iff a[j] >= b for all j in J */\r\n    eps = 1e-9 + 1e-12 * Math.abs(b);\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (Math.abs(e.aj) < b - eps) return 0;\r\n    /* perform back substitution x~[j] = 1 - x[j] and construct the\r\n     final equivalent covering inequality in generalized format */\r\n    b = 1.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n        e.aj = +1.0;\r\n    else /* e.aj < 0.0 */{\r\n        e.aj = -1.0; b -= 1.0;\r\n    }\r\n    }\r\n    callback(b);\r\n    return 2;\r\n}\r\n\r\nfunction npp_hidden_covering(npp, row){\r\n    /* identify hidden covering inequality */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, ret, count = 0;\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.lb;\r\n    }\r\n    else\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.ub;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] >= b\" */\r\n        ret = hidden_covering(npp, ptr, b, function(v){b=v});\r\n        xassert(0 <= ret && ret <= 2);\r\n        if (kase == 1 && ret == 1 || ret == 2)\r\n        {  /* the original inequality has been identified as hidden\r\n         covering inequality */\r\n            count++;\r\n            if (GLP_DEBUG){\r\n                xprintf(\"Original constraint:\");\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    xprintf(\" \" + aij.val + \" x\" + aij.col.j);\r\n                if (row.lb != -DBL_MAX) xprintf(\", >= \" + row.lb);\r\n                if (row.ub != +DBL_MAX) xprintf(\", <= \" + row.ub);\r\n                xprintf(\"\");\r\n                xprintf(\"Equivalent covering inequality:\");\r\n                for (e = ptr; e != null; e = e.next)\r\n                    xprintf(\" \" + (e.aj > 0.0 ? \"+\" : \"-\") + \"x\" + e.xj.j);\r\n                xprintf(\", >= \" + b + \"\");\r\n            }\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                else\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = b; row.ub = +DBL_MAX;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing upper bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_is_partitioning(npp, row){\r\n    /* test if constraint is partitioning equality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (row.lb != row.ub) return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.lb != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction reduce_ineq_coef(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] >= b */\r\n    /* returns: the number of coefficients reduced */\r\n    var e;\r\n    var count = 0;\r\n    var h, inf_t, new_a;\r\n    xassert(npp == npp);\r\n    /* compute h; see (15) */\r\n    h = 0.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n    {  if (e.xj.lb == -DBL_MAX) return count;\r\n        h += e.aj * e.xj.lb;\r\n    }\r\n    else /* e.aj < 0.0 */\r\n    {  if (e.xj.ub == +DBL_MAX) return count;\r\n        h += e.aj * e.xj.ub;\r\n    }\r\n    }\r\n    /* perform reduction of coefficients at binary variables */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  /* skip non-binary variable */\r\n        if (!(e.xj.is_int && e.xj.lb == 0.0 && e.xj.ub == 1.0))\r\n            continue;\r\n        if (e.aj > 0.0)\r\n        {  /* compute inf t[k]; see (14) */\r\n            inf_t = h;\r\n            if (b - e.aj < inf_t && inf_t < b)\r\n            {  /* compute reduced coefficient a'[k]; see (7) */\r\n                new_a = b - inf_t;\r\n                if (new_a >= +1e-3 &&\r\n                    e.aj - new_a >= 0.01 * (1.0 + e.aj))\r\n                {  /* accept a'[k] */\r\n                    if (GLP_DEBUG){xprintf(\"+\")}\r\n                    e.aj = new_a;\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        else /* e.aj < 0.0 */\r\n        {  /* compute inf t[k]; see (14) */\r\n            inf_t = h - e.aj;\r\n            if (b < inf_t && inf_t < b - e.aj)\r\n            {  /* compute reduced coefficient a'[k]; see (11) */\r\n                new_a = e.aj + (inf_t - b);\r\n                if (new_a <= -1e-3 &&\r\n                    new_a - e.aj >= 0.01 * (1.0 - e.aj))\r\n                {  /* accept a'[k] */\r\n                    if (GLP_DEBUG){xprintf(\"-\")}\r\n                    e.aj = new_a;\r\n                    /* update h; see (17) */\r\n                    h += (inf_t - b);\r\n                    /* compute b'; see (9) */\r\n                    b = inf_t;\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    callback(b);\r\n    return count\r\n}\r\n\r\nfunction npp_reduce_ineq_coef(npp, row){\r\n    /* reduce inequality constraint coefficients */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, count = new Array(2);\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    count[0] = count[1] = 0;\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        if (GLP_DEBUG){xprintf(\"L\")}\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.lb;\r\n    }\r\n    else\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        if (GLP_DEBUG){xprintf(\"U\")}\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.ub;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] >= b\" */\r\n        count[kase] = reduce_ineq_coef(npp, ptr, b, function(v){b=v});\r\n        if (count[kase] > 0)\r\n        {  /* the original inequality has been replaced by equivalent\r\n         one with coefficients reduced */\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                if (GLP_DEBUG){xprintf(\"*\")}\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                else\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = b; row.ub = +DBL_MAX;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing upper bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count[0] + count[1];\r\n}\r\n\r\n\r\nfunction npp_clean_prob(npp){\r\n    /* perform initial LP/MIP processing */\r\n    var row, next_row;\r\n    var col, next_col;\r\n    var ret;\r\n    xassert(npp == npp);\r\n    /* process rows which originally are free */\r\n    for (row = npp.r_head; row != null; row = next_row)\r\n    {  next_row = row.next;\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n        {  /* process free row */\r\n            if (GLP_DEBUG){xprintf(\"1\")}\r\n            npp_free_row(npp, row);\r\n            /* row was deleted */\r\n        }\r\n    }\r\n    /* process rows which originally are double-sided inequalities */\r\n    for (row = npp.r_head; row != null; row = next_row)\r\n    {  next_row = row.next;\r\n        if (row.lb != -DBL_MAX && row.ub != +DBL_MAX &&\r\n            row.lb < row.ub)\r\n        {  ret = npp_make_equality(npp, row);\r\n            if (ret == 0){\r\n\r\n            } else\r\n            if (ret == 1)\r\n            {  /* row was replaced by equality constraint */\r\n                if (GLP_DEBUG){xprintf(\"2\")}\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    /* process columns which are originally fixed */\r\n    for (col = npp.c_head; col != null; col = next_col)\r\n    {  next_col = col.next;\r\n        if (col.lb == col.ub)\r\n        {  /* process fixed column */\r\n            if (GLP_DEBUG){xprintf(\"3\")}\r\n            npp_fixed_col(npp, col);\r\n            /* column was deleted */\r\n        }\r\n    }\r\n    /* process columns which are originally double-bounded */\r\n    for (col = npp.c_head; col != null; col = next_col)\r\n    {  next_col = col.next;\r\n        if (col.lb != -DBL_MAX && col.ub != +DBL_MAX &&\r\n            col.lb < col.ub)\r\n        {  ret = npp_make_fixed(npp, col);\r\n            if (ret == 0){\r\n\r\n            }\r\n            else if (ret == 1)\r\n            {  /* column was replaced by fixed column; process it */\r\n                if (GLP_DEBUG){xprintf(\"4\")}\r\n                npp_fixed_col(npp, col);\r\n                /* column was deleted */\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction npp_process_row(npp, row, hard){\r\n    /* perform basic row processing */\r\n    var col;\r\n    var aij, next_aij, aaa;\r\n    var ret;\r\n    /* row must not be free */\r\n    xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));\r\n    /* start processing row */\r\n    if (row.ptr == null)\r\n    {  /* empty row */\r\n        ret = npp_empty_row(npp, row);\r\n        if (ret == 0)\r\n        {  /* row was deleted */\r\n            if (GLP_DEBUG){xprintf(\"A\")}\r\n            return 0;\r\n        }\r\n        else if (ret == 1)\r\n        {  /* primal infeasibility */\r\n            return GLP_ENOPFS;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n    }\r\n    if (row.ptr.r_next == null)\r\n    {  /* row singleton */\r\n        col = row.ptr.col;\r\n        if (row.lb == row.ub)\r\n        {  /* equality constraint */\r\n            ret = npp_eq_singlet(npp, row);\r\n            if (ret == 0)\r\n            {  /* column was fixed, row was deleted */\r\n                if (GLP_DEBUG){xprintf(\"B\")}\r\n                /* activate rows affected by column */\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    npp_activate_row(npp, aij.row);\r\n                /* process fixed column */\r\n                npp_fixed_col(npp, col);\r\n                /* column was deleted */\r\n                return 0;\r\n            }\r\n            else if (ret == 1 || ret == 2)\r\n            {  /* primal/integer infeasibility */\r\n                return GLP_ENOPFS;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n        else\r\n        {  /* inequality constraint */\r\n            ret = npp_ineq_singlet(npp, row);\r\n            if (0 <= ret && ret <= 3)\r\n            {  /* row was deleted */\r\n                if (GLP_DEBUG){xprintf(\"C\")}\r\n                /* activate column, since its length was changed due to\r\n                 row deletion */\r\n                npp_activate_col(npp, col);\r\n                if (ret >= 2)\r\n                {  /* column bounds changed significantly or column was\r\n                 fixed */\r\n                    /* activate rows affected by column */\r\n                    for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                        npp_activate_row(npp, aij.row);\r\n                }\r\n                if (ret == 3)\r\n                {  /* column was fixed; process it */\r\n                    if (GLP_DEBUG){xprintf(\"D\")}\r\n                    npp_fixed_col(npp, col);\r\n                    /* column was deleted */\r\n                }\r\n                return 0;\r\n            }\r\n            else if (ret == 4)\r\n            {  /* primal infeasibility */\r\n                return GLP_ENOPFS;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    /* general row analysis */\r\n    ret = npp_analyze_row(npp, row);\r\n    xassert(0x00 <= ret && ret <= 0xFF);\r\n    if (ret == 0x33)\r\n    {  /* row bounds are inconsistent with column bounds */\r\n        return GLP_ENOPFS;\r\n    }\r\n    if ((ret & 0x0F) == 0x00)\r\n    {  /* row lower bound does not exist or redundant */\r\n        if (row.lb != -DBL_MAX)\r\n        {  /* remove redundant row lower bound */\r\n            if (GLP_DEBUG){xprintf(\"F\")}\r\n            npp_inactive_bound(npp, row, 0);\r\n        }\r\n    }\r\n    else if ((ret & 0x0F) == 0x01)\r\n    {  /* row lower bound can be active */\r\n        /* see below */\r\n    }\r\n    else if ((ret & 0x0F) == 0x02)\r\n    {  /* row lower bound is a forcing bound */\r\n        if (GLP_DEBUG){xprintf(\"G\")}\r\n        /* process forcing row */\r\n        if (npp_forcing_row(npp, row, 0) == 0)\r\n            return fixup();\r\n    }\r\n    else\r\n        xassert(ret != ret);\r\n    if ((ret & 0xF0) == 0x00)\r\n    {  /* row upper bound does not exist or redundant */\r\n        if (row.ub != +DBL_MAX)\r\n        {  /* remove redundant row upper bound */\r\n            if (GLP_DEBUG){xprintf(\"I\")}\r\n            npp_inactive_bound(npp, row, 1);\r\n        }\r\n    }\r\n    else if ((ret & 0xF0) == 0x10)\r\n    {  /* row upper bound can be active */\r\n        /* see below */\r\n    }\r\n    else if ((ret & 0xF0) == 0x20)\r\n    {  /* row upper bound is a forcing bound */\r\n        if (GLP_DEBUG) {xprintf(\"J\")}\r\n        /* process forcing row */\r\n        if (npp_forcing_row(npp, row, 1) == 0) return fixup();\r\n    }\r\n    else\r\n        xassert(ret != ret);\r\n    if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n    {  /* row became free due to redundant bounds removal */\r\n        if (GLP_DEBUG) {xprintf(\"K\")}\r\n        /* activate its columns, since their length will change due\r\n         to row deletion */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            npp_activate_col(npp, aij.col);\r\n        /* process free row */\r\n        npp_free_row(npp, row);\r\n        /* row was deleted */\r\n        return 0;\r\n    }\r\n    /* row lower and/or upper bounds can be active */\r\n    if (npp.sol == GLP_MIP && hard)\r\n    {  /* improve current column bounds (optional) */\r\n        if (npp_improve_bounds(npp, row, 1) < 0)\r\n            return GLP_ENOPFS;\r\n    }\r\n    function fixup()   {  /* columns were fixed, row was made free */\r\n        for (aij = row.ptr; aij != null; aij = next_aij)\r\n        {  /* process column fixed by forcing row */\r\n            if (GLP_DEBUG){xprintf(\"H\")}\r\n            col = aij.col;\r\n            next_aij = aij.r_next;\r\n            /* activate rows affected by column */\r\n            for (aaa = col.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_activate_row(npp, aaa.row);\r\n            /* process fixed column */\r\n            npp_fixed_col(npp, col);\r\n            /* column was deleted */\r\n        }\r\n        /* process free row (which now is empty due to deletion of\r\n         all its columns) */\r\n        npp_free_row(npp, row);\r\n        /* row was deleted */\r\n        return 0;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction npp_improve_bounds(npp, row, flag){\r\n    /* improve current column bounds */\r\n    var col;\r\n    var aij, next_aij, aaa;\r\n    var kase, ret, count = 0;\r\n    var lb, ub;\r\n    xassert(npp.sol == GLP_MIP);\r\n    /* row must not be free */\r\n    xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));\r\n    /* determine implied column bounds */\r\n    npp_implied_bounds(npp, row);\r\n    /* and use these bounds to strengthen current column bounds */\r\n    for (aij = row.ptr; aij != null; aij = next_aij)\r\n    {  col = aij.col;\r\n        next_aij = aij.r_next;\r\n        for (kase = 0; kase <= 1; kase++)\r\n        {  /* save current column bounds */\r\n            lb = col.lb; ub = col.ub;\r\n            if (kase == 0)\r\n            {  /* process implied column lower bound */\r\n                if (col.ll.ll == -DBL_MAX) continue;\r\n                ret = npp_implied_lower(npp, col, col.ll.ll);\r\n            }\r\n            else\r\n            {  /* process implied column upper bound */\r\n                if (col.uu.uu == +DBL_MAX) continue;\r\n                ret = npp_implied_upper(npp, col, col.uu.uu);\r\n            }\r\n            if (ret == 0 || ret == 1)\r\n            {  /* current column bounds did not change or changed, but\r\n             not significantly; restore current column bounds */\r\n                col.lb = lb; col.ub = ub;\r\n            }\r\n            else if (ret == 2 || ret == 3)\r\n            {  /* current column bounds changed significantly or column\r\n             was fixed */\r\n                if (GLP_DEBUG){xprintf(\"L\")}\r\n                count++;\r\n                /* activate other rows affected by column, if required */\r\n                if (flag)\r\n                {  for (aaa = col.ptr; aaa != null; aaa = aaa.c_next)\r\n                {  if (aaa.row != row)\r\n                    npp_activate_row(npp, aaa.row);\r\n                }\r\n                }\r\n                if (ret == 3)\r\n                {  /* process fixed column */\r\n                    if (GLP_DEBUG){xprintf(\"M\")}\r\n                    npp_fixed_col(npp, col);\r\n                    /* column was deleted */\r\n                    break; /* for kase */\r\n                }\r\n            }\r\n            else if (ret == 4)\r\n            {  /* primal/integer infeasibility */\r\n                return -1;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_process_col(npp, col)\r\n{     /* perform basic column processing */\r\n    var row;\r\n    var aij;\r\n    var ret;\r\n    /* column must not be fixed */\r\n    xassert(col.lb < col.ub);\r\n    /* start processing column */\r\n    if (col.ptr == null)\r\n    {  /* empty column */\r\n        ret = npp_empty_col(npp, col);\r\n        if (ret == 0)\r\n        {  /* column was fixed and deleted */\r\n            if (GLP_DEBUG){xprintf(\"N\")}\r\n            return 0;\r\n        }\r\n        else if (ret == 1)\r\n        {  /* dual infeasibility */\r\n            return GLP_ENODFS;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n    }\r\n    if (col.ptr.c_next == null)\r\n    {  /* column singleton */\r\n        row = col.ptr.row;\r\n\r\n\r\n        function slack(){  /* implied slack variable */\r\n            if (GLP_DEBUG) {xprintf(\"O\")}\r\n            npp_implied_slack(npp, col);\r\n            /* column was deleted */\r\n            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n            {  /* row became free due to implied slack variable */\r\n                if (GLP_DEBUG){xprintf(\"P\")}\r\n                /* activate columns affected by row */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_activate_col(npp, aij.col);\r\n                /* process free row */\r\n                npp_free_row(npp, row);\r\n                /* row was deleted */\r\n            }\r\n            else\r\n            {  /* row became inequality constraint; activate it\r\n             since its length changed due to column deletion */\r\n                npp_activate_row(npp, row);\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        if (row.lb == row.ub)\r\n        {  /* equality constraint */\r\n            if (!col.is_int)\r\n                return slack();\r\n        }\r\n        else\r\n        {  /* inequality constraint */\r\n            if (!col.is_int)\r\n            {  ret = npp_implied_free(npp, col);\r\n                if (ret == 0)\r\n                {  /* implied free variable */\r\n                    if (GLP_DEBUG){xprintf(\"Q\")}\r\n                    /* column bounds were removed, row was replaced by\r\n                     equality constraint */\r\n                    return slack();\r\n                }\r\n                else if (ret == 1)\r\n                {  /* column is not implied free variable, because its\r\n                 lower and/or upper bounds can be active */\r\n                }\r\n                else if (ret == 2)\r\n                {  /* dual infeasibility */\r\n                    return GLP_ENODFS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /* column still exists */\r\n    return 0;\r\n}\r\n\r\nfunction npp_process_prob(npp, hard){\r\n    /* perform basic LP/MIP processing */\r\n    var row;\r\n    var col;\r\n    var processing, ret;\r\n    /* perform initial LP/MIP processing */\r\n    npp_clean_prob(npp);\r\n    /* activate all remaining rows and columns */\r\n    for (row = npp.r_head; row != null; row = row.next)\r\n        row.temp = 1;\r\n    for (col = npp.c_head; col != null; col = col.next)\r\n        col.temp = 1;\r\n    /* main processing loop */\r\n    processing = 1;\r\n    while (processing)\r\n    {  processing = 0;\r\n        /* process all active rows */\r\n        for (;;)\r\n        {  row = npp.r_head;\r\n            if (row == null || !row.temp) break;\r\n            npp_deactivate_row(npp, row);\r\n            ret = npp_process_row(npp, row, hard);\r\n            if (ret != 0) return done();\r\n            processing = 1;\r\n        }\r\n        /* process all active columns */\r\n        for (;;)\r\n        {  col = npp.c_head;\r\n            if (col == null || !col.temp) break;\r\n            npp_deactivate_col(npp, col);\r\n            ret = npp_process_col(npp, col);\r\n            if (ret != 0) return done();\r\n            processing = 1;\r\n        }\r\n    }\r\n    if (npp.sol == GLP_MIP && !hard)\r\n    {  /* improve current column bounds (optional) */\r\n        for (row = npp.r_head; row != null; row = row.next)\r\n        {  if (npp_improve_bounds(npp, row, 0) < 0)\r\n        {  ret = GLP_ENOPFS;\r\n            return done();\r\n        }\r\n        }\r\n    }\r\n    /* all seems ok */\r\n    ret = 0;\r\n    function done(){\r\n        xassert(ret == 0 || ret == GLP_ENOPFS || ret == GLP_ENODFS);\r\n        if (GLP_DEBUG){xprintf(\"\")}\r\n        return ret;\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction npp_simplex(npp, parm){\r\n    /* process LP prior to applying primal/dual simplex method */\r\n    xassert(npp.sol == GLP_SOL);\r\n    xassert(parm == parm);\r\n    return npp_process_prob(npp, 0);\r\n}\r\n\r\nfunction npp_integer(npp, parm){\r\n    /* process MIP prior to applying branch-and-bound method */\r\n    var row, prev_row;\r\n    var col;\r\n    var aij;\r\n    var count, ret;\r\n    xassert(npp.sol == GLP_MIP);\r\n    xassert(parm == parm);\r\n    /*==============================================================*/\r\n    /* perform basic MIP processing */\r\n    ret = npp_process_prob(npp, 1);\r\n    if (ret != 0) return ret;\r\n    /*==============================================================*/\r\n    /* binarize problem, if required */\r\n    if (parm.binarize)\r\n        npp_binarize_prob(npp);\r\n    /*==============================================================*/\r\n    /* identify hidden packing inequalities */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip free row */\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) continue;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        /* skip row having less than two variables */\r\n        if (row.ptr == null || row.ptr.r_next == null) continue;\r\n        /* skip row having non-binary variables */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  col = aij.col;\r\n            if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n                break;\r\n        }\r\n        if (aij != null) continue;\r\n        count += npp_hidden_packing(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" hidden packing inequaliti(es) were detected\");\r\n    /*==============================================================*/\r\n    /* identify hidden covering inequalities */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip free row */\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) continue;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        /* skip row having less than three variables */\r\n        if (row.ptr == null || row.ptr.r_next == null ||\r\n            row.ptr.r_next.r_next == null) continue;\r\n        /* skip row having non-binary variables */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  col = aij.col;\r\n            if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n                break;\r\n        }\r\n        if (aij != null) continue;\r\n        count += npp_hidden_covering(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" hidden covering inequaliti(es) were detected\");\r\n    /*==============================================================*/\r\n    /* reduce inequality constraint coefficients */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        count += npp_reduce_ineq_coef(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" constraint coefficient(s) were reduced\");\r\n    /*==============================================================*/\r\n    //if (GLP_DEBUG){routine(npp)}\r\n    /*==============================================================*/\r\n    /* all seems ok */\r\n    ret = 0;\r\n    return ret;\r\n}\r\n\r\n\r\nfunction mod_diff(x, y) {return (x - y) & 0x7FFFFFFF}\r\n/* difference modulo 2^31 */\r\n\r\nfunction flip_cycle(rand){\r\n/* this is an auxiliary routine to do 55 more steps of the basic\r\n recurrence, at high speed, and to reset fptr */\r\n    var ii, jj;\r\n    for (ii = 1, jj = 32; jj <= 55; ii++, jj++)\r\n        rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);\r\n    for (jj = 1; ii <= 55; ii++, jj++)\r\n        rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);\r\n    rand.fptr = 54;\r\n    return rand.A[55];\r\n}\r\n\r\nfunction rng_create_rand(){\r\n    var rand = {};\r\n    var i;\r\n    rand.A = new Array(56);\r\n    rand.A[0] = -1;\r\n    for (i = 1; i <= 55; i++) rand.A[i] = 0;\r\n    (rand.fptr) = 0;\r\n    rng_init_rand(rand, 1);\r\n    return rand;\r\n}\r\n\r\nfunction rng_init_rand(rand, seed){\r\n    var i;\r\n    var prev = seed, next = 1;\r\n    seed = prev = mod_diff(prev, 0);\r\n    rand.A[55] = prev;\r\n    for (i = 21; i; i = (i + 21) % 55)\r\n    {  rand.A[i] = next;\r\n        next = mod_diff(prev, next);\r\n        if (seed & 1)\r\n            seed = 0x40000000 + (seed >> 1);\r\n        else\r\n            seed >>= 1;\r\n        next = mod_diff(next, seed);\r\n        prev = rand.A[i];\r\n    }\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n}\r\n\r\nfunction rng_next_rand(rand){\r\n    return rand.A[rand.fptr] >= 0 ? rand.A[rand.fptr--] : flip_cycle(rand);\r\n}\r\n\r\nfunction rng_unif_rand(rand, m){\r\n    var two_to_the_31 = 0x80000000;\r\n    var t = two_to_the_31 - (two_to_the_31 % m);\r\n    var r;\r\n    xassert(m > 0);\r\n    do { r = rng_next_rand(rand); } while (t <= r);\r\n    return r % m;\r\n}\r\n\r\nfunction rng_unif_01(rand){\r\n    var x = rng_next_rand(rand) / 2147483647.0;\r\n    xassert(0.0 <= x && x <= 1.0);\r\n    return x;\r\n}\r\n\r\nfunction rng_uniform(rand, a, b){\r\n    if (a >= b)\r\n        xerror(\"rng_uniform: a = \" + a + \", b = \" + b + \"; invalid range\");\r\n    var x = rng_unif_01(rand);\r\n    x = a * (1.0 - x) + b * x;\r\n    xassert(a <= x && x <= b);\r\n    return x;\r\n}\r\n\r\nvar\r\n    SCF_TBG     = 1,  /* Bartels-Golub elimination */\r\n    SCF_TGR     = 2;  /* Givens plane rotation */\r\n\r\n/* return codes: */\r\nvar\r\n    SCF_ESING    = 1,  /* singular matrix */\r\n    SCF_ELIMIT   = 2;  /* update limit reached */\r\n\r\nvar _GLPSCF_DEBUG = 0;\r\n\r\nvar SCF_EPS = 1e-10;\r\n\r\nfunction scf_create_it(n_max){\r\n    if (_GLPSCF_DEBUG){\r\n        xprintf(\"scf_create_it: warning: debug mode enabled\");\r\n    }\r\n    if (!(1 <= n_max && n_max <= 32767))\r\n        xerror(\"scf_create_it: n_max = \" + n_max + \"; invalid parameter\");\r\n    var scf = {};\r\n    scf.n_max = n_max;\r\n    scf.n = 0;\r\n    scf.f = new Float64Array(1 + n_max * n_max);\r\n    scf.u = new Float64Array(1 + n_max * (n_max + 1) / 2);\r\n    scf.p = new Int32Array(1 + n_max);\r\n    scf.t_opt = SCF_TBG;\r\n    scf.rank = 0;\r\n    if (_GLPSCF_DEBUG)\r\n        scf.c = new Float64Array(1 + n_max * n_max);\r\n    else\r\n        scf.c = null;\r\n    scf.w = new Float64Array(1 + n_max);\r\n    return scf;\r\n}\r\n\r\nfunction f_loc(scf, i, j){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(1 <= j && j <= n);\r\n    return (i - 1) * n_max + j;\r\n}\r\n\r\nfunction u_loc(scf, i, j){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(i <= j && j <= n);\r\n    return (i - 1) * n_max + j - i * (i - 1) / 2;\r\n}\r\n\r\nfunction bg_transform(scf, k, un){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var j, k1, kj, kk, n1, nj;\r\n    var t;\r\n    xassert(1 <= k && k <= n);\r\n    /* main elimination loop */\r\n    for (; k < n; k++)\r\n    {  /* determine location of U[k,k] */\r\n        kk = u_loc(scf, k, k);\r\n        /* determine location of F[k,1] */\r\n        k1 = f_loc(scf, k, 1);\r\n        /* determine location of F[n,1] */\r\n        n1 = f_loc(scf, n, 1);\r\n        /* if |U[k,k]| < |U[n,k]|, interchange k-th and n-th rows to\r\n         provide |U[k,k]| >= |U[n,k]| */\r\n        if (Math.abs(u[kk]) < Math.abs(un[k]))\r\n        {  /* interchange k-th and n-th rows of matrix U */\r\n            for (j = k, kj = kk; j <= n; j++, kj++){\r\n                t = u[kj]; u[kj] = un[j]; un[j] = t;\r\n            }\r\n            /* interchange k-th and n-th rows of matrix F to keep the\r\n             main equality F * C = U * P */\r\n            for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++){\r\n                t = f[kj]; f[kj] = f[nj]; f[nj] = t;\r\n            }\r\n        }\r\n        /* now |U[k,k]| >= |U[n,k]| */\r\n        /* if U[k,k] is too small in the magnitude, replace U[k,k] and\r\n         U[n,k] by exact zero */\r\n        if (Math.abs(u[kk]) < SCF_EPS) u[kk] = un[k] = 0.0;\r\n        /* if U[n,k] is already zero, elimination is not needed */\r\n        if (un[k] == 0.0) continue;\r\n        /* compute gaussian multiplier t = U[n,k] / U[k,k] */\r\n        t = un[k] / u[kk];\r\n        /* apply gaussian elimination to nullify U[n,k] */\r\n        /* (n-th row of U) := (n-th row of U) - t * (k-th row of U) */\r\n        for (j = k+1, kj = kk+1; j <= n; j++, kj++)\r\n            un[j] -= t * u[kj];\r\n        /* (n-th row of F) := (n-th row of F) - t * (k-th row of F)\r\n         to keep the main equality F * C = U * P */\r\n        for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)\r\n            f[nj] -= t * f[kj];\r\n    }\r\n    /* if U[n,n] is too small in the magnitude, replace it by exact\r\n     zero */\r\n    if (Math.abs(un[n]) < SCF_EPS) un[n] = 0.0;\r\n    /* store U[n,n] in a proper location */\r\n    u[u_loc(scf, n, n)] = un[n];\r\n}\r\n\r\nfunction givens(a, b, callback){\r\n    var t, c, s;\r\n    if (b == 0.0){\r\n        c = 1.0; s = 0.0;\r\n    }\r\n    else if (Math.abs(a) <= Math.abs(b)){\r\n        t = - a / b; s = 1.0 / Math.sqrt(1.0 + t * t); c = s * t;\r\n    }\r\n    else{\r\n        t = - b / a; c = 1.0 / Math.sqrt(1.0 + t * t); s = c * t;\r\n    }\r\n    callback(c, s);\r\n}\r\n\r\nfunction gr_transform(scf, k, un){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var j, k1, kj, kk, n1, nj;\r\n    xassert(1 <= k && k <= n);\r\n    /* main elimination loop */\r\n    for (; k < n; k++)\r\n    {  /* determine location of U[k,k] */\r\n        kk = u_loc(scf, k, k);\r\n        /* determine location of F[k,1] */\r\n        k1 = f_loc(scf, k, 1);\r\n        /* determine location of F[n,1] */\r\n        n1 = f_loc(scf, n, 1);\r\n        /* if both U[k,k] and U[n,k] are too small in the magnitude,\r\n         replace them by exact zero */\r\n        if (Math.abs(u[kk]) < SCF_EPS && Math.abs(un[k]) < SCF_EPS)\r\n            u[kk] = un[k] = 0.0;\r\n        /* if U[n,k] is already zero, elimination is not needed */\r\n        if (un[k] == 0.0) continue;\r\n        /* compute the parameters of Givens plane rotation */\r\n        givens(u[kk], un[k],\r\n            function(c, s){\r\n                /* apply Givens rotation to k-th and n-th rows of matrix U */\r\n                for (j = k, kj = kk; j <= n; j++, kj++)\r\n                {  var ukj = u[kj], unj = un[j];\r\n                    u[kj] = c * ukj - s * unj;\r\n                    un[j] = s * ukj + c * unj;\r\n                }\r\n                /* apply Givens rotation to k-th and n-th rows of matrix F\r\n                 to keep the main equality F * C = U * P */\r\n                for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)\r\n                {  var fkj = f[kj], fnj = f[nj];\r\n                    f[kj] = c * fkj - s * fnj;\r\n                    f[nj] = s * fkj + c * fnj;\r\n                }\r\n            }\r\n        );\r\n    }\r\n    /* if U[n,n] is too small in the magnitude, replace it by exact\r\n     zero */\r\n    if (Math.abs(un[n]) < SCF_EPS) un[n] = 0.0;\r\n    /* store U[n,n] in a proper location */\r\n    u[u_loc(scf, n, n)] = un[n];\r\n}\r\n\r\nfunction transform(scf, k, un){\r\n    switch (scf.t_opt){\r\n        case SCF_TBG:\r\n            bg_transform(scf, k, un);\r\n            break;\r\n        case SCF_TGR:\r\n            gr_transform(scf, k, un);\r\n            break;\r\n        default:\r\n            xassert(scf != scf);\r\n    }\r\n}\r\n\r\nfunction estimate_rank(scf){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    var u = scf.u;\r\n    var i, ii, inc, rank = 0;\r\n    for (i = 1, ii = u_loc(scf, i, i), inc = n_max; i <= n; i++, ii += inc, inc--)\r\n        if (u[ii] != 0.0) rank++;\r\n    return rank;\r\n}\r\n\r\nif (_GLPSCF_DEBUG){\r\n\r\n    function check_error(scf, func){\r\n        var n = scf.n;\r\n        var f = scf.f;\r\n        var u = scf.u;\r\n        var p = scf.p;\r\n        var c = scf.c;\r\n        var i, j, k;\r\n        var d, dmax = 0.0, s, t;\r\n        xassert(c != null);\r\n        for (i = 1; i <= n; i++)\r\n        {  for (j = 1; j <= n; j++)\r\n        {  /* compute element (i,j) of product F * C */\r\n            s = 0.0;\r\n            for (k = 1; k <= n; k++)\r\n                s += f[f_loc(scf, i, k)] * c[f_loc(scf, k, j)];\r\n            /* compute element (i,j) of product U * P */\r\n            k = p[j];\r\n            t = (i <= k ? u[u_loc(scf, i, k)] : 0.0);\r\n            /* compute the maximal relative error */\r\n            d = Math.abs(s - t) / (1.0 + Math.abs(t));\r\n            if (dmax < d) dmax = d;\r\n        }\r\n        }\r\n        if (dmax > 1e-8)\r\n            xprintf(func + \": dmax = \" + dmax + \"; relative error too large\");\r\n    }\r\n}\r\n\r\nfunction scf_update_exp(scf, x, idx, y, idy, z){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    if (_GLPSCF_DEBUG){var c = scf.c}\r\n    var un = scf.w;\r\n    var i, ij, in_, j, k, nj, ret = 0;\r\n    var t;\r\n    /* check if the factorization can be expanded */\r\n    if (n == n_max)\r\n    {  /* there is not enough room */\r\n        ret = SCF_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* increase the order of the factorization */\r\n    scf.n = ++n;\r\n    /* fill new zero column of matrix F */\r\n    for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)\r\n    f[in_] = 0.0;\r\n    /* fill new zero row of matrix F */\r\n    for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)\r\n        f[nj] = 0.0;\r\n    /* fill new unity diagonal element of matrix F */\r\n    f[f_loc(scf, n, n)] = 1.0;\r\n    /* compute new column of matrix U, which is (old F) * x */\r\n    for (i = 1; i < n; i++)\r\n    {  /* u[i,n] := (i-th row of old F) * x */\r\n        t = 0.0;\r\n        for (j = 1, ij = f_loc(scf, i, 1); j < n; j++, ij++)\r\n            t += f[ij] * x[j+idx];\r\n        u[u_loc(scf, i, n)] = t;\r\n    }\r\n    /* compute new (spiked) row of matrix U, which is (old P) * y */\r\n    for (j = 1; j < n; j++) un[j] = y[p[j]+idy];\r\n    /* store new diagonal element of matrix U, which is z */\r\n    un[n] = z;\r\n    /* expand matrix P */\r\n    p[n] = n;\r\n    if (_GLPSCF_DEBUG){\r\n        /* expand matrix C */\r\n        /* fill its new column, which is x */\r\n        for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)\r\n            c[in_] = x[i+idx];\r\n        /* fill its new row, which is y */\r\n        for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)\r\n            c[nj] = y[j+idy];\r\n        /* fill its new diagonal element, which is z */\r\n        c[f_loc(scf, n, n)] = z;\r\n    }\r\n    /* restore upper triangular structure of matrix U */\r\n    for (k = 1; k < n; k++)\r\n        if (un[k] != 0.0) break;\r\n    transform(scf, k, un);\r\n    /* estimate the rank of matrices C and U */\r\n    scf.rank = estimate_rank(scf);\r\n    if (scf.rank != n) ret = SCF_ESING;\r\n    if (_GLPSCF_DEBUG){\r\n        /* check that the factorization is accurate enough */\r\n        check_error(scf, \"scf_update_exp\");\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction solve(scf, x, idx){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    var y = scf.w;\r\n    var i, j, ij;\r\n    var t;\r\n    /* y := F * b */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* y[i] = (i-th row of F) * b */\r\n        t = 0.0;\r\n        for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)\r\n            t += f[ij] * x[j+idx];\r\n        y[i] = t;\r\n    }\r\n    /* y := inv(U) * y */\r\n    for (i = n; i >= 1; i--)\r\n    {  t = y[i];\r\n        for (j = n, ij = u_loc(scf, i, n); j > i; j--, ij--)\r\n            t -= u[ij] * y[j];\r\n        y[i] = t / u[ij];\r\n    }\r\n    /* x := P' * y */\r\n    for (i = 1; i <= n; i++) x[p[i]+idx] = y[i];\r\n}\r\n\r\nfunction tsolve(scf, x, idx){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    var y = scf.w;\r\n    var i, j, ij;\r\n    var t;\r\n    /* y := P * b */\r\n    for (i = 1; i <= n; i++) y[i] = x[p[i]+idx];\r\n    /* y := inv(U') * y */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* compute y[i] */\r\n        ij = u_loc(scf, i, i);\r\n        t = (y[i] /= u[ij]);\r\n        /* substitute y[i] in other equations */\r\n        for (j = i+1, ij++; j <= n; j++, ij++)\r\n            y[j] -= u[ij] * t;\r\n    }\r\n    /* x := F' * y (computed as linear combination of rows of F) */\r\n    for (j = 1; j <= n; j++) x[j+idx] = 0.0;\r\n    for (i = 1; i <= n; i++)\r\n    {  t = y[i]; /* coefficient of linear combination */\r\n        for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)\r\n            x[j+idx] += f[ij] * t;\r\n    }\r\n}\r\n\r\nfunction scf_solve_it(scf, tr, x, idx){\r\n    if (scf.rank < scf.n)\r\n        xerror(\"scf_solve_it: singular matrix\");\r\n    if (!tr)\r\n        solve(scf, x, idx);\r\n    else\r\n        tsolve(scf, x, idx);\r\n}\r\n\r\nfunction scf_reset_it(scf){\r\n    /* reset factorization for empty matrix C */\r\n    scf.n = scf.rank = 0;\r\n}\r\n\r\nvar glp_scale_prob = exports[\"glp_scale_prob\"] = function(lp, flags){\r\n    function min_row_aij(lp, i, scaled){\r\n        var aij;\r\n        var min_aij, temp;\r\n        xassert(1 <= i && i <= lp.m);\r\n        min_aij = 1.0;\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.r_prev == null || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_row_aij(lp, i, scaled){\r\n        var aij;\r\n        var max_aij, temp;\r\n        xassert(1 <= i && i <= lp.m);\r\n        max_aij = 1.0;\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.r_prev == null || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function min_col_aij(lp, j, scaled){\r\n        var aij;\r\n        var min_aij, temp;\r\n        xassert(1 <= j && j <= lp.n);\r\n        min_aij = 1.0;\r\n        for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.c_prev == null || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_col_aij(lp, j, scaled){\r\n        var aij;\r\n        var max_aij, temp;\r\n        xassert(1 <= j && j <= lp.n);\r\n        max_aij = 1.0;\r\n        for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.c_prev == null || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function min_mat_aij(lp, scaled){\r\n        var i;\r\n        var min_aij, temp;\r\n        min_aij = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = min_row_aij(lp, i, scaled);\r\n            if (i == 1 || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_mat_aij(lp, scaled){\r\n        var i;\r\n        var max_aij, temp;\r\n        max_aij = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = max_row_aij(lp, i, scaled);\r\n            if (i == 1 || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function eq_scaling(lp, flag){\r\n        var i, j, pass;\r\n        var temp;\r\n        xassert(flag == 0 || flag == 1);\r\n        for (pass = 0; pass <= 1; pass++)\r\n        {  if (pass == flag)\r\n        {  /* scale rows */\r\n            for (i = 1; i <= lp.m; i++)\r\n            {  temp = max_row_aij(lp, i, 1);\r\n                glp_set_rii(lp, i, glp_get_rii(lp, i) / temp);\r\n            }\r\n        }\r\n        else\r\n        {  /* scale columns */\r\n            for (j = 1; j <= lp.n; j++)\r\n            {  temp = max_col_aij(lp, j, 1);\r\n                glp_set_sjj(lp, j, glp_get_sjj(lp, j) / temp);\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    function gm_scaling(lp, flag){\r\n        var i, j, pass;\r\n        var temp;\r\n        xassert(flag == 0 || flag == 1);\r\n        for (pass = 0; pass <= 1; pass++)\r\n        {  if (pass == flag)\r\n        {  /* scale rows */\r\n            for (i = 1; i <= lp.m; i++)\r\n            {  temp = min_row_aij(lp, i, 1) * max_row_aij(lp, i, 1);\r\n                glp_set_rii(lp, i, glp_get_rii(lp, i) / Math.sqrt(temp));\r\n            }\r\n        }\r\n        else\r\n        {  /* scale columns */\r\n            for (j = 1; j <= lp.n; j++)\r\n            {  temp = min_col_aij(lp, j, 1) * max_col_aij(lp, j, 1);\r\n                glp_set_sjj(lp, j, glp_get_sjj(lp, j) / Math.sqrt(temp));\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    function max_row_ratio(lp){\r\n        var i;\r\n        var ratio, temp;\r\n        ratio = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = max_row_aij(lp, i, 1) / min_row_aij(lp, i, 1);\r\n            if (i == 1 || ratio < temp) ratio = temp;\r\n        }\r\n        return ratio;\r\n    }\r\n\r\n    function max_col_ratio(lp){\r\n        var j;\r\n        var ratio, temp;\r\n        ratio = 1.0;\r\n        for (j = 1; j <= lp.n; j++)\r\n        {  temp = max_col_aij(lp, j, 1) / min_col_aij(lp, j, 1);\r\n            if (j == 1 || ratio < temp) ratio = temp;\r\n        }\r\n        return ratio;\r\n    }\r\n\r\n    function gm_iterate(lp, it_max, tau){\r\n        var k, flag;\r\n        var ratio = 0.0, r_old;\r\n        /* if the scaling \"quality\" for rows is better than for columns,\r\n         the rows are scaled first; otherwise, the columns are scaled\r\n         first */\r\n        flag = (max_row_ratio(lp) > max_col_ratio(lp));\r\n        for (k = 1; k <= it_max; k++)\r\n        {  /* save the scaling \"quality\" from previous iteration */\r\n            r_old = ratio;\r\n            /* determine the current scaling \"quality\" */\r\n            ratio = max_mat_aij(lp, 1) / min_mat_aij(lp, 1);\r\n            /* if improvement is not enough, terminate scaling */\r\n            if (k > 1 && ratio > tau * r_old) break;\r\n            /* otherwise, perform another iteration */\r\n            gm_scaling(lp, flag);\r\n        }\r\n    }\r\n\r\n    function scale_prob(lp, flags){\r\n\r\n        function fmt(a, b, c, d){\r\n            return a + \": min|aij| = \" + b + \"  max|aij| = \" + c + \"  ratio = \" + d + \"\"\r\n        }\r\n\r\n        var min_aij, max_aij, ratio;\r\n        xprintf(\"Scaling...\");\r\n        /* cancel the current scaling effect */\r\n        glp_unscale_prob(lp);\r\n        /* report original scaling \"quality\" */\r\n        min_aij = min_mat_aij(lp, 1);\r\n        max_aij = max_mat_aij(lp, 1);\r\n        ratio = max_aij / min_aij;\r\n        xprintf(fmt(\" A\", min_aij, max_aij, ratio));\r\n        /* check if the problem is well scaled */\r\n        if (min_aij >= 0.10 && max_aij <= 10.0)\r\n        {  xprintf(\"Problem data seem to be well scaled\");\r\n            /* skip scaling, if required */\r\n            if (flags & GLP_SF_SKIP) return;\r\n        }\r\n        /* perform iterative geometric mean scaling, if required */\r\n        if (flags & GLP_SF_GM)\r\n        {  gm_iterate(lp, 15, 0.90);\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"GM\", min_aij, max_aij, ratio));\r\n        }\r\n        /* perform equilibration scaling, if required */\r\n        if (flags & GLP_SF_EQ)\r\n        {  eq_scaling(lp, max_row_ratio(lp) > max_col_ratio(lp));\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"EQ\", min_aij, max_aij, ratio));\r\n        }\r\n        /* round scale factors to nearest power of two, if required */\r\n        if (flags & GLP_SF_2N)\r\n        {  var i, j;\r\n            for (i = 1; i <= lp.m; i++)\r\n                glp_set_rii(lp, i, round2n(glp_get_rii(lp, i)));\r\n            for (j = 1; j <= lp.n; j++)\r\n                glp_set_sjj(lp, j, round2n(glp_get_sjj(lp, j)));\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"2N\", min_aij, max_aij, ratio));\r\n        }\r\n    }\r\n\r\n\r\n    if (flags & ~(GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP | GLP_SF_AUTO))\r\n        xerror(\"glp_scale_prob: flags = \" + flags + \"; invalid scaling options\");\r\n    if (flags & GLP_SF_AUTO)\r\n        flags = (GLP_SF_GM | GLP_SF_EQ | GLP_SF_SKIP);\r\n    scale_prob(lp, flags);\r\n};\r\n\r\nfunction spx_primal(lp, parm){\r\n\r\n    var kappa = 0.10;\r\n\r\n    function alloc_csa(lp){\r\n        var m = lp.m;\r\n        var n = lp.n;\r\n        var nnz = lp.nnz;\r\n        var csa = {};\r\n        xassert(m > 0 && n > 0);\r\n        csa.m = m;\r\n        csa.n = n;\r\n        csa.type = new Int8Array(1+m+n);\r\n        csa.lb = new Float64Array(1+m+n);\r\n        csa.ub = new Float64Array(1+m+n);\r\n        csa.coef = new Float64Array(1+m+n);\r\n        csa.obj = new Float64Array(1+n);\r\n        csa.A_ptr = new Int32Array(1+n+1);\r\n        csa.A_ind = new Int32Array(1+nnz);\r\n        csa.A_val = new Float64Array(1+nnz);\r\n        csa.head = new Int32Array(1+m+n);\r\n        csa.stat = new Int8Array(1+n);\r\n        csa.N_ptr = new Int32Array(1+m+1);\r\n        csa.N_len = new Int32Array(1+m);\r\n        csa.N_ind = null; /* will be allocated later */\r\n        csa.N_val = null; /* will be allocated later */\r\n        csa.bbar = new Float64Array(1+m);\r\n        csa.cbar = new Float64Array(1+n);\r\n        csa.refsp = new Int8Array(1+m+n);\r\n        csa.gamma = new Float64Array(1+n);\r\n        csa.tcol_ind = new Int32Array(1+m);\r\n        csa.tcol_vec = new Float64Array(1+m);\r\n        csa.trow_ind = new Int32Array(1+n);\r\n        csa.trow_vec = new Float64Array(1+n);\r\n        csa.work1 = new Float64Array(1+m);\r\n        csa.work2 = new Float64Array(1+m);\r\n        csa.work3 = new Float64Array(1+m);\r\n        csa.work4 = new Float64Array(1+m);\r\n        return csa;\r\n    }\r\n\r\n    function init_csa(csa, lp){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var obj = csa.obj;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, j, k, loc;\r\n        var cmax;\r\n        var row, col;\r\n        /* auxiliary variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            type[i] = row.type;\r\n            lb[i] = row.lb * row.rii;\r\n            ub[i] = row.ub * row.rii;\r\n            coef[i] = 0.0;\r\n        }\r\n        /* structural variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            type[m+j] = col.type;\r\n            lb[m+j] = col.lb / col.sjj;\r\n            ub[m+j] = col.ub / col.sjj;\r\n            coef[m+j] = col.coef * col.sjj;\r\n        }\r\n        /* original objective function */\r\n        obj[0] = lp.c0;\r\n        xcopyArr(obj, 1, coef, m+1, n);\r\n        /* factor used to scale original objective coefficients */\r\n        cmax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            if (cmax < Math.abs(obj[j])) cmax = Math.abs(obj[j]);\r\n        if (cmax == 0.0) cmax = 1.0;\r\n        switch (lp.dir)\r\n        {  case GLP_MIN:\r\n            csa.zeta = + 1.0 / cmax;\r\n            break;\r\n            case GLP_MAX:\r\n                csa.zeta = - 1.0 / cmax;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        if (Math.abs(csa.zeta) < 1.0) csa.zeta *= 1000.0;\r\n        /* matrix A (by columns) */\r\n        loc = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {   A_ptr[j] = loc;\r\n            for (var aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n            {  A_ind[loc] = aij.row.i;\r\n                A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        A_ptr[n+1] = loc;\r\n        xassert(loc == lp.nnz+1);\r\n        /* basis header */\r\n        xassert(lp.valid);\r\n        xcopyArr(head, 1, lp.head, 1, m);\r\n        k = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            if (row.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = i;\r\n                stat[k] = row.stat;\r\n            }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = m + j;\r\n                stat[k] = col.stat;\r\n            }\r\n        }\r\n        xassert(k == n);\r\n        /* factorization of matrix B */\r\n        csa.valid = 1; lp.valid = 0;\r\n        csa.bfd = lp.bfd; lp.bfd = null;\r\n        /* matrix N (by rows) */\r\n        alloc_N(csa);\r\n        build_N(csa);\r\n        /* working parameters */\r\n        csa.phase = 0;\r\n        csa.tm_beg = xtime();\r\n        csa.it_beg = csa.it_cnt = lp.it_cnt;\r\n        csa.it_dpy = -1;\r\n        /* reference space and steepest edge coefficients */\r\n        csa.refct = 0;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (j = 1; j <= n; j++) gamma[j] = 1.0;\r\n    }\r\n\r\n    function inv_col(csa, i, ind, val){\r\n        /* this auxiliary routine returns row indices and numeric values\r\n         of non-zero elements of i-th column of the basis matrix */\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var k, len, ptr, t;\r\n        if(GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n        k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (k <= m)\r\n        {  /* B[i] is k-th column of submatrix I */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n            ptr = A_ptr[k-m];\r\n            len = A_ptr[k-m+1] - ptr;\r\n            xcopyArr(ind, 1, A_ind, ptr, len);\r\n            xcopyArr(val, 1, A_val, ptr, len);\r\n            for (t = 1; t <= len; t++) val[t] = - val[t];\r\n        }\r\n        return len;\r\n    }\r\n\r\n    function invert_B(csa){\r\n        var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function update_B(csa, i, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var val, ret;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= i && i <= m);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* new i-th column of B is k-th column of I */\r\n            var ind = new Array(1+1);\r\n            val = new Array(1+1);\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);\r\n        }\r\n        else\r\n        {  /* new i-th column of B is (k-m)-th column of (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            val = csa.work1;\r\n            var beg, end, ptr, len;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            len = 0;\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                val[++len] = - A_val[ptr];\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg-1, val);\r\n        }\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function error_ftran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector:\r\n         r = h - B * x = h - B[1] * x[1] - ... - B[m] * x[m],\r\n         where B[1], ..., B[m] are columns of matrix B */\r\n        xcopyArr(r, 1, h, 1, m);\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                r[k] -= temp;\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    r[A_ind[ptr]] += A_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    function refine_ftran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B * x */\r\n        error_ftran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B) * r */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function error_btran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector r = b - B'* x */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* r[i] := b[i] - (i-th column of B)'* x */\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            temp = h[i];\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                temp -= x[k];\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += A_val[ptr] * x[A_ind[ptr]];\r\n            }\r\n            r[i] = temp;\r\n        }\r\n    }\r\n\r\n    function refine_btran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B'* x */\r\n        error_btran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B') * r */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function alloc_N(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var i, j, beg, end, ptr;\r\n        /* determine number of non-zeros in each row of the augmented\r\n         constraint matrix (I|-A) */\r\n        for (i = 1; i <= m; i++)\r\n            N_len[i] = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {  beg = A_ptr[j];\r\n            end = A_ptr[j+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                N_len[A_ind[ptr]]++;\r\n        }\r\n        /* determine maximal row lengths of matrix N and set its row\r\n         pointers */\r\n        N_ptr[1] = 1;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* row of matrix N cannot have more than n non-zeros */\r\n            if (N_len[i] > n) N_len[i] = n;\r\n            N_ptr[i+1] = N_ptr[i] + N_len[i];\r\n        }\r\n        /* now maximal number of non-zeros in matrix N is known */\r\n        csa.N_ind = new Int32Array(N_ptr[m+1]);\r\n        csa.N_val = new Float64Array(N_ptr[m+1]);\r\n    }\r\n\r\n    function add_N_col(csa, j, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var pos;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= j && j <= n);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            pos = N_ptr[k] + (N_len[k]++);\r\n            if (GLP_DEBUG){xassert(pos < N_ptr[k+1])}\r\n            N_ind[pos] = j;\r\n            N_val[pos] = 1.0;\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var i, beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  i = A_ind[ptr]; /* row number */\r\n                pos = N_ptr[i] + (N_len[i]++);\r\n                if (GLP_DEBUG){xassert(pos < N_ptr[i+1])}\r\n                N_ind[pos] = j;\r\n                N_val[pos] = - A_val[ptr];\r\n            }\r\n        }\r\n    }\r\n\r\n    function del_N_col(csa, j, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var pos, head, tail;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= j && j <= n);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            /* find element in k-th row of N */\r\n            head = N_ptr[k];\r\n            for (pos = head; N_ind[pos] != j; pos++){} /* nop */\r\n            /* and remove it from the row list */\r\n            tail = head + (--N_len[k]);\r\n            if (GLP_DEBUG){xassert(pos <= tail)}\r\n            N_ind[pos] = N_ind[tail];\r\n            N_val[pos] = N_val[tail];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var i, beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  i = A_ind[ptr]; /* row number */\r\n                /* find element in i-th row of N */\r\n                head = N_ptr[i];\r\n                for (pos = head; N_ind[pos] != j; pos++){} /* nop */\r\n                /* and remove it from the row list */\r\n                tail = head + (--N_len[i]);\r\n                if (GLP_DEBUG){xassert(pos <= tail)}\r\n                N_ind[pos] = N_ind[tail];\r\n                N_val[pos] = N_val[tail];\r\n            }\r\n        }\r\n    }\r\n\r\n    function build_N(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var N_len = csa.N_len;\r\n        var j, k;\r\n        /* N := empty matrix */\r\n        xfillArr(N_len, 1, 0, m);\r\n        /* go through non-basic columns of matrix (I|-A) */\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] != GLP_NS)\r\n        {  /* xN[j] is non-fixed; add j-th column to matrix N which is\r\n         k-th column of matrix (I|-A) */\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            add_N_col(csa, j, k);\r\n        }\r\n        }\r\n    }\r\n\r\n    function get_xN(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var k;\r\n        var xN;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        switch (stat[j])\r\n        {  case GLP_NL:\r\n            /* x[k] is on its lower bound */\r\n            xN = lb[k]; break;\r\n            case GLP_NU:\r\n                /* x[k] is on its upper bound */\r\n                xN = ub[k]; break;\r\n            case GLP_NF:\r\n                /* x[k] is free non-basic variable */\r\n                xN = 0.0; break;\r\n            case GLP_NS:\r\n                /* x[k] is fixed non-basic variable */\r\n                xN = lb[k]; break;\r\n            default:\r\n                xassert(stat != stat);\r\n        }\r\n        return xN;\r\n    }\r\n\r\n    function eval_beta(csa, beta){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var h = csa.work2;\r\n        var i, j, k, beg, end, ptr;\r\n        var xN;\r\n        /* compute the right-hand side vector:\r\n         h := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n],\r\n         where N[1], ..., N[n] are columns of matrix N */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine current value of xN[j] */\r\n            xN = get_xN(csa, j);\r\n            if (xN == 0.0) continue;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] -= xN;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] += xN * A_val[ptr];\r\n            }\r\n        }\r\n        /* solve system B * beta = h */\r\n        xcopyArr(beta, 1, h, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, beta);\r\n        /* and refine the solution */\r\n        refine_ftran(csa, h, beta);\r\n    }\r\n\r\n    function eval_pi(csa, pi){\r\n        var m = csa.m;\r\n        var c = csa.coef;\r\n        var head = csa.head;\r\n        var cB = csa.work2;\r\n        var i;\r\n        /* construct the right-hand side vector cB */\r\n        for (i = 1; i <= m; i++)\r\n            cB[i] = c[head[i]];\r\n        /* solve system B'* pi = cB */\r\n        xcopyArr(pi, 1, cB, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, pi);\r\n        /* and refine the solution */\r\n        refine_btran(csa, cB, pi);\r\n    }\r\n\r\n    function eval_cost(csa, pi, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var k;\r\n        var dj;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        dj = coef[k];\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            dj -= pi[k];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                dj += A_val[ptr] * pi[A_ind[ptr]];\r\n        }\r\n        return dj;\r\n    }\r\n\r\n    function eval_bbar(csa)\r\n    {\r\n        eval_beta(csa, csa.bbar);\r\n    }\r\n\r\n    function eval_cbar(csa){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var head = csa.head}\r\n        var cbar = csa.cbar;\r\n        var pi = csa.work3;\r\n        var j;\r\n        if(GLP_DEBUG){var k}\r\n        /* compute simplex multipliers */\r\n        eval_pi(csa, pi);\r\n        /* compute and store reduced costs */\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                k = head[m+j]; /* x[k] = xN[j] */\r\n                xassert(1 <= k && k <= m+n);\r\n            }\r\n            cbar[j] = eval_cost(csa, pi, j);\r\n        }\r\n    }\r\n\r\n    function reset_refsp(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var j, k;\r\n        xassert(csa.refct == 0);\r\n        csa.refct = 1000;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            refsp[k] = 1;\r\n            gamma[j] = 1.0;\r\n        }\r\n    }\r\n\r\n    function eval_gamma(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var alfa = csa.work3;\r\n        var h = csa.work3;\r\n        var i, k;\r\n        var gamma;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[j] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * alfa = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, alfa);\r\n        /* compute gamma */\r\n        gamma = (refsp[k] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i];\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (refsp[k]) gamma += alfa[i] * alfa[i];\r\n        }\r\n        return gamma;\r\n    }\r\n\r\n    function chuzc(csa, tol_dj){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var gamma = csa.gamma;\r\n        var j, q;\r\n        var dj, best, temp;\r\n        /* nothing is chosen so far */\r\n        q = 0; best = 0.0;\r\n        /* look through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  dj = cbar[j];\r\n            switch (stat[j])\r\n            {  case GLP_NL:\r\n                /* xN[j] can increase */\r\n                if (dj >= - tol_dj) continue;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[j] can decrease */\r\n                    if (dj <= + tol_dj) continue;\r\n                    break;\r\n                case GLP_NF:\r\n                    /* xN[j] can change in any direction */\r\n                    if (- tol_dj <= dj && dj <= + tol_dj) continue;\r\n                    break;\r\n                case GLP_NS:\r\n                    /* xN[j] cannot change at all */\r\n                    continue;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n            /* xN[j] is eligible non-basic variable; choose one which has\r\n             largest weighted reduced cost */\r\n            if (GLP_DEBUG){xassert(gamma[j] > 0.0)}\r\n            temp = (dj * dj) / gamma[j];\r\n            if (best < temp){\r\n                q = j;\r\n                best = temp;\r\n            }\r\n        }\r\n        /* store the index of non-basic variable xN[q] chosen */\r\n        csa.q = q;\r\n    }\r\n\r\n    function eval_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.tcol_vec;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * tcol = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function refine_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.work3;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* refine solution of B * tcol = h */\r\n        refine_ftran(csa, h, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function sort_tcol(csa, tol_piv){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, num, pos;\r\n        var big, eps, temp;\r\n        /* compute infinity (maximum) norm of the column */\r\n        big = 0.0;\r\n        for (pos = 1; pos <= nnz; pos++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                i = tcol_ind[pos];\r\n                xassert(1 <= i && i <= m);\r\n            }\r\n            temp = Math.abs(tcol_vec[tcol_ind[pos]]);\r\n            if (big < temp) big = temp;\r\n        }\r\n        csa.tcol_max = big;\r\n        /* determine absolute pivot tolerance */\r\n        eps = tol_piv * (1.0 + 0.01 * big);\r\n        /* move significant column components to front of the list */\r\n        for (num = 0; num < nnz; )\r\n        {  i = tcol_ind[nnz];\r\n            if (Math.abs(tcol_vec[i]) < eps)\r\n                nnz--;\r\n            else\r\n            {  num++;\r\n                tcol_ind[nnz] = tcol_ind[num];\r\n                tcol_ind[num] = i;\r\n            }\r\n        }\r\n        csa.tcol_num = num;\r\n    }\r\n\r\n    function chuzr(csa, rtol){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var tcol_num = csa.tcol_num;\r\n        var i, i_stat, k, p, p_stat, pos;\r\n        var alfa, big, delta, s, t, teta, tmax;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* s := - sign(d[q]), where d[q] is reduced cost of xN[q] */\r\n        if (GLP_DEBUG){xassert(cbar[q] != 0.0)}\r\n        s = (cbar[q] > 0.0 ? -1.0 : +1.0);\r\n        /*** FIRST PASS ***/\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (type[k] == GLP_DB)\r\n        {  /* xN[q] has both lower and upper bounds */\r\n            p = -1; p_stat = 0; teta = ub[k] - lb[k]; big = 1.0;\r\n        }\r\n        else\r\n        {  /* xN[q] has no opposite bound */\r\n            p = 0; p_stat = 0; teta = DBL_MAX; big = 0.0;\r\n        }\r\n        /* walk through significant elements of the pivot column */\r\n        for (pos = 1; pos <= tcol_num; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            alfa = s * tcol_vec[i];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* xB[i] = ... + alfa * xN[q] + ..., and due to s we need to\r\n             consider the only case when xN[q] is increasing */\r\n            if (alfa > 0.0)\r\n            {  /* xB[i] is increasing */\r\n                if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(lb[k]));\r\n                    t = ((lb[k] + delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an upper bound */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(ub[k]));\r\n                    t = ((ub[k] + delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* xB[i] is decreasing */\r\n                if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(ub[k]));\r\n                    t = ((ub[k] - delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an lower bound */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(lb[k]));\r\n                    t = ((lb[k] - delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* t is a change of xN[q], on which xB[i] reaches its bound\r\n             (possibly relaxed); since the basic solution is assumed to\r\n             be primal feasible (or pseudo feasible on phase I), t has\r\n             to be non-negative by definition; however, it may happen\r\n             that xB[i] slightly (i.e. within a tolerance) violates its\r\n             bound, that leads to negative t; in the latter case, if\r\n             xB[i] is chosen, negative t means that xN[q] changes in\r\n             wrong direction; if pivot alfa[i,q] is close to zero, even\r\n             small bound violation of xB[i] may lead to a large change\r\n             of xN[q] in wrong direction; let, for example, xB[i] >= 0\r\n             and in the current basis its value be -5e-9; let also xN[q]\r\n             be on its zero bound and should increase; from the ratio\r\n             test rule it follows that the pivot alfa[i,q] < 0; however,\r\n             if alfa[i,q] is, say, -1e-9, the change of xN[q] in wrong\r\n             direction is 5e-9 / (-1e-9) = -5, and using it for updating\r\n             values of other basic variables will give absolutely wrong\r\n             results; therefore, if t is negative, we should replace it\r\n             by exact zero assuming that xB[i] is exactly on its bound,\r\n             and the violation appears due to round-off errors */\r\n            if (t < 0.0) t = 0.0;\r\n            /* apply minimal ratio test */\r\n            if (teta > t || teta == t && big < Math.abs(alfa)){\r\n                p = i; p_stat = i_stat; teta = t; big = Math.abs(alfa);\r\n            }\r\n\r\n        }\r\n        /* the second pass is skipped in the following cases: */\r\n        /* if the standard ratio test is used */\r\n        if (rtol == 0.0) return done();\r\n        /* if xN[q] reaches its opposite bound or if no basic variable\r\n         has been chosen on the first pass */\r\n        if (p <= 0) return done();\r\n        /* if xB[p] is a blocking variable, i.e. if it prevents xN[q]\r\n         from any change */\r\n        if (teta == 0.0) return done();\r\n        /*** SECOND PASS ***/\r\n        /* here tmax is a maximal change of xN[q], on which the solution\r\n         remains primal feasible (or pseudo feasible on phase I) within\r\n         a tolerance */\r\n        tmax = teta;\r\n        /* nothing is chosen so far */\r\n        p = 0; p_stat = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot column */\r\n        for (pos = 1; pos <= tcol_num; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            alfa = s * tcol_vec[i];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* xB[i] = ... + alfa * xN[q] + ..., and due to s we need to\r\n             consider the only case when xN[q] is increasing */\r\n            if (alfa > 0.0)\r\n            {  /* xB[i] is increasing */\r\n                if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    t = (lb[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an upper bound */\r\n                    t = (ub[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* xB[i] is decreasing */\r\n                if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    t = (ub[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an lower bound */\r\n                    t = (lb[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* (see comments for the first pass) */\r\n            if (t < 0.0) t = 0.0;\r\n            /* t is a change of xN[q], on which xB[i] reaches its bound;\r\n             if t <= tmax, all basic variables can violate their bounds\r\n             only within relaxation tolerance delta; we can use this\r\n             freedom and choose basic variable having largest influence\r\n             coefficient to avoid possible numeric instability */\r\n            if (t <= tmax && big < Math.abs(alfa)){\r\n                p = i; p_stat = i_stat; teta = t; big = Math.abs(alfa);\r\n            }\r\n        }\r\n        /* something must be chosen on the second pass */\r\n        xassert(p != 0);\r\n\r\n        function done(){\r\n            /* store the index and status of basic variable xB[p] chosen */\r\n            csa.p = p;\r\n            if (p > 0 && type[head[p]] == GLP_FX)\r\n                csa.p_stat = GLP_NS;\r\n            else\r\n                csa.p_stat = p_stat;\r\n            /* store corresponding change of non-basic variable xN[q] */\r\n            if (GLP_DEBUG){xassert(teta >= 0.0)}\r\n            csa.teta = s * teta;\r\n        }\r\n        done();\r\n    }\r\n\r\n    function eval_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector rho[p] */\r\n        for (i = 1; i <= m; i++)\r\n            rho[i] = 0.0;\r\n        rho[p] = 1.0;\r\n        /* solve system B'* rho = rho[p] */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, rho);\r\n    }\r\n\r\n    function refine_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var e = csa.work3;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* refine solution of B'* rho = e[p] */\r\n        refine_btran(csa, e, rho);\r\n    }\r\n\r\n    function eval_trow(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var stat = csa.stat}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var i, j, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* clear the pivot row */\r\n        for (j = 1; j <= n; j++)\r\n            trow_vec[j] = 0.0;\r\n        /* compute the pivot row as a linear combination of rows of the\r\n         matrix N: trow = - rho[1] * N'[1] - ... - rho[m] * N'[m] */\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = rho[i];\r\n            if (temp == 0.0) continue;\r\n            /* trow := trow - rho[i] * N'[i] */\r\n            beg = N_ptr[i];\r\n            end = beg + N_len[i];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {\r\n                if (GLP_DEBUG){\r\n                    j = N_ind[ptr];\r\n                    xassert(1 <= j && j <= n);\r\n                    xassert(stat[j] != GLP_NS);\r\n                }\r\n                trow_vec[N_ind[ptr]] -= temp * N_val[ptr];\r\n            }\r\n        }\r\n        /* construct sparse pattern of the pivot row */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (trow_vec[j] != 0.0)\r\n            trow_ind[++nnz] = j;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function update_bbar(csa){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var bbar = csa.bbar;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var p = csa.p;\r\n        var teta = csa.teta;\r\n        var i, pos;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= q && q <= n);\r\n            xassert(p < 0 || 1 <= p && p <= m);\r\n        }\r\n        /* if xN[q] leaves the basis, compute its value in the adjacent\r\n         basis, where it will replace xB[p] */\r\n        if (p > 0)\r\n            bbar[p] = get_xN(csa, q) + teta;\r\n        /* update values of other basic variables (except xB[p], because\r\n         it will be replaced by xN[q]) */\r\n        if (teta == 0.0) return;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            /* skip xB[p] */\r\n            if (i == p) continue;\r\n            /* (change of xB[i]) = alfa[i,q] * (change of xN[q]) */\r\n            bbar[i] += tcol_vec[i] * teta;\r\n        }\r\n    }\r\n\r\n    function reeval_cost(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, pos;\r\n        var dq;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        dq = coef[head[m+q]];\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            dq += coef[head[i]] * tcol_vec[i];\r\n        }\r\n        return dq;\r\n    }\r\n\r\n    function update_cbar(csa){\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var cbar = csa.cbar;\r\n        var q = csa.q;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, pos;\r\n        var new_dq;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* compute reduced cost of xB[p] in the adjacent basis, where it\r\n         will replace xN[q] */\r\n        if (GLP_DEBUG){xassert(trow_vec[q] != 0.0)}\r\n        new_dq = (cbar[q] /= trow_vec[q]);\r\n        /* update reduced costs of other non-basic variables (except\r\n         xN[q], because it will be replaced by xB[p]) */\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            /* skip xN[q] */\r\n            if (j == q) continue;\r\n            cbar[j] -= trow_vec[j] * new_dq;\r\n        }\r\n    }\r\n\r\n    function update_gamma(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var p = csa.p;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var u = csa.work3;\r\n        var i, j, k, pos, beg, end, ptr;\r\n        var gamma_q, delta_q, pivot, s, t, t1, t2;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* the basis changes, so decrease the count */\r\n        xassert(csa.refct > 0);\r\n        csa.refct--;\r\n        /* recompute gamma[q] for the current basis more accurately and\r\n         compute auxiliary vector u */\r\n        gamma_q = delta_q = (refsp[head[m+q]] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++) u[i] = 0.0;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (refsp[head[i]])\r\n            {  u[i] = t = tcol_vec[i];\r\n                gamma_q += t * t;\r\n            }\r\n            else\r\n                u[i] = 0.0;\r\n        }\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, u);\r\n        /* update gamma[k] for other non-basic variables (except fixed\r\n         variables and xN[q], because it will be replaced by xB[p]) */\r\n        pivot = trow_vec[q];\r\n        if (GLP_DEBUG){xassert(pivot != 0.0)}\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            /* skip xN[q] */\r\n            if (j == q) continue;\r\n            /* compute t */\r\n            t = trow_vec[j] / pivot;\r\n            /* compute inner product s = N'[j] * u */\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (k <= m)\r\n                s = u[k];\r\n            else\r\n            {  s = 0.0;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    s -= A_val[ptr] * u[A_ind[ptr]];\r\n            }\r\n            /* compute gamma[k] for the adjacent basis */\r\n            t1 = gamma[j] + t * t * gamma_q + 2.0 * t * s;\r\n            t2 = (refsp[k] ? 1.0 : 0.0) + delta_q * t * t;\r\n            gamma[j] = (t1 >= t2 ? t1 : t2);\r\n            if (gamma[j] < DBL_EPSILON) gamma[j] = DBL_EPSILON;\r\n        }\r\n        /* compute gamma[q] for the adjacent basis */\r\n        if (type[head[p]] == GLP_FX)\r\n            gamma[q] = 1.0;\r\n        else\r\n        {  gamma[q] = gamma_q / (pivot * pivot);\r\n            if (gamma[q] < DBL_EPSILON) gamma[q] = DBL_EPSILON;\r\n        }\r\n    }\r\n\r\n    function err_in_bbar(csa){\r\n        var m = csa.m;\r\n        var bbar = csa.bbar;\r\n        var i;\r\n        var e, emax, beta;\r\n        beta = new Float64Array(1+m);\r\n        eval_beta(csa, beta);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  e = Math.abs(beta[i] - bbar[i]) / (1.0 + Math.abs(beta[i]));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_cbar(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        var e, emax, cost, pi;\r\n        pi = new Float64Array(1+m);\r\n        eval_pi(csa, pi);\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS) continue;\r\n            cost = eval_cost(csa, pi, j);\r\n            e = Math.abs(cost - cbar[j]) / (1.0 + Math.abs(cost));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_gamma(csa){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var gamma = csa.gamma;\r\n        var j;\r\n        var e, emax, temp;\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS)\r\n        {  xassert(gamma[j] == 1.0);\r\n            continue;\r\n        }\r\n            temp = eval_gamma(csa, j);\r\n            e = Math.abs(temp - gamma[j]) / (1.0 + Math.abs(temp));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function change_basis(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var type = csa.type;\r\n        }\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var q = csa.q;\r\n        var p = csa.p;\r\n        var p_stat = csa.p_stat;\r\n        var k;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        if (p < 0)\r\n        {  /* xN[q] goes to its opposite bound */\r\n            if (GLP_DEBUG){\r\n                k = head[m+q]; /* x[k] = xN[q] */\r\n                xassert(1 <= k && k <= m+n);\r\n                xassert(type[k] == GLP_DB);\r\n            }\r\n            switch (stat[q])\r\n            {  case GLP_NL:\r\n                /* xN[q] increases */\r\n                stat[q] = GLP_NU;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[q] decreases */\r\n                    stat[q] = GLP_NL;\r\n                    break;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n        }\r\n        else\r\n        {  /* xB[p] leaves the basis, xN[q] enters the basis */\r\n            if (GLP_DEBUG){\r\n                xassert(1 <= p && p <= m);\r\n                k = head[p]; /* x[k] = xB[p] */\r\n                switch (p_stat)\r\n                {  case GLP_NL:\r\n                    /* xB[p] goes to its lower bound */\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB);\r\n                    break;\r\n                    case GLP_NU:\r\n                        /* xB[p] goes to its upper bound */\r\n                        xassert(type[k] == GLP_UP || type[k] == GLP_DB);\r\n                        break;\r\n                    case GLP_NS:\r\n                        /* xB[p] goes to its fixed value */\r\n                        xassert(type[k] == GLP_NS);\r\n                        break;\r\n                    default:\r\n                        xassert(p_stat != p_stat);\r\n                }\r\n            }\r\n            /* xB[p] <. xN[q] */\r\n            k = head[p];\r\n            head[p] = head[m+q];\r\n            head[m+q] = k;\r\n            stat[q] = p_stat;\r\n        }\r\n    }\r\n\r\n    function set_aux_obj(csa, tol_bnd){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k, cnt = 0;\r\n        var eps;\r\n        /* use a bit more restrictive tolerance */\r\n        tol_bnd *= 0.90;\r\n        /* clear all objective coefficients */\r\n        for (k = 1; k <= m+n; k++)\r\n            coef[k] = 0.0;\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has lower bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps)\r\n                {  /* and violates it */\r\n                    coef[k] = -1.0;\r\n                    cnt++;\r\n                }\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has upper bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps)\r\n                {  /* and violates it */\r\n                    coef[k] = +1.0;\r\n                    cnt++;\r\n                }\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    function set_orig_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var coef = csa.coef;\r\n        var obj = csa.obj;\r\n        var zeta = csa.zeta;\r\n        var i, j;\r\n        for (i = 1; i <= m; i++)\r\n            coef[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            coef[m+j] = zeta * obj[j];\r\n    }\r\n\r\n    function check_stab(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var i, k;\r\n        var eps;\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (phase == 1 && coef[k] < 0.0)\r\n            {  /* x[k] must not be greater than its lower bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] > lb[k] + eps) return 1;\r\n            }\r\n            else if (phase == 1 && coef[k] > 0.0)\r\n            {  /* x[k] must not be less than its upper bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] < ub[k] - eps) return 1;\r\n            }\r\n            else\r\n            {  /* either phase = 1 and coef[k] = 0, or phase = 2 */\r\n                if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* x[k] must not be less than its lower bound */\r\n                    eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                    if (bbar[i] < lb[k] - eps) return 1;\r\n                }\r\n                if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* x[k] must not be greater then its upper bound */\r\n                    eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                    if (bbar[i] > ub[k] + eps) return 1;\r\n                }\r\n            }\r\n        }\r\n        /* basic solution is primal feasible within a tolerance */\r\n        return 0;\r\n    }\r\n\r\n    function check_feas(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var type = csa.type;\r\n        }\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k;\r\n        var eps;\r\n        xassert(csa.phase == 1);\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (coef[k] < 0.0)\r\n            {  /* check if x[k] still violates its lower bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps) return 1;\r\n            }\r\n            else if (coef[k] > 0.0)\r\n            {  /* check if x[k] still violates its upper bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps) return 1;\r\n            }\r\n        }\r\n        /* basic solution is primal feasible within a tolerance */\r\n        return 0;\r\n    }\r\n\r\n    function eval_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var obj = csa.obj;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, j, k;\r\n        var sum;\r\n        sum = obj[0];\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k > m)\r\n                sum += obj[k-m] * bbar[i];\r\n        }\r\n        /* walk through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k > m)\r\n                sum += obj[k-m] * get_xN(csa, j);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function display(csa, parm, spec){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var phase = csa.phase;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k, cnt;\r\n        var sum;\r\n        if (parm.msg_lev < GLP_MSG_ON) return;\r\n        if (parm.out_dly > 0 &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)\r\n            return;\r\n        if (csa.it_cnt == csa.it_dpy) return;\r\n        if (!spec && csa.it_cnt % parm.out_frq != 0) return;\r\n        /* compute the sum of primal infeasibilities and determine the\r\n         number of basic fixed variables */\r\n        sum = 0.0; cnt = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has lower bound */\r\n                if (bbar[i] < lb[k])\r\n                    sum += (lb[k] - bbar[i]);\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has upper bound */\r\n                if (bbar[i] > ub[k])\r\n                    sum += (bbar[i] - ub[k]);\r\n            }\r\n            if (type[k] == GLP_FX) cnt++;\r\n        }\r\n        xprintf((phase == 1 ? ' ' : '*') + csa.it_cnt + \": obj = \" + eval_obj(csa) + \"  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        csa.it_dpy = csa.it_cnt;\r\n    }\r\n\r\n    function store_sol(csa, lp, p_stat, d_stat, ray){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var zeta = csa.zeta;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, k;\r\n        var row, col;\r\n        if (GLP_DEBUG){\r\n            xassert(lp.m == m);\r\n            xassert(lp.n == n);\r\n\r\n            /* basis factorization */\r\n            xassert(!lp.valid && lp.bfd == null);\r\n            xassert(csa.valid && csa.bfd != null);\r\n        }\r\n        lp.valid = 1; csa.valid = 0;\r\n        lp.bfd = csa.bfd; csa.bfd = null;\r\n        xcopyArr(lp.head, 1, head, 1, m);\r\n        /* basic solution status */\r\n        lp.pbs_stat = p_stat;\r\n        lp.dbs_stat = d_stat;\r\n        /* objective function value */\r\n        lp.obj_val = eval_obj(csa);\r\n        /* simplex iteration count */\r\n        lp.it_cnt = csa.it_cnt;\r\n        /* unbounded ray */\r\n        lp.some = ray;\r\n        /* basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = GLP_BS;\r\n                row.bind = i;\r\n                row.prim = bbar[i] / row.rii;\r\n                row.dual = 0.0;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = GLP_BS;\r\n                col.bind = i;\r\n                col.prim = bbar[i] * col.sjj;\r\n                col.dual = 0.0;\r\n            }\r\n        }\r\n        /* non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = stat[j];\r\n                row.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    row.prim = row.lb; break;\r\n                    case GLP_NU:\r\n                        row.prim = row.ub; break;\r\n                    case GLP_NF:\r\n                        row.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        row.prim = row.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                row.dual = (cbar[j] * row.rii) / zeta;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = stat[j];\r\n                col.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    col.prim = col.lb; break;\r\n                    case GLP_NU:\r\n                        col.prim = col.ub; break;\r\n                    case GLP_NF:\r\n                        col.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        col.prim = col.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                col.dual = (cbar[j] / col.sjj) / zeta;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    var csa;\r\n    var binv_st = 2;\r\n    /* status of basis matrix factorization:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var bbar_st = 0;\r\n    /* status of primal values of basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var cbar_st = 0;\r\n    /* status of reduced costs of non-basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var rigorous = 0;\r\n    /* rigorous mode flag; this flag is used to enable iterative\r\n     refinement on computing pivot rows and columns of the simplex\r\n     table */\r\n    var check = 0;\r\n    var p_stat, d_stat, ret;\r\n    /* allocate and initialize the common storage area */\r\n    csa = alloc_csa(lp);\r\n    init_csa(csa, lp);\r\n    if (parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"Objective scale factor = \" + csa.zeta + \"\");\r\n    while (true){\r\n        /* main loop starts here */\r\n        /* compute factorization of the basis matrix */\r\n        if (binv_st == 0)\r\n        {  ret = invert_B(csa);\r\n            if (ret != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            {  xprintf(\"Error: unable to factorize the basis matrix (\" + ret + \")\");\r\n                xprintf(\"Sorry, basis recovery procedure not implemented yet\");\r\n            }\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                return ret;\r\n            }\r\n            csa.valid = 1;\r\n            binv_st = 1; /* just computed */\r\n            /* invalidate basic solution components */\r\n            bbar_st = cbar_st = 0;\r\n        }\r\n        /* compute primal values of basic variables */\r\n        if (bbar_st == 0)\r\n        {  eval_bbar(csa);\r\n            bbar_st = 1; /* just computed */\r\n            /* determine the search phase, if not determined yet */\r\n            if (csa.phase == 0)\r\n            {  if (set_aux_obj(csa, parm.tol_bnd) > 0)\r\n            {  /* current basic solution is primal infeasible */\r\n                /* start to minimize the sum of infeasibilities */\r\n                csa.phase = 1;\r\n            }\r\n            else\r\n            {  /* current basic solution is primal feasible */\r\n                /* start to minimize the original objective function */\r\n                set_orig_obj(csa);\r\n                csa.phase = 2;\r\n            }\r\n                xassert(check_stab(csa, parm.tol_bnd) == 0);\r\n                /* working objective coefficients have been changed, so\r\n                 invalidate reduced costs */\r\n                cbar_st = 0;\r\n                display(csa, parm, 1);\r\n            }\r\n            /* make sure that the current basic solution remains primal\r\n             feasible (or pseudo feasible on phase I) */\r\n            if (check_stab(csa, parm.tol_bnd))\r\n            {  /* there are excessive bound violations due to round-off\r\n             errors */\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: numerical instability (primal simplex, phase \" + (csa.phase == 1 ? \"I\" : \"II\") + \")\");\r\n                /* restart the search */\r\n                csa.phase = 0;\r\n                binv_st = 0;\r\n                rigorous = 5;\r\n                continue;\r\n            }\r\n        }\r\n        xassert(csa.phase == 1 || csa.phase == 2);\r\n        /* on phase I we do not need to wait until the current basic\r\n         solution becomes dual feasible; it is sufficient to make sure\r\n         that no basic variable violates its bounds */\r\n        if (csa.phase == 1 && !check_feas(csa, parm.tol_bnd))\r\n        {  /* the current basis is primal feasible; switch to phase II */\r\n            csa.phase = 2;\r\n            set_orig_obj(csa);\r\n            cbar_st = 0;\r\n            display(csa, parm, 1);\r\n        }\r\n        /* compute reduced costs of non-basic variables */\r\n        if (cbar_st == 0)\r\n        {  eval_cbar(csa);\r\n            cbar_st = 1; /* just computed */\r\n        }\r\n        /* redefine the reference space, if required */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct == 0) reset_refsp(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* at this point the basis factorization and all basic solution\r\n         components are valid */\r\n        xassert(binv_st && bbar_st && cbar_st);\r\n        /* check accuracy of current basic solution components (only for\r\n         debugging) */\r\n        if (check)\r\n        {  var e_bbar = err_in_bbar(csa);\r\n            var e_cbar = err_in_cbar(csa);\r\n            var e_gamma =\r\n                (parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0.0);\r\n            xprintf(\"e_bbar = \" + e_bbar + \"; e_cbar = \" + e_cbar + \"; e_gamma = \" + e_gamma + \"\");\r\n            xassert(e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3);\r\n        }\r\n        /* check if the iteration limit has been exhausted */\r\n        if (parm.it_lim < INT_MAX &&\r\n            csa.it_cnt - csa.it_beg >= parm.it_lim)\r\n        {  if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (csa.phase == 2 && cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                p_stat = GLP_INFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                break;\r\n                case 2:\r\n                    p_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            chuzc(csa, parm.tol_dj);\r\n            d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = GLP_EITLIM;\r\n            return ret;\r\n        }\r\n        /* check if the time limit has been exhausted */\r\n        if (parm.tm_lim < INT_MAX &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim)\r\n        {  if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (csa.phase == 2 && cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                p_stat = GLP_INFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                break;\r\n                case 2:\r\n                    p_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            chuzc(csa, parm.tol_dj);\r\n            d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = GLP_ETMLIM;\r\n            return ret;\r\n        }\r\n        /* display the search progress */\r\n        display(csa, parm, 0);\r\n        /* choose non-basic variable xN[q] */\r\n        chuzc(csa, parm.tol_dj);\r\n        if (csa.q == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n                p_stat = GLP_NOFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                chuzc(csa, parm.tol_dj);\r\n                d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n                    p_stat = d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n        /* compute pivot column of the simplex table */\r\n        eval_tcol(csa);\r\n        if (rigorous) refine_tcol(csa);\r\n        sort_tcol(csa, parm.tol_piv);\r\n        /* check accuracy of the reduced cost of xN[q] */\r\n        {  var d1 = csa.cbar[csa.q]; /* less accurate */\r\n            var d2 = reeval_cost(csa);  /* more accurate */\r\n            xassert(d1 != 0.0);\r\n            if (Math.abs(d1 - d2) > 1e-5 * (1.0 + Math.abs(d2)) ||\r\n                !(d1 < 0.0 && d2 < 0.0 || d1 > 0.0 && d2 > 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"d1 = \" + d1 + \"; d2 = \" + d2 + \"\");\r\n                if (cbar_st != 1 || !rigorous)\r\n                {  if (cbar_st != 1) cbar_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n            /* replace cbar[q] by more accurate value keeping its sign */\r\n            if (d1 > 0.0)\r\n                csa.cbar[csa.q] = (d2 > 0.0 ? d2 : +DBL_EPSILON);\r\n            else\r\n                csa.cbar[csa.q] = (d2 < 0.0 ? d2 : -DBL_EPSILON);\r\n        }\r\n        /* choose basic variable xB[p] */\r\n        switch (parm.r_test)\r\n        {  case GLP_RT_STD:\r\n            chuzr(csa, 0.0);\r\n            break;\r\n            case GLP_RT_HAR:\r\n                chuzr(csa, 0.30 * parm.tol_bnd);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        if (csa.p == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1 || !rigorous)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            rigorous = 1;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Error: unable to choose basic variable on phase I\");\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"PROBLEM HAS UNBOUNDED SOLUTION\");\r\n                    store_sol(csa, lp, GLP_FEAS, GLP_NOFEAS,\r\n                        csa.head[csa.m+csa.q]);\r\n                    ret = 0;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            return ret;\r\n        }\r\n        /* check if the pivot element is acceptable */\r\n        if (csa.p > 0)\r\n        {  var piv = csa.tcol_vec[csa.p];\r\n            var eps = 1e-5 * (1.0 + 0.01 * csa.tcol_max);\r\n            if (Math.abs(piv) < eps)\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv = \" + piv + \"; eps = \" + eps + \"\");\r\n                if (!rigorous)\r\n                {  rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        /* now xN[q] and xB[p] have been chosen anyhow */\r\n        /* compute pivot row of the simplex table */\r\n        if (csa.p > 0)\r\n        {  var rho = csa.work4;\r\n            eval_rho(csa, rho);\r\n            if (rigorous) refine_rho(csa, rho);\r\n            eval_trow(csa, rho);\r\n        }\r\n        /* accuracy check based on the pivot element */\r\n        if (csa.p > 0)\r\n        {  var piv1 = csa.tcol_vec[csa.p]; /* more accurate */\r\n            var piv2 = csa.trow_vec[csa.q]; /* less accurate */\r\n            xassert(piv1 != 0.0);\r\n            if (Math.abs(piv1 - piv2) > 1e-8 * (1.0 + Math.abs(piv1)) ||\r\n                !(piv1 > 0.0 && piv2 > 0.0 || piv1 < 0.0 && piv2 < 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv1 = \" + piv1 + \"; piv2 = \" + piv2 + \"\");\r\n                if (binv_st != 1 || !rigorous)\r\n                {  if (binv_st != 1) binv_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n                /* use more accurate version in the pivot row */\r\n                if (csa.trow_vec[csa.q] == 0.0)\r\n                {  csa.trow_nnz++;\r\n                    xassert(csa.trow_nnz <= csa.n);\r\n                    csa.trow_ind[csa.trow_nnz] = csa.q;\r\n                }\r\n                csa.trow_vec[csa.q] = piv1;\r\n            }\r\n        }\r\n        /* update primal values of basic variables */\r\n        update_bbar(csa);\r\n        bbar_st = 2; /* updated */\r\n        /* update reduced costs of non-basic variables */\r\n        if (csa.p > 0)\r\n        {  update_cbar(csa);\r\n            cbar_st = 2; /* updated */\r\n            /* on phase I objective coefficient of xB[p] in the adjacent\r\n             basis becomes zero */\r\n            if (csa.phase == 1)\r\n            {  var k = csa.head[csa.p]; /* x[k] = xB[p] . xN[q] */\r\n                csa.cbar[csa.q] -= csa.coef[k];\r\n                csa.coef[k] = 0.0;\r\n            }\r\n        }\r\n        /* update steepest edge coefficients */\r\n        if (csa.p > 0)\r\n        {  switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n                break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct > 0) update_gamma(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        }\r\n        /* update factorization of the basis matrix */\r\n        if (csa.p > 0)\r\n        {  ret = update_B(csa, csa.p, csa.head[csa.m+csa.q]);\r\n            if (ret == 0)\r\n                binv_st = 2; /* updated */\r\n            else\r\n            {  csa.valid = 0;\r\n                binv_st = 0; /* invalid */\r\n            }\r\n        }\r\n        /* update matrix N */\r\n        if (csa.p > 0)\r\n        {  del_N_col(csa, csa.q, csa.head[csa.m+csa.q]);\r\n            if (csa.type[csa.head[csa.p]] != GLP_FX)\r\n                add_N_col(csa, csa.q, csa.head[csa.p]);\r\n        }\r\n        /* change the basis header */\r\n        change_basis(csa);\r\n        /* iteration complete */\r\n        csa.it_cnt++;\r\n        if (rigorous > 0) rigorous--;\r\n        continue;\r\n    }\r\n\r\n    /* return to the calling program */\r\n    //return ret;\r\n}\r\n\r\nfunction spx_dual(lp, parm){\r\n\r\n    var kappa = 0.10;\r\n\r\n    function alloc_csa(lp){\r\n        var m = lp.m;\r\n        var n = lp.n;\r\n        var nnz = lp.nnz;\r\n        var csa = {};\r\n        xassert(m > 0 && n > 0);\r\n        csa.m = m;\r\n        csa.n = n;\r\n        csa.type = new Int8Array(1+m+n);\r\n        csa.lb = new Float64Array(1+m+n);\r\n        csa.ub = new Float64Array(1+m+n);\r\n        csa.coef = new Float64Array(1+m+n);\r\n        csa.orig_type = new Int8Array(1+m+n);\r\n        csa.orig_lb = new Float64Array(1+m+n);\r\n        csa.orig_ub = new Float64Array(1+m+n);\r\n        csa.obj = new Float64Array(1+n);\r\n        csa.A_ptr = new Int32Array(1+n+1);\r\n        csa.A_ind = new Int32Array(1+nnz);\r\n        csa.A_val = new Float64Array(1+nnz);\r\n        csa.AT_ptr = new Int32Array(1+m+1);\r\n        csa.AT_ind = new Int32Array(1+nnz);\r\n        csa.AT_val = new Float64Array(1+nnz);\r\n        csa.head = new Int32Array(1+m+n);\r\n        csa.bind = new Int32Array(1+m+n);\r\n        csa.stat = new Int8Array(1+n);\r\n        csa.bbar = new Float64Array(1+m);\r\n        csa.cbar = new Float64Array(1+n);\r\n        csa.refsp = new Int8Array(1+m+n);\r\n        csa.gamma = new Float64Array(1+m);\r\n        csa.trow_ind = new Int32Array(1+n);\r\n        csa.trow_vec = new Float64Array(1+n);\r\n        csa.tcol_ind = new Int32Array(1+m);\r\n        csa.tcol_vec = new Float64Array(1+m);\r\n        csa.work1 = new Float64Array(1+m);\r\n        csa.work2 = new Float64Array(1+m);\r\n        csa.work3 = new Float64Array(1+m);\r\n        csa.work4 = new Float64Array(1+m);\r\n        return csa;\r\n    }\r\n\r\n    this[\"chrome_workaround_1\"] = function(csa, lp){\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var n = csa.n;\r\n        var aij, loc, j;\r\n        /* matrix A (by columns) */\r\n        loc = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            A_ptr[j] = loc;\r\n            for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n            {  A_ind[loc] = aij.row.i;\r\n                A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        A_ptr[n+1] = loc;\r\n        xassert(loc-1 == lp.nnz);\r\n    };\r\n\r\n    this[\"chrome_workaround_2\"] = function(csa, lp){\r\n        var loc, i, aij;\r\n        var AT_ptr = csa.AT_ptr;\r\n        var AT_ind = csa.AT_ind;\r\n        var AT_val = csa.AT_val;\r\n        var m = csa.m;\r\n\r\n        /* matrix A (by rows) */\r\n        loc = 1;\r\n        for (i = 1; i <= m; i++)\r\n        {\r\n            AT_ptr[i] = loc;\r\n            for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n            {  AT_ind[loc] = aij.col.j;\r\n                AT_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        AT_ptr[m+1] = loc;\r\n        xassert(loc-1 == lp.nnz);\r\n\r\n    };\r\n\r\n    function init_csa(csa, lp){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var orig_type = csa.orig_type;\r\n        var orig_lb = csa.orig_lb;\r\n        var orig_ub = csa.orig_ub;\r\n        var obj = csa.obj;\r\n\r\n        var head = csa.head;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, j, k, loc;\r\n        var cmax, aij, row, col;\r\n        /* auxiliary variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            type[i] = row.type;\r\n            lb[i] = row.lb * row.rii;\r\n            ub[i] = row.ub * row.rii;\r\n            coef[i] = 0.0;\r\n        }\r\n        /* structural variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            type[m+j] = col.type;\r\n            lb[m+j] = col.lb / col.sjj;\r\n            ub[m+j] = col.ub / col.sjj;\r\n            coef[m+j] = col.coef * col.sjj;\r\n        }\r\n        /* original bounds of variables */\r\n        xcopyArr(orig_type, 1, type, 1, m+n);\r\n        xcopyArr(orig_lb, 1, lb, 1, m+n);\r\n        xcopyArr(orig_ub, 1, ub, 1, m+n);\r\n        /* original objective function */\r\n        obj[0] = lp.c0;\r\n        xcopyArr(obj, 1, coef, m+1, n);\r\n        /* factor used to scale original objective coefficients */\r\n        cmax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            if (cmax < Math.abs(obj[j])) cmax = Math.abs(obj[j]);\r\n        if (cmax == 0.0) cmax = 1.0;\r\n        switch (lp.dir)\r\n        {  case GLP_MIN:\r\n            csa.zeta = + 1.0 / cmax;\r\n            break;\r\n            case GLP_MAX:\r\n                csa.zeta = - 1.0 / cmax;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        if (Math.abs(csa.zeta) < 1.0) csa.zeta *= 1000.0;\r\n        /* scale working objective coefficients */\r\n        for (j = 1; j <= n; j++) coef[m+j] *= csa.zeta;\r\n\r\n        chrome_workaround_1(csa, lp);\r\n        chrome_workaround_2(csa, lp);\r\n\r\n        /* basis header */\r\n        xassert(lp.valid);\r\n        xcopyArr(head, 1, lp.head, 1, m);\r\n        k = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            if (row.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = i;\r\n                stat[k] = row.stat;\r\n            }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = m + j;\r\n                stat[k] = col.stat;\r\n            }\r\n        }\r\n        xassert(k == n);\r\n        for (k = 1; k <= m+n; k++)\r\n            bind[head[k]] = k;\r\n        /* factorization of matrix B */\r\n        csa.valid = 1; lp.valid = 0;\r\n        csa.bfd = lp.bfd; lp.bfd = null;\r\n        /* working parameters */\r\n        csa.phase = 0;\r\n        csa.tm_beg = xtime();\r\n        csa.it_beg = csa.it_cnt = lp.it_cnt;\r\n        csa.it_dpy = -1;\r\n        /* reference space and steepest edge coefficients */\r\n        csa.refct = 0;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (i = 1; i <= m; i++) gamma[i] = 1.0;\r\n    }\r\n\r\n    function inv_col(csa, i, ind, val){\r\n        /* this auxiliary routine returns row indices and numeric values\r\n         of non-zero elements of i-th column of the basis matrix */\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var k, len, ptr, t;\r\n        if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n        k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (k <= m)\r\n        {  /* B[i] is k-th column of submatrix I */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n            ptr = A_ptr[k-m];\r\n            len = A_ptr[k-m+1] - ptr;\r\n            xcopyArr(ind, 1, A_ind, ptr, len);\r\n            xcopyArr(val, 1, A_val, ptr, len);\r\n            for (t = 1; t <= len; t++) val[t] = - val[t];\r\n        }\r\n        return len;\r\n    }\r\n\r\n    function invert_B(csa){\r\n        var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function update_B(csa, i, k)\r\n    {   var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var ret, val;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= i && i <= m);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* new i-th column of B is k-th column of I */\r\n            var ind = new Array(1+1);\r\n            val = new Array(1+1);\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);\r\n        }\r\n        else\r\n        {  /* new i-th column of B is (k-m)-th column of (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            val = csa.work1;\r\n            var beg, end, ptr, len;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            len = 0;\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                val[++len] = - A_val[ptr];\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg-1, val);\r\n        }\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function error_ftran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector:\r\n         r = h - B * x = h - B[1] * x[1] - ... - B[m] * x[m],\r\n         where B[1], ..., B[m] are columns of matrix B */\r\n        xcopyArr(r, 1, h, 1, m);\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                r[k] -= temp;\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    r[A_ind[ptr]] += A_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    function refine_ftran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B * x */\r\n        error_ftran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B) * r */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function error_btran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector r = b - B'* x */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* r[i] := b[i] - (i-th column of B)'* x */\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            temp = h[i];\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                temp -= x[k];\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += A_val[ptr] * x[A_ind[ptr]];\r\n            }\r\n            r[i] = temp;\r\n        }\r\n    }\r\n\r\n    function refine_btran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B'* x */\r\n        error_btran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B') * r */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function get_xN(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var k;\r\n        var xN;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        switch (stat[j])\r\n        {  case GLP_NL:\r\n            /* x[k] is on its lower bound */\r\n            xN = lb[k]; break;\r\n            case GLP_NU:\r\n                /* x[k] is on its upper bound */\r\n                xN = ub[k]; break;\r\n            case GLP_NF:\r\n                /* x[k] is free non-basic variable */\r\n                xN = 0.0; break;\r\n            case GLP_NS:\r\n                /* x[k] is fixed non-basic variable */\r\n                xN = lb[k]; break;\r\n            default:\r\n                xassert(stat != stat);\r\n        }\r\n        return xN;\r\n    }\r\n\r\n    function eval_beta(csa, beta){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var h = csa.work2;\r\n        var i, j, k, beg, end, ptr;\r\n        var xN;\r\n        /* compute the right-hand side vector:\r\n         h := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n],\r\n         where N[1], ..., N[n] are columns of matrix N */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {   k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine current value of xN[j] */\r\n            xN = get_xN(csa, j);\r\n            if (xN == 0.0) continue;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] -= xN;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] += xN * A_val[ptr];\r\n            }\r\n        }\r\n        /* solve system B * beta = h */\r\n        xcopyArr(beta, 1, h, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, beta);\r\n        /* and refine the solution */\r\n        refine_ftran(csa, h, beta);\r\n    }\r\n\r\n    function eval_pi(csa, pi){\r\n        var m = csa.m;\r\n        var c = csa.coef;\r\n        var head = csa.head;\r\n        var cB = csa.work2;\r\n        var i;\r\n        /* construct the right-hand side vector cB */\r\n        for (i = 1; i <= m; i++)\r\n            cB[i] = c[head[i]];\r\n        /* solve system B'* pi = cB */\r\n        xcopyArr(pi, 1, cB, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, pi);\r\n        /* and refine the solution */\r\n        refine_btran(csa, cB, pi);\r\n    }\r\n\r\n    function eval_cost(csa, pi, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var k;\r\n        var dj;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        dj = coef[k];\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            dj -= pi[k];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                dj += A_val[ptr] * pi[A_ind[ptr]];\r\n        }\r\n        return dj;\r\n    }\r\n\r\n    function eval_bbar(csa){\r\n        eval_beta(csa, csa.bbar);\r\n    }\r\n\r\n    function eval_cbar(csa){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var head = csa.head}\r\n        var cbar = csa.cbar;\r\n        var pi = csa.work3;\r\n        var j;\r\n        if (GLP_DEBUG){var k}\r\n        /* compute simplex multipliers */\r\n        eval_pi(csa, pi);\r\n        /* compute and store reduced costs */\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                k = head[m+j]; /* x[k] = xN[j] */\r\n                xassert(1 <= k && k <= m+n);\r\n            }\r\n            cbar[j] = eval_cost(csa, pi, j);\r\n        }\r\n    }\r\n\r\n    function reset_refsp(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, k;\r\n        xassert(csa.refct == 0);\r\n        csa.refct = 1000;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            refsp[k] = 1;\r\n            gamma[i] = 1.0;\r\n        }\r\n    }\r\n\r\n    function eval_gamma(csa, gamma){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var alfa = csa.work3;\r\n        var h = csa.work3;\r\n        var i, j, k;\r\n        /* gamma[i] := eta[i] (or 1, if xB[i] is free) */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (type[k] == GLP_FR)\r\n                gamma[i] = 1.0;\r\n            else\r\n                gamma[i] = (refsp[k] ? 1.0 : 0.0);\r\n        }\r\n        /* compute columns of the current simplex table */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* skip column, if xN[j] is not in C */\r\n            if (!refsp[k]) continue;\r\n            if (GLP_DEBUG){\r\n                /* set C must not contain fixed variables */\r\n                xassert(type[k] != GLP_FX);\r\n            }\r\n            /* construct the right-hand side vector h = - N[j] */\r\n            for (i = 1; i <= m; i++)\r\n                h[i] = 0.0;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] = -1.0;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                var A_ptr = csa.A_ptr;\r\n                var A_ind = csa.A_ind;\r\n                var A_val = csa.A_val;\r\n                var beg, end, ptr;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] = A_val[ptr];\r\n            }\r\n            /* solve system B * alfa = h */\r\n            xassert(csa.valid);\r\n            bfd_ftran(csa.bfd, alfa);\r\n            /* gamma[i] := gamma[i] + alfa[i,j]^2 */\r\n            for (i = 1; i <= m; i++)\r\n            {  k = head[i]; /* x[k] = xB[i] */\r\n                if (type[k] != GLP_FR)\r\n                    gamma[i] += alfa[i] * alfa[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function chuzr(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var gamma = csa.gamma;\r\n        var i, k, p;\r\n        var delta, best, eps, ri, temp;\r\n        /* nothing is chosen so far */\r\n        p = 0; delta = 0.0; best = 0.0;\r\n        /* look through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine bound violation ri[i] */\r\n            ri = 0.0;\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* xB[i] has lower bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps)\r\n                {  /* and significantly violates it */\r\n                    ri = lb[k] - bbar[i];\r\n                }\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* xB[i] has upper bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps)\r\n                {  /* and significantly violates it */\r\n                    ri = ub[k] - bbar[i];\r\n                }\r\n            }\r\n            /* if xB[i] is not eligible, skip it */\r\n            if (ri == 0.0) continue;\r\n            /* xB[i] is eligible basic variable; choose one with largest\r\n             weighted bound violation */\r\n            if (GLP_DEBUG){xassert(gamma[i] >= 0.0)}\r\n            temp = gamma[i];\r\n            if (temp < DBL_EPSILON) temp = DBL_EPSILON;\r\n            temp = (ri * ri) / temp;\r\n            if (best < temp){\r\n                p = i; delta = ri; best = temp;\r\n            }\r\n        }\r\n        /* store the index of basic variable xB[p] chosen and its change\r\n         in the adjacent basis */\r\n        csa.p = p;\r\n        csa.delta = delta;\r\n    }\r\n\r\n    function eval_rho(csa, e){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* solve system B'* rho = e[p] */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, rho);\r\n    }\r\n\r\n    function refine_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var e = csa.work3;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* refine solution of B'* rho = e[p] */\r\n        refine_btran(csa, e, rho);\r\n    }\r\n\r\n    function eval_trow1(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, k, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* compute the pivot row as inner products of columns of the\r\n         matrix N and vector rho: trow[j] = - rho * N[j] */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS)\r\n        {  /* xN[j] is fixed */\r\n            trow_vec[j] = 0.0;\r\n            continue;\r\n        }\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                temp = - rho[k];\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m]; end = A_ptr[k-m+1];\r\n                temp = 0.0;\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += rho[A_ind[ptr]] * A_val[ptr];\r\n            }\r\n            if (temp != 0.0)\r\n                trow_ind[++nnz] = j;\r\n            trow_vec[j] = temp;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function eval_trow2(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var AT_ptr = csa.AT_ptr;\r\n        var AT_ind = csa.AT_ind;\r\n        var AT_val = csa.AT_val;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var i, j, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* clear the pivot row */\r\n        for (j = 1; j <= n; j++)\r\n            trow_vec[j] = 0.0;\r\n        /* compute the pivot row as a linear combination of rows of the\r\n         matrix N: trow = - rho[1] * N'[1] - ... - rho[m] * N'[m] */\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = rho[i];\r\n            if (temp == 0.0) continue;\r\n            /* trow := trow - rho[i] * N'[i] */\r\n            j = bind[i] - m; /* x[i] = xN[j] */\r\n            if (j >= 1 && stat[j] != GLP_NS)\r\n                trow_vec[j] -= temp;\r\n            beg = AT_ptr[i]; end = AT_ptr[i+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  j = bind[m + AT_ind[ptr]] - m; /* x[k] = xN[j] */\r\n                if (j >= 1 && stat[j] != GLP_NS)\r\n                    trow_vec[j] += temp * AT_val[ptr];\r\n            }\r\n        }\r\n        /* construct sparse pattern of the pivot row */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (trow_vec[j] != 0.0)\r\n            trow_ind[++nnz] = j;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function eval_trow(csa, rho){\r\n        var m = csa.m;\r\n        var i, nnz;\r\n        var dens;\r\n        /* determine the density of the vector rho */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n            if (rho[i] != 0.0) nnz++;\r\n        dens = nnz / m;\r\n        if (dens >= 0.20)\r\n        {  /* rho is relatively dense */\r\n            eval_trow1(csa, rho);\r\n        }\r\n        else\r\n        {  /* rho is relatively sparse */\r\n            eval_trow2(csa, rho);\r\n        }\r\n    }\r\n\r\n    function sort_trow(csa, tol_piv){\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var stat = csa.stat;\r\n        }\r\n        var nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, num, pos;\r\n        var big, eps, temp;\r\n        /* compute infinity (maximum) norm of the row */\r\n        big = 0.0;\r\n        for (pos = 1; pos <= nnz; pos++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                j = trow_ind[pos];\r\n                xassert(1 <= j && j <= n);\r\n                xassert(stat[j] != GLP_NS);\r\n            }\r\n            temp = Math.abs(trow_vec[trow_ind[pos]]);\r\n            if (big < temp) big = temp;\r\n        }\r\n        csa.trow_max = big;\r\n        /* determine absolute pivot tolerance */\r\n        eps = tol_piv * (1.0 + 0.01 * big);\r\n        /* move significant row components to the front of the list */\r\n        for (num = 0; num < nnz; )\r\n        {  j = trow_ind[nnz];\r\n            if (Math.abs(trow_vec[j]) < eps)\r\n                nnz--;\r\n            else\r\n            {  num++;\r\n                trow_ind[nnz] = trow_ind[num];\r\n                trow_ind[num] = j;\r\n            }\r\n        }\r\n        csa.trow_num = num;\r\n    }\r\n\r\n    function chuzc(csa, rtol){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        if (GLP_DEBUG){\r\n            var p = csa.p;\r\n        }\r\n        var delta = csa.delta;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var trow_num = csa.trow_num;\r\n        var j, pos, q;\r\n        var alfa, big, s, t, teta, tmax;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* delta > 0 means that xB[p] violates its lower bound and goes\r\n         to it in the adjacent basis, so lambdaB[p] is increasing from\r\n         its lower zero bound;\r\n         delta < 0 means that xB[p] violates its upper bound and goes\r\n         to it in the adjacent basis, so lambdaB[p] is decreasing from\r\n         its upper zero bound */\r\n        if (GLP_DEBUG){xassert(delta != 0.0)}\r\n        /* s := sign(delta) */\r\n        s = (delta > 0.0 ? +1.0 : -1.0);\r\n        /*** FIRST PASS ***/\r\n        /* nothing is chosen so far */\r\n        q = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot row */\r\n        for (pos = 1; pos <= trow_num; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            alfa = s * trow_vec[j];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* lambdaN[j] = ... - alfa * lambdaB[p] - ..., and due to s we\r\n             need to consider only increasing lambdaB[p] */\r\n            if (alfa > 0.0)\r\n            {  /* lambdaN[j] is decreasing */\r\n                if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero lower bound */\r\n                    t = (cbar[j] + rtol) / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* lambdaN[j] is increasing */\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero upper bound */\r\n                    t = (cbar[j] - rtol) / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* t is a change of lambdaB[p], on which lambdaN[j] reaches\r\n             its zero bound (possibly relaxed); since the basic solution\r\n             is assumed to be dual feasible, t has to be non-negative by\r\n             definition; however, it may happen that lambdaN[j] slightly\r\n             (i.e. within a tolerance) violates its zero bound, that\r\n             leads to negative t; in the latter case, if xN[j] is chosen,\r\n             negative t means that lambdaB[p] changes in wrong direction\r\n             that may cause wrong results on updating reduced costs;\r\n             thus, if t is negative, we should replace it by exact zero\r\n             assuming that lambdaN[j] is exactly on its zero bound, and\r\n             violation appears due to round-off errors */\r\n            if (t < 0.0) t = 0.0;\r\n            /* apply minimal ratio test */\r\n            if (teta > t || teta == t && big < Math.abs(alfa)){\r\n                q = j; teta = t; big = Math.abs(alfa);\r\n            }\r\n\r\n        }\r\n        /* the second pass is skipped in the following cases: */\r\n        /* if the standard ratio test is used */\r\n        if (rtol == 0.0) return done();\r\n        /* if no non-basic variable has been chosen on the first pass */\r\n        if (q == 0) return done();\r\n        /* if lambdaN[q] prevents lambdaB[p] from any change */\r\n        if (teta == 0.0) return done();\r\n        /*** SECOND PASS ***/\r\n        /* here tmax is a maximal change of lambdaB[p], on which the\r\n         solution remains dual feasible within a tolerance */\r\n        tmax = teta;\r\n        /* nothing is chosen so far */\r\n        q = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot row */\r\n        for (pos = 1; pos <= trow_num; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            alfa = s * trow_vec[j];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* lambdaN[j] = ... - alfa * lambdaB[p] - ..., and due to s we\r\n             need to consider only increasing lambdaB[p] */\r\n            if (alfa > 0.0)\r\n            {  /* lambdaN[j] is decreasing */\r\n                if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero lower bound */\r\n                    t = cbar[j] / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* lambdaN[j] is increasing */\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero upper bound */\r\n                    t = cbar[j] / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* (see comments for the first pass) */\r\n            if (t < 0.0) t = 0.0;\r\n            /* t is a change of lambdaB[p], on which lambdaN[j] reaches\r\n             its zero (lower or upper) bound; if t <= tmax, all reduced\r\n             costs can violate their zero bounds only within relaxation\r\n             tolerance rtol, so we can choose non-basic variable having\r\n             largest influence coefficient to avoid possible numerical\r\n             instability */\r\n            if (t <= tmax && big < Math.abs(alfa)){\r\n                q = j; teta = t; big = Math.abs(alfa);\r\n            }\r\n        }\r\n        /* something must be chosen on the second pass */\r\n        xassert(q != 0);\r\n\r\n        function done(){\r\n            /* store the index of non-basic variable xN[q] chosen */\r\n            csa.q = q;\r\n            /* store reduced cost of xN[q] in the adjacent basis */\r\n            csa.new_dq = s * teta;\r\n        }\r\n        done();\r\n    }\r\n\r\n    function eval_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.tcol_vec;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * tcol = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function refine_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.work3;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* refine solution of B * tcol = h */\r\n        refine_ftran(csa, h, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function update_cbar(csa){\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var cbar = csa.cbar;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var q = csa.q;\r\n        var new_dq = csa.new_dq;\r\n        var j, pos;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* set new reduced cost of xN[q] */\r\n        cbar[q] = new_dq;\r\n        /* update reduced costs of other non-basic variables */\r\n        if (new_dq == 0.0) return;\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            if (j != q)\r\n                cbar[j] -= trow_vec[j] * new_dq;\r\n        }\r\n    }\r\n\r\n    function update_bbar(csa){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var bbar = csa.bbar;\r\n        var p = csa.p;\r\n        var delta = csa.delta;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, pos;\r\n        var teta;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n            /* determine the change of xN[q] in the adjacent basis */\r\n            xassert(tcol_vec[p] != 0.0);\r\n        }\r\n        teta = delta / tcol_vec[p];\r\n        /* set new primal value of xN[q] */\r\n        bbar[p] = get_xN(csa, q) + teta;\r\n        /* update primal values of other basic variables */\r\n        if (teta == 0.0) return;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            if (i != p)\r\n                bbar[i] += tcol_vec[i] * teta;\r\n        }\r\n    }\r\n\r\n    function update_gamma(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var p = csa.p;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var u = csa.work3;\r\n        var i, j, k,pos;\r\n        var gamma_p, eta_p, pivot, t, t1, t2;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* the basis changes, so decrease the count */\r\n        xassert(csa.refct > 0);\r\n        csa.refct--;\r\n        /* recompute gamma[p] for the current basis more accurately and\r\n         compute auxiliary vector u */\r\n        if (GLP_DEBUG){xassert(type[head[p]] != GLP_FR)}\r\n        gamma_p = eta_p = (refsp[head[p]] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++) u[i] = 0.0;\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {   j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){\r\n                xassert(1 <= k && k <= m+n);\r\n                xassert(type[k] != GLP_FX);\r\n            }\r\n            if (!refsp[k]) continue;\r\n            t = trow_vec[j];\r\n            gamma_p += t * t;\r\n            /* u := u + N[j] * delta[j] * trow[j] */\r\n            if (k <= m)\r\n            {  /* N[k] = k-j stolbec submatrix I */\r\n                u[k] += t;\r\n            }\r\n            else\r\n            {  /* N[k] = k-m-k stolbec (-A) */\r\n                var A_ptr = csa.A_ptr;\r\n                var A_ind = csa.A_ind;\r\n                var A_val = csa.A_val;\r\n                var beg, end, ptr;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    u[A_ind[ptr]] -= t * A_val[ptr];\r\n            }\r\n        }\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, u);\r\n        /* update gamma[i] for other basic variables (except xB[p] and\r\n         free variables) */\r\n        pivot = tcol_vec[p];\r\n        if (GLP_DEBUG){xassert(pivot != 0.0)}\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {   i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i];\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* skip xB[p] */\r\n            if (i == p) continue;\r\n            /* skip free basic variable */\r\n            if (type[head[i]] == GLP_FR)\r\n            {\r\n                if (GLP_DEBUG){xassert(gamma[i] == 1.0)}\r\n                continue;\r\n            }\r\n            /* compute gamma[i] for the adjacent basis */\r\n            t = tcol_vec[i] / pivot;\r\n            t1 = gamma[i] + t * t * gamma_p + 2.0 * t * u[i];\r\n            t2 = (refsp[k] ? 1.0 : 0.0) + eta_p * t * t;\r\n            gamma[i] = (t1 >= t2 ? t1 : t2);\r\n            /* (though gamma[i] can be exact zero, because the reference\r\n             space does not include non-basic fixed variables) */\r\n            if (gamma[i] < DBL_EPSILON) gamma[i] = DBL_EPSILON;\r\n        }\r\n        /* compute gamma[p] for the adjacent basis */\r\n        if (type[head[m+q]] == GLP_FR)\r\n            gamma[p] = 1.0;\r\n        else\r\n        {  gamma[p] = gamma_p / (pivot * pivot);\r\n            if (gamma[p] < DBL_EPSILON) gamma[p] = DBL_EPSILON;\r\n        }\r\n        /* if xB[p], which becomes xN[q] in the adjacent basis, is fixed\r\n         and belongs to the reference space, remove it from there, and\r\n         change all gamma's appropriately */\r\n        k = head[p];\r\n        if (type[k] == GLP_FX && refsp[k])\r\n        {  refsp[k] = 0;\r\n            for (pos = 1; pos <= tcol_nnz; pos++)\r\n            {  i = tcol_ind[pos];\r\n                if (i == p)\r\n                {  if (type[head[m+q]] == GLP_FR) continue;\r\n                    t = 1.0 / tcol_vec[p];\r\n                }\r\n                else\r\n                {  if (type[head[i]] == GLP_FR) continue;\r\n                    t = tcol_vec[i] / tcol_vec[p];\r\n                }\r\n                gamma[i] -= t * t;\r\n                if (gamma[i] < DBL_EPSILON) gamma[i] = DBL_EPSILON;\r\n            }\r\n        }\r\n    }\r\n\r\n    function err_in_bbar(csa){\r\n        var m = csa.m;\r\n        var bbar = csa.bbar;\r\n        var i;\r\n        var e, emax;\r\n        var beta = new Float64Array(1+m);\r\n        eval_beta(csa, beta);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  e = Math.abs(beta[i] - bbar[i]) / (1.0 + Math.abs(beta[i]));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    /***********************************************************************\r\n     *  err_in_cbar - compute maximal relative error in dual solution\r\n     *\r\n     *  This routine returns maximal relative error:\r\n     *\r\n     *     max |cost[j] - cbar[j]| / (1 + |cost[j]|),\r\n     *\r\n     *  where cost and cbar are, respectively, directly computed and the\r\n     *  current (updated) reduced costs of non-basic non-fixed variables.\r\n     *\r\n     *  NOTE: The routine is intended only for debugginig purposes. */\r\n\r\n    function err_in_cbar(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        var e, emax, cost;\r\n        var pi = new Float64Array(1+m);\r\n        eval_pi(csa, pi);\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS) continue;\r\n            cost = eval_cost(csa, pi, j);\r\n            e = Math.abs(cost - cbar[j]) / (1.0 + Math.abs(cost));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_gamma(csa){\r\n        var m = csa.m;\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var gamma = csa.gamma;\r\n        var exact = csa.work4;\r\n        var i;\r\n        var e, emax, temp;\r\n        eval_gamma(csa, exact);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (type[head[i]] == GLP_FR)\r\n        {  xassert(gamma[i] == 1.0);\r\n            xassert(exact[i] == 1.0);\r\n            continue;\r\n        }\r\n            temp = exact[i];\r\n            e = Math.abs(temp - gamma[i]) / (1.0 + Math.abs(temp));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function change_basis(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var p = csa.p;\r\n        var delta = csa.delta;\r\n        var q = csa.q;\r\n        var k;\r\n        /* xB[p] leaves the basis, xN[q] enters the basis */\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* xB[p] <. xN[q] */\r\n        k = head[p]; head[p] = head[m+q]; head[m+q] = k;\r\n        bind[head[p]] = p; bind[head[m+q]] = m + q;\r\n        if (type[k] == GLP_FX)\r\n            stat[q] = GLP_NS;\r\n        else if (delta > 0.0)\r\n        {\r\n            if (GLP_DEBUG){\r\n                xassert(type[k] == GLP_LO || type[k] == GLP_DB)\r\n            }\r\n\r\n            stat[q] = GLP_NL;\r\n        }\r\n        else /* delta < 0.0 */\r\n        {\r\n            if (GLP_DEBUG)\r\n                xassert(type[k] == GLP_UP || type[k] == GLP_DB);\r\n            stat[q] = GLP_NU;\r\n        }\r\n    }\r\n\r\n    function check_feas(csa, tol_dj){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (cbar[j] < - tol_dj)\r\n                if (orig_type[k] == GLP_LO || orig_type[k] == GLP_FR)\r\n                    return 1;\r\n            if (cbar[j] > + tol_dj)\r\n                if (orig_type[k] == GLP_UP || orig_type[k] == GLP_FR)\r\n                    return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function set_aux_bnds(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        for (k = 1; k <= m+n; k++)\r\n        {  switch (orig_type[k])\r\n        {  case GLP_FR:\r\n                /* to force free variables to enter the basis */\r\n                type[k] = GLP_DB; lb[k] = -1e3; ub[k] = +1e3;\r\n                break;\r\n            case GLP_LO:\r\n                type[k] = GLP_DB; lb[k] = 0.0; ub[k] = +1.0;\r\n                break;\r\n            case GLP_UP:\r\n                type[k] = GLP_DB; lb[k] = -1.0; ub[k] = 0.0;\r\n                break;\r\n            case GLP_DB:\r\n            case GLP_FX:\r\n                type[k] = GLP_FX; lb[k] = ub[k] = 0.0;\r\n                break;\r\n            default:\r\n                xassert(orig_type != orig_type);\r\n        }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {   k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (type[k] == GLP_FX)\r\n                stat[j] = GLP_NS;\r\n            else if (cbar[j] >= 0.0)\r\n                stat[j] = GLP_NL;\r\n            else\r\n                stat[j] = GLP_NU;\r\n        }\r\n    }\r\n\r\n    function set_orig_bnds(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var orig_type = csa.orig_type;\r\n        var orig_lb = csa.orig_lb;\r\n        var orig_ub = csa.orig_ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        xcopyArr(type, 1, orig_type, 1, m+n);\r\n        xcopyArr(lb, 1, orig_lb, 1, m+n);\r\n        xcopyArr(ub, 1, orig_ub, 1, m+n);\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            switch (type[k])\r\n            {  case GLP_FR:\r\n                stat[j] = GLP_NF;\r\n                break;\r\n                case GLP_LO:\r\n                    stat[j] = GLP_NL;\r\n                    break;\r\n                case GLP_UP:\r\n                    stat[j] = GLP_NU;\r\n                    break;\r\n                case GLP_DB:\r\n                    if (cbar[j] >= +DBL_EPSILON)\r\n                        stat[j] = GLP_NL;\r\n                    else if (cbar[j] <= -DBL_EPSILON)\r\n                        stat[j] = GLP_NU;\r\n                    else if (Math.abs(lb[k]) <= Math.abs(ub[k]))\r\n                        stat[j] = GLP_NL;\r\n                    else\r\n                        stat[j] = GLP_NU;\r\n                    break;\r\n                case GLP_FX:\r\n                    stat[j] = GLP_NS;\r\n                    break;\r\n                default:\r\n                    xassert(type != type);\r\n            }\r\n        }\r\n    }\r\n\r\n    function check_stab(csa, tol_dj){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (cbar[j] < - tol_dj)\r\n            if (stat[j] == GLP_NL || stat[j] == GLP_NF) return 1;\r\n            if (cbar[j] > + tol_dj)\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF) return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function eval_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var obj = csa.obj;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, j, k;\r\n        var sum;\r\n        sum = obj[0];\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k > m)\r\n                sum += obj[k-m] * bbar[i];\r\n        }\r\n        /* walk through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k > m)\r\n                sum += obj[k-m] * get_xN(csa, j);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function display(csa, parm, spec){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var coef = csa.coef;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, cnt;\r\n        var sum;\r\n        if (parm.msg_lev < GLP_MSG_ON) return;\r\n        if (parm.out_dly > 0 &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)\r\n            return;\r\n        if (csa.it_cnt == csa.it_dpy) return;\r\n        if (!spec && csa.it_cnt % parm.out_frq != 0) return;\r\n        /* compute the sum of dual infeasibilities */\r\n        sum = 0.0;\r\n        if (phase == 1)\r\n        {  for (i = 1; i <= m; i++)\r\n            sum -= coef[head[i]] * bbar[i];\r\n            for (j = 1; j <= n; j++)\r\n                sum -= coef[head[m+j]] * get_xN(csa, j);\r\n        }\r\n        else\r\n        {  for (j = 1; j <= n; j++)\r\n        {  if (cbar[j] < 0.0)\r\n            if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                sum -= cbar[j];\r\n            if (cbar[j] > 0.0)\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                    sum += cbar[j];\r\n        }\r\n        }\r\n        /* determine the number of basic fixed variables */\r\n        cnt = 0;\r\n        for (i = 1; i <= m; i++)\r\n            if (orig_type[head[i]] == GLP_FX) cnt++;\r\n        if (csa.phase == 1)\r\n            xprintf(\" \" + csa.it_cnt + \":  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        else\r\n            xprintf(\"|\" + csa.it_cnt + \": obj = \" + eval_obj(csa) + \"  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        csa.it_dpy = csa.it_cnt;\r\n    }\r\n\r\n    function store_sol(csa, lp, p_stat, d_stat, ray){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var zeta = csa.zeta;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, k;\r\n        var col, row;\r\n        if (GLP_DEBUG){\r\n            xassert(lp.m == m);\r\n            xassert(lp.n == n);\r\n            /* basis factorization */\r\n            xassert(!lp.valid && lp.bfd == null);\r\n            xassert(csa.valid && csa.bfd != null);\r\n        }\r\n        lp.valid = 1; csa.valid = 0;\r\n        lp.bfd = csa.bfd; csa.bfd = null;\r\n        xcopyArr(lp.head, 1, head, 1, m);\r\n        /* basic solution status */\r\n        lp.pbs_stat = p_stat;\r\n        lp.dbs_stat = d_stat;\r\n        /* objective function value */\r\n        lp.obj_val = eval_obj(csa);\r\n        /* simplex iteration count */\r\n        lp.it_cnt = csa.it_cnt;\r\n        /* unbounded ray */\r\n        lp.some = ray;\r\n        /* basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = GLP_BS;\r\n                row.bind = i;\r\n                row.prim = bbar[i] / row.rii;\r\n                row.dual = 0.0;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = GLP_BS;\r\n                col.bind = i;\r\n                col.prim = bbar[i] * col.sjj;\r\n                col.dual = 0.0;\r\n            }\r\n        }\r\n        /* non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = stat[j];\r\n                row.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    row.prim = row.lb; break;\r\n                    case GLP_NU:\r\n                        row.prim = row.ub; break;\r\n                    case GLP_NF:\r\n                        row.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        row.prim = row.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                row.dual = (cbar[j] * row.rii) / zeta;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = stat[j];\r\n                col.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    col.prim = col.lb; break;\r\n                    case GLP_NU:\r\n                        col.prim = col.ub; break;\r\n                    case GLP_NF:\r\n                        col.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        col.prim = col.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                col.dual = (cbar[j] / col.sjj) / zeta;\r\n            }\r\n        }\r\n    }\r\n\r\n    var csa;\r\n    var binv_st = 2;\r\n    /* status of basis matrix factorization:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var bbar_st = 0;\r\n    /* status of primal values of basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var cbar_st = 0;\r\n    /* status of reduced costs of non-basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var rigorous = 0;\r\n    /* rigorous mode flag; this flag is used to enable iterative\r\n     refinement on computing pivot rows and columns of the simplex\r\n     table */\r\n    var check = 0;\r\n    var p_stat, d_stat, ret;\r\n    /* allocate and initialize the common storage area */\r\n    csa = alloc_csa(lp);\r\n    init_csa(csa, lp);\r\n    if (parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"Objective scale factor = \" + csa.zeta + \"\");\r\n\r\n    while (true){\r\n        /* main loop starts here */\r\n        /* compute factorization of the basis matrix */\r\n        if (binv_st == 0)\r\n        {  ret = invert_B(csa);\r\n            if (ret != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            {  xprintf(\"Error: unable to factorize the basis matrix (\" + ret + \")\");\r\n                xprintf(\"Sorry, basis recovery procedure not implemented yet\");\r\n            }\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                return ret;\r\n            }\r\n            csa.valid = 1;\r\n            binv_st = 1; /* just computed */\r\n            /* invalidate basic solution components */\r\n            bbar_st = cbar_st = 0;\r\n        }\r\n        /* compute reduced costs of non-basic variables */\r\n        if (cbar_st == 0)\r\n        {  eval_cbar(csa);\r\n            cbar_st = 1; /* just computed */\r\n            /* determine the search phase, if not determined yet */\r\n            if (csa.phase == 0)\r\n            {  if (check_feas(csa, 0.90 * parm.tol_dj) != 0)\r\n            {  /* current basic solution is dual infeasible */\r\n                /* start searching for dual feasible solution */\r\n                csa.phase = 1;\r\n                set_aux_bnds(csa);\r\n            }\r\n            else\r\n            {  /* current basic solution is dual feasible */\r\n                /* start searching for optimal solution */\r\n                csa.phase = 2;\r\n                set_orig_bnds(csa);\r\n            }\r\n                xassert(check_stab(csa, parm.tol_dj) == 0);\r\n                /* some non-basic double-bounded variables might become\r\n                 fixed (on phase I) or vice versa (on phase II) */\r\n                csa.refct = 0;\r\n                /* bounds of non-basic variables have been changed, so\r\n                 invalidate primal values */\r\n                bbar_st = 0;\r\n            }\r\n            /* make sure that the current basic solution remains dual\r\n             feasible */\r\n            if (check_stab(csa, parm.tol_dj) != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n                xprintf(\"Warning: numerical instability (dual simplex, phase \" + (csa.phase == 1 ? \"I\" : \"II\") + \")\");\r\n                if (parm.meth == GLP_DUALP)\r\n                {  store_sol(csa, lp, GLP_UNDEF, GLP_UNDEF, 0);\r\n                    ret = GLP_EFAIL;\r\n                    return ret;\r\n                }\r\n                /* restart the search */\r\n                csa.phase = 0;\r\n                binv_st = 0;\r\n                rigorous = 5;\r\n                continue;\r\n            }\r\n        }\r\n        xassert(csa.phase == 1 || csa.phase == 2);\r\n        /* on phase I we do not need to wait until the current basic\r\n         solution becomes primal feasible; it is sufficient to make\r\n         sure that all reduced costs have correct signs */\r\n        if (csa.phase == 1 && check_feas(csa, parm.tol_dj) == 0)\r\n        {  /* the current basis is dual feasible; switch to phase II */\r\n            display(csa, parm, 1);\r\n            csa.phase = 2;\r\n            if (cbar_st != 1)\r\n            {  eval_cbar(csa);\r\n                cbar_st = 1;\r\n            }\r\n            set_orig_bnds(csa);\r\n            csa.refct = 0;\r\n            bbar_st = 0;\r\n        }\r\n        /* compute primal values of basic variables */\r\n        if (bbar_st == 0)\r\n        {  eval_bbar(csa);\r\n            if (csa.phase == 2)\r\n                csa.bbar[0] = eval_obj(csa);\r\n            bbar_st = 1; /* just computed */\r\n        }\r\n        /* redefine the reference space, if required */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct == 0) reset_refsp(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* at this point the basis factorization and all basic solution\r\n         components are valid */\r\n        xassert(binv_st && bbar_st && cbar_st);\r\n        /* check accuracy of current basic solution components (only for\r\n         debugging) */\r\n        if (check)\r\n        {  var e_bbar = err_in_bbar(csa);\r\n            var e_cbar = err_in_cbar(csa);\r\n            var e_gamma =\r\n                (parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0.0);\r\n            xprintf(\"e_bbar = \" + e_bbar + \"; e_cbar = \" + e_cbar + \"; e_gamma = \" + e_gamma + \"\");\r\n            xassert(e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3);\r\n        }\r\n        /* if the objective has to be maximized, check if it has reached\r\n         its lower limit */\r\n        if (csa.phase == 2 && csa.zeta < 0.0 &&\r\n            parm.obj_ll > -DBL_MAX && csa.bbar[0] <= parm.obj_ll)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OBJECTIVE LOWER LIMIT REACHED; SEARCH TERMINATED\"\r\n                );\r\n            store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);\r\n            ret = GLP_EOBJLL;\r\n            return ret;\r\n        }\r\n        /* if the objective has to be minimized, check if it has reached\r\n         its upper limit */\r\n        if (csa.phase == 2 && csa.zeta > 0.0 &&\r\n            parm.obj_ul < +DBL_MAX && csa.bbar[0] >= parm.obj_ul)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OBJECTIVE UPPER LIMIT REACHED; SEARCH TERMINATED\"\r\n                );\r\n            store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);\r\n            ret = GLP_EOBJUL;\r\n            return ret;\r\n        }\r\n        /* check if the iteration limit has been exhausted */\r\n        if (parm.it_lim < INT_MAX &&\r\n            csa.it_cnt - csa.it_beg >= parm.it_lim)\r\n        {  if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1)\r\n        {  if (csa.phase == 2 && bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                d_stat = GLP_INFEAS;\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                break;\r\n                case 2:\r\n                    d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, GLP_INFEAS, d_stat, 0);\r\n            ret = GLP_EITLIM;\r\n            return ret;\r\n        }\r\n        /* check if the time limit has been exhausted */\r\n        if (parm.tm_lim < INT_MAX &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim)\r\n        {  if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1)\r\n        {  if (csa.phase == 2 && bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                d_stat = GLP_INFEAS;\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                break;\r\n                case 2:\r\n                    d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, GLP_INFEAS, d_stat, 0);\r\n            ret = GLP_ETMLIM;\r\n            return ret;\r\n        }\r\n        /* display the search progress */\r\n        display(csa, parm, 0);\r\n        /* choose basic variable xB[p] */\r\n        chuzr(csa, parm.tol_bnd);\r\n        if (csa.p == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                p_stat = GLP_INFEAS; d_stat = GLP_NOFEAS;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n                    p_stat = d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n        /* compute pivot row of the simplex table */\r\n        {  var rho = csa.work4;\r\n            eval_rho(csa, rho);\r\n            if (rigorous) refine_rho(csa, rho);\r\n            eval_trow(csa, rho);\r\n            sort_trow(csa, parm.tol_bnd);\r\n        }\r\n        /* choose non-basic variable xN[q] */\r\n        switch (parm.r_test)\r\n        {  case GLP_RT_STD:\r\n            chuzc(csa, 0.0);\r\n            break;\r\n            case GLP_RT_HAR:\r\n                chuzc(csa, 0.30 * parm.tol_dj);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        if (csa.q == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1 || !rigorous)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            rigorous = 1;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Error: unable to choose basic variable on phase I\");\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n                    store_sol(csa, lp, GLP_NOFEAS, GLP_FEAS,\r\n                        csa.head[csa.p]);\r\n                    ret = 0;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            return ret;\r\n        }\r\n        /* check if the pivot element is acceptable */\r\n        {  var piv = csa.trow_vec[csa.q];\r\n            var eps = 1e-5 * (1.0 + 0.01 * csa.trow_max);\r\n            if (Math.abs(piv) < eps)\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv = \" + piv + \"; eps = \" + eps + \"\");\r\n                if (!rigorous)\r\n                {  rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        /* now xN[q] and xB[p] have been chosen anyhow */\r\n        /* compute pivot column of the simplex table */\r\n        eval_tcol(csa);\r\n        if (rigorous) refine_tcol(csa);\r\n        /* accuracy check based on the pivot element */\r\n        {  var piv1 = csa.tcol_vec[csa.p]; /* more accurate */\r\n            var piv2 = csa.trow_vec[csa.q]; /* less accurate */\r\n            xassert(piv1 != 0.0);\r\n            if (Math.abs(piv1 - piv2) > 1e-8 * (1.0 + Math.abs(piv1)) ||\r\n                !(piv1 > 0.0 && piv2 > 0.0 || piv1 < 0.0 && piv2 < 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv1 = \" + piv1 + \"; piv2 = \" + piv2 + \"\");\r\n                if (binv_st != 1 || !rigorous)\r\n                {  if (binv_st != 1) binv_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n                /* (not a good idea; should be revised later) */\r\n                if (csa.tcol_vec[csa.p] == 0.0)\r\n                {  csa.tcol_nnz++;\r\n                    xassert(csa.tcol_nnz <= csa.m);\r\n                    csa.tcol_ind[csa.tcol_nnz] = csa.p;\r\n                }\r\n                csa.tcol_vec[csa.p] = piv2;\r\n            }\r\n        }\r\n        /* update primal values of basic variables */\r\n        update_bbar(csa);\r\n        if (csa.phase == 2)\r\n            csa.bbar[0] += (csa.cbar[csa.q] / csa.zeta) *\r\n                (csa.delta / csa.tcol_vec[csa.p]);\r\n        bbar_st = 2; /* updated */\r\n        /* update reduced costs of non-basic variables */\r\n        update_cbar(csa);\r\n        cbar_st = 2; /* updated */\r\n        /* update steepest edge coefficients */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct > 0) update_gamma(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* update factorization of the basis matrix */\r\n        ret = update_B(csa, csa.p, csa.head[csa.m+csa.q]);\r\n        if (ret == 0)\r\n            binv_st = 2; /* updated */\r\n        else\r\n        {  csa.valid = 0;\r\n            binv_st = 0; /* invalid */\r\n        }\r\n        /* change the basis header */\r\n        change_basis(csa);\r\n        /* iteration complete */\r\n        csa.it_cnt++;\r\n        if (rigorous > 0) rigorous--;\r\n    }\r\n}\r\n\r\n}(typeof exports === 'object' && exports || this));\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(6);\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 63277e3f81178526c235.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/escher-fba/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 63277e3f81178526c235","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 0\n// module chunks = 0","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/@just-boris/preact-scripts/~/babel-runtime/regenerator/index.js\n// module id = 1\n// module chunks = 0","import {\r\n  glp_create_prob, glp_set_prob_name, glp_set_obj_dir, glp_add_rows,\r\n  glp_add_cols, glp_set_row_name, glp_set_row_bnds, glp_set_col_name,\r\n  glp_set_col_bnds, glp_set_obj_coef, glp_load_matrix, glp_simplex,\r\n  glp_get_obj_val, glp_get_num_cols, glp_get_col_name, glp_get_col_prim,\r\n  SMCP, GLP_MAX, GLP_FX, GLP_DB, GLP_ON\r\n} from 'glpk.js'\r\n\r\nexport class Model {\r\n  // constructor (data) {\r\n  //   this.reactions = data.reactions.map(x => ({...x}))\r\n  //   this.metabolites = data.metabolites.map(x => ({...x}))\r\n  //   this.genes = data.genes.map(x => ({...x}))\r\n  //   this.id = data.id\r\n  //   this.notes = data.notes // TODO is this an object? if so clone\r\n  //   this.description = data.description\r\n  // }\r\n\r\n  buildGlpkProblem () {\r\n    /** Build a GLPK LP for the model */\r\n\r\n    const nRows = this.metabolites.length\r\n    const nCols = this.reactions.length\r\n    const ia = []\r\n    const ja = []\r\n    const ar = []\r\n    const metLookup = {}\r\n\r\n    // initialize LP objective\r\n    var lp = glp_create_prob()\r\n    glp_set_prob_name(lp, 'knockout FBA')\r\n    // maximize\r\n    glp_set_obj_dir(lp, GLP_MAX)\r\n    // set up rows and columns\r\n    glp_add_rows(lp, nRows)\r\n    glp_add_cols(lp, nCols)\r\n\r\n    // metabolites\r\n    this.metabolites.forEach(function (metabolite, i) {\r\n      var rowInd = i + 1\r\n      glp_set_row_name(lp, rowInd, metabolite.id)\r\n      glp_set_row_bnds(lp, rowInd, GLP_FX, 0.0, 0.0)\r\n      // remember the indices of the metabolites\r\n      metLookup[metabolite.id] = rowInd\r\n    })\r\n\r\n    // reactions\r\n    var matInd = 1\r\n    this.reactions.forEach(function (reaction, i) {\r\n      var colInd = i + 1\r\n\r\n      glp_set_col_name(lp, colInd, reaction.id)\r\n      if (reaction.lower_bound === reaction.upper_bound) {\r\n        glp_set_col_bnds(lp, colInd, GLP_FX, reaction.lower_bound, reaction.upper_bound)\r\n      } else {\r\n        glp_set_col_bnds(lp, colInd, GLP_DB, reaction.lower_bound, reaction.upper_bound)\r\n      }\r\n\r\n      // object_coefficient is optional for reaction in COBRA JSON\r\n      if ('objective_coefficient' in reaction) {\r\n        glp_set_obj_coef(lp, colInd, reaction.objective_coefficient)\r\n      }\r\n\r\n      // S matrix values\r\n      for (var met_id in reaction.metabolites) {\r\n        ia[matInd] = metLookup[met_id]\r\n        ja[matInd] = colInd\r\n        ar[matInd] = reaction.metabolites[met_id]\r\n        matInd++\r\n      }\r\n    })\r\n    // Load the S matrix\r\n    glp_load_matrix(lp, ia.length - 1, ia, ja, ar)\r\n\r\n    return lp\r\n  }\r\n\r\n  optimize () {\r\n    const problem = this.buildGlpkProblem()\r\n    var smcp = new SMCP({ presolve: GLP_ON })\r\n    const returnCode = glp_simplex(problem, smcp)\r\n    var f = null\r\n    var x = null\r\n    if (returnCode === 0) {\r\n      // get the objective\r\n      f = glp_get_obj_val(problem)\r\n      // get the primal\r\n      x = {}\r\n      for (var i = 1; i <= glp_get_num_cols(problem); i++) {\r\n        x[glp_get_col_name(problem, i)] = glp_get_col_prim(problem, i)\r\n      }\r\n    } else {\r\n      console.log('Invalid Solution')\r\n    }\r\n\r\n    return new Solution(f, x)\r\n  }\r\n}\r\n\r\nexport class Solution {\r\n  constructor (objectiveValue, fluxes) {\r\n    this.objectiveValue = objectiveValue\r\n    this.fluxes = fluxes\r\n  }\r\n}\r\n\r\nexport function modelFromWorkerData (data) {\r\n  const model = new Model()\r\n  model.reactions = data.reactions\r\n  model.metabolites = data.metabolites\r\n  model.genes = data.genes\r\n  model.id = data.id\r\n  model.notes = data.notes\r\n  model.description = data.description\r\n  return model\r\n  //  Change when model structure changes significantly from original model JSON. Outputs JSON model data.\r\n}\r\n\r\nexport function solutionFromWorkerData ({ objectiveValue, fluxes }) {\r\n  return new Solution(objectiveValue, fluxes)\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} data\r\n */\r\nexport function modelFromJsonData (data) {\r\n  let model = new Model()\r\n  if (data !== null) {\r\n    model.reactions = data.reactions.map(x => ({...x}))\r\n    model.metabolites = data.metabolites.map(x => ({...x}))\r\n    model.genes = data.genes.map(x => ({...x}))\r\n    model.id = data.id\r\n    model.notes = data.notes // TODO is this an object? if so clone\r\n    model.description = data.description\r\n  } else {\r\n    model = null\r\n  }\r\n  return model\r\n}\r\n\r\nexport function modelFromJson (jsonString) {\r\n  return modelFromJsonData(JSON.parse(jsonString))\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/COBRA.js","/* eslint-disable no-undef */\r\nimport * as COBRA from './COBRA.js'\r\nonmessage = async (message) => {\r\n  const model = COBRA.modelFromWorkerData(message.data)\r\n  const solution = await (model.optimize())\r\n  postMessage(solution)\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/COBRA.worker.js","/*! glpk.js - v4.49.0\r\n* https://github.com/hgourvest/glpk.js\r\n* Copyright (c) 2013 Henri Gourvest; Licensed GPLv2 */\r\n(function(exports) {\r\nfunction xassert(test){\r\n    if (!test){\r\n        throw new Error('assert');\r\n    }\r\n}\r\n\r\n\r\n\r\nvar\r\n    /** @const */GLP_DEBUG = false,\r\n    /** @const */DBL_MAX = Number.MAX_VALUE,\r\n    /** @const */DBL_MIN = Number.MIN_VALUE,\r\n    /** @const */DBL_DIG = 16,\r\n    /** @const */INT_MAX = 0x7FFFFFFF,\r\n    /** @const */DBL_EPSILON = 0.22204460492503131E-15,\r\n    /** @const */CHAR_BIT = 1;\r\n\r\nvar\r\n/** CAUTION: DO NOT CHANGE THE LIMITS BELOW */\r\n/** @const */  M_MAX = 100000000, /* = 100*10^6 */\r\n/* maximal number of rows in the problem object */\r\n\r\n/** @const */    N_MAX = 100000000, /* = 100*10^6 */\r\n/* maximal number of columns in the problem object */\r\n\r\n/** @const */    NNZ_MAX = 500000000; /* = 500*10^6 */\r\n/* maximal number of constraint coefficients in the problem object */\r\n\r\n/** @const */\r\nvar XEOF = -1;\r\n\r\nfunction xerror(message){\r\n    throw new Error(message);\r\n}\r\n\r\nvar xprintf = function(data){\r\n\r\n};\r\n\r\nexports[\"glp_get_print_func\"] = function(){return xprintf};\r\nexports[\"glp_set_print_func\"] = function(value){xprintf = value};\r\n\r\nfunction xcopyObj(dest, src){\r\n    for (var prop in src){dest[prop] = src[prop];}\r\n}\r\n\r\nfunction xcopyArr(dest, destFrom, src, srcFrom, count){\r\n    for (; count > 0; destFrom++, srcFrom++, count--){dest[destFrom] = src[srcFrom];}\r\n}\r\n\r\nfunction xfillArr(dest, destFrom, value, count){\r\n    for (; count > 0; destFrom++, count--){dest[destFrom] = value;}\r\n}\r\n\r\nfunction xfillObjArr(dest, destFrom, count){\r\n    for (; count > 0; destFrom++, count--){dest[destFrom] = {}}\r\n}\r\n\r\nfunction xtime(){\r\n    var d = new Date();\r\n    return d.getTime();\r\n}\r\n\r\nfunction xdifftime(to, from){\r\n    return (to - from) / 1000;\r\n}\r\n\r\nfunction xqsort(base, idx, num, compar){\r\n    var tmp = new Array(num);\r\n    xcopyArr(tmp, 0, base, idx, num);\r\n    tmp.sort(compar);\r\n    xcopyArr(base, idx, tmp, 0, num);\r\n}\r\n\r\nvar\r\n    global_env = {};\r\n\r\nfunction get_env_ptr(){\r\n    return global_env;\r\n}\r\n\r\nvar glp_version = exports[\"glp_version\"] = function(){\r\n    return GLP_MAJOR_VERSION + \".\" + GLP_MINOR_VERSION;\r\n};\r\n\r\nfunction isspace(c){\r\n    return (\" \\t\\n\\v\\f\\r\".indexOf(c) >= 0)\r\n}\r\n\r\nfunction iscntrl(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return ((code >= 0x00 && code <= 0x1f) || code == 0x7f)\r\n}\r\n\r\nfunction isalpha(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x41 && code <= 0x5A)|| (code >= 0x61 && code <= 0x7A)\r\n}\r\n\r\nfunction isalnum(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x41 && code <= 0x5A)|| (code >= 0x61 && code <= 0x7A) || (code >= 0x30 && code <= 0x39)\r\n}\r\n\r\nfunction isdigit(c){\r\n    var code = (typeof c == 'string')?c.charCodeAt(0):-1;\r\n    return (code >= 0x30 && code <= 0x39)\r\n}\r\n\r\nfunction strchr(str, c){\r\n    return str.indexOf(c)\r\n}\r\n\r\nfunction tolower(c){\r\n    return c.toLowerCase();\r\n}\r\n\r\n\r\nfunction sprintf () {\r\n    // http://kevin.vanzonneveld.net\r\n    // +   original by: Ash Searle (http://hexmen.com/blog/)\r\n    // + namespaced by: Michael White (http://getsprink.com)\r\n    // +    tweaked by: Jack\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +      input by: Paulo Freitas\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +      input by: Brett Zamir (http://brett-zamir.me)\r\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\r\n    // +   improved by: Dj\r\n    // +   improved by: Allidylls\r\n    // *     example 1: sprintf(\"%01.2f\", 123.1);\r\n    // *     returns 1: 123.10\r\n    // *     example 2: sprintf(\"[%10s]\", 'monkey');\r\n    // *     returns 2: '[    monkey]'\r\n    // *     example 3: sprintf(\"[%'#10s]\", 'monkey');\r\n    // *     returns 3: '[####monkey]'\r\n    // *     example 4: sprintf(\"%d\", 123456789012345);\r\n    // *     returns 4: '123456789012345'\r\n    var regex = /%%|%(\\d+\\$)?([-+\\'#0 ]*)(\\*\\d+\\$|\\*|\\d+)?(\\.(\\*\\d+\\$|\\*|\\d+))?([scboxXuideEfFgG])/g;\r\n    var a = arguments,\r\n        i = 0,\r\n        format = a[i++];\r\n\r\n    // pad()\r\n    var pad = function (str, len, chr, leftJustify) {\r\n        if (!chr) {\r\n            chr = ' ';\r\n        }\r\n        var padding = (str.length >= len) ? '' : Array(1 + len - str.length >>> 0).join(chr);\r\n        return leftJustify ? str + padding : padding + str;\r\n    };\r\n\r\n    // justify()\r\n    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {\r\n        var diff = minWidth - value.length;\r\n        if (diff > 0) {\r\n            if (leftJustify || !zeroPad) {\r\n                value = pad(value, minWidth, customPadChar, leftJustify);\r\n            } else {\r\n                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n\r\n    // formatBaseX()\r\n    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {\r\n        // Note: casts negative numbers to positive ones\r\n        var number = value >>> 0;\r\n        prefix = prefix && number && {\r\n            '2': '0b',\r\n            '8': '0',\r\n            '16': '0x'\r\n        }[base] || '';\r\n        value = prefix + pad(number.toString(base), precision || 0, '0', false);\r\n        return justify(value, prefix, leftJustify, minWidth, zeroPad);\r\n    };\r\n\r\n    // formatString()\r\n    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {\r\n        if (precision != null) {\r\n            value = value.slice(0, precision);\r\n        }\r\n        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);\r\n    };\r\n\r\n    // doFormat()\r\n    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {\r\n        var number;\r\n        var prefix;\r\n        var method;\r\n        var textTransform;\r\n        var value;\r\n\r\n        if (substring == '%%') {\r\n            return '%';\r\n        }\r\n\r\n        // parse flags\r\n        var leftJustify = false,\r\n            positivePrefix = '',\r\n            zeroPad = false,\r\n            prefixBaseX = false,\r\n            customPadChar = ' ';\r\n        var flagsl = flags.length;\r\n        for (var j = 0; flags && j < flagsl; j++) {\r\n            switch (flags.charAt(j)) {\r\n                case ' ':\r\n                    positivePrefix = ' ';\r\n                    break;\r\n                case '+':\r\n                    positivePrefix = '+';\r\n                    break;\r\n                case '-':\r\n                    leftJustify = true;\r\n                    break;\r\n                case \"'\":\r\n                    customPadChar = flags.charAt(j + 1);\r\n                    break;\r\n                case '0':\r\n                    zeroPad = true;\r\n                    break;\r\n                case '#':\r\n                    prefixBaseX = true;\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // parameters may be null, undefined, empty-string or real valued\r\n        // we want to ignore null, undefined and empty-string values\r\n        if (!minWidth) {\r\n            minWidth = 0;\r\n        } else if (minWidth == '*') {\r\n            minWidth = +a[i++];\r\n        } else if (minWidth.charAt(0) == '*') {\r\n            minWidth = +a[minWidth.slice(1, -1)];\r\n        } else {\r\n            minWidth = +minWidth;\r\n        }\r\n\r\n        // Note: undocumented perl feature:\r\n        if (minWidth < 0) {\r\n            minWidth = -minWidth;\r\n            leftJustify = true;\r\n        }\r\n\r\n        if (!isFinite(minWidth)) {\r\n            throw new Error('sprintf: (minimum-)width must be finite');\r\n        }\r\n\r\n        if (!precision) {\r\n            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type == 'd') ? 0 : undefined;\r\n        } else if (precision == '*') {\r\n            precision = +a[i++];\r\n        } else if (precision.charAt(0) == '*') {\r\n            precision = +a[precision.slice(1, -1)];\r\n        } else {\r\n            precision = +precision;\r\n        }\r\n\r\n        // grab value using valueIndex if required?\r\n        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];\r\n\r\n        switch (type) {\r\n            case 's':\r\n                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);\r\n            case 'c':\r\n                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);\r\n            case 'b':\r\n                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'o':\r\n                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'x':\r\n                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'X':\r\n                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad).toUpperCase();\r\n            case 'u':\r\n                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);\r\n            case 'i':\r\n            case 'd':\r\n                number = +value || 0;\r\n                number = Math.round(number - number % 1); // Plain Math.round doesn't just truncate\r\n                prefix = number < 0 ? '-' : positivePrefix;\r\n                value = prefix + pad(String(Math.abs(number)), precision, '0', false);\r\n                return justify(value, prefix, leftJustify, minWidth, zeroPad);\r\n            case 'e':\r\n            case 'E':\r\n            case 'f': // Should handle locales (as per setlocale)\r\n            case 'F':\r\n            case 'g':\r\n            case 'G':\r\n                number = +value;\r\n                prefix = number < 0 ? '-' : positivePrefix;\r\n                method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];\r\n                textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];\r\n                value = prefix + Math.abs(number)[method](precision);\r\n                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();\r\n            default:\r\n                return substring;\r\n        }\r\n    };\r\n\r\n    return format.replace(regex, doFormat);\r\n}\r\n\r\n\r\n/* glpapi.h */\r\n\r\nvar\r\n    /** @const */ GLP_PROB_MAGIC = 0xD7D9D6C2;\r\n\r\nfunction create_prob(lp){\r\n    lp.magic = GLP_PROB_MAGIC;\r\n    //lp.pool = dmp_create_pool();\r\n    lp.parms = null;\r\n    lp.tree = null;\r\n    /* LP/MIP data */\r\n    lp.name = null;\r\n    lp.obj = null;\r\n    lp.dir = GLP_MIN;\r\n    lp.c0 = 0.0;\r\n    lp.m_max = 100;\r\n    lp.n_max = 200;\r\n    lp.m = lp.n = 0;\r\n    lp.nnz = 0;\r\n    lp.row = new Array(1+lp.m_max);\r\n    lp.col = new Array(1+lp.n_max);\r\n    lp.r_tree = {};\r\n    lp.c_tree = {};\r\n    /* basis factorization */\r\n    lp.valid = 0;\r\n    lp.head = new Int32Array(1+lp.m_max);\r\n    lp.bfcp = null;\r\n    lp.bfd = null;\r\n    /* basic solution (LP) */\r\n    lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n    lp.obj_val = 0.0;\r\n    lp.it_cnt = 0;\r\n    lp.some = 0;\r\n    /* interior-point solution (LP) */\r\n    lp.ipt_stat = GLP_UNDEF;\r\n    lp.ipt_obj = 0.0;\r\n    /* integer solution (MIP) */\r\n    lp.mip_stat = GLP_UNDEF;\r\n    lp.mip_obj = 0.0;\r\n}\r\n\r\nvar glp_create_prob = exports[\"glp_create_prob\"] = function(){\r\n    var lp = {};\r\n    create_prob(lp);\r\n    return lp;\r\n};\r\n\r\nvar glp_set_prob_name = exports[\"glp_set_prob_name\"] = function(lp, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_prob_name: operation not allowed\");\r\n    lp.name = name;\r\n};\r\n\r\nvar glp_set_obj_name = exports[\"glp_set_obj_name\"] = function(lp, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_name: operation not allowed\");\r\n    lp.obj = name;\r\n};\r\n\r\nvar glp_set_obj_dir = exports[\"glp_set_obj_dir\"] = function(lp, dir){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_dir: operation not allowed\");\r\n    if (!(dir == GLP_MIN || dir == GLP_MAX))\r\n        xerror(\"glp_set_obj_dir: dir = \" + dir  + \"; invalid direction flag\");\r\n    lp.dir = dir;\r\n};\r\n\r\nvar glp_add_rows = exports[\"glp_add_rows\"] = function (lp, nrs){\r\n    var tree = lp.tree;\r\n    var row;\r\n    /* determine new number of rows */\r\n    if (nrs < 1)\r\n        xerror(\"glp_add_rows: nrs = \" + nrs + \"; invalid number of rows\");\r\n    if (nrs > M_MAX - lp.m)\r\n        xerror(\"glp_add_rows: nrs = \" + nrs + \"; too many rows\");\r\n    var m_new = lp.m + nrs;\r\n    /* increase the room, if necessary */\r\n    if (lp.m_max < m_new){\r\n        while (lp.m_max < m_new){\r\n            lp.m_max += lp.m_max;\r\n            xassert(lp.m_max > 0);\r\n        }\r\n        lp.row.length = 1+lp.m_max;\r\n\r\n        /* do not forget about the basis header */\r\n        lp.head = new Int32Array(1+lp.m_max);\r\n    }\r\n    /* add new rows to the end of the row list */\r\n    for (var i = lp.m+1; i <= m_new; i++)\r\n    {  /* create row descriptor */\r\n        lp.row[i] = row = {};\r\n        row.i = i;\r\n        row.name = null;\r\n        row.node = null;\r\n        row.level = 0;\r\n        row.origin = 0;\r\n        row.klass = 0;\r\n        if (tree != null)\r\n        {  switch (tree.reason)\r\n        {  case 0:\r\n                break;\r\n            case GLP_IROWGEN:\r\n                xassert(tree.curr != null);\r\n                row.level = tree.curr.level;\r\n                row.origin = GLP_RF_LAZY;\r\n                break;\r\n            case GLP_ICUTGEN:\r\n                xassert(tree.curr != null);\r\n                row.level = tree.curr.level;\r\n                row.origin = GLP_RF_CUT;\r\n                break;\r\n            default:\r\n                xassert(tree != tree);\r\n        }\r\n        }\r\n        row.type = GLP_FR;\r\n        row.lb = row.ub = 0.0;\r\n        row.ptr = null;\r\n        row.rii = 1.0;\r\n        row.stat = GLP_BS;\r\n        row.bind = 0;\r\n        row.prim = row.dual = 0.0;\r\n        row.pval = row.dval = 0.0;\r\n        row.mipx = 0.0;\r\n    }\r\n    /* set new number of rows */\r\n    lp.m = m_new;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n    if (tree != null && tree.reason != 0) tree.reopt = 1;\r\n    /* return the ordinal number of the first row added */\r\n    return m_new - nrs + 1;\r\n};\r\n\r\nvar glp_add_cols = exports[\"glp_add_cols\"] = function(lp, ncs){\r\n    var tree = lp.tree;\r\n    var col;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_add_cols: operation not allowed\");\r\n    /* determine new number of columns */\r\n    if (ncs < 1)\r\n        xerror(\"glp_add_cols: ncs = \" + ncs + \"; invalid number of columns\");\r\n    if (ncs > N_MAX - lp.n)\r\n        xerror(\"glp_add_cols: ncs = \" + ncs + \"; too many columns\");\r\n    var n_new = lp.n + ncs;\r\n    /* increase the room, if necessary */\r\n    if (lp.n_max < n_new)\r\n    {\r\n        while (lp.n_max < n_new)\r\n        {  lp.n_max += lp.n_max;\r\n            xassert(lp.n_max > 0);\r\n        }\r\n        lp.col.length = 1+lp.n_max;\r\n    }\r\n    /* add new columns to the end of the column list */\r\n    for (var j = lp.n+1; j <= n_new; j++)\r\n    {  /* create column descriptor */\r\n        lp.col[j] = col = {};\r\n        col.j = j;\r\n        col.name = null;\r\n        col.node = null;\r\n        col.kind = GLP_CV;\r\n        col.type = GLP_FX;\r\n        col.lb = col.ub = 0.0;\r\n        col.coef = 0.0;\r\n        col.ptr = null;\r\n        col.sjj = 1.0;\r\n        col.stat = GLP_NS;\r\n        col.bind = 0; /* the basis may remain valid */\r\n        col.prim = col.dual = 0.0;\r\n        col.pval = col.dval = 0.0;\r\n        col.mipx = 0.0;\r\n    }\r\n    /* set new number of columns */\r\n    lp.n = n_new;\r\n    /* return the ordinal number of the first column added */\r\n    return n_new - ncs + 1;\r\n};\r\n\r\nvar glp_set_row_name = exports[\"glp_set_row_name\"] = function(lp, i, name)\r\n{\r\n    var tree = lp.tree;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_name: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    if (tree != null && tree.reason != 0){\r\n        xassert(tree.curr != null);\r\n        xassert(row.level == tree.curr.level);\r\n    }\r\n    if (row.name != null){\r\n        delete(lp.r_tree[row.name]);\r\n        row.name = null;\r\n    }\r\n    if (name != null){\r\n        row.name = name;\r\n        lp.r_tree[row.name] = row;\r\n    }\r\n};\r\n\r\nvar glp_set_col_name = exports[\"glp_set_col_name\"] = function(lp, j, name){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_col_name: operation not allowed\");\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_name: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n\r\n    if (col.name != null){\r\n        delete(lp.c_tree[col.name]);\r\n        col.name = null;\r\n    }\r\n\r\n    if (name != null){\r\n        col.name = name;\r\n        lp.c_tree[col.name] = col;\r\n    }\r\n};\r\n\r\nvar glp_set_row_bnds = exports[\"glp_set_row_bnds\"] = function(lp, i, type, lb, ub){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_bnds: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    row.type = type;\r\n    switch (type){\r\n        case GLP_FR:\r\n            row.lb = row.ub = 0.0;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NF;\r\n            break;\r\n        case GLP_LO:\r\n            row.lb = lb; row.ub = 0.0;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NL;\r\n            break;\r\n        case GLP_UP:\r\n            row.lb = 0.0; row.ub = ub;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NU;\r\n            break;\r\n        case GLP_DB:\r\n            row.lb = lb; row.ub = ub;\r\n            if (!(row.stat == GLP_BS ||\r\n                row.stat == GLP_NL || row.stat == GLP_NU))\r\n                row.stat = (Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU);\r\n            break;\r\n        case GLP_FX:\r\n            row.lb = row.ub = lb;\r\n            if (row.stat != GLP_BS) row.stat = GLP_NS;\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_row_bnds: i = \" + i + \"; type = \" + type + \"; invalid row type\");\r\n    }\r\n};\r\n\r\nvar glp_set_col_bnds = exports[\"glp_set_col_bnds\"] = function(lp, j, type, lb, ub){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_bnds: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n    col.type = type;\r\n    switch (type){\r\n        case GLP_FR:\r\n            col.lb = col.ub = 0.0;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NF;\r\n            break;\r\n        case GLP_LO:\r\n            col.lb = lb; col.ub = 0.0;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NL;\r\n            break;\r\n        case GLP_UP:\r\n            col.lb = 0.0; col.ub = ub;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NU;\r\n            break;\r\n        case GLP_DB:\r\n            col.lb = lb; col.ub = ub;\r\n            if (!(col.stat == GLP_BS ||\r\n                col.stat == GLP_NL || col.stat == GLP_NU))\r\n                col.stat = (Math.abs(lb) <= Math.abs(ub) ? GLP_NL : GLP_NU);\r\n            break;\r\n        case GLP_FX:\r\n            col.lb = col.ub = lb;\r\n            if (col.stat != GLP_BS) col.stat = GLP_NS;\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_col_bnds: j = \" + j + \"; type = \" + type + \"; invalid column type\");\r\n    }\r\n};\r\n\r\nvar glp_set_obj_coef = exports[\"glp_set_obj_coef\"] = function(lp, j, coef){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_obj_coef: operation not allowed\");\r\n    if (!(0 <= j && j <= lp.n))\r\n        xerror(\"glp_set_obj_coef: j = \" + j + \"; column number out of range\");\r\n    if (j == 0)\r\n        lp.c0 = coef;\r\n    else\r\n        lp.col[j].coef = coef;\r\n};\r\n\r\nvar glp_set_mat_row = exports[\"glp_set_mat_row\"] = function(lp, i, len, ind, val){\r\n    var tree = lp.tree;\r\n    var col, aij, next, j, k;\r\n    /* obtain pointer to i-th row */\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; row number out of range\");\r\n    var row = lp.row[i];\r\n    if (tree != null && tree.reason != 0){\r\n        xassert(tree.curr != null);\r\n        xassert(row.level == tree.curr.level);\r\n    }\r\n    /* remove all existing elements from i-th row */\r\n    while (row.ptr != null){\r\n        /* take next element in the row */\r\n        aij = row.ptr;\r\n        /* remove the element from the row list */\r\n        row.ptr = aij.r_next;\r\n        /* obtain pointer to corresponding column */\r\n        col = aij.col;\r\n        /* remove the element from the column list */\r\n        if (aij.c_prev == null)\r\n            col.ptr = aij.c_next;\r\n        else\r\n            aij.c_prev.c_next = aij.c_next;\r\n        if (aij.c_next != null)\r\n            aij.c_next.c_prev = aij.c_prev;\r\n        /* return the element to the memory pool */\r\n        lp.nnz--;\r\n        /* if the corresponding column is basic, invalidate the basis\r\n         factorization */\r\n        if (col.stat == GLP_BS) lp.valid = 0;\r\n    }\r\n    /* store new contents of i-th row */\r\n    if (!(0 <= len && len <= lp.n))\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; len = \" + len + \"; invalid row length \");\r\n    if (len > NNZ_MAX - lp.nnz)\r\n        xerror(\"glp_set_mat_row: i = \" + i + \"; len = \" + len + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= len; k++){\r\n        /* take number j of corresponding column */\r\n        j = ind[k];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_set_mat_row: i = \" + i + \"; ind[\" + k + \"] = \" + j + \"; column index out of range\");\r\n        col = lp.col[j];\r\n        /* if there is element with the same column index, it can only\r\n         be found in the beginning of j-th column list */\r\n        if (col.ptr != null && col.ptr.row.i == i)\r\n            xerror(\"glp_set_mat_row: i = \" + i + \"; ind[\" + k + \"] = \" + j + \"; duplicate column indices not allowed\");\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = val[k];\r\n        /* add the new element to the beginning of i-th row and j-th\r\n         column lists */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        aij.c_prev = null;\r\n        aij.c_next = col.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n        row.ptr = col.ptr = aij;\r\n        /* if the corresponding column is basic, invalidate the basis\r\n         factorization */\r\n        if (col.stat == GLP_BS && aij.val != 0.0) lp.valid = 0;\r\n    }\r\n    /* remove zero elements from i-th row */\r\n    for (aij = row.ptr; aij != null; aij = next)\r\n    {  next = aij.r_next;\r\n        if (aij.val == 0.0)\r\n        {  /* remove the element from the row list */\r\n            if (aij.r_prev == null)\r\n                row.ptr = next;\r\n            else\r\n                aij.r_prev.r_next = next;\r\n            if (next != null)\r\n                next.r_prev = aij.r_prev;\r\n            /* remove the element from the column list */\r\n            xassert(aij.c_prev == null);\r\n            aij.col.ptr = aij.c_next;\r\n            if (aij.c_next != null) aij.c_next.c_prev = null;\r\n            /* return the element to the memory pool */\r\n            lp.nnz--;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_set_mat_col = exports[\"glp_set_mat_col\"] = function(lp, j, len, ind, val){\r\n    var tree = lp.tree;\r\n    var row, aij, next;\r\n    var i, k;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_set_mat_col: operation not allowed\");\r\n    /* obtain pointer to j-th column */\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; column number out of range\");\r\n    var col = lp.col[j];\r\n    /* remove all existing elements from j-th column */\r\n    while (col.ptr != null)\r\n    {  /* take next element in the column */\r\n        aij = col.ptr;\r\n        /* remove the element from the column list */\r\n        col.ptr = aij.c_next;\r\n        /* obtain pointer to corresponding row */\r\n        row = aij.row;\r\n        /* remove the element from the row list */\r\n        if (aij.r_prev == null)\r\n            row.ptr = aij.r_next;\r\n        else\r\n            aij.r_prev.r_next = aij.r_next;\r\n        if (aij.r_next != null)\r\n            aij.r_next.r_prev = aij.r_prev;\r\n        /* return the element to the memory pool */\r\n        lp.nnz--;\r\n    }\r\n    /* store new contents of j-th column */\r\n    if (!(0 <= len && len <= lp.m))\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; len = \" + len + \"; invalid column length\");\r\n    if (len > NNZ_MAX - lp.nnz)\r\n        xerror(\"glp_set_mat_col: j = \" + j + \"; len = \" + len + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= len; k++){\r\n        /* take number i of corresponding row */\r\n        i = ind[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_set_mat_col: j = \" + j + \"; ind[\" + k + \"] = \" + i + \"; row index out of range\");\r\n        row = lp.row[i];\r\n        /* if there is element with the same row index, it can only be\r\n         found in the beginning of i-th row list */\r\n        if (row.ptr != null && row.ptr.col.j == j)\r\n            xerror(\"glp_set_mat_col: j = \" + j + \"; ind[\" + k + \"] = \" + i + \"; duplicate row indices not allowed\");\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = val[k];\r\n        /* add the new element to the beginning of i-th row and j-th\r\n         column lists */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        aij.c_prev = null;\r\n        aij.c_next = col.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n        row.ptr = col.ptr = aij;\r\n    }\r\n    /* remove zero elements from j-th column */\r\n    for (aij = col.ptr; aij != null; aij = next)\r\n    {  next = aij.c_next;\r\n        if (aij.val == 0.0)\r\n        {  /* remove the element from the row list */\r\n            xassert(aij.r_prev == null);\r\n            aij.row.ptr = aij.r_next;\r\n            if (aij.r_next != null) aij.r_next.r_prev = null;\r\n            /* remove the element from the column list */\r\n            if (aij.c_prev == null)\r\n                col.ptr = next;\r\n            else\r\n                aij.c_prev.c_next = next;\r\n            if (next != null)\r\n                next.c_prev = aij.c_prev;\r\n            /* return the element to the memory pool */\r\n            lp.nnz--;\r\n        }\r\n    }\r\n    /* if j-th column is basic, invalidate the basis factorization */\r\n    if (col.stat == GLP_BS) lp.valid = 0;\r\n};\r\n\r\nvar glp_load_matrix = exports[\"glp_load_matrix\"] = function(lp, ne, ia, ja, ar){\r\n    var tree = lp.tree;\r\n    var row, col, aij, next;\r\n    var i, j, k;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_load_matrix: operation not allowed\");\r\n    /* clear the constraint matrix */\r\n    for (i = 1; i <= lp.m; i++){\r\n        row = lp.row[i];\r\n        while (row.ptr != null){\r\n            aij = row.ptr;\r\n            row.ptr = aij.r_next;\r\n            lp.nnz--;\r\n        }\r\n    }\r\n    xassert(lp.nnz == 0);\r\n    for (j = 1; j <= lp.n; j++) lp.col[j].ptr = null;\r\n    /* load the new contents of the constraint matrix and build its\r\n     row lists */\r\n    if (ne < 0)\r\n        xerror(\"glp_load_matrix: ne = \" + ne + \"; invalid number of constraint coefficients\");\r\n    if (ne > NNZ_MAX)\r\n        xerror(\"glp_load_matrix: ne = \" + ne + \"; too many constraint coefficients\");\r\n    for (k = 1; k <= ne; k++){\r\n        /* take indices of new element */\r\n        i = ia[k]; j = ja[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_load_matrix: ia[\" + k + \"] = \" + i + \"; row index out of range\");\r\n        row = lp.row[i];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_load_matrix: ja[\" + k + \"] = \" + j + \"; column index out of range\");\r\n        col = lp.col[j];\r\n        /* create new element */\r\n        aij = {}; lp.nnz++;\r\n        aij.row = row;\r\n        aij.col = col;\r\n        aij.val = ar[k];\r\n        /* add the new element to the beginning of i-th row list */\r\n        aij.r_prev = null;\r\n        aij.r_next = row.ptr;\r\n        if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n        row.ptr = aij;\r\n    }\r\n    xassert(lp.nnz == ne);\r\n    /* build column lists of the constraint matrix and check elements\r\n     with identical indices */\r\n    for (i = 1; i <= lp.m; i++){\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n            /* obtain pointer to corresponding column */\r\n            col = aij.col;\r\n            /* if there is element with identical indices, it can only\r\n             be found in the beginning of j-th column list */\r\n            if (col.ptr != null && col.ptr.row.i == i){\r\n                for (k = 1; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == col.j) break;\r\n                xerror(\"glp_load_mat: ia[\" + k + \"] = \" + i + \"; ja[\" + k + \"] = \" + col.j + \"; duplicate indices not allowed\");\r\n            }\r\n            /* add the element to the beginning of j-th column list */\r\n            aij.c_prev = null;\r\n            aij.c_next = col.ptr;\r\n            if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n            col.ptr = aij;\r\n        }\r\n    }\r\n    /* remove zero elements from the constraint matrix */\r\n    for (i = 1; i <= lp.m; i++)\r\n    {  row = lp.row[i];\r\n        for (aij = row.ptr; aij != null; aij = next)\r\n        {  next = aij.r_next;\r\n            if (aij.val == 0.0)\r\n            {  /* remove the element from the row list */\r\n                if (aij.r_prev == null)\r\n                    row.ptr = next;\r\n                else\r\n                    aij.r_prev.r_next = next;\r\n                if (next != null)\r\n                    next.r_prev = aij.r_prev;\r\n                /* remove the element from the column list */\r\n                if (aij.c_prev == null)\r\n                    aij.col.ptr = aij.c_next;\r\n                else\r\n                    aij.c_prev.c_next = aij.c_next;\r\n                if (aij.c_next != null)\r\n                    aij.c_next.c_prev = aij.c_prev;\r\n                /* return the element to the memory pool */\r\n                lp.nnz--;\r\n            }\r\n        }\r\n    }\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n};\r\n\r\nvar glp_check_dup = exports[\"glp_check_dup\"] = function(m, n, ne, ia, ja){\r\n    var i, j, k, ptr, next, ret;\r\n    var flag;\r\n    if (m < 0)\r\n        xerror(\"glp_check_dup: m = %d; invalid parameter\");\r\n    if (n < 0)\r\n        xerror(\"glp_check_dup: n = %d; invalid parameter\");\r\n    if (ne < 0)\r\n        xerror(\"glp_check_dup: ne = %d; invalid parameter\");\r\n    if (ne > 0 && ia == null)\r\n        xerror(\"glp_check_dup: ia = \" + ia + \"; invalid parameter\");\r\n    if (ne > 0 && ja == null)\r\n        xerror(\"glp_check_dup: ja = \" + ja + \"; invalid parameter\");\r\n    for (k = 1; k <= ne; k++){\r\n        i = ia[k]; j = ja[k];\r\n        if (!(1 <= i && i <= m && 1 <= j && j <= n)){\r\n            ret = -k;\r\n            return ret;\r\n        }\r\n    }\r\n    if (m == 0 || n == 0)\r\n    {  ret = 0;\r\n        return ret;\r\n    }\r\n    /* allocate working arrays */\r\n    ptr = new Int32Array(1+m);\r\n    next = new Int32Array(1+ne);\r\n    flag = new Int8Array(1+n);\r\n    /* build row lists */\r\n    for (k = 1; k <= ne; k++){\r\n        i = ia[k];\r\n        next[k] = ptr[i];\r\n        ptr[i] = k;\r\n    }\r\n    /* check for duplicate elements */\r\n    for (i = 1; i <= m; i++){\r\n        for (k = ptr[i]; k != 0; k = next[k]){\r\n            j = ja[k];\r\n            if (flag[j]){\r\n                /* find first element (i,j) */\r\n                for (k = 1; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == j) break;\r\n                xassert(k <= ne);\r\n                /* find next (duplicate) element (i,j) */\r\n                for (k++; k <= ne; k++)\r\n                    if (ia[k] == i && ja[k] == j) break;\r\n                xassert(k <= ne);\r\n                ret = +k;\r\n                return ret;\r\n            }\r\n            flag[j] = 1;\r\n        }\r\n        /* clear column flags */\r\n        for (k = ptr[i]; k != 0; k = next[k])\r\n            flag[ja[k]] = 0;\r\n    }\r\n    /* no duplicate element found */\r\n    ret = 0;\r\n    return ret;\r\n};\r\n\r\nvar glp_sort_matrix = exports[\"glp_sort_matrix\"] = function(P){\r\n    var aij;\r\n    var i, j;\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_sort_matrix: P = \" + P + \"; invalid problem object\");\r\n    /* rebuild row linked lists */\r\n    for (i = P.m; i >= 1; i--)\r\n        P.row[i].ptr = null;\r\n    for (j = P.n; j >= 1; j--){\r\n        for (aij = P.col[j].ptr; aij != null; aij = aij.c_next){\r\n            i = aij.row.i;\r\n            aij.r_prev = null;\r\n            aij.r_next = P.row[i].ptr;\r\n            if (aij.r_next != null) aij.r_next.r_prev = aij;\r\n            P.row[i].ptr = aij;\r\n        }\r\n    }\r\n    /* rebuild column linked lists */\r\n    for (j = P.n; j >= 1; j--)\r\n        P.col[j].ptr = null;\r\n    for (i = P.m; i >= 1; i--){\r\n        for (aij = P.row[i].ptr; aij != null; aij = aij.r_next){\r\n            j = aij.col.j;\r\n            aij.c_prev = null;\r\n            aij.c_next = P.col[j].ptr;\r\n            if (aij.c_next != null) aij.c_next.c_prev = aij;\r\n            P.col[j].ptr = aij;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_del_rows = exports[\"glp_del_rows\"] = function(lp, nrs, num){\r\n    var tree = lp.tree;\r\n    var row;\r\n    var i, k, m_new;\r\n    /* mark rows to be deleted */\r\n    if (!(1 <= nrs && nrs <= lp.m))\r\n        xerror(\"glp_del_rows: nrs = \" + nrs + \"; invalid number of rows\");\r\n    for (k = 1; k <= nrs; k++){\r\n        /* take the number of row to be deleted */\r\n        i = num[k];\r\n        /* obtain pointer to i-th row */\r\n        if (!(1 <= i && i <= lp.m))\r\n            xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        row = lp.row[i];\r\n        if (tree != null && tree.reason != 0){\r\n            if (!(tree.reason == GLP_IROWGEN || tree.reason == GLP_ICUTGEN))\r\n                xerror(\"glp_del_rows: operation not allowed\");\r\n            xassert(tree.curr != null);\r\n            if (row.level != tree.curr.level)\r\n                xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; invalid attempt to delete row created not in current subproblem\");\r\n            if (row.stat != GLP_BS)\r\n                xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; invalid attempt to delete active row (constraint)\");\r\n            tree.reinv = 1;\r\n        }\r\n        /* check that the row is not marked yet */\r\n        if (row.i == 0)\r\n            xerror(\"glp_del_rows: num[\" + k + \"] = \" + i + \"; duplicate row numbers not allowed\");\r\n        /* erase symbolic name assigned to the row */\r\n        glp_set_row_name(lp, i, null);\r\n        xassert(row.node == null);\r\n        /* erase corresponding row of the constraint matrix */\r\n        glp_set_mat_row(lp, i, 0, null, null);\r\n        xassert(row.ptr == null);\r\n        /* mark the row to be deleted */\r\n        row.i = 0;\r\n    }\r\n    /* delete all marked rows from the row list */\r\n    m_new = 0;\r\n    for (i = 1; i <= lp.m; i++){\r\n        /* obtain pointer to i-th row */\r\n        row = lp.row[i];\r\n        /* check if the row is marked */\r\n        if (row.i != 0){\r\n            /* it is not marked; keep it */\r\n            row.i = ++m_new;\r\n            lp.row[row.i] = row;\r\n        }\r\n    }\r\n    /* set new number of rows */\r\n    lp.m = m_new;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n};\r\n\r\nvar glp_del_cols = exports[\"glp_del_cols\"] = function(lp, ncs, num){\r\n    var tree = lp.tree;\r\n    var col;\r\n    var j, k, n_new;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_del_cols: operation not allowed\");\r\n    /* mark columns to be deleted */\r\n    if (!(1 <= ncs && ncs <= lp.n))\r\n        xerror(\"glp_del_cols: ncs = \" + ncs + \"; invalid number of columns\");\r\n    for (k = 1; k <= ncs; k++){\r\n        /* take the number of column to be deleted */\r\n        j = num[k];\r\n        /* obtain pointer to j-th column */\r\n        if (!(1 <= j && j <= lp.n))\r\n            xerror(\"glp_del_cols: num[\" + k + \"] = \" + j + \"; column number out of range\");\r\n        col = lp.col[j];\r\n        /* check that the column is not marked yet */\r\n        if (col.j == 0)\r\n            xerror(\"glp_del_cols: num[\" + k + \"] = \" + j + \"; duplicate column numbers not allowed\");\r\n        /* erase symbolic name assigned to the column */\r\n        glp_set_col_name(lp, j, null);\r\n        xassert(col.node == null);\r\n        /* erase corresponding column of the constraint matrix */\r\n        glp_set_mat_col(lp, j, 0, null, null);\r\n        xassert(col.ptr == null);\r\n        /* mark the column to be deleted */\r\n        col.j = 0;\r\n        /* if it is basic, invalidate the basis factorization */\r\n        if (col.stat == GLP_BS) lp.valid = 0;\r\n    }\r\n    /* delete all marked columns from the column list */\r\n    n_new = 0;\r\n    for (j = 1; j <= lp.n; j++)\r\n    {  /* obtain pointer to j-th column */\r\n        col = lp.col[j];\r\n        /* check if the column is marked */\r\n        if (col.j != 0){\r\n            /* it is not marked; keep it */\r\n            col.j = ++n_new;\r\n            lp.col[col.j] = col;\r\n        }\r\n    }\r\n    /* set new number of columns */\r\n    lp.n = n_new;\r\n    /* if the basis header is still valid, adjust it */\r\n    if (lp.valid){\r\n        var m = lp.m;\r\n        var head = lp.head;\r\n        for (j = 1; j <= n_new; j++){\r\n            k = lp.col[j].bind;\r\n            if (k != 0){\r\n                xassert(1 <= k && k <= m);\r\n                head[k] = m + j;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_copy_prob = exports[\"glp_copy_prob\"] = function(dest, prob, names){\r\n    var tree = dest.tree;\r\n    var bfcp = {};\r\n    var i, j, len, ind;\r\n    var val;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_copy_prob: operation not allowed\");\r\n    if (dest == prob)\r\n        xerror(\"glp_copy_prob: copying problem object to itself not allowed\");\r\n    if (!(names == GLP_ON || names == GLP_OFF))\r\n        xerror(\"glp_copy_prob: names = \" + names + \"; invalid parameter\");\r\n    glp_erase_prob(dest);\r\n    if (names && prob.name != null)\r\n        glp_set_prob_name(dest, prob.name);\r\n    if (names && prob.obj != null)\r\n        glp_set_obj_name(dest, prob.obj);\r\n    dest.dir = prob.dir;\r\n    dest.c0 = prob.c0;\r\n    if (prob.m > 0)\r\n        glp_add_rows(dest, prob.m);\r\n    if (prob.n > 0)\r\n        glp_add_cols(dest, prob.n);\r\n    glp_get_bfcp(prob, bfcp);\r\n    glp_set_bfcp(dest, bfcp);\r\n    dest.pbs_stat = prob.pbs_stat;\r\n    dest.dbs_stat = prob.dbs_stat;\r\n    dest.obj_val = prob.obj_val;\r\n    dest.some = prob.some;\r\n    dest.ipt_stat = prob.ipt_stat;\r\n    dest.ipt_obj = prob.ipt_obj;\r\n    dest.mip_stat = prob.mip_stat;\r\n    dest.mip_obj = prob.mip_obj;\r\n    var to, from;\r\n    for (i = 1; i <= prob.m; i++){\r\n        to = dest.row[i];\r\n        from = prob.row[i];\r\n        if (names && from.name != null)\r\n            glp_set_row_name(dest, i, from.name);\r\n        to.type = from.type;\r\n        to.lb = from.lb;\r\n        to.ub = from.ub;\r\n        to.rii = from.rii;\r\n        to.stat = from.stat;\r\n        to.prim = from.prim;\r\n        to.dual = from.dual;\r\n        to.pval = from.pval;\r\n        to.dval = from.dval;\r\n        to.mipx = from.mipx;\r\n    }\r\n    ind = new Int32Array(1+prob.m);\r\n    val = new Float64Array(1+prob.m);\r\n    for (j = 1; j <= prob.n; j++){\r\n        to = dest.col[j];\r\n        from = prob.col[j];\r\n        if (names && from.name != null)\r\n            glp_set_col_name(dest, j, from.name);\r\n        to.kind = from.kind;\r\n        to.type = from.type;\r\n        to.lb = from.lb;\r\n        to.ub = from.ub;\r\n        to.coef = from.coef;\r\n        len = glp_get_mat_col(prob, j, ind, val);\r\n        glp_set_mat_col(dest, j, len, ind, val);\r\n        to.sjj = from.sjj;\r\n        to.stat = from.stat;\r\n        to.prim = from.prim;\r\n        to.dual = from.dual;\r\n        to.pval = from.pval;\r\n        to.dval = from.dval;\r\n        to.mipx = from.mipx;\r\n    }\r\n};\r\n\r\nvar glp_erase_prob = exports[\"glp_erase_prob\"] = function(lp){\r\n    var tree = lp.tree;\r\n    if (tree != null && tree.reason != 0)\r\n        xerror(\"glp_erase_prob: operation not allowed\");\r\n    delete_prob(lp);\r\n    create_prob(lp);\r\n};\r\n\r\nfunction delete_prob(lp){\r\n    lp.magic = 0x3F3F3F3F;\r\n    lp.parms = null;\r\n    xassert(lp.tree == null);\r\n    lp.row = null;\r\n    lp.col = null;\r\n    lp.r_tree = null;\r\n    lp.c_tree = null;\r\n    lp.head = null;\r\n    lp.bfcp = null;\r\n    lp.bfd = null;\r\n}\r\n\r\nvar glp_get_prob_name = exports[\"glp_get_prob_name\"] = function(lp){\r\n    return lp.name;\r\n};\r\n\r\nvar glp_get_obj_name = exports[\"glp_get_obj_name\"] = function(lp){\r\n    return lp.obj;\r\n};\r\n\r\nvar glp_get_obj_dir = exports[\"glp_get_obj_dir\"] = function(lp){\r\n    return lp.dir;\r\n};\r\n\r\nvar glp_get_num_rows = exports[\"glp_get_num_rows\"] = function(lp){\r\n    return lp.m;\r\n};\r\n\r\nvar glp_get_num_cols = exports[\"glp_get_num_cols\"] = function(lp){\r\n    return lp.n;\r\n};\r\n\r\nvar glp_get_row_name = exports[\"glp_get_row_name\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_name: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].name;\r\n};\r\n\r\nvar glp_get_col_name = exports[\"glp_get_col_name\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_name: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].name;\r\n};\r\n\r\nvar glp_get_row_type = exports[\"glp_get_row_type\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_type: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].type;\r\n};\r\n\r\nvar glp_get_row_lb = exports[\"glp_get_row_lb\"] = function(lp, i){\r\n    var lb;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_lb: i = \" + i + \"; row number out of range\");\r\n    switch (lp.row[i].type){\r\n        case GLP_FR:\r\n        case GLP_UP:\r\n            lb = -DBL_MAX; break;\r\n        case GLP_LO:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            lb = lp.row[i].lb; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return lb;\r\n};\r\n\r\nvar glp_get_row_ub = exports[\"glp_get_row_ub\"] = function(lp, i){\r\n    var ub;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_ub: i = \" + i + \"; row number out of range\");\r\n    switch (lp.row[i].type){\r\n        case GLP_FR:\r\n        case GLP_LO:\r\n            ub = +DBL_MAX; break;\r\n        case GLP_UP:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            ub = lp.row[i].ub; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return ub;\r\n};\r\n\r\nvar glp_get_col_type = exports[\"glp_get_col_type\"] = function(lp, j)\r\n{     if (!(1 <= j && j <= lp.n))\r\n    xerror(\"glp_get_col_type: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].type;\r\n};\r\n\r\nvar glp_get_col_lb = exports[\"glp_get_col_lb\"] = function(lp, j){\r\n    var lb;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_lb: j = \" + j + \"; column number out of range\");\r\n    switch (lp.col[j].type){\r\n        case GLP_FR:\r\n        case GLP_UP:\r\n            lb = -DBL_MAX; break;\r\n        case GLP_LO:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            lb = lp.col[j].lb; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return lb;\r\n};\r\n\r\nvar glp_get_col_ub = exports[\"glp_get_col_ub\"] = function(lp, j){\r\n    var ub;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_ub: j = \" + j + \"; column number out of range\");\r\n    switch (lp.col[j].type){\r\n        case GLP_FR:\r\n        case GLP_LO:\r\n            ub = +DBL_MAX; break;\r\n        case GLP_UP:\r\n        case GLP_DB:\r\n        case GLP_FX:\r\n            ub = lp.col[j].ub; break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return ub;\r\n};\r\n\r\nvar glp_get_obj_coef = exports[\"glp_get_obj_coef\"] = function(lp, j){\r\n    if (!(0 <= j && j <= lp.n))\r\n        xerror(\"glp_get_obj_coef: j = \" + j + \"; column number out of range\");\r\n    return j == 0 ? lp.c0 : lp.col[j].coef;\r\n};\r\n\r\nvar glp_get_num_nz = exports[\"glp_get_num_nz\"] = function (lp){\r\n    return lp.nnz;\r\n};\r\n\r\nvar glp_get_mat_row = exports[\"glp_get_mat_row\"] = function(lp, i, ind, val){\r\n    var aij;\r\n    var len;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_mat_row: i = \" + i + \"; row number out of range\");\r\n    len = 0;\r\n    for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n        len++;\r\n        if (ind != null) ind[len] = aij.col.j;\r\n        if (val != null) val[len] = aij.val;\r\n    }\r\n    xassert(len <= lp.n);\r\n    return len;\r\n};\r\n\r\nvar glp_get_mat_col = exports[\"glp_get_mat_col\"] = function(lp, j, ind, val){\r\n    var aij;\r\n    var len;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_mat_col: j = \" + j + \"; column number out of range\");\r\n    len = 0;\r\n    for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next){\r\n        len++;\r\n        if (ind != null) ind[len] = aij.row.i;\r\n        if (val != null) val[len] = aij.val;\r\n    }\r\n    xassert(len <= lp.m);\r\n    return len;\r\n};\r\n\r\nvar glp_create_index = exports[\"glp_create_index\"] = function(lp){\r\n    var row;\r\n    var col;\r\n    var i, j;\r\n    /* create row name index */\r\n    if (lp.r_tree == null){\r\n        lp.r_tree = {};\r\n        for (i = 1; i <= lp.m; i++){\r\n            row = lp.row[i];\r\n            if (row.name != null){\r\n                lp.r_tree[row.name] = row;\r\n            }\r\n        }\r\n    }\r\n    /* create column name index */\r\n    if (lp.c_tree == null)\r\n    {  lp.c_tree = {};\r\n        for (j = 1; j <= lp.n; j++){\r\n            col = lp.col[j];\r\n            if (col.name != null){\r\n                lp.c_tree[col.name] = col;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_find_row = exports[\"glp_find_row\"] = function(lp, name){\r\n    var i = 0;\r\n    if (lp.r_tree == null)\r\n        xerror(\"glp_find_row: row name index does not exist\");\r\n    var row = lp.r_tree[name];\r\n    if (row) i = row.i;\r\n    return i;\r\n};\r\n\r\nvar glp_find_col = exports[\"glp_find_col\"] = function(lp, name){\r\n    var j = 0;\r\n    if (lp.c_tree == null)\r\n        xerror(\"glp_find_col: column name index does not exist\");\r\n    var col = lp.c_tree[name];\r\n    if (col) j = col.j;\r\n    return j;\r\n};\r\n\r\nvar glp_delete_index = exports[\"glp_delete_index\"] = function(lp){\r\n    lp.r_tree = null;\r\n    lp.r_tree = null;\r\n};\r\n\r\nvar glp_set_rii = exports[\"glp_set_rii\"] = function(lp, i, rii){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_rii: i = \" + i + \"; row number out of range\");\r\n    if (rii <= 0.0)\r\n        xerror(\"glp_set_rii: i = \" + i + \"; rii = \" + rii + \"; invalid scale factor\");\r\n    if (lp.valid && lp.row[i].rii != rii){\r\n        for (var aij = lp.row[i].ptr; aij != null; aij = aij.r_next){\r\n            if (aij.col.stat == GLP_BS){\r\n                /* invalidate the basis factorization */\r\n                lp.valid = 0;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    lp.row[i].rii = rii;\r\n};\r\n\r\nvar glp_set_sjj = exports[\"glp_set_sjj\"] = function(lp, j, sjj){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_sjj: j = \" + j + \"; column number out of range\");\r\n    if (sjj <= 0.0)\r\n        xerror(\"glp_set_sjj: j = \" + j + \"; sjj = \" + sjj + \"; invalid scale factor\");\r\n    if (lp.valid && lp.col[j].sjj != sjj && lp.col[j].stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    lp.col[j].sjj = sjj;\r\n};\r\n\r\nvar glp_get_rii = exports[\"glp_get_rii\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_rii: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].rii;\r\n};\r\n\r\nvar glp_get_sjj = exports[\"glp_get_sjj\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_sjj: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].sjj;\r\n};\r\n\r\nvar glp_unscale_prob = exports[\"glp_unscale_prob\"] = function(lp){\r\n    var m = glp_get_num_rows(lp);\r\n    var n = glp_get_num_cols(lp);\r\n    var i, j;\r\n    for (i = 1; i <= m; i++) glp_set_rii(lp, i, 1.0);\r\n    for (j = 1; j <= n; j++) glp_set_sjj(lp, j, 1.0);\r\n};\r\n\r\nvar glp_set_row_stat = exports[\"glp_set_row_stat\"] = function(lp, i, stat){\r\n    var row;\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_set_row_stat: i = \" + i + \"; row number out of range\");\r\n    if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))\r\n        xerror(\"glp_set_row_stat: i = \" + i + \"; stat = \" + stat + \"; invalid status\");\r\n    row = lp.row[i];\r\n    if (stat != GLP_BS){\r\n        switch (row.type){\r\n            case GLP_FR: stat = GLP_NF; break;\r\n            case GLP_LO: stat = GLP_NL; break;\r\n            case GLP_UP: stat = GLP_NU; break;\r\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\r\n            case GLP_FX: stat = GLP_NS; break;\r\n            default: xassert(row != row);\r\n        }\r\n    }\r\n    if (row.stat == GLP_BS && stat != GLP_BS || row.stat != GLP_BS && stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    row.stat = stat;\r\n};\r\n\r\nvar glp_set_col_stat = exports[\"glp_set_col_stat\"] = function(lp, j, stat){\r\n    var col;\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_set_col_stat: j = \" + j + \"; column number out of range\");\r\n    if (!(stat == GLP_BS || stat == GLP_NL || stat == GLP_NU || stat == GLP_NF || stat == GLP_NS))\r\n        xerror(\"glp_set_col_stat: j = \" + j + \"; stat = \" + stat + \"; invalid status\");\r\n    col = lp.col[j];\r\n    if (stat != GLP_BS){\r\n        switch (col.type){\r\n            case GLP_FR: stat = GLP_NF; break;\r\n            case GLP_LO: stat = GLP_NL; break;\r\n            case GLP_UP: stat = GLP_NU; break;\r\n            case GLP_DB: if (stat != GLP_NU) stat = GLP_NL; break;\r\n            case GLP_FX: stat = GLP_NS; break;\r\n            default: xassert(col != col);\r\n        }\r\n    }\r\n    if (col.stat == GLP_BS && stat != GLP_BS || col.stat != GLP_BS && stat == GLP_BS){\r\n        /* invalidate the basis factorization */\r\n        lp.valid = 0;\r\n    }\r\n    col.stat = stat;\r\n};\r\n\r\nvar glp_std_basis = exports[\"glp_std_basis\"] = function(lp){\r\n    var i, j;\r\n    /* make all auxiliary variables basic */\r\n    for (i = 1; i <= lp.m; i++)\r\n        glp_set_row_stat(lp, i, GLP_BS);\r\n    /* make all structural variables non-basic */\r\n    for (j = 1; j <= lp.n; j++){\r\n        var col = lp.col[j];\r\n        if (col.type == GLP_DB && Math.abs(col.lb) > Math.abs(col.ub))\r\n            glp_set_col_stat(lp, j, GLP_NU);\r\n        else\r\n            glp_set_col_stat(lp, j, GLP_NL);\r\n    }\r\n};\r\n\r\nvar glp_simplex = exports[\"glp_simplex\"] = function(P, parm){\r\n\r\n    function solve_lp(P, parm){\r\n        /* solve LP directly without using the preprocessor */\r\n        var ret;\r\n        if (!glp_bf_exists(P)){\r\n            ret = glp_factorize(P);\r\n            if (ret == 0){\r\n\r\n            }\r\n            else if (ret == GLP_EBADB){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is invalid\");\r\n            }\r\n            else if (ret == GLP_ESING){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is singular\");\r\n            }\r\n            else if (ret == GLP_ECOND){\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"glp_simplex: initial basis is ill-conditioned\");\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n            if (ret != 0) return ret;\r\n        }\r\n        if (parm.meth == GLP_PRIMAL)\r\n            ret = spx_primal(P, parm);\r\n        else if (parm.meth == GLP_DUALP)\r\n        {  ret = spx_dual(P, parm);\r\n            if (ret == GLP_EFAIL && P.valid)\r\n                ret = spx_primal(P, parm);\r\n        }\r\n        else if (parm.meth == GLP_DUAL)\r\n            ret = spx_dual(P, parm);\r\n        else\r\n            xassert(parm != parm);\r\n        return ret;\r\n    }\r\n\r\n    function preprocess_and_solve_lp(P, parm){\r\n        /* solve LP using the preprocessor */\r\n        var npp;\r\n        var lp = null;\r\n        var bfcp = {};\r\n        var ret;\r\n\r\n\r\n        function post(){\r\n            /* postprocess solution from the transformed LP */\r\n            npp_postprocess(npp, lp);\r\n            /* the transformed LP is no longer needed */\r\n            lp = null;\r\n            /* store solution to the original problem */\r\n            npp_unload_sol(npp, P);\r\n            /* the original LP has been successfully solved */\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n\r\n\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Preprocessing...\");\r\n        /* create preprocessor workspace */\r\n        npp = npp_create_wksp();\r\n        /* load original problem into the preprocessor workspace */\r\n        npp_load_prob(npp, P, GLP_OFF, GLP_SOL, GLP_OFF);\r\n        /* process LP prior to applying primal/dual simplex method */\r\n        ret = npp_simplex(npp, parm);\r\n        if (ret == 0)\r\n        {\r\n\r\n        }\r\n        else if (ret == GLP_ENOPFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\");\r\n        }\r\n        else if (ret == GLP_ENODFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* build transformed LP */\r\n        lp = glp_create_prob();\r\n        npp_build_prob(npp, lp);\r\n        /* if the transformed LP is empty, it has empty solution, which\r\n         is optimal */\r\n        if (lp.m == 0 && lp.n == 0)\r\n        {  lp.pbs_stat = lp.dbs_stat = GLP_FEAS;\r\n            lp.obj_val = lp.c0;\r\n            if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0)\r\n            {  xprintf(P.it_cnt + \": obj = \" + lp.obj_val + \"  infeas = 0.0\");\r\n            }\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OPTIMAL SOLUTION FOUND BY LP PREPROCESSOR\");\r\n            return post();\r\n        }\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n        {  xprintf(lp.m + \" row\" + (lp.m == 1 ? \"\" : \"s\") + \", \" + lp.n + \" column\" + (lp.n == 1 ? \"\" : \"s\") + \", \"\r\n            + lp.nnz + \" non-zero\" + (lp.nnz == 1 ? \"\" : \"s\") + \"\");\r\n        }\r\n        /* inherit basis factorization control parameters */\r\n        glp_get_bfcp(P, bfcp);\r\n        glp_set_bfcp(lp, bfcp);\r\n        /* scale the transformed problem */\r\n\r\n        {   var env = get_env_ptr();\r\n            var term_out = env.term_out;\r\n            if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n                env.term_out = GLP_OFF;\r\n            else\r\n                env.term_out = GLP_ON;\r\n            glp_scale_prob(lp, GLP_SF_AUTO);\r\n            env.term_out = term_out;\r\n        }\r\n        /* build advanced initial basis */\r\n        {   env = get_env_ptr();\r\n            term_out = env.term_out;\r\n            if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n                env.term_out = GLP_OFF;\r\n            else\r\n                env.term_out = GLP_ON;\r\n            glp_adv_basis(lp, 0);\r\n            env.term_out = term_out;\r\n        }\r\n        /* solve the transformed LP */\r\n        lp.it_cnt = P.it_cnt;\r\n        ret = solve_lp(lp, parm);\r\n        P.it_cnt = lp.it_cnt;\r\n        /* only optimal solution can be postprocessed */\r\n        if (!(ret == 0 && lp.pbs_stat == GLP_FEAS && lp.dbs_stat == GLP_FEAS)){\r\n            if (parm.msg_lev >= GLP_MSG_ERR)\r\n                xprintf(\"glp_simplex: unable to recover undefined or non-optimal solution\");\r\n            if (ret == 0){\r\n                if (lp.pbs_stat == GLP_NOFEAS)\r\n                    ret = GLP_ENOPFS;\r\n                else if (lp.dbs_stat == GLP_NOFEAS)\r\n                    ret = GLP_ENODFS;\r\n                else\r\n                    xassert(lp != lp);\r\n            }\r\n            return ret;\r\n        }\r\n        return post();\r\n    }\r\n\r\n    function trivial_lp(P, parm){\r\n        /* solve trivial LP which has empty constraint matrix */\r\n        var row, col;\r\n        var i, j;\r\n        var p_infeas, d_infeas, zeta;\r\n        P.valid = 0;\r\n        P.pbs_stat = P.dbs_stat = GLP_FEAS;\r\n        P.obj_val = P.c0;\r\n        P.some = 0;\r\n        p_infeas = d_infeas = 0.0;\r\n        /* make all auxiliary variables basic */\r\n        for (i = 1; i <= P.m; i++){\r\n            row = P.row[i];\r\n            row.stat = GLP_BS;\r\n            row.prim = row.dual = 0.0;\r\n            /* check primal feasibility */\r\n            if (row.type == GLP_LO || row.type == GLP_DB || row.type == GLP_FX){\r\n                /* row has lower bound */\r\n                if (row.lb > + parm.tol_bnd){\r\n                    P.pbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth != GLP_PRIMAL)\r\n                        P.some = i;\r\n                }\r\n                if (p_infeas < + row.lb)\r\n                    p_infeas = + row.lb;\r\n            }\r\n            if (row.type == GLP_UP || row.type == GLP_DB || row.type == GLP_FX){\r\n                /* row has upper bound */\r\n                if (row.ub < - parm.tol_bnd){\r\n                    P.pbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth != GLP_PRIMAL)\r\n                        P.some = i;\r\n                }\r\n                if (p_infeas < - row.ub)\r\n                    p_infeas = - row.ub;\r\n            }\r\n        }\r\n        /* determine scale factor for the objective row */\r\n        zeta = 1.0;\r\n        for (j = 1; j <= P.n; j++)\r\n        {  col = P.col[j];\r\n            if (zeta < Math.abs(col.coef)) zeta = Math.abs(col.coef);\r\n        }\r\n        zeta = (P.dir == GLP_MIN ? +1.0 : -1.0) / zeta;\r\n        /* make all structural variables non-basic */\r\n\r\n        function lo(){col.stat = GLP_NL; col.prim = col.lb}\r\n        function up(){col.stat = GLP_NU; col.prim = col.ub}\r\n\r\n        for (j = 1; j <= P.n; j++)\r\n        {  col = P.col[j];\r\n            if (col.type == GLP_FR){\r\n                col.stat = GLP_NF; col.prim = 0.0;\r\n            }\r\n            else if (col.type == GLP_LO)\r\n                lo();\r\n            else if (col.type == GLP_UP)\r\n                up();\r\n            else if (col.type == GLP_DB)\r\n            {  if (zeta * col.coef > 0.0)\r\n                lo();\r\n            else if (zeta * col.coef < 0.0)\r\n                up();\r\n            else if (Math.abs(col.lb) <= Math.abs(col.ub))\r\n                lo();\r\n            else\r\n                up();\r\n            }\r\n            else if (col.type == GLP_FX){\r\n                col.stat = GLP_NS; col.prim = col.lb;\r\n            }\r\n            col.dual = col.coef;\r\n            P.obj_val += col.coef * col.prim;\r\n            /* check dual feasibility */\r\n            if (col.type == GLP_FR || col.type == GLP_LO){\r\n                /* column has no upper bound */\r\n                if (zeta * col.dual < - parm.tol_dj){\r\n                    P.dbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth == GLP_PRIMAL)\r\n                        P.some = P.m + j;\r\n                }\r\n                if (d_infeas < - zeta * col.dual)\r\n                    d_infeas = - zeta * col.dual;\r\n            }\r\n            if (col.type == GLP_FR || col.type == GLP_UP)\r\n            {  /* column has no lower bound */\r\n                if (zeta * col.dual > + parm.tol_dj)\r\n                {  P.dbs_stat = GLP_NOFEAS;\r\n                    if (P.some == 0 && parm.meth == GLP_PRIMAL)\r\n                        P.some = P.m + j;\r\n                }\r\n                if (d_infeas < + zeta * col.dual)\r\n                    d_infeas = + zeta * col.dual;\r\n            }\r\n        }\r\n        /* simulate the simplex solver output */\r\n        if (parm.msg_lev >= GLP_MSG_ON && parm.out_dly == 0){\r\n            xprintf(\"~\" + P.it_cnt + \": obj = \" + P.obj_val + \"  infeas = \" + (parm.meth == GLP_PRIMAL ? p_infeas : d_infeas) + \"\");\r\n        }\r\n        if (parm.msg_lev >= GLP_MSG_ALL && parm.out_dly == 0){\r\n            if (P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS)\r\n                xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n            else if (P.pbs_stat == GLP_NOFEAS)\r\n                xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n            else if (parm.meth == GLP_PRIMAL)\r\n                xprintf(\"PROBLEM HAS UNBOUNDED SOLUTION\");\r\n            else\r\n                xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n    }\r\n\r\n    /* solve LP problem with the simplex method */\r\n    var i, j, ret;\r\n    /* check problem object */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_simplex: P = \" + P + \"; invalid problem object\");\r\n    if (P.tree != null && P.tree.reason != 0)\r\n        xerror(\"glp_simplex: operation not allowed\");\r\n    /* check control parameters */\r\n    if (parm == null){\r\n        parm = new SMCP();\r\n    }\r\n    if (!(parm.msg_lev == GLP_MSG_OFF ||\r\n        parm.msg_lev == GLP_MSG_ERR ||\r\n        parm.msg_lev == GLP_MSG_ON  ||\r\n        parm.msg_lev == GLP_MSG_ALL ||\r\n        parm.msg_lev == GLP_MSG_DBG))\r\n        xerror(\"glp_simplex: msg_lev = \" + parm.msg_lev + \"; invalid parameter\");\r\n    if (!(parm.meth == GLP_PRIMAL ||\r\n        parm.meth == GLP_DUALP  ||\r\n        parm.meth == GLP_DUAL))\r\n        xerror(\"glp_simplex: meth = \" + parm.meth + \"; invalid parameter\");\r\n    if (!(parm.pricing == GLP_PT_STD || parm.pricing == GLP_PT_PSE))\r\n        xerror(\"glp_simplex: pricing = \" + parm.pricing + \"; invalid parameter\");\r\n    if (!(parm.r_test == GLP_RT_STD || parm.r_test == GLP_RT_HAR))\r\n        xerror(\"glp_simplex: r_test = \" + parm.r_test + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_bnd && parm.tol_bnd < 1.0))\r\n        xerror(\"glp_simplex: tol_bnd = \" + parm.tol_bnd + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_dj && parm.tol_dj < 1.0))\r\n        xerror(\"glp_simplex: tol_dj = \" + parm.tol_dj + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_piv && parm.tol_piv < 1.0))\r\n        xerror(\"glp_simplex: tol_piv = \" + parm.tol_piv + \"; invalid parameter\");\r\n    if (parm.it_lim < 0)\r\n        xerror(\"glp_simplex: it_lim = \" + parm.it_lim + \"; invalid parameter\");\r\n    if (parm.tm_lim < 0)\r\n        xerror(\"glp_simplex: tm_lim = \" + parm.tm_lim + \"; invalid parameter\");\r\n    if (parm.out_frq < 1)\r\n        xerror(\"glp_simplex: out_frq = \" + parm.out_frq + \"; invalid parameter\");\r\n    if (parm.out_dly < 0)\r\n        xerror(\"glp_simplex: out_dly = \" + parm.out_dly + \"; invalid parameter\");\r\n    if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))\r\n        xerror(\"glp_simplex: presolve = \" + parm.presolve + \"; invalid parameter\");\r\n    /* basic solution is currently undefined */\r\n    P.pbs_stat = P.dbs_stat = GLP_UNDEF;\r\n    P.obj_val = 0.0;\r\n    P.some = 0;\r\n    /* check bounds of double-bounded variables */\r\n    for (i = 1; i <= P.m; i++)\r\n    {  var row = P.row[i];\r\n        if (row.type == GLP_DB && row.lb >= row.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_simplex: row \" + i + \": lb = \" + row.lb + \", ub = \" + row.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  var col = P.col[j];\r\n        if (col.type == GLP_DB && col.lb >= col.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_simplex: column \" +  j + \": lb = \" + col.lb + \", ub = \" + col.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    /* solve LP problem */\r\n    if (parm.msg_lev >= GLP_MSG_ALL)\r\n    {   xprintf(\"GLPK Simplex Optimizer, v\" + glp_version() + \"\");\r\n        xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" +\r\n            P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\") + \"\");\r\n    }\r\n    if (P.nnz == 0){\r\n        trivial_lp(P, parm);\r\n        ret = 0;\r\n    }\r\n    else if (!parm.presolve)\r\n        ret = solve_lp(P, parm);\r\n    else\r\n        ret = preprocess_and_solve_lp(P, parm);\r\n    /* return to the application program */\r\n    return ret;\r\n};\r\n\r\n/***********************************************************************\r\n *  NAME\r\n *\r\n *  glp_init_smcp - initialize simplex method control parameters\r\n *\r\n *  SYNOPSIS\r\n *\r\n *  void glp_init_smcp(glp_smcp *parm);\r\n *\r\n *  DESCRIPTION\r\n *\r\n *  The routine glp_init_smcp initializes control parameters, which are\r\n *  used by the simplex solver, with default values.\r\n *\r\n *  Default values of the control parameters are stored in a glp_smcp\r\n *  structure, which the parameter parm points to. */\r\n\r\nvar SMCP = exports[\"SMCP\"] = /**@constructor*/ function(options){\r\n    options = options || {};\r\n    this.msg_lev = options[\"msg_lev\"] || GLP_MSG_ALL;\r\n    this.meth = options[\"meth\"] || GLP_PRIMAL;\r\n    this.pricing = options[\"pricing\"] || GLP_PT_PSE;\r\n    this.r_test = options[\"r_test\"] || GLP_RT_HAR;\r\n    this.tol_bnd = options[\"tol_bnd\"] || 1e-7;\r\n    this.tol_dj = options[\"tol_dj\"] || 1e-7;\r\n    this.tol_piv = options[\"tol_piv\"] || 1e-10;\r\n    this.obj_ll = options[\"obj_ll\"] || -DBL_MAX;\r\n    this.obj_ul = options[\"obj_ul\"] || +DBL_MAX;\r\n    this.it_lim = options[\"it_lim\"] || INT_MAX;\r\n    this.tm_lim = options[\"tm_lim\"] || INT_MAX;\r\n    this.out_frq = options[\"out_frq\"] || 500;\r\n    this.out_dly = options[\"out_dly\"] || 0;\r\n    this.presolve = options[\"presolve\"] || GLP_OFF;\r\n};\r\n\r\n/***********************************************************************\r\n *  NAME\r\n *\r\n *  glp_get_status - retrieve generic status of basic solution\r\n *\r\n *  SYNOPSIS\r\n *\r\n *  int glp_get_status(glp_prob *lp);\r\n *\r\n *  RETURNS\r\n *\r\n *  The routine glp_get_status reports the generic status of the basic\r\n *  solution for the specified problem object as follows:\r\n *\r\n *  GLP_OPT    - solution is optimal;\r\n *  GLP_FEAS   - solution is feasible;\r\n *  GLP_INFEAS - solution is infeasible;\r\n *  GLP_NOFEAS - problem has no feasible solution;\r\n *  GLP_UNBND  - problem has unbounded solution;\r\n *  GLP_UNDEF  - solution is undefined. */\r\n\r\nvar glp_get_status = exports[\"glp_get_status\"] = function(lp){\r\n    var status;\r\n    status = glp_get_prim_stat(lp);\r\n    switch (status)\r\n    {  case GLP_FEAS:\r\n        switch (glp_get_dual_stat(lp))\r\n        {  case GLP_FEAS:\r\n            status = GLP_OPT;\r\n            break;\r\n            case GLP_NOFEAS:\r\n                status = GLP_UNBND;\r\n                break;\r\n            case GLP_UNDEF:\r\n            case GLP_INFEAS:\r\n                //status = status;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        break;\r\n        case GLP_UNDEF:\r\n        case GLP_INFEAS:\r\n        case GLP_NOFEAS:\r\n            //status = status;\r\n            break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n    return status;\r\n};\r\n\r\nvar glp_get_prim_stat = exports[\"glp_get_prim_stat\"] = function(lp){\r\n    return lp.pbs_stat;\r\n};\r\n\r\nvar glp_get_dual_stat = exports[\"glp_get_dual_stat\"] = function(lp){\r\n    return lp.dbs_stat;\r\n};\r\n\r\nvar glp_get_obj_val = exports[\"glp_get_obj_val\"] = function(lp){\r\n    return lp.obj_val;\r\n};\r\n\r\nvar glp_get_row_stat = exports[\"glp_get_row_stat\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_stat: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].stat;\r\n};\r\n\r\nvar glp_get_row_prim = exports[\"glp_get_row_prim\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_prim: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].prim;\r\n};\r\n\r\nvar glp_get_row_dual = exports[\"glp_get_row_dual\"] = function(lp, i){\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_dual: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].dual;\r\n};\r\n\r\nvar glp_get_col_stat = exports[\"glp_get_col_stat\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_stat: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].stat;\r\n};\r\n\r\nvar glp_get_col_prim = exports[\"glp_get_col_prim\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_prim: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].prim;\r\n};\r\n\r\nvar glp_get_col_dual = exports[\"glp_get_col_dual\"] = function(lp, j){\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_dual: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].dual;\r\n};\r\n\r\nvar glp_get_unbnd_ray = exports[\"glp_get_unbnd_ray\"] = function(lp){\r\n    var k = lp.some;\r\n    xassert(k >= 0);\r\n    if (k > lp.m + lp.n) k = 0;\r\n    return k;\r\n};\r\n\r\nvar glp_set_col_kind = exports[\"glp_set_col_kind\"] = function(mip, j, kind){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_set_col_kind: j = \" + j + \"; column number out of range\");\r\n    var col = mip.col[j];\r\n    switch (kind)\r\n    {  case GLP_CV:\r\n        col.kind = GLP_CV;\r\n        break;\r\n        case GLP_IV:\r\n            col.kind = GLP_IV;\r\n            break;\r\n        case GLP_BV:\r\n            col.kind = GLP_IV;\r\n            if (!(col.type == GLP_DB && col.lb == 0.0 && col.ub ==\r\n                1.0)) glp_set_col_bnds(mip, j, GLP_DB, 0.0, 1.0);\r\n            break;\r\n        default:\r\n            xerror(\"glp_set_col_kind: j = \" + j + \"; kind = \" + kind + \"; invalid column kind\");\r\n    }\r\n};\r\n\r\nvar glp_get_col_kind = exports[\"glp_get_col_kind\"] = function(mip, j){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_get_col_kind: j = \" + j + \"; column number out of range\");\r\n    var col = mip.col[j];\r\n    var kind = col.kind;\r\n    switch (kind)\r\n    {  case GLP_CV:\r\n        break;\r\n        case GLP_IV:\r\n            if (col.type == GLP_DB && col.lb == 0.0 && col.ub == 1.0)\r\n                kind = GLP_BV;\r\n            break;\r\n        default:\r\n            xassert(kind != kind);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar glp_get_num_int = exports[\"glp_get_num_int\"] = function(mip){\r\n    var col;\r\n    var count = 0;\r\n    for (var j = 1; j <= mip.n; j++)\r\n    {  col = mip.col[j];\r\n        if (col.kind == GLP_IV) count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nvar glp_get_num_bin = exports[\"glp_get_num_bin\"] = function(mip){\r\n    var col;\r\n    var count = 0;\r\n    for (var j = 1; j <= mip.n; j++)\r\n    {  col = mip.col[j];\r\n        if (col.kind == GLP_IV && col.type == GLP_DB && col.lb ==\r\n            0.0 && col.ub == 1.0) count++;\r\n    }\r\n    return count;\r\n};\r\n\r\nvar glp_intopt = exports[\"glp_intopt\"] = function(P, parm){\r\n    function solve_mip(P, parm){\r\n        /* solve MIP directly without using the preprocessor */\r\n        var T;\r\n        var ret;\r\n        /* optimal basis to LP relaxation must be provided */\r\n        if (glp_get_status(P) != GLP_OPT)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: optimal basis to initial LP relaxation not provided\");\r\n            ret = GLP_EROOT;\r\n            return ret;\r\n        }\r\n        /* it seems all is ok */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Integer optimization begins...\");\r\n        /* create the branch-and-bound tree */\r\n        T = ios_create_tree(P, parm);\r\n        /* solve the problem instance */\r\n        ret = ios_driver(T);\r\n        /* delete the branch-and-bound tree */\r\n        ios_delete_tree(T);\r\n        /* analyze exit code reported by the mip driver */\r\n        if (ret == 0)\r\n        {  if (P.mip_stat == GLP_FEAS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"INTEGER OPTIMAL SOLUTION FOUND\");\r\n            P.mip_stat = GLP_OPT;\r\n        }\r\n        else\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO INTEGER FEASIBLE SOLUTION\");\r\n            P.mip_stat = GLP_NOFEAS;\r\n        }\r\n        }\r\n        else if (ret == GLP_EMIPGAP)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"RELATIVE MIP GAP TOLERANCE REACHED; SEARCH TERMINATED\");\r\n        }\r\n        else if (ret == GLP_ETMLIM)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n        }\r\n        else if (ret == GLP_EFAIL)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: cannot solve current LP relaxation\");\r\n        }\r\n        else if (ret == GLP_ESTOP)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"SEARCH TERMINATED BY APPLICATION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        return ret;\r\n    }\r\n\r\n    function preprocess_and_solve_mip(P, parm){\r\n        /* solve MIP using the preprocessor */\r\n        var env = get_env_ptr();\r\n        var term_out = env.term_out;\r\n        var npp;\r\n        var mip = null;\r\n        var bfcp = {};\r\n        var ret;\r\n\r\n        function post(){\r\n            npp_postprocess(npp, mip);\r\n            /* the transformed MIP is no longer needed */\r\n            mip = null;\r\n            /* store solution to the original problem */\r\n            npp_unload_sol(npp, P);\r\n            return ret;\r\n        }\r\n\r\n\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Preprocessing...\");\r\n        /* create preprocessor workspace */\r\n        npp = npp_create_wksp();\r\n        /* load original problem into the preprocessor workspace */\r\n        npp_load_prob(npp, P, GLP_OFF, GLP_MIP, GLP_OFF);\r\n        /* process MIP prior to applying the branch-and-bound method */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        ret = npp_integer(npp, parm);\r\n        env.term_out = term_out;\r\n        if (ret == 0)\r\n        {\r\n\r\n        }\r\n        else if (ret == GLP_ENOPFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"PROBLEM HAS NO PRIMAL FEASIBLE SOLUTION\");\r\n        }\r\n        else if (ret == GLP_ENODFS)\r\n        {  if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"LP RELAXATION HAS NO DUAL FEASIBLE SOLUTION\");\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* build transformed MIP */\r\n        mip = glp_create_prob();\r\n        npp_build_prob(npp, mip);\r\n        /* if the transformed MIP is empty, it has empty solution, which\r\n         is optimal */\r\n        if (mip.m == 0 && mip.n == 0)\r\n        {  mip.mip_stat = GLP_OPT;\r\n            mip.mip_obj = mip.c0;\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n            {  xprintf(\"Objective value = \" + mip.mip_obj + \"\");\r\n                xprintf(\"INTEGER OPTIMAL SOLUTION FOUND BY MIP PREPROCESSOR\");\r\n            }\r\n            return post();\r\n        }\r\n        /* display some statistics */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n        {   var ni = glp_get_num_int(mip);\r\n            var nb = glp_get_num_bin(mip);\r\n            var s;\r\n            xprintf(mip.m + \" row\" + (mip.m == 1 ? \"\" : \"s\") + \", \" + mip.n + \" column\" + (mip.n == 1 ? \"\" : \"s\") +\r\n                \", \" + mip.nnz + \" non-zero\" + (mip.nnz == 1 ? \"\" : \"s\") + \"\");\r\n            if (nb == 0)\r\n                s = \"none of\";\r\n            else if (ni == 1 && nb == 1)\r\n                s = \"\";\r\n            else if (nb == 1)\r\n                s = \"one of\";\r\n            else if (nb == ni)\r\n                s = \"all of\";\r\n            else\r\n                s = nb + \" of\";\r\n            xprintf(ni + \" integer variable\" + (ni == 1 ? \"\" : \"s\") + \", \" + s + \" which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n        }\r\n        /* inherit basis factorization control parameters */\r\n        glp_get_bfcp(P, bfcp);\r\n        glp_set_bfcp(mip, bfcp);\r\n        /* scale the transformed problem */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        glp_scale_prob(mip,\r\n            GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP);\r\n        env.term_out = term_out;\r\n        /* build advanced initial basis */\r\n        if (!term_out || parm.msg_lev < GLP_MSG_ALL)\r\n            env.term_out = GLP_OFF;\r\n        else\r\n            env.term_out = GLP_ON;\r\n        glp_adv_basis(mip, 0);\r\n        env.term_out = term_out;\r\n        /* solve initial LP relaxation */\r\n        if (parm.msg_lev >= GLP_MSG_ALL)\r\n            xprintf(\"Solving LP relaxation...\");\r\n        var smcp = new SMCP();\r\n        //glp_init_smcp(smcp);\r\n\r\n        smcp.msg_lev = parm.msg_lev;\r\n        mip.it_cnt = P.it_cnt;\r\n        ret = glp_simplex(mip, smcp);\r\n        P.it_cnt = mip.it_cnt;\r\n        if (ret != 0)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: cannot solve LP relaxation\");\r\n            ret = GLP_EFAIL;\r\n            return ret;\r\n        }\r\n        /* check status of the basic solution */\r\n        ret = glp_get_status(mip);\r\n        if (ret == GLP_OPT)\r\n            ret = 0;\r\n        else if (ret == GLP_NOFEAS)\r\n            ret = GLP_ENOPFS;\r\n        else if (ret == GLP_UNBND)\r\n            ret = GLP_ENODFS;\r\n        else\r\n            xassert(ret != ret);\r\n        if (ret != 0) return ret;\r\n        /* solve the transformed MIP */\r\n        mip.it_cnt = P.it_cnt;\r\n        ret = solve_mip(mip, parm);\r\n        P.it_cnt = mip.it_cnt;\r\n        /* only integer feasible solution can be postprocessed */\r\n        if (!(mip.mip_stat == GLP_OPT || mip.mip_stat == GLP_FEAS))\r\n        {  P.mip_stat = mip.mip_stat;\r\n            return ret;\r\n        }\r\n        return post();\r\n    }\r\n\r\n    /* solve MIP problem with the branch-and-bound method */\r\n    var i, j, ret, col;\r\n    /* check problem object */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_intopt: P = \" + P + \"; invalid problem object\");\r\n    if (P.tree != null)\r\n        xerror(\"glp_intopt: operation not allowed\");\r\n    /* check control parameters */\r\n    if (parm == null){\r\n        parm = new IOCP();\r\n        //glp_init_iocp(parm);\r\n    }\r\n    if (!(parm.msg_lev == GLP_MSG_OFF ||\r\n        parm.msg_lev == GLP_MSG_ERR ||\r\n        parm.msg_lev == GLP_MSG_ON  ||\r\n        parm.msg_lev == GLP_MSG_ALL ||\r\n        parm.msg_lev == GLP_MSG_DBG))\r\n        xerror(\"glp_intopt: msg_lev = \" + parm.msg_lev + \"; invalid parameter\");\r\n    if (!(parm.br_tech == GLP_BR_FFV ||\r\n        parm.br_tech == GLP_BR_LFV ||\r\n        parm.br_tech == GLP_BR_MFV ||\r\n        parm.br_tech == GLP_BR_DTH ||\r\n        parm.br_tech == GLP_BR_PCH))\r\n        xerror(\"glp_intopt: br_tech = \" + parm.br_tech + \"; invalid parameter\");\r\n    if (!(parm.bt_tech == GLP_BT_DFS ||\r\n        parm.bt_tech == GLP_BT_BFS ||\r\n        parm.bt_tech == GLP_BT_BLB ||\r\n        parm.bt_tech == GLP_BT_BPH))\r\n        xerror(\"glp_intopt: bt_tech = \" + parm.bt_tech + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_int && parm.tol_int < 1.0))\r\n        xerror(\"glp_intopt: tol_int = \" + parm.tol_int + \"; invalid parameter\");\r\n    if (!(0.0 < parm.tol_obj && parm.tol_obj < 1.0))\r\n        xerror(\"glp_intopt: tol_obj = \" + parm.tol_obj + \"; invalid parameter\");\r\n    if (parm.tm_lim < 0)\r\n        xerror(\"glp_intopt: tm_lim = \" + parm.tm_lim + \"; invalid parameter\");\r\n    if (parm.out_frq < 0)\r\n        xerror(\"glp_intopt: out_frq = \" + parm.out_frq + \"; invalid parameter\");\r\n    if (parm.out_dly < 0)\r\n        xerror(\"glp_intopt: out_dly = \" + parm.out_dly + \"; invalid parameter\");\r\n    if (!(0 <= parm.cb_size && parm.cb_size <= 256))\r\n        xerror(\"glp_intopt: cb_size = \" + parm.cb_size + \"; invalid parameter\");\r\n    if (!(parm.pp_tech == GLP_PP_NONE ||\r\n        parm.pp_tech == GLP_PP_ROOT ||\r\n        parm.pp_tech == GLP_PP_ALL))\r\n        xerror(\"glp_intopt: pp_tech = \" + parm.pp_tech + \"; invalid parameter\");\r\n    if (parm.mip_gap < 0.0)\r\n        xerror(\"glp_intopt: mip_gap = \" + parm.mip_gap + \"; invalid parameter\");\r\n    if (!(parm.mir_cuts == GLP_ON || parm.mir_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: mir_cuts = \" + parm.mir_cuts + \"; invalid parameter\");\r\n    if (!(parm.gmi_cuts == GLP_ON || parm.gmi_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: gmi_cuts = \" + parm.gmi_cuts + \"; invalid parameter\");\r\n    if (!(parm.cov_cuts == GLP_ON || parm.cov_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: cov_cuts = \" + parm.cov_cuts + \"; invalid parameter\");\r\n    if (!(parm.clq_cuts == GLP_ON || parm.clq_cuts == GLP_OFF))\r\n        xerror(\"glp_intopt: clq_cuts = \" + parm.clq_cuts + \"; invalid parameter\");\r\n    if (!(parm.presolve == GLP_ON || parm.presolve == GLP_OFF))\r\n        xerror(\"glp_intopt: presolve = \" + parm.presolve + \"; invalid parameter\");\r\n    if (!(parm.binarize == GLP_ON || parm.binarize == GLP_OFF))\r\n        xerror(\"glp_intopt: binarize = \" + parm.binarize + \"; invalid parameter\");\r\n    if (!(parm.fp_heur == GLP_ON || parm.fp_heur == GLP_OFF))\r\n        xerror(\"glp_intopt: fp_heur = \" + parm.fp_heur + \"; invalid parameter\");\r\n    /* integer solution is currently undefined */\r\n    P.mip_stat = GLP_UNDEF;\r\n    P.mip_obj = 0.0;\r\n    /* check bounds of double-bounded variables */\r\n    for (i = 1; i <= P.m; i++)\r\n    {   var row = P.row[i];\r\n        if (row.type == GLP_DB && row.lb >= row.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: row \" + i + \": lb = \" + row.lb + \", ub = \" + row.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {   col = P.col[j];\r\n        if (col.type == GLP_DB && col.lb >= col.ub)\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: column \" + j + \": lb = \" + col.lb + \", ub = \" + col.ub + \"; incorrect bounds\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n    }\r\n    /* bounds of all integer variables must be integral */\r\n    for (j = 1; j <= P.n; j++)\r\n    {   col = P.col[j];\r\n        if (col.kind != GLP_IV) continue;\r\n        if (col.type == GLP_LO || col.type == GLP_DB)\r\n        {  if (col.lb != Math.floor(col.lb))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer lower bound \" + col.lb + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n        if (col.type == GLP_UP || col.type == GLP_DB)\r\n        {  if (col.ub != Math.floor(col.ub))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer upper bound \" + col.ub + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n        if (col.type == GLP_FX)\r\n        {  if (col.lb != Math.floor(col.lb))\r\n        {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            xprintf(\"glp_intopt: integer column \" + j + \" has non-integer fixed value \" + col.lb + \"\");\r\n            ret = GLP_EBOUND;\r\n            return ret;\r\n        }\r\n        }\r\n    }\r\n    /* solve MIP problem */\r\n    if (parm.msg_lev >= GLP_MSG_ALL)\r\n    {   var ni = glp_get_num_int(P);\r\n        var nb = glp_get_num_bin(P);\r\n        var s;\r\n        xprintf(\"GLPK Integer Optimizer, v\" + glp_version() + \"\");\r\n        xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" + P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\") + \"\");\r\n        if (nb == 0)\r\n            s = \"none of\";\r\n        else if (ni == 1 && nb == 1)\r\n            s = \"\";\r\n        else if (nb == 1)\r\n            s = \"one of\";\r\n        else if (nb == ni)\r\n            s = \"all of\";\r\n        else\r\n            s = nb + \" of\";\r\n        xprintf(ni + \" integer variable\" + (ni == 1 ? \"\" : \"s\") + \", \" + s + \" which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n    }\r\n    if (!parm.presolve)\r\n        ret = solve_mip(P, parm);\r\n    else\r\n        ret = preprocess_and_solve_mip(P, parm);\r\n    /* return to the application program */\r\n    return ret;\r\n};\r\n\r\nvar IOCP = exports[\"IOCP\"] = /**@constructor*/ function(options){\r\n    options = options || {};\r\n    this.msg_lev = options[\"msg_lev\"] ||  GLP_MSG_ALL;\r\n    this.br_tech = options[\"br_tech\"] || GLP_BR_DTH;\r\n    this.bt_tech = options[\"bt_tech\"] || GLP_BT_BLB;\r\n    this.tol_int = options[\"tol_int\"] || 1e-5;\r\n    this.tol_obj = options[\"tol_obj\"] || 1e-7;\r\n    this.tm_lim = options[\"tm_lim\"] || INT_MAX;\r\n    this.out_frq = options[\"out_frq\"] || 5000;\r\n    this.out_dly = options[\"out_dly\"] || 10000;\r\n    this.cb_func = options[\"cb_func\"] || null;\r\n    this.cb_info = options[\"cb_info\"] || null;\r\n    this.cb_size = options[\"cb_size\"] || 0;\r\n    this.pp_tech = options[\"pp_tech\"] || GLP_PP_ALL;\r\n    this.mip_gap = options[\"mip_gap\"] || 0.0;\r\n    this.mir_cuts = options[\"mir_cuts\"] || GLP_OFF;\r\n    this.gmi_cuts = options[\"gmi_cuts\"] || GLP_OFF;\r\n    this.cov_cuts = options[\"cov_cuts\"] || GLP_OFF;\r\n    this.clq_cuts = options[\"clq_cuts\"] || GLP_OFF;\r\n    this.presolve = options[\"presolve\"] || GLP_OFF;\r\n    this.binarize = options[\"binarize\"] || GLP_OFF;\r\n    this.fp_heur = options[\"fp_heur\"] || GLP_OFF;\r\n};\r\n\r\n/*\r\nvar glp_init_iocp = exports[\"glp_init_iocp\"] = function(parm){\r\n    parm.msg_lev = GLP_MSG_ALL;\r\n    parm.br_tech = GLP_BR_DTH;\r\n    parm.bt_tech = GLP_BT_BLB;\r\n    parm.tol_int = 1e-5;\r\n    parm.tol_obj = 1e-7;\r\n    parm.tm_lim = INT_MAX;\r\n    parm.out_frq = 5000;\r\n    parm.out_dly = 10000;\r\n    parm.cb_func = null;\r\n    parm.cb_info = null;\r\n    parm.cb_size = 0;\r\n    parm.pp_tech = GLP_PP_ALL;\r\n    parm.mip_gap = 0.0;\r\n    parm.mir_cuts = GLP_OFF;\r\n    parm.gmi_cuts = GLP_OFF;\r\n    parm.cov_cuts = GLP_OFF;\r\n    parm.clq_cuts = GLP_OFF;\r\n    parm.presolve = GLP_OFF;\r\n    parm.binarize = GLP_OFF;\r\n    parm.fp_heur = GLP_OFF;\r\n};\r\n*/\r\n\r\nvar glp_mip_status = exports[\"glp_mip_status\"] = function(mip){\r\n    return mip.mip_stat;\r\n};\r\n\r\nvar glp_mip_obj_val = exports[\"glp_mip_obj_val\"] = function(mip){\r\n    return mip.mip_obj;\r\n};\r\n\r\nvar glp_mip_row_val = exports[\"glp_mip_row_val\"] = function(mip, i){\r\n    if (!(1 <= i && i <= mip.m))\r\n        xerror(\"glp_mip_row_val: i = \" + i + \"; row number out of range\");\r\n    return mip.row[i].mipx;\r\n};\r\n\r\nvar glp_mip_col_val = exports[\"glp_mip_col_val\"] = function(mip, j){\r\n    if (!(1 <= j && j <= mip.n))\r\n        xerror(\"glp_mip_col_val: j = \" + j + \"; column number out of range\");\r\n    return mip.col[j].mipx;\r\n};\r\n\r\nfunction glp_check_kkt(P, sol, cond, callback){\r\n    /* check feasibility and optimality conditions */\r\n    var m = P.m;\r\n    var n = P.n;\r\n    var row, col, aij;\r\n    var i, j, ae_ind, re_ind;\r\n    var e, sp, sn, t, ae_max, re_max;\r\n    if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\r\n        xerror(\"glp_check_kkt: sol = \" + sol + \"; invalid solution indicator\");\r\n    if (!(cond == GLP_KKT_PE || cond == GLP_KKT_PB ||\r\n        cond == GLP_KKT_DE || cond == GLP_KKT_DB ||\r\n        cond == GLP_KKT_CS))\r\n        xerror(\"glp_check_kkt: cond = \" + cond + \"; invalid condition indicator \");\r\n    ae_max = re_max = 0.0;\r\n    ae_ind = re_ind = 0;\r\n    if (cond == GLP_KKT_PE)\r\n    {  /* xR - A * xS = 0 */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            sp = sn = 0.0;\r\n            /* t := xR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = row.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = row.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            if (t >= 0.0) sp += t; else sn -= t;\r\n            for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            {  col = aij.col;\r\n                /* t := - a[i,j] * xS[j] */\r\n                if (sol == GLP_SOL)\r\n                    t = - aij.val * col.prim;\r\n                else if (sol == GLP_IPT)\r\n                    t = - aij.val * col.pval;\r\n                else if (sol == GLP_MIP)\r\n                    t = - aij.val * col.mipx;\r\n                else\r\n                    xassert(sol != sol);\r\n                if (t >= 0.0) sp += t; else sn -= t;\r\n            }\r\n            /* absolute error */\r\n            e = Math.abs(sp - sn);\r\n            if (ae_max < e){\r\n                ae_max = e;\r\n                ae_ind = i;\r\n            }\r\n            /* relative error */\r\n            e /= (1.0 + sp + sn);\r\n            if (re_max < e){\r\n                re_max = e;\r\n                re_ind = i;\r\n            }\r\n\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_PB)\r\n    {  /* lR <= xR <= uR */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            /* t := xR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = row.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = row.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            /* check lower bound */\r\n            if (row.type == GLP_LO || row.type == GLP_DB ||\r\n                row.type == GLP_FX)\r\n            {  if (t < row.lb)\r\n            {  /* absolute error */\r\n                e = row.lb - t;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = i;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(row.lb));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = i;\r\n                }\r\n            }\r\n            }\r\n            /* check upper bound */\r\n            if (row.type == GLP_UP || row.type == GLP_DB ||\r\n                row.type == GLP_FX)\r\n            {  if (t > row.ub)\r\n            {  /* absolute error */\r\n                e = t - row.ub;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = i;\r\n                }\r\n\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(row.ub));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = i;\r\n                }\r\n            }\r\n            }\r\n        }\r\n        /* lS <= xS <= uS */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            /* t := xS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.prim;\r\n            else if (sol == GLP_IPT)\r\n                t = col.pval;\r\n            else if (sol == GLP_MIP)\r\n                t = col.mipx;\r\n            else\r\n                xassert(sol != sol);\r\n            /* check lower bound */\r\n            if (col.type == GLP_LO || col.type == GLP_DB ||\r\n                col.type == GLP_FX)\r\n            {  if (t < col.lb)\r\n            {  /* absolute error */\r\n                e = col.lb - t;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = m+j;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(col.lb));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n            /* check upper bound */\r\n            if (col.type == GLP_UP || col.type == GLP_DB ||\r\n                col.type == GLP_FX)\r\n            {  if (t > col.ub)\r\n            {  /* absolute error */\r\n                e = t - col.ub;\r\n                if (ae_max < e){\r\n                    ae_max = e;\r\n                    ae_ind = m+j;\r\n                }\r\n                /* relative error */\r\n                e /= (1.0 + Math.abs(col.ub));\r\n                if (re_max < e){\r\n                    re_max = e;\r\n                    re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_DE)\r\n    {  /* A' * (lambdaR - cR) + (lambdaS - cS) = 0 */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            sp = sn = 0.0;\r\n            /* t := lambdaS[j] - cS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.dual - col.coef;\r\n            else if (sol == GLP_IPT)\r\n                t = col.dval - col.coef;\r\n            else\r\n                xassert(sol != sol);\r\n            if (t >= 0.0) sp += t; else sn -= t;\r\n            for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            {  row = aij.row;\r\n                /* t := a[i,j] * (lambdaR[i] - cR[i]) */\r\n                if (sol == GLP_SOL)\r\n                    t = aij.val * row.dual;\r\n                else if (sol == GLP_IPT)\r\n                    t = aij.val * row.dval;\r\n                else\r\n                    xassert(sol != sol);\r\n                if (t >= 0.0) sp += t; else sn -= t;\r\n            }\r\n            /* absolute error */\r\n            e = Math.abs(sp - sn);\r\n            if (ae_max < e){\r\n                ae_max = e;\r\n                ae_ind = m+j;\r\n            }\r\n            /* relative error */\r\n            e /= (1.0 + sp + sn);\r\n            if (re_max < e){\r\n                re_max = e;\r\n                re_ind = m+j;\r\n            }\r\n        }\r\n    }\r\n    else if (cond == GLP_KKT_DB)\r\n    {  /* check lambdaR */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = P.row[i];\r\n            /* t := lambdaR[i] */\r\n            if (sol == GLP_SOL)\r\n                t = row.dual;\r\n            else if (sol == GLP_IPT)\r\n                t = row.dval;\r\n            else\r\n                xassert(sol != sol);\r\n            /* correct sign */\r\n            if (P.dir == GLP_MIN)\r\n                t = + t;\r\n            else if (P.dir == GLP_MAX)\r\n                t = - t;\r\n            else\r\n                xassert(P != P);\r\n            /* check for positivity */\r\n            if (row.stat == GLP_NF || row.stat == GLP_NL)\r\n            {  if (t < 0.0)\r\n            {  e = - t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = i;\r\n                }\r\n            }\r\n            }\r\n            /* check for negativity */\r\n            if (row.stat == GLP_NF || row.stat == GLP_NU)\r\n            {  if (t > 0.0)\r\n            {  e = + t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = i;\r\n                }\r\n            }\r\n            }\r\n        }\r\n        /* check lambdaS */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = P.col[j];\r\n            /* t := lambdaS[j] */\r\n            if (sol == GLP_SOL)\r\n                t = col.dual;\r\n            else if (sol == GLP_IPT)\r\n                t = col.dval;\r\n            else\r\n                xassert(sol != sol);\r\n            /* correct sign */\r\n            if (P.dir == GLP_MIN)\r\n                t = + t;\r\n            else if (P.dir == GLP_MAX)\r\n                t = - t;\r\n            else\r\n                xassert(P != P);\r\n            /* check for positivity */\r\n            if (col.stat == GLP_NF || col.stat == GLP_NL)\r\n            {  if (t < 0.0)\r\n            {  e = - t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n            /* check for negativity */\r\n            if (col.stat == GLP_NF || col.stat == GLP_NU)\r\n            {  if (t > 0.0)\r\n            {  e = + t;\r\n                if (ae_max < e){\r\n                    ae_max = re_max = e;\r\n                    ae_ind = re_ind = m+j;\r\n                }\r\n            }\r\n            }\r\n        }\r\n    }\r\n    else\r\n        xassert(cond != cond);\r\n\r\n    callback(ae_max, ae_ind, re_max, re_ind);\r\n}\r\n\r\nvar glp_bf_exists = exports[\"glp_bf_exists\"] = function(lp){\r\n    return (lp.m == 0 || lp.valid);\r\n};\r\n\r\nvar glp_factorize = exports[\"glp_factorize\"] = function(lp){\r\n\r\n    function b_col(lp, j, ind, val){\r\n        var m = lp.m;\r\n        var aij;\r\n        var k, len;\r\n        xassert(1 <= j && j <= m);\r\n        /* determine the ordinal number of basic auxiliary or structural\r\n         variable x[k] corresponding to basic variable xB[j] */\r\n        k = lp.head[j];\r\n        /* build j-th column of the basic matrix, which is k-th column of\r\n         the scaled augmented matrix (I | -R*A*S) */\r\n        if (k <= m)\r\n        {  /* x[k] is auxiliary variable */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* x[k] is structural variable */\r\n            len = 0;\r\n            for (aij = lp.col[k-m].ptr; aij != null; aij = aij.c_next)\r\n            {  len++;\r\n                ind[len] = aij.row.i;\r\n                val[len] = - aij.row.rii * aij.val * aij.col.sjj;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var head = lp.head;\r\n    var j, k, stat, ret;\r\n    /* invalidate the basis factorization */\r\n    lp.valid = 0;\r\n    /* build the basis header */\r\n    j = 0;\r\n    for (k = 1; k <= m+n; k++)\r\n    {  if (k <= m)\r\n    {  stat = row[k].stat;\r\n        row[k].bind = 0;\r\n    }\r\n    else\r\n    {  stat = col[k-m].stat;\r\n        col[k-m].bind = 0;\r\n    }\r\n        if (stat == GLP_BS)\r\n        {  j++;\r\n            if (j > m)\r\n            {  /* too many basic variables */\r\n                ret = GLP_EBADB;\r\n                return ret;\r\n            }\r\n            head[j] = k;\r\n            if (k <= m)\r\n                row[k].bind = j;\r\n            else\r\n                col[k-m].bind = j;\r\n        }\r\n    }\r\n    if (j < m)\r\n    {  /* too few basic variables */\r\n        ret = GLP_EBADB;\r\n        return ret;\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    if (m > 0)\r\n    {  if (lp.bfd == null)\r\n    {  lp.bfd = bfd_create_it();\r\n        copy_bfcp(lp);\r\n    }\r\n        switch (bfd_factorize(lp.bfd, m, lp.head, b_col, lp))\r\n        {  case 0:\r\n            /* ok */\r\n            break;\r\n            case BFD_ESING:\r\n                /* singular matrix */\r\n                ret = GLP_ESING;\r\n                return ret;\r\n            case BFD_ECOND:\r\n                /* ill-conditioned matrix */\r\n                ret = GLP_ECOND;\r\n                return ret;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        lp.valid = 1;\r\n    }\r\n    /* factorization successful */\r\n    ret = 0;\r\n    /* bring the return code to the calling program */\r\n    return ret;\r\n};\r\n\r\nvar glp_bf_updated = exports[\"glp_bf_updated\"] = function(lp){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_bf_update: basis factorization does not exist\");\r\n    return (lp.m == 0 ? 0 : bfd_get_count(lp.bfd));\r\n};\r\n\r\nvar glp_get_bfcp = exports[\"glp_get_bfcp\"] = function(lp, parm){\r\n    var bfcp = lp.bfcp;\r\n    if (bfcp == null)\r\n    {  parm.type = GLP_BF_FT;\r\n        parm.lu_size = 0;\r\n        parm.piv_tol = 0.10;\r\n        parm.piv_lim = 4;\r\n        parm.suhl = GLP_ON;\r\n        parm.eps_tol = 1e-15;\r\n        parm.max_gro = 1e+10;\r\n        parm.nfs_max = 100;\r\n        parm.upd_tol = 1e-6;\r\n        parm.nrs_max = 100;\r\n        parm.rs_size = 0;\r\n    }\r\n    else\r\n        xcopyObj(parm, bfcp);\r\n};\r\n\r\nfunction copy_bfcp(lp){\r\n    var parm = {};\r\n    glp_get_bfcp(lp, parm);\r\n    bfd_set_parm(lp.bfd, parm);\r\n}\r\n\r\nvar glp_set_bfcp = exports[\"glp_set_bfcp\"] = function(lp, parm){\r\n    var bfcp = lp.bfcp;\r\n    if (parm == null)\r\n    {  /* reset to default values */\r\n        if (bfcp != null)\r\n            lp.bfcp = null;\r\n    }\r\n    else\r\n    {  /* set to specified values */\r\n        if (bfcp == null)\r\n            bfcp = lp.bfcp = {};\r\n        xcopyObj(bfcp, parm);\r\n        if (!(bfcp.type == GLP_BF_FT || bfcp.type == GLP_BF_BG ||\r\n            bfcp.type == GLP_BF_GR))\r\n            xerror(\"glp_set_bfcp: type = \" + bfcp.type + \"; invalid parameter\");\r\n        if (bfcp.lu_size < 0)\r\n            xerror(\"glp_set_bfcp: lu_size = \" + bfcp.lu_size + \"; invalid parameter\");\r\n        if (!(0.0 < bfcp.piv_tol && bfcp.piv_tol < 1.0))\r\n            xerror(\"glp_set_bfcp: piv_tol = \" + bfcp.piv_tol + \"; invalid parameter\");\r\n        if (bfcp.piv_lim < 1)\r\n            xerror(\"glp_set_bfcp: piv_lim = \" + bfcp.piv_lim + \"; invalid parameter\");\r\n        if (!(bfcp.suhl == GLP_ON || bfcp.suhl == GLP_OFF))\r\n            xerror(\"glp_set_bfcp: suhl = \" + bfcp.suhl + \"; invalid parameter\");\r\n        if (!(0.0 <= bfcp.eps_tol && bfcp.eps_tol <= 1e-6))\r\n            xerror(\"glp_set_bfcp: eps_tol = \" + bfcp.eps_tol + \"; invalid parameter\");\r\n        if (bfcp.max_gro < 1.0)\r\n            xerror(\"glp_set_bfcp: max_gro = \" + bfcp.max_gro + \"; invalid parameter\");\r\n        if (!(1 <= bfcp.nfs_max && bfcp.nfs_max <= 32767))\r\n            xerror(\"glp_set_bfcp: nfs_max = \" + bfcp.nfs_max + \"; invalid parameter\");\r\n        if (!(0.0 < bfcp.upd_tol && bfcp.upd_tol < 1.0))\r\n            xerror(\"glp_set_bfcp: upd_tol = \" + bfcp.upd_tol + \"; invalid parameter\");\r\n        if (!(1 <= bfcp.nrs_max && bfcp.nrs_max <= 32767))\r\n            xerror(\"glp_set_bfcp: nrs_max = \" + bfcp.nrs_max + \"; invalid parameter\");\r\n        if (bfcp.rs_size < 0)\r\n            xerror(\"glp_set_bfcp: rs_size = \" + bfcp.nrs_max + \"; invalid parameter\");\r\n        if (bfcp.rs_size == 0)\r\n            bfcp.rs_size = 20 * bfcp.nrs_max;\r\n    }\r\n    if (lp.bfd != null) copy_bfcp(lp);\r\n};\r\n\r\nvar glp_get_bhead = exports[\"glp_get_bhead\"] = function(lp, k){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_bhead: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= lp.m))\r\n        xerror(\"glp_get_bhead: k = \" + k + \"; index out of range\");\r\n    return lp.head[k];\r\n};\r\n\r\nvar glp_get_row_bind = exports[\"glp_get_row_bind\"] = function(lp, i){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_row_bind: basis factorization does not exist\");\r\n    if (!(1 <= i && i <= lp.m))\r\n        xerror(\"glp_get_row_bind: i = \" + i + \"; row number out of range\");\r\n    return lp.row[i].bind;\r\n};\r\n\r\nvar glp_get_col_bind = exports[\"glp_get_col_bind\"] = function(lp, j){\r\n    if (!(lp.m == 0 || lp.valid))\r\n        xerror(\"glp_get_col_bind: basis factorization does not exist\");\r\n    if (!(1 <= j && j <= lp.n))\r\n        xerror(\"glp_get_col_bind: j = \" + j + \"; column number out of range\");\r\n    return lp.col[j].bind;\r\n};\r\n\r\nvar glp_ftran = exports[\"glp_ftran\"] = function(lp, x){\r\n    var m = lp.m;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var i, k;\r\n    /* B*x = b ===> (R*B*SB)*(inv(SB)*x) = R*b ===>\r\n     B\"*x\" = b\", where b\" = R*b, x = SB*x\" */\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_ftran: basis factorization does not exist\");\r\n    /* b\" := R*b */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] *= row[i].rii;\r\n    /* x\" := inv(B\")*b\" */\r\n    if (m > 0) bfd_ftran(lp.bfd, x);\r\n    /* x := SB*x\" */\r\n    for (i = 1; i <= m; i++)\r\n    {  k = lp.head[i];\r\n        if (k <= m)\r\n            x[i] /= row[k].rii;\r\n        else\r\n            x[i] *= col[k-m].sjj;\r\n    }\r\n};\r\n\r\nvar glp_btran = exports[\"glp_btran\"] = function(lp, x){\r\n    var m = lp.m;\r\n    var row = lp.row;\r\n    var col = lp.col;\r\n    var i, k;\r\n    /* B'*x = b ===> (SB*B'*R)*(inv(R)*x) = SB*b ===>\r\n     (B\")'*x\" = b\", where b\" = SB*b, x = R*x\" */\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_btran: basis factorization does not exist\");\r\n    /* b\" := SB*b */\r\n    for (i = 1; i <= m; i++)\r\n    {  k = lp.head[i];\r\n        if (k <= m)\r\n            x[i] /= row[k].rii;\r\n        else\r\n            x[i] *= col[k-m].sjj;\r\n    }\r\n    /* x\" := inv[(B\")']*b\" */\r\n    if (m > 0) bfd_btran(lp.bfd, x);\r\n    /* x := R*x\" */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] *= row[i].rii;\r\n};\r\n\r\nvar glp_warm_up = exports[\"glp_warm_up\"] = function(P){\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, type, stat, ret;\r\n    var eps, temp, work;\r\n    /* invalidate basic solution */\r\n    P.pbs_stat = P.dbs_stat = GLP_UNDEF;\r\n    P.obj_val = 0.0;\r\n    P.some = 0;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        row.prim = row.dual = 0.0;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        col.prim = col.dual = 0.0;\r\n    }\r\n    /* compute the basis factorization, if necessary */\r\n    if (!glp_bf_exists(P))\r\n    {  ret = glp_factorize(P);\r\n        if (ret != 0) return ret;\r\n    }\r\n    /* allocate working array */\r\n    work = new Float64Array(1+P.m);\r\n    /* determine and store values of non-basic variables, compute\r\n     vector (- N * xN) */\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat == GLP_BS)\r\n            continue;\r\n        else if (row.stat == GLP_NL)\r\n            row.prim = row.lb;\r\n        else if (row.stat == GLP_NU)\r\n            row.prim = row.ub;\r\n        else if (row.stat == GLP_NF)\r\n            row.prim = 0.0;\r\n        else if (row.stat == GLP_NS)\r\n            row.prim = row.lb;\r\n        else\r\n            xassert(row != row);\r\n        /* N[j] is i-th column of matrix (I|-A) */\r\n        work[i] -= row.prim;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n            continue;\r\n        else if (col.stat == GLP_NL)\r\n            col.prim = col.lb;\r\n        else if (col.stat == GLP_NU)\r\n            col.prim = col.ub;\r\n        else if (col.stat == GLP_NF)\r\n            col.prim = 0.0;\r\n        else if (col.stat == GLP_NS)\r\n            col.prim = col.lb;\r\n        else\r\n            xassert(col != col);\r\n        /* N[j] is (m+j)-th column of matrix (I|-A) */\r\n        if (col.prim != 0.0)\r\n        {  for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            work[aij.row.i] += aij.val * col.prim;\r\n        }\r\n    }\r\n    /* compute vector of basic variables xB = - inv(B) * N * xN */\r\n    glp_ftran(P, work);\r\n    /* store values of basic variables, check primal feasibility */\r\n    P.pbs_stat = GLP_FEAS;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat != GLP_BS)\r\n            continue;\r\n        row.prim = work[row.bind];\r\n        type = row.type;\r\n        if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(row.lb);\r\n            if (row.prim < row.lb - eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n        if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(row.ub);\r\n            if (row.prim > row.ub + eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat != GLP_BS)\r\n            continue;\r\n        col.prim = work[col.bind];\r\n        type = col.type;\r\n        if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(col.lb);\r\n            if (col.prim < col.lb - eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n        if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n        {  eps = 1e-6 + 1e-9 * Math.abs(col.ub);\r\n            if (col.prim > col.ub + eps)\r\n                P.pbs_stat = GLP_INFEAS;\r\n        }\r\n    }\r\n    /* compute value of the objective function */\r\n    P.obj_val = P.c0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        P.obj_val += col.coef * col.prim;\r\n    }\r\n    /* build vector cB of objective coefficients at basic variables */\r\n    for (i = 1; i <= P.m; i++)\r\n        work[i] = 0.0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n            work[col.bind] = col.coef;\r\n    }\r\n    /* compute vector of simplex multipliers pi = inv(B') * cB */\r\n    glp_btran(P, work);\r\n    /* compute and store reduced costs of non-basic variables d[j] =\r\n     c[j] - N'[j] * pi, check dual feasibility */\r\n    P.dbs_stat = GLP_FEAS;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.stat == GLP_BS)\r\n        {  row.dual = 0.0;\r\n            continue;\r\n        }\r\n        /* N[j] is i-th column of matrix (I|-A) */\r\n        row.dual = - work[i];\r\n        stat = row.stat;\r\n        temp = (P.dir == GLP_MIN ? + row.dual : - row.dual);\r\n        if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\r\n            (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\r\n            P.dbs_stat = GLP_INFEAS;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.stat == GLP_BS)\r\n        {  col.dual = 0.0;\r\n            continue;\r\n        }\r\n        /* N[j] is (m+j)-th column of matrix (I|-A) */\r\n        col.dual = col.coef;\r\n        for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n            col.dual += aij.val * work[aij.row.i];\r\n        stat = col.stat;\r\n        temp = (P.dir == GLP_MIN ? + col.dual : - col.dual);\r\n        if ((stat == GLP_NF || stat == GLP_NL) && temp < -1e-5 ||\r\n            (stat == GLP_NF || stat == GLP_NU) && temp > +1e-5)\r\n            P.dbs_stat = GLP_INFEAS;\r\n    }\r\n    /* free working array */\r\n    return 0;\r\n};\r\n\r\nvar glp_eval_tab_row = exports[\"glp_eval_tab_row\"] = function(lp, k, ind, val){\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var i, t, len, lll, iii;\r\n    var alfa, rho, vvv;\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_eval_tab_row: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_eval_tab_row: k = \" + k + \"; variable number out of range\");\r\n    /* determine xB[i] which corresponds to x[k] */\r\n    if (k <= m)\r\n        i = glp_get_row_bind(lp, k);\r\n    else\r\n        i = glp_get_col_bind(lp, k-m);\r\n    if (i == 0)\r\n        xerror(\"glp_eval_tab_row: k = \" + k + \"; variable must be basic\");\r\n    xassert(1 <= i && i <= m);\r\n    /* allocate working arrays */\r\n    rho = new Float64Array(1+m);\r\n    iii = new Int32Array(1+m);\r\n    vvv = new Float64Array(1+m);\r\n    /* compute i-th row of the inverse; see (8) */\r\n    rho[i] = 1.0;\r\n    glp_btran(lp, rho);\r\n    /* compute i-th row of the simplex table */\r\n    len = 0;\r\n    for (k = 1; k <= m+n; k++)\r\n    {  if (k <= m)\r\n    {  /* x[k] is auxiliary variable, so N[k] is a unity column */\r\n        if (glp_get_row_stat(lp, k) == GLP_BS) continue;\r\n        /* compute alfa[i,j]; see (9) */\r\n        alfa = - rho[k];\r\n    }\r\n    else\r\n    {  /* x[k] is structural variable, so N[k] is a column of the\r\n     original constraint matrix A with negative sign */\r\n        if (glp_get_col_stat(lp, k-m) == GLP_BS) continue;\r\n        /* compute alfa[i,j]; see (9) */\r\n        lll = glp_get_mat_col(lp, k-m, iii, vvv);\r\n        alfa = 0.0;\r\n        for (t = 1; t <= lll; t++) alfa += rho[iii[t]] * vvv[t];\r\n    }\r\n        /* store alfa[i,j] */\r\n        if (alfa != 0.0) {\r\n            len++;\r\n            ind[len] = k;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    xassert(len <= n);\r\n    /* return to the calling program */\r\n    return len;\r\n};\r\n\r\nvar glp_eval_tab_col = exports[\"glp_eval_tab_col\"] = function(lp, k, ind, val){\r\n    var m = lp.m;\r\n    var n = lp.n;\r\n    var t, len, stat;\r\n    var col;\r\n    if (!(m == 0 || lp.valid))\r\n        xerror(\"glp_eval_tab_col: basis factorization does not exist\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_eval_tab_col: k = \" + k + \"; variable number out of range\");\r\n    if (k <= m)\r\n        stat = glp_get_row_stat(lp, k);\r\n    else\r\n        stat = glp_get_col_stat(lp, k-m);\r\n    if (stat == GLP_BS)\r\n        xerror(\"glp_eval_tab_col: k = \" + k + \"; variable must be non-basic\");\r\n    /* obtain column N[k] with negative sign */\r\n    col = new Float64Array(1+m);\r\n    if (k <= m)\r\n    {  /* x[k] is auxiliary variable, so N[k] is a unity column */\r\n        col[k] = -1.0;\r\n    }\r\n    else\r\n    {  /* x[k] is structural variable, so N[k] is a column of the\r\n     original constraint matrix A with negative sign */\r\n        len = glp_get_mat_col(lp, k-m, ind, val);\r\n        for (t = 1; t <= len; t++) col[ind[t]] = val[t];\r\n    }\r\n    /* compute column of the simplex table, which corresponds to the\r\n     specified non-basic variable x[k] */\r\n    glp_ftran(lp, col);\r\n    len = 0;\r\n    for (t = 1; t <= m; t++)\r\n    {  if (col[t] != 0.0)\r\n    {  len++;\r\n        ind[len] = glp_get_bhead(lp, t);\r\n        val[len] = col[t];\r\n    }\r\n    }\r\n    /* return to the calling program */\r\n    return len;\r\n};\r\n\r\nvar glp_transform_row = exports[\"glp_transform_row\"] = function(P, len, ind, val){\r\n    var i, j, k, m, n, t, lll, iii;\r\n    var alfa, a, aB, rho, vvv;\r\n    if (!glp_bf_exists(P))\r\n        xerror(\"glp_transform_row: basis factorization does not exist \");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* unpack the row to be transformed to the array a */\r\n    a = new Float64Array(1+n);\r\n    if (!(0 <= len && len <= n))\r\n        xerror(\"glp_transform_row: len = \" + len + \"; invalid row length\");\r\n    for (t = 1; t <= len; t++)\r\n    {  j = ind[t];\r\n        if (!(1 <= j && j <= n))\r\n            xerror(\"glp_transform_row: ind[\" + t + \"] = \" + j + \"; column index out of range\");\r\n        if (val[t] == 0.0)\r\n            xerror(\"glp_transform_row: val[\" + t + \"] = 0; zero coefficient not allowed\");\r\n        if (a[j] != 0.0)\r\n            xerror(\"glp_transform_row: ind[\" + t + \"] = \" + j + \"; duplicate column indices not allowed\");\r\n        a[j] = val[t];\r\n    }\r\n    /* construct the vector aB */\r\n    aB = new Float64Array(1+m);\r\n    for (i = 1; i <= m; i++)\r\n    {  k = glp_get_bhead(P, i);\r\n        /* xB[i] is k-th original variable */\r\n        xassert(1 <= k && k <= m+n);\r\n        aB[i] = (k <= m ? 0.0 : a[k-m]);\r\n    }\r\n    /* solve the system B'*rho = aB to compute the vector rho */\r\n    rho = aB; glp_btran(P, rho);\r\n    /* compute coefficients at non-basic auxiliary variables */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (glp_get_row_stat(P, i) != GLP_BS)\r\n    {  alfa = - rho[i];\r\n        if (alfa != 0.0)\r\n        {  len++;\r\n            ind[len] = i;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    }\r\n    /* compute coefficients at non-basic structural variables */\r\n    iii = new Int32Array(1+m);\r\n    vvv = new Float64Array(1+m);\r\n    for (j = 1; j <= n; j++)\r\n    {  if (glp_get_col_stat(P, j) != GLP_BS)\r\n    {  alfa = a[j];\r\n        lll = glp_get_mat_col(P, j, iii, vvv);\r\n        for (t = 1; t <= lll; t++) alfa += vvv[t] * rho[iii[t]];\r\n        if (alfa != 0.0)\r\n        {  len++;\r\n            ind[len] = m+j;\r\n            val[len] = alfa;\r\n        }\r\n    }\r\n    }\r\n    xassert(len <= n);\r\n    return len;\r\n};\r\n\r\nvar glp_transform_col = exports[\"glp_transform_col\"] = function(P, len, ind, val){\r\n    var i, m, t;\r\n    var a, alfa;\r\n    if (!glp_bf_exists(P))\r\n        xerror(\"glp_transform_col: basis factorization does not exist \");\r\n    m = glp_get_num_rows(P);\r\n    /* unpack the column to be transformed to the array a */\r\n    a = new Float64Array(1+m);\r\n    if (!(0 <= len && len <= m))\r\n        xerror(\"glp_transform_col: len = \" + len + \"; invalid column length\");\r\n    for (t = 1; t <= len; t++)\r\n    {  i = ind[t];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"glp_transform_col: ind[\" + t + \"] = \" + i + \"; row index out of range\");\r\n        if (val[t] == 0.0)\r\n            xerror(\"glp_transform_col: val[\" + t + \"] = 0; zero coefficient not allowed\");\r\n        if (a[i] != 0.0)\r\n            xerror(\"glp_transform_col: ind[\" + t + \"] = \" + i + \"; duplicate row indices not allowed\");\r\n        a[i] = val[t];\r\n    }\r\n    /* solve the system B*a = alfa to compute the vector alfa */\r\n    alfa = a; glp_ftran(P, alfa);\r\n    /* store resultant coefficients */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (alfa[i] != 0.0)\r\n    {  len++;\r\n        ind[len] = glp_get_bhead(P, i);\r\n        val[len] = alfa[i];\r\n    }\r\n    }\r\n    return len;\r\n};\r\n\r\nvar glp_prim_rtest = exports[\"glp_prim_rtest\"] = function(P, len, ind, val, dir, eps){\r\n    var k, m, n, piv, t, type, stat;\r\n    var alfa, big, beta, lb, ub, temp, teta;\r\n    if (glp_get_prim_stat(P) != GLP_FEAS)\r\n        xerror(\"glp_prim_rtest: basic solution is not primal feasible \");\r\n    if (!(dir == +1 || dir == -1))\r\n        xerror(\"glp_prim_rtest: dir = \" + dir + \"; invalid parameter\");\r\n    if (!(0.0 < eps && eps < 1.0))\r\n        xerror(\"glp_prim_rtest: eps = \" + eps + \"; invalid parameter\");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* initial settings */\r\n    piv = 0; teta = DBL_MAX; big = 0.0;\r\n    /* walk through the entries of the specified column */\r\n    for (t = 1; t <= len; t++)\r\n    {  /* get the ordinal number of basic variable */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= m+n))\r\n            xerror(\"glp_prim_rtest: ind[\" + t + \"] = \" + k + \"; variable number out of range\");\r\n        /* determine type, bounds, status and primal value of basic\r\n         variable xB[i] = x[k] in the current basic solution */\r\n        if (k <= m)\r\n        {  type = glp_get_row_type(P, k);\r\n            lb = glp_get_row_lb(P, k);\r\n            ub = glp_get_row_ub(P, k);\r\n            stat = glp_get_row_stat(P, k);\r\n            beta = glp_get_row_prim(P, k);\r\n        }\r\n        else\r\n        {  type = glp_get_col_type(P, k-m);\r\n            lb = glp_get_col_lb(P, k-m);\r\n            ub = glp_get_col_ub(P, k-m);\r\n            stat = glp_get_col_stat(P, k-m);\r\n            beta = glp_get_col_prim(P, k-m);\r\n        }\r\n        if (stat != GLP_BS)\r\n            xerror(\"glp_prim_rtest: ind[\" + t + \"] = \" + k + \"; non-basic variable not allowed\");\r\n        /* determine influence coefficient at basic variable xB[i]\r\n         in the explicitly specified column and turn to the case of\r\n         increasing the variable x in order to simplify the program\r\n         logic */\r\n        alfa = (dir > 0 ? + val[t] : - val[t]);\r\n        /* analyze main cases */\r\n        if (type == GLP_FR)\r\n        {  /* xB[i] is free variable */\r\n            continue;\r\n        }\r\n        else if (type == GLP_LO)\r\n        {  /* xB[i] has an lower bound */\r\n            if (alfa > - eps) continue;\r\n            temp = (lb - beta) / alfa;\r\n        }\r\n        else if (type == GLP_UP)\r\n        {  /* xB[i] has an upper bound */\r\n            if (alfa < + eps) continue;\r\n            temp = (ub - beta) / alfa;\r\n        }\r\n        else if (type == GLP_DB)\r\n        {  /* xB[i] has both lower and upper bounds */\r\n            if (alfa < 0.0)\r\n            {  /* xB[i] has an lower bound */\r\n                if (alfa > - eps) continue;\r\n                temp = (lb - beta) / alfa;\r\n            } else {\r\n                /* xB[i] has an upper bound */\r\n                if (alfa < + eps) continue;\r\n                temp = (ub - beta) / alfa;\r\n            }\r\n        }\r\n        else if (type == GLP_FX)\r\n        {  /* xB[i] is fixed variable */\r\n            if (- eps < alfa && alfa < + eps) continue;\r\n            temp = 0.0;\r\n        }\r\n        else\r\n            xassert(type != type);\r\n        /* if the value of the variable xB[i] violates its lower or\r\n         upper bound (slightly, because the current basis is assumed\r\n         to be primal feasible), temp is negative; we can think this\r\n         happens due to round-off errors and the value is exactly on\r\n         the bound; this allows replacing temp by zero */\r\n        if (temp < 0.0) temp = 0.0;\r\n        /* apply the minimal ratio test */\r\n        if (teta > temp || teta == temp && big < Math.abs(alfa)){\r\n            piv = t;\r\n            teta = temp;\r\n            big = Math.abs(alfa);\r\n        }\r\n\r\n    }\r\n    /* return index of the pivot element chosen */\r\n    return piv;\r\n};\r\n\r\nvar glp_dual_rtest = exports[\"glp_dual_rtest\"] = function(P, len, ind, val, dir, eps){\r\n    var k, m, n, piv, t, stat;\r\n    var alfa, big, cost, obj, temp, teta;\r\n    if (glp_get_dual_stat(P) != GLP_FEAS)\r\n        xerror(\"glp_dual_rtest: basic solution is not dual feasible\");\r\n    if (!(dir == +1 || dir == -1))\r\n        xerror(\"glp_dual_rtest: dir = \" + dir + \"; invalid parameter\");\r\n    if (!(0.0 < eps && eps < 1.0))\r\n        xerror(\"glp_dual_rtest: eps = \" + eps + \"; invalid parameter\");\r\n    m = glp_get_num_rows(P);\r\n    n = glp_get_num_cols(P);\r\n    /* take into account optimization direction */\r\n    obj = (glp_get_obj_dir(P) == GLP_MIN ? +1.0 : -1.0);\r\n    /* initial settings */\r\n    piv = 0; teta = DBL_MAX; big = 0.0;\r\n    /* walk through the entries of the specified row */\r\n    for (t = 1; t <= len; t++)\r\n    {  /* get ordinal number of non-basic variable */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= m+n))\r\n            xerror(\"glp_dual_rtest: ind[\" + t + \"] = \" + k + \"; variable number out of range\");\r\n        /* determine status and reduced cost of non-basic variable\r\n         x[k] = xN[j] in the current basic solution */\r\n        if (k <= m)\r\n        {  stat = glp_get_row_stat(P, k);\r\n            cost = glp_get_row_dual(P, k);\r\n        }\r\n        else\r\n        {  stat = glp_get_col_stat(P, k-m);\r\n            cost = glp_get_col_dual(P, k-m);\r\n        }\r\n        if (stat == GLP_BS)\r\n            xerror(\"glp_dual_rtest: ind[\" + t + \"] = \" + k + \"; basic variable not allowed\");\r\n        /* determine influence coefficient at non-basic variable xN[j]\r\n         in the explicitly specified row and turn to the case of\r\n         increasing the variable x in order to simplify the program\r\n         logic */\r\n        alfa = (dir > 0 ? + val[t] : - val[t]);\r\n        /* analyze main cases */\r\n        if (stat == GLP_NL)\r\n        {  /* xN[j] is on its lower bound */\r\n            if (alfa < + eps) continue;\r\n            temp = (obj * cost) / alfa;\r\n        }\r\n        else if (stat == GLP_NU)\r\n        {  /* xN[j] is on its upper bound */\r\n            if (alfa > - eps) continue;\r\n            temp = (obj * cost) / alfa;\r\n        }\r\n        else if (stat == GLP_NF)\r\n        {  /* xN[j] is non-basic free variable */\r\n            if (- eps < alfa && alfa < + eps) continue;\r\n            temp = 0.0;\r\n        }\r\n        else if (stat == GLP_NS)\r\n        {  /* xN[j] is non-basic fixed variable */\r\n            continue;\r\n        }\r\n        else\r\n            xassert(stat != stat);\r\n        /* if the reduced cost of the variable xN[j] violates its zero\r\n         bound (slightly, because the current basis is assumed to be\r\n         dual feasible), temp is negative; we can think this happens\r\n         due to round-off errors and the reduced cost is exact zero;\r\n         this allows replacing temp by zero */\r\n        if (temp < 0.0) temp = 0.0;\r\n        /* apply the minimal ratio test */\r\n        if (teta > temp || teta == temp && big < Math.abs(alfa)){\r\n            piv = t;\r\n            teta = temp;\r\n            big = Math.abs(alfa);\r\n        }\r\n    }\r\n    /* return index of the pivot element chosen */\r\n    return piv;\r\n};\r\n\r\nfunction _glp_analyze_row(P, len, ind, val, type, rhs, eps, callback){\r\n    var t, k, dir, piv, ret = 0;\r\n    var x, dx, y, dy, dz;\r\n    if (P.pbs_stat == GLP_UNDEF)\r\n        xerror(\"glp_analyze_row: primal basic solution components are undefined\");\r\n    if (P.dbs_stat != GLP_FEAS)\r\n        xerror(\"glp_analyze_row: basic solution is not dual feasible\");\r\n    /* compute the row value y = sum alfa[j] * xN[j] in the current\r\n     basis */\r\n    if (!(0 <= len && len <= P.n))\r\n        xerror(\"glp_analyze_row: len = \" + len + \"; invalid row length\");\r\n    y = 0.0;\r\n    for (t = 1; t <= len; t++)\r\n    {  /* determine value of x[k] = xN[j] in the current basis */\r\n        k = ind[t];\r\n        if (!(1 <= k && k <= P.m+P.n))\r\n            xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; row/column index out of range\");\r\n        if (k <= P.m)\r\n        {  /* x[k] is auxiliary variable */\r\n            if (P.row[k].stat == GLP_BS)\r\n                xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; basic auxiliary variable is not allowed\");\r\n            x = P.row[k].prim;\r\n        }\r\n        else\r\n        {  /* x[k] is structural variable */\r\n            if (P.col[k-P.m].stat == GLP_BS)\r\n                xerror(\"glp_analyze_row: ind[\" + t + \"] = \" + k + \"; basic structural variable is not allowed\");\r\n            x = P.col[k-P.m].prim;\r\n        }\r\n        y += val[t] * x;\r\n    }\r\n    /* check if the row is primal infeasible in the current basis,\r\n     i.e. the constraint is violated at the current point */\r\n    if (type == GLP_LO)\r\n    {  if (y >= rhs)\r\n    {  /* the constraint is not violated */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n        /* in the adjacent basis y goes to its lower bound */\r\n        dir = +1;\r\n    }\r\n    else if (type == GLP_UP)\r\n    {  if (y <= rhs)\r\n    {  /* the constraint is not violated */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n        /* in the adjacent basis y goes to its upper bound */\r\n        dir = -1;\r\n    }\r\n    else\r\n        xerror(\"glp_analyze_row: type = \" + type + \"; invalid parameter\");\r\n    /* compute dy = y.new - y.old */\r\n    dy = rhs - y;\r\n    /* perform dual ratio test to determine which non-basic variable\r\n     should enter the adjacent basis to keep it dual feasible */\r\n    piv = glp_dual_rtest(P, len, ind, val, dir, eps);\r\n    if (piv == 0)\r\n    {  /* no dual feasible adjacent basis exists */\r\n        ret = 2;\r\n        return ret;\r\n    }\r\n    /* non-basic variable x[k] = xN[j] should enter the basis */\r\n    k = ind[piv];\r\n    xassert(1 <= k && k <= P.m+P.n);\r\n    /* determine its value in the current basis */\r\n    if (k <= P.m)\r\n        x = P.row[k].prim;\r\n    else\r\n        x = P.col[k-P.m].prim;\r\n    /* compute dx = x.new - x.old = dy / alfa[j] */\r\n    xassert(val[piv] != 0.0);\r\n    dx = dy / val[piv];\r\n    /* compute dz = z.new - z.old = d[j] * dx, where d[j] is reduced\r\n     cost of xN[j] in the current basis */\r\n    if (k <= P.m)\r\n        dz = P.row[k].dual * dx;\r\n    else\r\n        dz = P.col[k-P.m].dual * dx;\r\n    /* store the analysis results */\r\n\r\n    callback(piv, x, dx, y, dy, dz);\r\n    return ret;\r\n}\r\n\r\nvar glp_analyze_bound = exports[\"glp_analyze_bound\"] = function(P, k, callback){\r\n    var row;\r\n    var col;\r\n    var  m, n, stat, kase, p, len, piv, ind;\r\n    var  x, new_x, ll, uu, xx, delta, val;\r\n    var value1, var1, value2, var2;\r\n    value1 = var1 = value2 = var2 = null;\r\n\r\n    function store(){\r\n        /* store analysis results */\r\n        if (kase < 0)\r\n        {  value1 = new_x;\r\n            var1 = p;\r\n        }\r\n        else\r\n        {  value2 = new_x;\r\n            var2 = p;\r\n        }\r\n    }\r\n\r\n    /* sanity checks */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_analyze_bound: P = \" + P + \"; invalid problem object\");\r\n    m = P.m; n = P.n;\r\n    if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))\r\n        xerror(\"glp_analyze_bound: optimal basic solution required\");\r\n    if (!(m == 0 || P.valid))\r\n        xerror(\"glp_analyze_bound: basis factorization required\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_analyze_bound: k = \" + k + \"; variable number out of range\");\r\n    /* retrieve information about the specified non-basic variable\r\n     x[k] whose active bound is to be analyzed */\r\n    if (k <= m)\r\n    {  row = P.row[k];\r\n        stat = row.stat;\r\n        x = row.prim;\r\n    }\r\n    else\r\n    {  col = P.col[k-m];\r\n        stat = col.stat;\r\n        x = col.prim;\r\n    }\r\n    if (stat == GLP_BS)\r\n        xerror(\"glp_analyze_bound: k = \" + k + \"; basic variable not allowed \");\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+m);\r\n    val = new Float64Array(1+m);\r\n    /* compute column of the simplex table corresponding to the\r\n     non-basic variable x[k] */\r\n    len = glp_eval_tab_col(P, k, ind, val);\r\n    xassert(0 <= len && len <= m);\r\n    /* perform analysis */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* kase < 0 means active bound of x[k] is decreasing;\r\n     kase > 0 means active bound of x[k] is increasing */\r\n        /* use the primal ratio test to determine some basic variable\r\n         x[p] which reaches its bound first */\r\n        piv = glp_prim_rtest(P, len, ind, val, kase, 1e-9);\r\n        if (piv == 0)\r\n        {  /* nothing limits changing the active bound of x[k] */\r\n            p = 0;\r\n            new_x = (kase < 0 ? -DBL_MAX : +DBL_MAX);\r\n            store();\r\n            continue;\r\n        }\r\n        /* basic variable x[p] limits changing the active bound of\r\n         x[k]; determine its value in the current basis */\r\n        xassert(1 <= piv && piv <= len);\r\n        p = ind[piv];\r\n        if (p <= m)\r\n        {  row = P.row[p];\r\n            ll = glp_get_row_lb(P, row.i);\r\n            uu = glp_get_row_ub(P, row.i);\r\n            stat = row.stat;\r\n            xx = row.prim;\r\n        }\r\n        else\r\n        {  col = P.col[p-m];\r\n            ll = glp_get_col_lb(P, col.j);\r\n            uu = glp_get_col_ub(P, col.j);\r\n            stat = col.stat;\r\n            xx = col.prim;\r\n        }\r\n        xassert(stat == GLP_BS);\r\n        /* determine delta x[p] = bound of x[p] - value of x[p] */\r\n        if (kase < 0 && val[piv] > 0.0 ||\r\n            kase > 0 && val[piv] < 0.0)\r\n        {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\r\n            xassert(ll != -DBL_MAX);\r\n            delta = ll - xx;\r\n        }\r\n        else\r\n        {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\r\n            xassert(uu != +DBL_MAX);\r\n            delta = uu - xx;\r\n        }\r\n        /* delta x[p] = alfa[p,k] * delta x[k], so new x[k] = x[k] +\r\n         delta x[k] = x[k] + delta x[p] / alfa[p,k] is the value of\r\n         x[k] in the adjacent basis */\r\n        xassert(val[piv] != 0.0);\r\n        new_x = x + delta / val[piv];\r\n        store();\r\n    }\r\n    callback(value1, var1, value2, var2)\r\n};\r\n\r\nvar glp_analyze_coef = exports[\"glp_analyze_coef\"] = function(P, k, callback){\r\n    var row, col;\r\n    var m, n, type, stat, kase, p, q, dir, clen, cpiv, rlen, rpiv, cind, rind;\r\n    var lb, ub, coef, x, lim_coef, new_x, d, delta, ll, uu, xx, rval, cval;\r\n    var coef1 = null, var1 = null, value1 = null, coef2 = null, var2 = null, value2 = null;\r\n\r\n    function store(){\r\n        /* store analysis results */\r\n        if (kase < 0)\r\n        {   coef1 = lim_coef;\r\n            var1 = q;\r\n            value1 = new_x;\r\n        }\r\n        else\r\n        {   coef2 = lim_coef;\r\n            var2 = q;\r\n            value2 = new_x;\r\n        }\r\n    }\r\n\r\n    /* sanity checks */\r\n    if (P == null || P.magic != GLP_PROB_MAGIC)\r\n        xerror(\"glp_analyze_coef: P = \" + P + \"; invalid problem object\");\r\n    m = P.m;\r\n    n = P.n;\r\n    if (!(P.pbs_stat == GLP_FEAS && P.dbs_stat == GLP_FEAS))\r\n        xerror(\"glp_analyze_coef: optimal basic solution required\");\r\n    if (!(m == 0 || P.valid))\r\n        xerror(\"glp_analyze_coef: basis factorization required\");\r\n    if (!(1 <= k && k <= m+n))\r\n        xerror(\"glp_analyze_coef: k = \" + k + \"; variable number out of range\");\r\n    /* retrieve information about the specified basic variable x[k]\r\n     whose objective coefficient c[k] is to be analyzed */\r\n    if (k <= m)\r\n    {  row = P.row[k];\r\n        type = row.type;\r\n        lb = row.lb;\r\n        ub = row.ub;\r\n        coef = 0.0;\r\n        stat = row.stat;\r\n        x = row.prim;\r\n    }\r\n    else\r\n    {  col = P.col[k-m];\r\n        type = col.type;\r\n        lb = col.lb;\r\n        ub = col.ub;\r\n        coef = col.coef;\r\n        stat = col.stat;\r\n        x = col.prim;\r\n    }\r\n    if (stat != GLP_BS)\r\n        xerror(\"glp_analyze_coef: k = \" + k + \"; non-basic variable not allowed\");\r\n    /* allocate working arrays */\r\n    cind = new Int32Array(1+m);\r\n    cval = new Float64Array(1+m);\r\n    rind = new Int32Array(1+n);\r\n    rval = new Float64Array(1+n);\r\n    /* compute row of the simplex table corresponding to the basic\r\n     variable x[k] */\r\n    rlen = glp_eval_tab_row(P, k, rind, rval);\r\n    xassert(0 <= rlen && rlen <= n);\r\n    /* perform analysis */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* kase < 0 means objective coefficient c[k] is decreasing;\r\n     kase > 0 means objective coefficient c[k] is increasing */\r\n        /* note that decreasing c[k] is equivalent to increasing dual\r\n         variable lambda[k] and vice versa; we need to correctly set\r\n         the dir flag as required by the routine glp_dual_rtest */\r\n        if (P.dir == GLP_MIN)\r\n            dir = - kase;\r\n        else if (P.dir == GLP_MAX)\r\n            dir = + kase;\r\n        else\r\n            xassert(P != P);\r\n        /* use the dual ratio test to determine non-basic variable\r\n         x[q] whose reduced cost d[q] reaches zero bound first */\r\n        rpiv = glp_dual_rtest(P, rlen, rind, rval, dir, 1e-9);\r\n        if (rpiv == 0)\r\n        {  /* nothing limits changing c[k] */\r\n            lim_coef = (kase < 0 ? -DBL_MAX : +DBL_MAX);\r\n            q = 0;\r\n            /* x[k] keeps its current value */\r\n            new_x = x;\r\n            store();\r\n            continue;\r\n        }\r\n        /* non-basic variable x[q] limits changing coefficient c[k];\r\n         determine its status and reduced cost d[k] in the current\r\n         basis */\r\n        xassert(1 <= rpiv && rpiv <= rlen);\r\n        q = rind[rpiv];\r\n        xassert(1 <= q && q <= m+n);\r\n        if (q <= m)\r\n        {  row = P.row[q];\r\n            stat = row.stat;\r\n            d = row.dual;\r\n        }\r\n        else\r\n        {  col = P.col[q-m];\r\n            stat = col.stat;\r\n            d = col.dual;\r\n        }\r\n        /* note that delta d[q] = new d[q] - d[q] = - d[q], because\r\n         new d[q] = 0; delta d[q] = alfa[k,q] * delta c[k], so\r\n         delta c[k] = delta d[q] / alfa[k,q] = - d[q] / alfa[k,q] */\r\n        xassert(rval[rpiv] != 0.0);\r\n        delta = - d / rval[rpiv];\r\n        /* compute new c[k] = c[k] + delta c[k], which is the limiting\r\n         value of the objective coefficient c[k] */\r\n        lim_coef = coef + delta;\r\n        /* let c[k] continue decreasing/increasing that makes d[q]\r\n         dual infeasible and forces x[q] to enter the basis;\r\n         to perform the primal ratio test we need to know in which\r\n         direction x[q] changes on entering the basis; we determine\r\n         that analyzing the sign of delta d[q] (see above), since\r\n         d[q] may be close to zero having wrong sign */\r\n        /* let, for simplicity, the problem is minimization */\r\n        if (kase < 0 && rval[rpiv] > 0.0 ||\r\n            kase > 0 && rval[rpiv] < 0.0)\r\n        {  /* delta d[q] < 0, so d[q] being non-negative will become\r\n         negative, so x[q] will increase */\r\n            dir = +1;\r\n        }\r\n        else\r\n        {  /* delta d[q] > 0, so d[q] being non-positive will become\r\n         positive, so x[q] will decrease */\r\n            dir = -1;\r\n        }\r\n        /* if the problem is maximization, correct the direction */\r\n        if (P.dir == GLP_MAX) dir = - dir;\r\n        /* check that we didn't make a silly mistake */\r\n        if (dir > 0)\r\n            xassert(stat == GLP_NL || stat == GLP_NF);\r\n        else\r\n            xassert(stat == GLP_NU || stat == GLP_NF);\r\n        /* compute column of the simplex table corresponding to the\r\n         non-basic variable x[q] */\r\n        clen = glp_eval_tab_col(P, q, cind, cval);\r\n        /* make x[k] temporarily free (unbounded) */\r\n        if (k <= m)\r\n        {  row = P.row[k];\r\n            row.type = GLP_FR;\r\n            row.lb = row.ub = 0.0;\r\n        }\r\n        else\r\n        {  col = P.col[k-m];\r\n            col.type = GLP_FR;\r\n            col.lb = col.ub = 0.0;\r\n        }\r\n        /* use the primal ratio test to determine some basic variable\r\n         which leaves the basis */\r\n        cpiv = glp_prim_rtest(P, clen, cind, cval, dir, 1e-9);\r\n        /* restore original bounds of the basic variable x[k] */\r\n        if (k <= m)\r\n        {  row = P.row[k];\r\n            row.type = type;\r\n            row.lb = lb;\r\n            row.ub = ub;\r\n        }\r\n        else\r\n        {  col = P.col[k-m];\r\n            col.type = type;\r\n            col.lb = lb;\r\n            col.ub = ub;\r\n        }\r\n        if (cpiv == 0)\r\n        {  /* non-basic variable x[q] can change unlimitedly */\r\n            if (dir < 0 && rval[rpiv] > 0.0 ||\r\n                dir > 0 && rval[rpiv] < 0.0)\r\n            {  /* delta x[k] = alfa[k,q] * delta x[q] < 0 */\r\n                new_x = -DBL_MAX;\r\n            }\r\n            else\r\n            {  /* delta x[k] = alfa[k,q] * delta x[q] > 0 */\r\n                new_x = +DBL_MAX;\r\n            }\r\n            store();\r\n            continue;\r\n        }\r\n        /* some basic variable x[p] limits changing non-basic variable\r\n         x[q] in the adjacent basis */\r\n        xassert(1 <= cpiv && cpiv <= clen);\r\n        p = cind[cpiv];\r\n        xassert(1 <= p && p <= m+n);\r\n        xassert(p != k);\r\n        if (p <= m)\r\n        {  row = P.row[p];\r\n            xassert(row.stat == GLP_BS);\r\n            ll = glp_get_row_lb(P, row.i);\r\n            uu = glp_get_row_ub(P, row.i);\r\n            xx = row.prim;\r\n        }\r\n        else\r\n        {  col = P.col[p-m];\r\n            xassert(col.stat == GLP_BS);\r\n            ll = glp_get_col_lb(P, col.j);\r\n            uu = glp_get_col_ub(P, col.j);\r\n            xx = col.prim;\r\n        }\r\n        /* determine delta x[p] = new x[p] - x[p] */\r\n        if (dir < 0 && cval[cpiv] > 0.0 ||\r\n            dir > 0 && cval[cpiv] < 0.0)\r\n        {  /* delta x[p] < 0, so x[p] goes toward its lower bound */\r\n            xassert(ll != -DBL_MAX);\r\n            delta = ll - xx;\r\n        }\r\n        else\r\n        {  /* delta x[p] > 0, so x[p] goes toward its upper bound */\r\n            xassert(uu != +DBL_MAX);\r\n            delta = uu - xx;\r\n        }\r\n        /* compute new x[k] = x[k] + alfa[k,q] * delta x[q], where\r\n         delta x[q] = delta x[p] / alfa[p,q] */\r\n        xassert(cval[cpiv] != 0.0);\r\n        new_x = x + (rval[rpiv] / cval[cpiv]) * delta;\r\n        store();\r\n    }\r\n    callback(coef1, var1, value1, coef2, var2, value2)\r\n};\r\n\r\nvar glp_ios_reason = exports[\"glp_ios_reason\"] = function(tree){\r\n    return tree.reason;\r\n};\r\n\r\nvar glp_ios_get_prob = exports[\"glp_ios_get_prob\"] = function(tree){\r\n    return tree.mip;\r\n};\r\n\r\nfunction glp_ios_tree_size(tree, callback){\r\n    callback(tree.a_cnt, tree.n_cnt, tree.t_cnt);\r\n}\r\n\r\nfunction glp_ios_curr_node(tree){\r\n    /* obtain pointer to the current subproblem */\r\n    var node = tree.curr;\r\n    /* return its reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_next_node(tree, p){\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_next_node: p = \" + p + \"; invalid subproblem reference number\");\r\n    }\r\n\r\n    var node;\r\n    if (p == 0)\r\n    {  /* obtain pointer to the first active subproblem */\r\n        node = tree.head;\r\n    }\r\n    else\r\n    {  /* obtain pointer to the specified subproblem */\r\n        if (!(1 <= p && p <= tree.nslots))\r\n            doError();\r\n        node = tree.slot[p].node;\r\n        if (node == null) doError();\r\n        /* the specified subproblem must be active */\r\n        if (node.count != 0)\r\n            xerror(\"glp_ios_next_node: p = \" + p + \"; subproblem not in the active list\");\r\n        /* obtain pointer to the next active subproblem */\r\n        node = node.next;\r\n    }\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_prev_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_prev_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    if (p == 0)\r\n    {  /* obtain pointer to the last active subproblem */\r\n        node = tree.tail;\r\n    }\r\n    else\r\n    {  /* obtain pointer to the specified subproblem */\r\n        if (!(1 <= p && p <= tree.nslots))\r\n            doError();\r\n        node = tree.slot[p].node;\r\n        if (node == null) doError();\r\n        /* the specified subproblem must be active */\r\n        if (node.count != 0)\r\n            xerror(\"glp_ios_prev_node: p = \" + p + \"; subproblem not in the active list\");\r\n        /* obtain pointer to the previous active subproblem */\r\n        node = node.prev;\r\n    }\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_up_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_up_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* obtain pointer to the parent subproblem */\r\n    node = node.up;\r\n    /* return the reference number */\r\n    return node == null ? 0 : node.p;\r\n}\r\n\r\nfunction glp_ios_node_level(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_level: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return the node level */\r\n    return node.level;\r\n}\r\n\r\nfunction glp_ios_node_bound(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_bound: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return the node local bound */\r\n    return node.bound;\r\n}\r\n\r\nfunction glp_ios_best_node(tree){\r\n    return ios_best_node(tree);\r\n}\r\n\r\nfunction glp_ios_mip_gap(tree){\r\n    return ios_relative_gap(tree);\r\n}\r\n\r\nfunction glp_ios_node_data(tree, p)\r\n{\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_node_level: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* return pointer to the application-specific data */\r\n    return node.data;\r\n}\r\n\r\nfunction glp_ios_row_attr(tree, i, attr){\r\n    var row;\r\n    if (!(1 <= i && i <= tree.mip.m))\r\n        xerror(\"glp_ios_row_attr: i = \" + i + \"; row number out of range\");\r\n    row = tree.mip.row[i];\r\n    attr.level = row.level;\r\n    attr.origin = row.origin;\r\n    attr.klass = row.klass;\r\n}\r\n\r\nfunction glp_ios_pool_size(tree){\r\n    /* determine current size of the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_pool_size: operation not allowed\");\r\n    xassert(tree.local != null);\r\n    return tree.local.size;\r\n}\r\n\r\nfunction glp_ios_add_row(tree, name, klass, flags, len, ind, val, type, rhs){\r\n    /* add row (constraint) to the cut pool */\r\n    var num;\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_add_row: operation not allowed\");\r\n    xassert(tree.local != null);\r\n    num = ios_add_row(tree, tree.local, name, klass, flags, len,\r\n        ind, val, type, rhs);\r\n    return num;\r\n}\r\n\r\nfunction glp_ios_del_row(tree, i){\r\n    /* remove row (constraint) from the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_del_row: operation not allowed\");\r\n    ios_del_row(tree.local, i);\r\n}\r\n\r\nfunction glp_ios_clear_pool(tree){\r\n    /* remove all rows (constraints) from the cut pool */\r\n    if (tree.reason != GLP_ICUTGEN)\r\n        xerror(\"glp_ios_clear_pool: operation not allowed\");\r\n    ios_clear_pool(tree.local);\r\n}\r\n\r\nfunction glp_ios_can_branch(tree, j){\r\n    if (!(1 <= j && j <= tree.mip.n))\r\n        xerror(\"glp_ios_can_branch: j = \" + j + \"; column number out of range\");\r\n    return tree.non_int[j];\r\n}\r\n\r\nfunction glp_ios_branch_upon(tree, j, sel){\r\n    if (!(1 <= j && j <= tree.mip.n))\r\n        xerror(\"glp_ios_branch_upon: j = \" + j + \"; column number out of range\");\r\n    if (!(sel == GLP_DN_BRNCH || sel == GLP_UP_BRNCH || sel == GLP_NO_BRNCH))\r\n        xerror(\"glp_ios_branch_upon: sel = \" + sel + \": invalid branch selection flag\");\r\n    if (!(tree.non_int[j]))\r\n        xerror(\"glp_ios_branch_upon: j = \" + j + \"; variable cannot be used to branch upon\");\r\n    if (tree.br_var != 0)\r\n        xerror(\"glp_ios_branch_upon: branching variable already chosen\");\r\n    tree.br_var = j;\r\n    tree.br_sel = sel;\r\n}\r\n\r\nfunction glp_ios_select_node(tree, p){\r\n    var node;\r\n\r\n    function doError(){\r\n        xerror(\"glp_ios_select_node: p = \" + p + \"; invalid subproblem reference number\")\r\n    }\r\n\r\n    /* obtain pointer to the specified subproblem */\r\n    if (!(1 <= p && p <= tree.nslots))\r\n        doError();\r\n    node = tree.slot[p].node;\r\n    if (node == null) doError();\r\n    /* the specified subproblem must be active */\r\n    if (node.count != 0)\r\n        xerror(\"glp_ios_select_node: p = \" + p + \"; subproblem not in the active list\");\r\n    /* no subproblem must be selected yet */\r\n    if (tree.next_p != 0)\r\n        xerror(\"glp_ios_select_node: subproblem already selected\");\r\n    /* select the specified subproblem to continue the search */\r\n    tree.next_p = p;\r\n}\r\n\r\nfunction glp_ios_heur_sol(tree, x){\r\n    var mip = tree.mip;\r\n    var m = tree.orig_m;\r\n    var n = tree.n;\r\n    var i, j;\r\n    var obj;\r\n    xassert(mip.m >= m);\r\n    xassert(mip.n == n);\r\n    /* check values of integer variables and compute value of the\r\n     objective function */\r\n    obj = mip.c0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        if (col.kind == GLP_IV)\r\n        {  /* provided value must be integral */\r\n            if (x[j] != Math.floor(x[j])) return 1;\r\n        }\r\n        obj += col.coef * x[j];\r\n    }\r\n    /* check if the provided solution is better than the best known\r\n     integer feasible solution */\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  switch (mip.dir)\r\n    {  case GLP_MIN:\r\n            if (obj >= tree.mip.mip_obj) return 1;\r\n            break;\r\n        case GLP_MAX:\r\n            if (obj <= tree.mip.mip_obj) return 1;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    /* it is better; store it in the problem object */\r\n    if (tree.parm.msg_lev >= GLP_MSG_ON)\r\n        xprintf(\"Solution found by heuristic: \" + obj + \"\");\r\n    mip.mip_stat = GLP_FEAS;\r\n    mip.mip_obj = obj;\r\n    for (j = 1; j <= n; j++)\r\n        mip.col[j].mipx = x[j];\r\n    for (i = 1; i <= m; i++)\r\n    {  var row = mip.row[i];\r\n        var aij;\r\n        row.mipx = 0.0;\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            row.mipx += aij.val * aij.col.mipx;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction glp_ios_terminate(tree){\r\n    if (tree.parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"The search is prematurely terminated due to application request\");\r\n    tree.stop = 1;\r\n}\r\n\r\n/* glpapi14.c (processing models in GNU MathProg language) */\r\n\r\nvar glp_mpl_alloc_wksp = exports[\"glp_mpl_alloc_wksp\"] = function(){\r\n    /* allocate the MathProg translator workspace */\r\n    return mpl_initialize();\r\n};\r\n\r\nvar _glp_mpl_init_rand = exports[\"_glp_mpl_init_rand\"] = function (tran, seed){\r\n    if (tran.phase != 0)\r\n    xerror(\"glp_mpl_init_rand: invalid call sequence\\n\");\r\n    rng_init_rand(tran.rand, seed);\r\n};\r\n\r\nvar glp_mpl_read_model = exports[\"glp_mpl_read_model\"] = function(tran, name, callback, skip){\r\n    /* read and translate model section */\r\n    var ret;\r\n    if (tran.phase != 0)\r\n        xerror(\"glp_mpl_read_model: invalid call sequence\");\r\n    ret = mpl_read_model(tran, name, callback, skip);\r\n    if (ret == 1 || ret == 2)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_read_model_from_string = exports[\"glp_mpl_read_model_from_string\"] = function(tran, name, str, skip){\r\n    var pos = 0;\r\n    return glp_mpl_read_model(tran, name,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        },\r\n        skip\r\n    )\r\n};\r\n\r\nvar glp_mpl_read_data = exports[\"glp_mpl_read_data\"] = function(tran, name, callback){\r\n    /* read and translate data section */\r\n    var ret;\r\n    if (!(tran.phase == 1 || tran.phase == 2))\r\n        xerror(\"glp_mpl_read_data: invalid call sequence\");\r\n    ret = mpl_read_data(tran, name, callback);\r\n    if (ret == 2)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_read_data_from_string = exports[\"glp_mpl_read_data_from_string\"] = function(tran, name, str){\r\n    var pos = 0;\r\n    return glp_mpl_read_data(tran, name,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        }\r\n    )\r\n};\r\n\r\nvar glp_mpl_generate = exports[\"glp_mpl_generate\"] = function(tran, name, callback, tablecb){\r\n    /* generate the model */\r\n    var ret;\r\n    if (!(tran.phase == 1 || tran.phase == 2))\r\n        xerror(\"glp_mpl_generate: invalid call sequence\\n\");\r\n    ret = mpl_generate(tran, name, callback, tablecb);\r\n    if (ret == 3)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    return ret;\r\n};\r\n\r\nvar glp_mpl_build_prob = exports[\"glp_mpl_build_prob\"] = function(tran, prob){\r\n    /* build LP/MIP problem instance from the model */\r\n    var m, n, i, j, t, kind, type, len, ind;\r\n    var lb, ub, val;\r\n    if (tran.phase != 3)\r\n        xerror(\"glp_mpl_build_prob: invalid call sequence\\n\");\r\n    /* erase the problem object */\r\n    glp_erase_prob(prob);\r\n    /* set problem name */\r\n    glp_set_prob_name(prob, mpl_get_prob_name(tran));\r\n    /* build rows (constraints) */\r\n    m = mpl_get_num_rows(tran);\r\n    if (m > 0)\r\n        glp_add_rows(prob, m);\r\n    for (i = 1; i <= m; i++)\r\n    {  /* set row name */\r\n        glp_set_row_name(prob, i, mpl_get_row_name(tran, i));\r\n        /* set row bounds */\r\n        type = mpl_get_row_bnds(tran, i, function(l,u){lb=l; ub=u});\r\n        switch (type)\r\n        {  case MPL_FR: type = GLP_FR; break;\r\n            case MPL_LO: type = GLP_LO; break;\r\n            case MPL_UP: type = GLP_UP; break;\r\n            case MPL_DB: type = GLP_DB; break;\r\n            case MPL_FX: type = GLP_FX; break;\r\n            default: xassert(type != type);\r\n        }\r\n        if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1.0 + Math.abs(lb)))\r\n        {  type = GLP_FX;\r\n            if (Math.abs(lb) <= Math.abs(ub)) ub = lb; else lb = ub;\r\n        }\r\n        glp_set_row_bnds(prob, i, type, lb, ub);\r\n        /* warn about non-zero constant term */\r\n        if (mpl_get_row_c0(tran, i) != 0.0)\r\n            xprintf(\"glp_mpl_build_prob: row \" + mpl_get_row_name(tran, i) + \"; constant term \" + mpl_get_row_c0(tran, i) + \" ignored\");\r\n    }\r\n    /* build columns (variables) */\r\n    n = mpl_get_num_cols(tran);\r\n    if (n > 0)\r\n        glp_add_cols(prob, n);\r\n    for (j = 1; j <= n; j++)\r\n    {  /* set column name */\r\n        glp_set_col_name(prob, j, mpl_get_col_name(tran, j));\r\n        /* set column kind */\r\n        kind = mpl_get_col_kind(tran, j);\r\n        switch (kind)\r\n        {  case MPL_NUM:\r\n            break;\r\n            case MPL_INT:\r\n            case MPL_BIN:\r\n                glp_set_col_kind(prob, j, GLP_IV);\r\n                break;\r\n            default:\r\n                xassert(kind != kind);\r\n        }\r\n        /* set column bounds */\r\n        type = mpl_get_col_bnds(tran, j, function(l,u){lb=l; ub=u});\r\n        switch (type)\r\n        {  case MPL_FR: type = GLP_FR; break;\r\n            case MPL_LO: type = GLP_LO; break;\r\n            case MPL_UP: type = GLP_UP; break;\r\n            case MPL_DB: type = GLP_DB; break;\r\n            case MPL_FX: type = GLP_FX; break;\r\n            default: xassert(type != type);\r\n        }\r\n        if (kind == MPL_BIN)\r\n        {  if (type == GLP_FR || type == GLP_UP || lb < 0.0) lb = 0.0;\r\n            if (type == GLP_FR || type == GLP_LO || ub > 1.0) ub = 1.0;\r\n            type = GLP_DB;\r\n        }\r\n        if (type == GLP_DB && Math.abs(lb - ub) < 1e-9 * (1.0 + Math.abs(lb)))\r\n        {  type = GLP_FX;\r\n            if (Math.abs(lb) <= Math.abs(ub)) ub = lb; else lb = ub;\r\n        }\r\n        glp_set_col_bnds(prob, j, type, lb, ub);\r\n    }\r\n    /* load the constraint matrix */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  len = mpl_get_mat_row(tran, i, ind, val);\r\n        glp_set_mat_row(prob, i, len, ind, val);\r\n    }\r\n    /* build objective function (the first objective is used) */\r\n    for (i = 1; i <= m; i++)\r\n    {  kind = mpl_get_row_kind(tran, i);\r\n        if (kind == MPL_MIN || kind == MPL_MAX)\r\n        {  /* set objective name */\r\n            glp_set_obj_name(prob, mpl_get_row_name(tran, i));\r\n            /* set optimization direction */\r\n            glp_set_obj_dir(prob, kind == MPL_MIN ? GLP_MIN : GLP_MAX);\r\n            /* set constant term */\r\n            glp_set_obj_coef(prob, 0, mpl_get_row_c0(tran, i));\r\n            /* set objective coefficients */\r\n            len = mpl_get_mat_row(tran, i, ind, val);\r\n            for (t = 1; t <= len; t++)\r\n                glp_set_obj_coef(prob, ind[t], val[t]);\r\n            break;\r\n        }\r\n    }\r\n};\r\n\r\nvar glp_mpl_postsolve = exports[\"glp_mpl_postsolve\"] = function(tran, prob, sol){\r\n    /* postsolve the model */\r\n    var i, j, m, n, stat, ret;\r\n    var prim, dual;\r\n    if (!(tran.phase == 3 && !tran.flag_p))\r\n        xerror(\"glp_mpl_postsolve: invalid call sequence\");\r\n    if (!(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP))\r\n        xerror(\"glp_mpl_postsolve: sol = \" + sol + \"; invalid parameter\");\r\n    m = mpl_get_num_rows(tran);\r\n    n = mpl_get_num_cols(tran);\r\n    if (!(m == glp_get_num_rows(prob) &&\r\n        n == glp_get_num_cols(prob)))\r\n        xerror(\"glp_mpl_postsolve: wrong problem object\\n\");\r\n    if (!mpl_has_solve_stmt(tran))\r\n      return 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  if (sol == GLP_SOL)\r\n    {  stat = glp_get_row_stat(prob, i);\r\n        prim = glp_get_row_prim(prob, i);\r\n        dual = glp_get_row_dual(prob, i);\r\n    }\r\n    else if (sol == GLP_IPT)\r\n    {  stat = 0;\r\n        prim = glp_ipt_row_prim(prob, i);\r\n        dual = glp_ipt_row_dual(prob, i);\r\n    }\r\n    else if (sol == GLP_MIP)\r\n    {  stat = 0;\r\n        prim = glp_mip_row_val(prob, i);\r\n        dual = 0.0;\r\n    }\r\n    else\r\n        xassert(sol != sol);\r\n        if (Math.abs(prim) < 1e-9) prim = 0.0;\r\n        if (Math.abs(dual) < 1e-9) dual = 0.0;\r\n        mpl_put_row_soln(tran, i, stat, prim, dual);\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  if (sol == GLP_SOL)\r\n    {  stat = glp_get_col_stat(prob, j);\r\n        prim = glp_get_col_prim(prob, j);\r\n        dual = glp_get_col_dual(prob, j);\r\n    }\r\n    else if (sol == GLP_IPT)\r\n    {  stat = 0;\r\n        prim = glp_ipt_col_prim(prob, j);\r\n        dual = glp_ipt_col_dual(prob, j);\r\n    }\r\n    else if (sol == GLP_MIP)\r\n    {  stat = 0;\r\n        prim = glp_mip_col_val(prob, j);\r\n        dual = 0.0;\r\n    }\r\n    else\r\n        xassert(sol != sol);\r\n        if (Math.abs(prim) < 1e-9) prim = 0.0;\r\n        if (Math.abs(dual) < 1e-9) dual = 0.0;\r\n        mpl_put_col_soln(tran, j, stat, prim, dual);\r\n    }\r\n    ret = mpl_postsolve(tran);\r\n    if (ret == 3)\r\n        ret = 0;\r\n    else if (ret == 4)\r\n        ret = 1;\r\n    return ret;\r\n};\r\n\r\nfunction avl_create_tree(fcmp, info)\r\n{     /* create AVL tree */\r\n    var tree = {};\r\n    //tree.pool = dmp_create_pool();\r\n    tree.root = null;\r\n    tree.fcmp = fcmp;\r\n    tree.info = info;\r\n    tree.size = 0;\r\n    tree.height = 0;\r\n    return tree;\r\n}\r\n\r\nfunction avl_strcmp(info, key1, key2)\r\n{   /* compare character string keys */\r\n    if (key1 == key2)\r\n        return 0;\r\n    else if (key1 > key2)\r\n        return 1;\r\n    else\r\n        return -1;\r\n}\r\n\r\nfunction avl_insert_node(tree, key)\r\n{   /* insert new node into AVL tree */\r\n    var p, q, r, flag;\r\n    /* find an appropriate point for insertion */\r\n    p = null; q = tree.root;\r\n    while (q != null)\r\n    {  p = q;\r\n        if (tree.fcmp(tree.info, key, p.key) <= 0)\r\n        {  flag = 0;\r\n            q = p.left;\r\n            p.rank++;\r\n        }\r\n        else\r\n        {  flag = 1;\r\n            q = p.right;\r\n        }\r\n    }\r\n    /* create new node and insert it into the tree */\r\n    r = {};\r\n    r.key = key; r.type = 0; r.link = null;\r\n    r.rank = 1; r.up = p;\r\n    r.flag = (p == null ? 0 : flag);\r\n    r.bal = 0; r.left = null; r.right = null;\r\n    tree.size++;\r\n    if (p == null)\r\n        tree.root = r;\r\n    else\r\n    if (flag == 0) p.left = r; else p.right = r;\r\n    /* go upstairs to the root and correct all subtrees affected by\r\n     insertion */\r\n    while (p != null)\r\n    {  if (flag == 0)\r\n    {  /* the height of the left subtree of [p] is increased */\r\n        if (p.bal > 0)\r\n        {  p.bal = 0;\r\n            break;\r\n        }\r\n        if (p.bal < 0)\r\n        {  rotate_subtree(tree, p);\r\n            break;\r\n        }\r\n        p.bal = -1; flag = p.flag; p = p.up;\r\n    }\r\n    else\r\n    {  /* the height of the right subtree of [p] is increased */\r\n        if (p.bal < 0)\r\n        {  p.bal = 0;\r\n            break;\r\n        }\r\n        if (p.bal > 0)\r\n        {  rotate_subtree(tree, p);\r\n            break;\r\n        }\r\n        p.bal = +1; flag = p.flag; p = p.up;\r\n    }\r\n    }\r\n    /* if the root has been reached, the height of the entire tree is\r\n     increased */\r\n    if (p == null) tree.height++;\r\n    return r;\r\n}\r\n\r\nfunction avl_set_node_type(node, type)\r\n{     /* assign the type field of specified node */\r\n    node.type = type;\r\n}\r\n\r\nfunction avl_set_node_link(node, link)\r\n{     /* assign the link field of specified node */\r\n    node.link = link;\r\n}\r\n\r\nfunction avl_find_node(tree, key)\r\n{     /* find node in AVL tree */\r\n    var p, c;\r\n    p = tree.root;\r\n    while (p != null)\r\n    {  c = tree.fcmp(tree.info, key, p.key);\r\n        if (c == 0) break;\r\n        p = (c < 0 ? p.left : p.right);\r\n    }\r\n    return p;\r\n}\r\n\r\nfunction avl_get_node_type(node)\r\n{     /* retrieve the type field of specified node */\r\n    return node.type;\r\n}\r\n\r\nfunction avl_get_node_link(node)\r\n{     /* retrieve the link field of specified node */\r\n    return node.link;\r\n}\r\n\r\nfunction find_next_node(tree, node)\r\n{   /* find next node in AVL tree */\r\n    var p, q;\r\n    if (tree.root == null) return null;\r\n    p = node;\r\n    q = (p == null ? tree.root : p.right);\r\n    if (q == null)\r\n    {  /* go upstairs from the left subtree */\r\n        for (;;)\r\n        {  q = p.up;\r\n            if (q == null) break;\r\n            if (p.flag == 0) break;\r\n            p = q;\r\n        }\r\n    }\r\n    else\r\n    {  /* go downstairs into the right subtree */\r\n        for (;;)\r\n        {  p = q.left;\r\n            if (p == null) break;\r\n            q = p;\r\n        }\r\n    }\r\n    return q;\r\n}\r\n\r\nfunction avl_delete_node(tree, node)\r\n{   /* delete specified node from AVL tree */\r\n    var f, p, q, r, s, x, y, flag;\r\n    p = node;\r\n    /* if both subtrees of the specified node are non-empty, the node\r\n     should be interchanged with the next one, at least one subtree\r\n     of which is always empty */\r\n    if (p.left != null && p.right != null){\r\n        f = p.up; q = p.left;\r\n        r = find_next_node(tree, p); s = r.right;\r\n        if (p.right == r)\r\n        {  if (f == null)\r\n            tree.root = r;\r\n        else\r\n        if (p.flag == 0) f.left = r; else f.right = r;\r\n            r.rank = p.rank; r.up = f;\r\n            r.flag = p.flag; r.bal = p.bal;\r\n            r.left = q; r.right = p;\r\n            q.up = r;\r\n            p.rank = 1; p.up = r; p.flag = 1;\r\n            p.bal = (s == null ? 0 : +1);\r\n            p.left = null; p.right = s;\r\n            if (s != null) s.up = p;\r\n        }\r\n        else\r\n        {  x = p.right; y = r.up;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            r.rank = p.rank; r.up = f;\r\n            r.flag = p.flag; r.bal = p.bal;\r\n            r.left = q; r.right = x;\r\n            q.up = r; x.up = r; y.left = p;\r\n            p.rank = 1; p.up = y; p.flag = 0;\r\n            p.bal = (s == null ? 0 : +1);\r\n            p.left = null; p.right = s;\r\n            if (s != null) s.up = p;\r\n        }\r\n    }\r\n    /* now the specified node [p] has at least one empty subtree;\r\n     go upstairs to the root and adjust the rank field of all nodes\r\n     affected by deletion */\r\n        q = p; f = q.up;\r\n    while (f != null)\r\n    {  if (q.flag == 0) f.rank--;\r\n        q = f; f = q.up;\r\n    }\r\n    /* delete the specified node from the tree */\r\n    f = p.up; flag = p.flag;\r\n    q = p.left != null ? p.left : p.right;\r\n    if (f == null)\r\n        tree.root = q;\r\n    else\r\n    if (flag == 0) f.left = q; else f.right = q;\r\n    if (q != null){q.up = f; q.flag = flag}\r\n    tree.size--;\r\n    /* go upstairs to the root and correct all subtrees affected by\r\n     deletion */\r\n    while (f != null)\r\n    {  if (flag == 0)\r\n    {  /* the height of the left subtree of [f] is decreased */\r\n        if (f.bal == 0)\r\n        {  f.bal = +1;\r\n            break;\r\n        }\r\n        if (f.bal < 0)\r\n            f.bal = 0;\r\n        else\r\n        {  f = rotate_subtree(tree, f);\r\n            if (f.bal < 0) break;\r\n        }\r\n        flag = f.flag; f = f.up;\r\n    }\r\n    else\r\n    {  /* the height of the right subtree of [f] is decreased */\r\n        if (f.bal == 0)\r\n        {  f.bal = -1;\r\n            break;\r\n        }\r\n        if (f.bal > 0)\r\n            f.bal = 0;\r\n        else\r\n        {  f = rotate_subtree(tree, f);\r\n            if (f.bal > 0) break;\r\n        }\r\n        flag = f.flag; f = f.up;\r\n    }\r\n    }\r\n    /* if the root has been reached, the height of the entire tree is\r\n     decreased */\r\n    if (f == null) tree.height--;\r\n}\r\n\r\nfunction rotate_subtree(tree, node)\r\n{     /* restore balance of AVL subtree */\r\n    var f, p, q, r, x, y;\r\n    xassert(node != null);\r\n    p = node;\r\n    if (p.bal < 0)\r\n    {  /* perform negative (left) rotation */\r\n        f = p.up; q = p.left; r = q.right;\r\n        if (q.bal <= 0)\r\n        {  /* perform single negative rotation */\r\n            if (f == null)\r\n                tree.root = q;\r\n            else\r\n            if (p.flag == 0) f.left = q; else f.right = q;\r\n            p.rank -= q.rank;\r\n            q.up = f; q.flag = p.flag; q.bal++; q.right = p;\r\n            p.up = q; p.flag = 1;\r\n            p.bal = -q.bal; p.left = r;\r\n            if (r != null){r.up = p; r.flag = 0}\r\n            node = q;\r\n        }\r\n        else\r\n        {  /* perform double negative rotation */\r\n            x = r.left; y = r.right;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            p.rank -= (q.rank + r.rank);\r\n            r.rank += q.rank;\r\n            p.bal = (r.bal >= 0 ? 0 : +1);\r\n            q.bal = (r.bal <= 0 ? 0 : -1);\r\n            r.up = f; r.flag = p.flag; r.bal = 0;\r\n            r.left = q; r.right = p;\r\n            p.up = r; p.flag = 1; p.left = y;\r\n            q.up = r; q.flag = 0; q.right = x;\r\n            if (x != null){x.up = q; x.flag = 1}\r\n            if (y != null){y.up = p; y.flag = 0}\r\n            node = r;\r\n        }\r\n    }\r\n    else\r\n    {  /* perform positive (right) rotation */\r\n        f = p.up; q = p.right; r = q.left;\r\n        if (q.bal >= 0)\r\n        {  /* perform single positive rotation */\r\n            if (f == null)\r\n                tree.root = q;\r\n            else\r\n            if (p.flag == 0) f.left = q; else f.right = q;\r\n            q.rank += p.rank;\r\n            q.up = f; q.flag = p.flag; q.bal--; q.left = p;\r\n            p.up = q; p.flag = 0;\r\n            p.bal = -q.bal; p.right = r;\r\n            if (r != null){r.up = p; r.flag = 1}\r\n            node = q;\r\n        }\r\n        else\r\n        {  /* perform double positive rotation */\r\n            x = r.left; y = r.right;\r\n            if (f == null)\r\n                tree.root = r;\r\n            else\r\n            if (p.flag == 0) f.left = r; else f.right = r;\r\n            q.rank -= r.rank;\r\n            r.rank += p.rank;\r\n            p.bal = (r.bal <= 0 ? 0 : -1);\r\n            q.bal = (r.bal >= 0 ? 0 : +1);\r\n            r.up = f; r.flag = p.flag; r.bal = 0;\r\n            r.left = p; r.right = q;\r\n            p.up = r; p.flag = 0; p.right = x;\r\n            q.up = r; q.flag = 1; q.left = y;\r\n            if (x != null){x.up = p; x.flag = 1}\r\n            if (y != null){y.up = q; y.flag = 0}\r\n            node = r;\r\n        }\r\n    }\r\n    return node;\r\n}\r\n/* return codes: */\r\nvar\r\n    BFD_ESING   = 1,  /* singular matrix */\r\n    BFD_ECOND   = 2,  /* ill-conditioned matrix */\r\n    BFD_ECHECK  = 3,  /* insufficient accuracy */\r\n    BFD_ELIMIT  = 4,  /* update limit reached */\r\n    BFD_EROOM   = 5;  /* SVA overflow */\r\n\r\nfunction bfd_create_it(){\r\n    var bfd = {};\r\n    bfd.valid = 0;\r\n    bfd.type = GLP_BF_FT;\r\n    bfd.fhv = null;\r\n    bfd.lpf = null;\r\n    bfd.lu_size = 0;\r\n    bfd.piv_tol = 0.10;\r\n    bfd.piv_lim = 4;\r\n    bfd.suhl = 1;\r\n    bfd.eps_tol = 1e-15;\r\n    bfd.max_gro = 1e+10;\r\n    bfd.nfs_max = 100;\r\n    bfd.upd_tol = 1e-6;\r\n    bfd.nrs_max = 100;\r\n    bfd.rs_size = 1000;\r\n    bfd.upd_lim = -1;\r\n    bfd.upd_cnt = 0;\r\n    return bfd;\r\n}\r\n\r\nfunction bfd_set_parm(bfd, parm){\r\n    /* change LP basis factorization control parameters */\r\n    xassert(bfd != null);\r\n    bfd.type = parm.type;\r\n    bfd.lu_size = parm.lu_size;\r\n    bfd.piv_tol = parm.piv_tol;\r\n    bfd.piv_lim = parm.piv_lim;\r\n    bfd.suhl = parm.suhl;\r\n    bfd.eps_tol = parm.eps_tol;\r\n    bfd.max_gro = parm.max_gro;\r\n    bfd.nfs_max = parm.nfs_max;\r\n    bfd.upd_tol = parm.upd_tol;\r\n    bfd.nrs_max = parm.nrs_max;\r\n    bfd.rs_size = parm.rs_size;\r\n}\r\n\r\nfunction bfd_factorize(bfd, m, bh, col, info){\r\n    var luf;\r\n    var nov, ret;\r\n    xassert(bfd != null);\r\n    xassert(1 <= m && m <= M_MAX);\r\n    /* invalidate the factorization */\r\n    bfd.valid = 0;\r\n    /* create the factorization, if necessary */\r\n    nov = 0;\r\n    switch (bfd.type)\r\n    {  case GLP_BF_FT:\r\n        bfd.lpf = null;\r\n        if (bfd.fhv == null){\r\n            bfd.fhv = fhv_create_it(); nov = 1;\r\n        }\r\n        break;\r\n        case GLP_BF_BG:\r\n        case GLP_BF_GR:\r\n            bfd.fhv = null;\r\n            if (bfd.lpf == null){\r\n                bfd.lpf = lpf_create_it(); nov = 1;\r\n            }\r\n            break;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    /* set control parameters specific to LUF */\r\n    if (bfd.fhv != null)\r\n        luf = bfd.fhv.luf;\r\n    else if (bfd.lpf != null)\r\n        luf = bfd.lpf.luf;\r\n    else\r\n        xassert(bfd != bfd);\r\n    if (nov) luf.new_sva = bfd.lu_size;\r\n    luf.piv_tol = bfd.piv_tol;\r\n    luf.piv_lim = bfd.piv_lim;\r\n    luf.suhl = bfd.suhl;\r\n    luf.eps_tol = bfd.eps_tol;\r\n    luf.max_gro = bfd.max_gro;\r\n    /* set control parameters specific to FHV */\r\n    if (bfd.fhv != null)\r\n    {  if (nov) bfd.fhv.hh_max = bfd.nfs_max;\r\n        bfd.fhv.upd_tol = bfd.upd_tol;\r\n    }\r\n    /* set control parameters specific to LPF */\r\n    if (bfd.lpf != null)\r\n    {  if (nov) bfd.lpf.n_max = bfd.nrs_max;\r\n        if (nov) bfd.lpf.v_size = bfd.rs_size;\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    if (bfd.fhv != null)\r\n    {  switch (fhv_factorize(bfd.fhv, m, col, info))\r\n    {  case 0:\r\n            break;\r\n        case FHV_ESING:\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case FHV_ECOND:\r\n            ret = BFD_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else if (bfd.lpf != null)\r\n    {  switch (lpf_factorize(bfd.lpf, m, bh, col, info))\r\n    {  case 0:\r\n            /* set the Schur complement update type */\r\n            switch (bfd.type)\r\n            {  case GLP_BF_BG:\r\n                /* Bartels-Golub update */\r\n                bfd.lpf.scf.t_opt = SCF_TBG;\r\n                break;\r\n                case GLP_BF_GR:\r\n                    /* Givens rotation update */\r\n                    bfd.lpf.scf.t_opt = SCF_TGR;\r\n                    break;\r\n                default:\r\n                    xassert(bfd != bfd);\r\n            }\r\n            break;\r\n        case LPF_ESING:\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case LPF_ECOND:\r\n            ret = BFD_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else\r\n        xassert(bfd != bfd);\r\n    /* the basis matrix has been successfully factorized */\r\n    bfd.valid = 1;\r\n    bfd.upd_cnt = 0;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction bfd_ftran(bfd, x){\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    if (bfd.fhv != null)\r\n        fhv_ftran(bfd.fhv, x);\r\n    else if (bfd.lpf != null)\r\n        lpf_ftran(bfd.lpf, x);\r\n    else\r\n        xassert(bfd != bfd);\r\n}\r\n\r\nfunction bfd_btran(bfd, x){\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    if (bfd.fhv != null)\r\n        fhv_btran(bfd.fhv, x);\r\n    else if (bfd.lpf != null)\r\n        lpf_btran(bfd.lpf, x);\r\n    else\r\n        xassert(bfd != bfd);\r\n}\r\n\r\nfunction bfd_update_it(bfd, j, bh, len, ind, idx, val){\r\n    var ret;\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    /* try to update the factorization */\r\n    if (bfd.fhv != null)\r\n    {  switch (fhv_update_it(bfd.fhv, j, len, ind, idx, val))\r\n    {  case 0:\r\n            break;\r\n        case FHV_ESING:\r\n            bfd.valid = 0;\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case FHV_ECHECK:\r\n            bfd.valid = 0;\r\n            ret = BFD_ECHECK;\r\n            return ret;\r\n        case FHV_ELIMIT:\r\n            bfd.valid = 0;\r\n            ret = BFD_ELIMIT;\r\n            return ret;\r\n        case FHV_EROOM:\r\n            bfd.valid = 0;\r\n            ret = BFD_EROOM;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else if (bfd.lpf != null)\r\n    {  switch (lpf_update_it(bfd.lpf, j, bh, len, ind, idx, val))\r\n    {  case 0:\r\n            break;\r\n        case LPF_ESING:\r\n            bfd.valid = 0;\r\n            ret = BFD_ESING;\r\n            return ret;\r\n        case LPF_ELIMIT:\r\n            bfd.valid = 0;\r\n            ret = BFD_ELIMIT;\r\n            return ret;\r\n        default:\r\n            xassert(bfd != bfd);\r\n    }\r\n    }\r\n    else\r\n        xassert(bfd != bfd);\r\n    /* the factorization has been successfully updated */\r\n    /* increase the update count */\r\n    bfd.upd_cnt++;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction bfd_get_count(bfd){\r\n    /* determine factorization update count */\r\n    xassert(bfd != null);\r\n    xassert(bfd.valid);\r\n    return bfd.upd_cnt;\r\n}\r\n\r\nfunction check_parm(func, parm){\r\n    /* check control parameters */\r\n    xassert(func != null);\r\n    xassert(parm != null);\r\n}\r\n\r\nvar CHAR_SET = \"!\\\"#$%&()/,.;?@_`'{}|~\";\r\n/* characters, which may appear in symbolic names */\r\n\r\nvar glp_read_lp = exports[\"glp_read_lp\"] = function(P, parm, callback){\r\n    var\r\n        T_EOF        = 0x00,  /* end of file */\r\n        T_MINIMIZE   = 0x01,  /* keyword 'minimize' */\r\n        T_MAXIMIZE   = 0x02,  /* keyword 'maximize' */\r\n        T_SUBJECT_TO = 0x03,  /* keyword 'subject to' */\r\n        T_BOUNDS     = 0x04,  /* keyword 'bounds' */\r\n        T_GENERAL    = 0x05,  /* keyword 'general' */\r\n        T_INTEGER    = 0x06,  /* keyword 'integer' */\r\n        T_BINARY     = 0x07,  /* keyword 'binary' */\r\n        T_END        = 0x08,  /* keyword 'end' */\r\n        T_NAME       = 0x09,  /* symbolic name */\r\n        T_NUMBER     = 0x0A,  /* numeric constant */\r\n        T_PLUS       = 0x0B,  /* delimiter '+' */\r\n        T_MINUS      = 0x0C,  /* delimiter '-' */\r\n        T_COLON      = 0x0D,  /* delimiter ':' */\r\n        T_LE         = 0x0E,  /* delimiter '<=' */\r\n        T_GE         = 0x0F,  /* delimiter '>=' */\r\n        T_EQ         = 0x10;  /* delimiter '=' */\r\n\r\n    function error(csa, fmt){\r\n        /* print error message and terminate processing */\r\n        throw new Error(csa.count + \": \" + fmt);\r\n    }\r\n\r\n    function warning(csa, fmt)\r\n    {     /* print warning message and continue processing */\r\n        xprintf(csa.count + \": warning: \" + fmt);\r\n    }\r\n\r\n    function read_char(csa){\r\n        /* read next character from input file */\r\n        var c;\r\n        xassert(csa.c != XEOF);\r\n        if (csa.c == '\\n') csa.count++;\r\n        c = csa.callback();\r\n        if (c < 0)\r\n        {\r\n            if (csa.c == '\\n')\r\n            {  csa.count--;\r\n                c = XEOF;\r\n            }\r\n            else\r\n            {  warning(csa, \"missing final end of line\");\r\n                c = '\\n';\r\n            }\r\n        }\r\n        else if (c == '\\n'){\r\n\r\n        }\r\n        else if (isspace(c))\r\n            c = ' ';\r\n        else if (iscntrl(c))\r\n            error(csa, \"invalid control character \" + c.charCodeAt(0));\r\n        csa.c = c;\r\n    }\r\n\r\n    function add_char(csa){\r\n        /* append current character to current token */\r\n        csa.image += csa.c;\r\n        read_char(csa);\r\n    }\r\n\r\n    function the_same(s1, s2)\r\n    {\r\n        /* compare two character strings ignoring case sensitivity */\r\n        return (s1.toLowerCase() == s2.toLowerCase())?1:0;\r\n    }\r\n\r\n    function scan_token(csa){\r\n        /* scan next token */\r\n        var flag;\r\n        csa.token = -1;\r\n        csa.image = \"\";\r\n        csa.value = 0.0;\r\n\r\n\r\n        function name(){  /* symbolic name */\r\n            csa.token = T_NAME;\r\n            while (isalnum(csa.c) || strchr(CHAR_SET, csa.c) >= 0)\r\n                add_char(csa);\r\n            if (flag)\r\n            {  /* check for keyword */\r\n                if (the_same(csa.image, \"minimize\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"minimum\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"min\"))\r\n                    csa.token = T_MINIMIZE;\r\n                else if (the_same(csa.image, \"maximize\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"maximum\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"max\"))\r\n                    csa.token = T_MAXIMIZE;\r\n                else if (the_same(csa.image, \"subject\"))\r\n                {  if (csa.c == ' ')\r\n                {  read_char(csa);\r\n                    if (tolower(csa.c) == 't')\r\n                    {  csa.token = T_SUBJECT_TO;\r\n                        csa.image += ' ';\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'o')\r\n                            error(csa, \"keyword `subject to' incomplete\");\r\n                        add_char(csa);\r\n                        if (isalpha(csa.c))\r\n                            error(csa, \"keyword `\" + csa.image + csa.c + \"...' not recognized\");\r\n                    }\r\n                }\r\n                }\r\n                else if (the_same(csa.image, \"such\"))\r\n                {  if (csa.c == ' ')\r\n                {  read_char(csa);\r\n                    if (tolower(csa.c) == 't')\r\n                    {  csa.token = T_SUBJECT_TO;\r\n                        csa.image += ' ';\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'h')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 'a')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (tolower(csa.c) != 't')\r\n                            error(csa, \"keyword `such that' incomplete\");\r\n                        add_char(csa);\r\n                        if (isalpha(csa.c))\r\n                            error(csa, \"keyword `\" + csa.image + csa.c + \"...' not recognized\");\r\n                    }\r\n                }\r\n                }\r\n                else if (the_same(csa.image, \"st\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"s.t.\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"st.\"))\r\n                    csa.token = T_SUBJECT_TO;\r\n                else if (the_same(csa.image, \"bounds\"))\r\n                    csa.token = T_BOUNDS;\r\n                else if (the_same(csa.image, \"bound\"))\r\n                    csa.token = T_BOUNDS;\r\n                else if (the_same(csa.image, \"general\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"generals\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"gen\"))\r\n                    csa.token = T_GENERAL;\r\n                else if (the_same(csa.image, \"integer\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"integers\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"int\"))\r\n                    csa.token = T_INTEGER;\r\n                else if (the_same(csa.image, \"binary\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"binaries\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"bin\"))\r\n                    csa.token = T_BINARY;\r\n                else if (the_same(csa.image, \"end\"))\r\n                    csa.token = T_END;\r\n            }\r\n        }\r\n\r\n        while (true){\r\n            flag = 0;\r\n            /* skip non-significant characters */\r\n            while (csa.c == ' ') read_char(csa);\r\n            /* recognize and scan current token */\r\n            if (csa.c == XEOF)\r\n                csa.token = T_EOF;\r\n            else if (csa.c == '\\n')\r\n            {  read_char(csa);\r\n                /* if the next character is letter, it may begin a keyword */\r\n                if (isalpha(csa.c))\r\n                {  flag = 1;\r\n                    name();\r\n                } else\r\n                    continue;\r\n            }\r\n            else if (csa.c == '\\\\')\r\n            {  /* comment; ignore everything until end-of-line */\r\n                while (csa.c != '\\n') read_char(csa);\r\n                continue;\r\n            }\r\n            else if (isalpha(csa.c) || csa.c != '.' && strchr(CHAR_SET, csa.c) >= 0){\r\n                name();\r\n\r\n            }\r\n            else if (isdigit(csa.c) || csa.c == '.')\r\n            {  /* numeric constant */\r\n                csa.token = T_NUMBER;\r\n                /* scan integer part */\r\n                while (isdigit(csa.c)) add_char(csa);\r\n                /* scan optional fractional part (it is mandatory, if there is\r\n                 no integer part) */\r\n                if (csa.c == '.')\r\n                {  add_char(csa);\r\n                    if (csa.image.length == 1 && !isdigit(csa.c))\r\n                        error(csa, \"invalid use of decimal point\");\r\n                    while (isdigit(csa.c)) add_char(csa);\r\n                }\r\n                /* scan optional decimal exponent */\r\n                if (csa.c == 'e' || csa.c == 'E')\r\n                {  add_char(csa);\r\n                    if (csa.c == '+' || csa.c == '-') add_char(csa);\r\n                    if (!isdigit(csa.c))\r\n                        error(csa, \"numeric constant `\" + csa.image + \"' incomplete\");\r\n                    while (isdigit(csa.c)) add_char(csa);\r\n                }\r\n                /* convert the numeric constant to floating-point */\r\n                csa.value = Number(csa.image);\r\n                if (csa.value == Number.NaN)\r\n                    error(csa, \"numeric constant `\" + csa.image + \"' out of range\");\r\n            }\r\n            else if (csa.c == '+'){\r\n                csa.token = T_PLUS; add_char(csa);\r\n            }\r\n            else if (csa.c == '-'){\r\n                csa.token = T_MINUS; add_char(csa);\r\n            }\r\n            else if (csa.c == ':'){\r\n                csa.token = T_COLON; add_char(csa);\r\n            }\r\n            else if (csa.c == '<')\r\n            {  csa.token = T_LE; add_char(csa);\r\n                if (csa.c == '=') add_char(csa);\r\n            }\r\n            else if (csa.c == '>')\r\n            {  csa.token = T_GE; add_char(csa);\r\n                if (csa.c == '=') add_char(csa);\r\n            }\r\n            else if (csa.c == '=')\r\n            {  csa.token = T_EQ; add_char(csa);\r\n                if (csa.c == '<'){\r\n                    csa.token = T_LE; add_char(csa);\r\n                }\r\n                else if (csa.c == '>'){\r\n                    csa.token = T_GE; add_char(csa);\r\n                }\r\n            }\r\n            else\r\n                error(csa, \"character `\" + csa.c + \"' not recognized\");\r\n            break\r\n        }\r\n\r\n        /* skip non-significant characters */\r\n        while (csa.c == ' ') read_char(csa);\r\n    }\r\n\r\n    function find_col(csa, name){\r\n        /* find column by its symbolic name */\r\n        var j = glp_find_col(csa.P, name);\r\n        if (j == 0)\r\n        {  /* not found; create new column */\r\n            j = glp_add_cols(csa.P, 1);\r\n            glp_set_col_name(csa.P, j, name);\r\n            /* enlarge working arrays, if necessary */\r\n            if (csa.n_max < j)\r\n            {  var n_max = csa.n_max;\r\n                var ind = csa.ind;\r\n                var val = csa.val;\r\n                var flag = csa.flag;\r\n                var lb = csa.lb;\r\n                var ub = csa.ub;\r\n                csa.n_max += csa.n_max;\r\n                csa.ind = new Int32Array(1+csa.n_max);\r\n                xcopyArr(csa.ind, 1, ind, 1, n_max);\r\n                csa.val = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.val, 1, val, 1, n_max);\r\n                csa.flag = new Int8Array(1+csa.n_max);\r\n                xfillArr(csa.flag, 1, 0, csa.n_max);\r\n                xcopyArr(csa.flag, 1, flag, 1, n_max);\r\n                csa.lb = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.lb, 1, lb, 1, n_max);\r\n                csa.ub = new Float64Array(1+csa.n_max);\r\n                xcopyArr(csa.ub, 1, ub, 1, n_max);\r\n            }\r\n            csa.lb[j] = +DBL_MAX; csa.ub[j] = -DBL_MAX;\r\n        }\r\n        return j;\r\n    }\r\n\r\n    function parse_linear_form(csa){\r\n        var j, k, len = 0, newlen;\r\n        var s, coef;\r\n\r\n        while(true){\r\n            /* parse an optional sign */\r\n            if (csa.token == T_PLUS){\r\n                s = +1.0; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_MINUS){\r\n                s = -1.0; scan_token(csa);\r\n            }\r\n            else\r\n                s = +1.0;\r\n            /* parse an optional coefficient */\r\n            if (csa.token == T_NUMBER){\r\n                coef = csa.value; scan_token(csa);\r\n            }\r\n            else\r\n                coef = 1.0;\r\n            /* parse a variable name */\r\n            if (csa.token != T_NAME)\r\n                error(csa, \"missing variable name\");\r\n            /* find the corresponding column */\r\n            j = find_col(csa, csa.image);\r\n            /* check if the variable is already used in the linear form */\r\n            if (csa.flag[j])\r\n                error(csa, \"multiple use of variable `\" + csa.image + \"' not allowed\");\r\n            /* add new term to the linear form */\r\n            len++; csa.ind[len] = j; csa.val[len] = s * coef;\r\n            /* and mark that the variable is used in the linear form */\r\n            csa.flag[j] = 1;\r\n            scan_token(csa);\r\n            /* if the next token is a sign, there is another term */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS) continue;\r\n            /* clear marks of the variables used in the linear form */\r\n            for (k = 1; k <= len; k++) csa.flag[csa.ind[k]] = 0;\r\n            /* remove zero coefficients */\r\n            newlen = 0;\r\n            for (k = 1; k <= len; k++)\r\n            {  if (csa.val[k] != 0.0)\r\n            {  newlen++;\r\n                csa.ind[newlen] = csa.ind[k];\r\n                csa.val[newlen] = csa.val[k];\r\n            }\r\n            }\r\n            break;\r\n        }\r\n        return newlen;\r\n    }\r\n\r\n    function parse_objective(csa){\r\n        /* parse objective sense */\r\n        var k, len;\r\n        /* parse the keyword 'minimize' or 'maximize' */\r\n        if (csa.token == T_MINIMIZE)\r\n            glp_set_obj_dir(csa.P, GLP_MIN);\r\n        else if (csa.token == T_MAXIMIZE)\r\n            glp_set_obj_dir(csa.P, GLP_MAX);\r\n        else\r\n            xassert(csa != csa);\r\n        scan_token(csa);\r\n        /* parse objective name */\r\n        if (csa.token == T_NAME && csa.c == ':')\r\n        {  /* objective name is followed by a colon */\r\n            glp_set_obj_name(csa.P, csa.image);\r\n            scan_token(csa);\r\n            xassert(csa.token == T_COLON);\r\n            scan_token(csa);\r\n        }\r\n        else\r\n        {  /* objective name is not specified; use default */\r\n            glp_set_obj_name(csa.P, \"obj\");\r\n        }\r\n        /* parse linear form */\r\n        len = parse_linear_form(csa);\r\n        for (k = 1; k <= len; k++)\r\n            glp_set_obj_coef(csa.P, csa.ind[k], csa.val[k]);\r\n    }\r\n\r\n    function parse_constraints(csa){\r\n        var i, len, type;\r\n        var s;\r\n        /* parse the keyword 'subject to' */\r\n        xassert(csa.token == T_SUBJECT_TO);\r\n        scan_token(csa);\r\n\r\n        while (true){\r\n            /* create new row (constraint) */\r\n            i = glp_add_rows(csa.P, 1);\r\n            /* parse row name */\r\n            if (csa.token == T_NAME && csa.c == ':')\r\n            {  /* row name is followed by a colon */\r\n                if (glp_find_row(csa.P, csa.image) != 0)\r\n                    error(csa, \"constraint `\" + csa.image + \"' multiply defined\");\r\n                glp_set_row_name(csa.P, i, csa.image);\r\n                scan_token(csa);\r\n                xassert(csa.token == T_COLON);\r\n                scan_token(csa);\r\n            }\r\n            else\r\n            {  /* row name is not specified; use default */\r\n                glp_set_row_name(csa.P, i, \"r.\" + csa.count);\r\n            }\r\n            /* parse linear form */\r\n            len = parse_linear_form(csa);\r\n            glp_set_mat_row(csa.P, i, len, csa.ind, csa.val);\r\n            /* parse constraint sense */\r\n            if (csa.token == T_LE){\r\n                type = GLP_UP; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_GE){\r\n                type = GLP_LO; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_EQ){\r\n                type = GLP_FX; scan_token(csa);\r\n            }\r\n            else\r\n                error(csa, \"missing constraint sense\");\r\n            /* parse right-hand side */\r\n            if (csa.token == T_PLUS){\r\n                s = +1.0; scan_token(csa);\r\n            }\r\n            else if (csa.token == T_MINUS){\r\n                s = -1.0; scan_token(csa);\r\n            }\r\n            else\r\n                s = +1.0;\r\n            if (csa.token != T_NUMBER)\r\n                error(csa, \"missing right-hand side\");\r\n            glp_set_row_bnds(csa.P, i, type, s * csa.value, s * csa.value);\r\n            /* the rest of the current line must be empty */\r\n            if (!(csa.c == '\\n' || csa.c == XEOF))\r\n                error(csa, \"invalid symbol(s) beyond right-hand side\");\r\n            scan_token(csa);\r\n            /* if the next token is a sign, numeric constant, or a symbolic\r\n             name, here is another constraint */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS ||\r\n                csa.token == T_NUMBER || csa.token == T_NAME) continue;\r\n            break;\r\n        }\r\n    }\r\n\r\n    function set_lower_bound(csa, j, lb){\r\n        /* set lower bound of j-th variable */\r\n        if (csa.lb[j] != +DBL_MAX)\r\n        {\r\n            warning(csa, \"lower bound of variable `\" + glp_get_col_name(csa.P, j) + \"' redefined\");\r\n        }\r\n        csa.lb[j] = lb;\r\n    }\r\n\r\n    function set_upper_bound(csa, j, ub){\r\n        /* set upper bound of j-th variable */\r\n        if (csa.ub[j] != -DBL_MAX)\r\n        {\r\n            warning(csa, \"upper bound of variable `\" + glp_get_col_name(csa.P, j) + \"' redefined\");\r\n        }\r\n        csa.ub[j] = ub;\r\n    }\r\n\r\n    function parse_bounds(csa){\r\n        var j, lb_flag;\r\n        var lb, s;\r\n        /* parse the keyword 'bounds' */\r\n        xassert(csa.token == T_BOUNDS);\r\n        scan_token(csa);\r\n\r\n        while (true){\r\n            /* bound definition can start with a sign, numeric constant, or\r\n             a symbolic name */\r\n            if (!(csa.token == T_PLUS || csa.token == T_MINUS ||\r\n                csa.token == T_NUMBER || csa.token == T_NAME)) return;\r\n            /* parse bound definition */\r\n            if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n            {  /* parse signed lower bound */\r\n                lb_flag = 1;\r\n                s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                scan_token(csa);\r\n                if (csa.token == T_NUMBER){\r\n                    lb = s * csa.value; scan_token(csa);\r\n                }\r\n                else if (the_same(csa.image, \"infinity\") ||\r\n                    the_same(csa.image, \"inf\"))\r\n                {  if (s > 0.0)\r\n                    error(csa, \"invalid use of `+inf' as lower bound\");\r\n                    lb = -DBL_MAX; scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing lower bound\");\r\n            }\r\n            else if (csa.token == T_NUMBER)\r\n            {  /* parse unsigned lower bound */\r\n                lb_flag = 1;\r\n                lb = csa.value; scan_token(csa);\r\n            }\r\n            else\r\n            {  /* lower bound is not specified */\r\n                lb_flag = 0;\r\n            }\r\n            /* parse the token that should follow the lower bound */\r\n            if (lb_flag)\r\n            {  if (csa.token != T_LE)\r\n                error(csa, \"missing `<', `<=', or `=<' after lower bound\");\r\n                scan_token(csa);\r\n            }\r\n            /* parse variable name */\r\n            if (csa.token != T_NAME)\r\n                error(csa, \"missing variable name\");\r\n            j = find_col(csa, csa.image);\r\n            /* set lower bound */\r\n            if (lb_flag) set_lower_bound(csa, j, lb);\r\n            scan_token(csa);\r\n            /* parse the context that follows the variable name */\r\n            if (csa.token == T_LE)\r\n            {  /* parse upper bound */\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed upper bound */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_upper_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else if (the_same(csa.image, \"infinity\") ||\r\n                        the_same(csa.image, \"inf\"))\r\n                    {  if (s < 0.0)\r\n                        error(csa, \"invalid use of `-inf' as upper bound\");\r\n                        set_upper_bound(csa, j, +DBL_MAX);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing upper bound\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned upper bound */\r\n                    set_upper_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing upper bound\");\r\n            }\r\n            else if (csa.token == T_GE)\r\n            {  /* parse lower bound */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x >= ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed lower bound */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_lower_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else if (the_same(csa.image, \"infinity\") ||\r\n                        the_same(csa.image, \"inf\") == 0)\r\n                    {  if (s > 0.0)\r\n                        error(csa, \"invalid use of `+inf' as lower bound\");\r\n                        set_lower_bound(csa, j, -DBL_MAX);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing lower bound\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned lower bound */\r\n                    set_lower_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing lower bound\");\r\n            }\r\n            else if (csa.token == T_EQ)\r\n            {  /* parse fixed value */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x = ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                scan_token(csa);\r\n                if (csa.token == T_PLUS || csa.token == T_MINUS)\r\n                {  /* parse signed fixed value */\r\n                    s = (csa.token == T_PLUS ? +1.0 : -1.0);\r\n                    scan_token(csa);\r\n                    if (csa.token == T_NUMBER)\r\n                    {  set_lower_bound(csa, j, s * csa.value);\r\n                        set_upper_bound(csa, j, s * csa.value);\r\n                        scan_token(csa);\r\n                    }\r\n                    else\r\n                        error(csa, \"missing fixed value\");\r\n                }\r\n                else if (csa.token == T_NUMBER)\r\n                {  /* parse unsigned fixed value */\r\n                    set_lower_bound(csa, j, csa.value);\r\n                    set_upper_bound(csa, j, csa.value);\r\n                    scan_token(csa);\r\n                }\r\n                else\r\n                    error(csa, \"missing fixed value\");\r\n            }\r\n            else if (the_same(csa.image, \"free\"))\r\n            {  /* parse the keyword 'free' */\r\n                if (lb_flag)\r\n                {  /* the context '... <= x free ...' is invalid */\r\n                    error(csa, \"invalid bound definition\");\r\n                }\r\n                set_lower_bound(csa, j, -DBL_MAX);\r\n                set_upper_bound(csa, j, +DBL_MAX);\r\n                scan_token(csa);\r\n            }\r\n            else if (!lb_flag)\r\n            {  /* neither lower nor upper bounds are specified */\r\n                error(csa, \"invalid bound definition\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function parse_integer(csa){\r\n        var j, binary;\r\n        /* parse the keyword 'general', 'integer', or 'binary' */\r\n        if (csa.token == T_GENERAL){\r\n            binary = 0; scan_token(csa);\r\n        }\r\n        else if (csa.token == T_INTEGER){\r\n            binary = 0; scan_token(csa);\r\n        }\r\n        else if (csa.token == T_BINARY){\r\n            binary = 1; scan_token(csa);\r\n        }\r\n        else\r\n            xassert(csa != csa);\r\n        /* parse list of variables (may be empty) */\r\n        while (csa.token == T_NAME)\r\n        {  /* find the corresponding column */\r\n            j = find_col(csa, csa.image);\r\n            /* change kind of the variable */\r\n            glp_set_col_kind(csa.P, j, GLP_IV);\r\n            /* set 0-1 bounds for the binary variable */\r\n            if (binary)\r\n            {  set_lower_bound(csa, j, 0.0);\r\n                set_upper_bound(csa, j, 1.0);\r\n            }\r\n            scan_token(csa);\r\n        }\r\n    }\r\n\r\n    /* read problem data in CPLEX LP format */\r\n    var csa = {};\r\n    var ret;\r\n    xprintf(\"Reading problem data\");\r\n    if (parm == null){\r\n        parm = {};\r\n    }\r\n    /* check control parameters */\r\n    check_parm(\"glp_read_lp\", parm);\r\n    /* initialize common storage area */\r\n    csa.P = P;\r\n    csa.parm = parm;\r\n    csa.callback = callback;\r\n    csa.count = 0;\r\n    csa.c = '\\n';\r\n    csa.token = T_EOF;\r\n    csa.image = \"\";\r\n    csa.value = 0.0;\r\n    csa.n_max = 100;\r\n    csa.ind = new Int32Array(1+csa.n_max);\r\n    csa.val = new Float64Array(1+csa.n_max);\r\n    csa.flag = new Int8Array(1+csa.n_max);\r\n    xfillArr(csa.flag, 1, 0, csa.n_max);\r\n    csa.lb = new Float64Array(1+csa.n_max);\r\n    csa.ub = new Float64Array(1+csa.n_max);\r\n    /* erase problem object */\r\n    glp_erase_prob(P);\r\n    glp_create_index(P);\r\n    /* scan very first token */\r\n    scan_token(csa);\r\n    /* parse definition of the objective function */\r\n    if (!(csa.token == T_MINIMIZE || csa.token == T_MAXIMIZE))\r\n        error(csa, \"`minimize' or `maximize' keyword missing\");\r\n    parse_objective(csa);\r\n    /* parse constraints section */\r\n    if (csa.token != T_SUBJECT_TO)\r\n        error(csa, \"constraints section missing\");\r\n    parse_constraints(csa);\r\n    /* parse optional bounds section */\r\n    if (csa.token == T_BOUNDS) parse_bounds(csa);\r\n    /* parse optional general, integer, and binary sections */\r\n    while (csa.token == T_GENERAL ||\r\n        csa.token == T_INTEGER ||\r\n        csa.token == T_BINARY) parse_integer(csa);\r\n    /* check for the keyword 'end' */\r\n    if (csa.token == T_END)\r\n        scan_token(csa);\r\n    else if (csa.token == T_EOF)\r\n        warning(csa, \"keyword `end' missing\");\r\n    else\r\n        error(csa, \"symbol \" + csa.image + \" in wrong position\");\r\n    /* nothing must follow the keyword 'end' (except comments) */\r\n    if (csa.token != T_EOF)\r\n        error(csa, \"extra symbol(s) detected beyond `end'\");\r\n    /* set bounds of variables */\r\n    {  var j, type;\r\n        var lb, ub;\r\n        for (j = 1; j <= P.n; j++)\r\n        {  lb = csa.lb[j];\r\n            ub = csa.ub[j];\r\n            if (lb == +DBL_MAX) lb = 0.0;      /* default lb */\r\n            if (ub == -DBL_MAX) ub = +DBL_MAX; /* default ub */\r\n            if (lb == -DBL_MAX && ub == +DBL_MAX)\r\n                type = GLP_FR;\r\n            else if (ub == +DBL_MAX)\r\n                type = GLP_LO;\r\n            else if (lb == -DBL_MAX)\r\n                type = GLP_UP;\r\n            else if (lb != ub)\r\n                type = GLP_DB;\r\n            else\r\n                type = GLP_FX;\r\n            glp_set_col_bnds(csa.P, j, type, lb, ub);\r\n        }\r\n    }\r\n    /* print some statistics */\r\n    xprintf(P.m + \" row\" + (P.m == 1 ? \"\" : \"s\") + \", \" + P.n + \" column\" + (P.n == 1 ? \"\" : \"s\") + \", \" + P.nnz + \" non-zero\" + (P.nnz == 1 ? \"\" : \"s\"));\r\n    if (glp_get_num_int(P) > 0)\r\n    {  var ni = glp_get_num_int(P);\r\n        var nb = glp_get_num_bin(P);\r\n        if (ni == 1)\r\n        {  if (nb == 0)\r\n            xprintf(\"One variable is integer\");\r\n        else\r\n            xprintf(\"One variable is binary\");\r\n        }\r\n        else\r\n        {   var line = ni + \" integer variables, \";\r\n            if (nb == 0)\r\n                line += \"none\";\r\n            else if (nb == 1)\r\n                line += \"one\";\r\n            else if (nb == ni)\r\n                line += \"all\";\r\n            else\r\n                line += nb;\r\n            xprintf(line + \" of which \" + (nb == 1 ? \"is\" : \"are\") + \" binary\");\r\n        }\r\n    }\r\n    xprintf(csa.count + \" lines were read\");\r\n    /* problem data has been successfully read */\r\n    glp_delete_index(P);\r\n    glp_sort_matrix(P);\r\n    ret = 0;\r\n\r\n    function done(){\r\n        if (ret != 0) glp_erase_prob(P);\r\n        return ret;\r\n    }\r\n    return done();\r\n};\r\n\r\nvar glp_write_lp = exports[\"glp_write_lp\"] = function(P, parm, callback){\r\n\r\n    function check_name(name){\r\n        /* check if specified name is valid for CPLEX LP format */\r\n        if (name[0] == '.') return 1;\r\n        if (isdigit((name[0]))) return 1;\r\n        for (var i = 0; i < name.length; i++)\r\n        {  if (!isalnum(name[i]) &&\r\n            strchr(CHAR_SET, name[i]) < 0) return 1;\r\n        }\r\n        return 0; /* name is ok */\r\n    }\r\n\r\n    function adjust_name(name){\r\n        /* attempt to adjust specified name to make it valid for CPLEX LP format */\r\n        for (var i = 0; i < name.length; i++)\r\n        {  if (name[i] == ' ')\r\n            name[i] = '_';\r\n        else if (name[i] == '-')\r\n            name[i] = '~';\r\n        else if (name[i] == '[')\r\n            name[i] = '(';\r\n        else if (name[i] == ']')\r\n            name[i] = ')';\r\n        }\r\n    }\r\n\r\n    function row_name(csa, i){\r\n        /* construct symbolic name of i-th row (constraint) */\r\n        var name;\r\n        if (i == 0)\r\n            name = glp_get_obj_name(csa.P);\r\n        else\r\n            name = glp_get_row_name(csa.P, i);\r\n        if (name == null) return fake();\r\n        adjust_name(name);\r\n        if (check_name(name)) return fake();\r\n        return name;\r\n\r\n        function fake(){\r\n            if (i == 0)\r\n                return \"obj\";\r\n            else\r\n                return \"r_\" + i;\r\n        }\r\n    }\r\n\r\n    function col_name(csa, j){\r\n        /* construct symbolic name of j-th column (variable) */\r\n        var name = glp_get_col_name(csa.P, j);\r\n        if (name == null) return fake();\r\n        adjust_name(name);\r\n        if (check_name(name)) return fake();\r\n        return name;\r\n        function fake(){\r\n            return \"x_\" + j;\r\n        }\r\n    }\r\n\r\n    /* write problem data in CPLEX LP format */\r\n    var csa = {};\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, len, flag, count, ret;\r\n    var line, term, name;\r\n    xprintf(\"Writing problem data\");\r\n    if (parm == null){\r\n        parm = {};\r\n    }\r\n    /* check control parameters */\r\n    check_parm(\"glp_write_lp\", parm);\r\n    /* initialize common storage area */\r\n    csa.P = P;\r\n    csa.parm = parm;\r\n    count = 0;\r\n    /* write problem name */\r\n    callback(\"\\\\* Problem: \" + (P.name == null ? \"Unknown\" : P.name) + \" *\\\\\"); count++;\r\n    callback(\"\"); count++;\r\n    /* the problem should contain at least one row and one column */\r\n    if (!(P.m > 0 && P.n > 0))\r\n    {  xprintf(\"Warning: problem has no rows/columns\");\r\n        callback(\"\\\\* WARNING: PROBLEM HAS NO ROWS/COLUMNS *\\\\\"); count++;\r\n        callback(\"\"); count++;\r\n        return skip();\r\n    }\r\n    /* write the objective function definition */\r\n    if (P.dir == GLP_MIN){\r\n        callback(\"Minimize\"); count++;\r\n    }\r\n    else if (P.dir == GLP_MAX){\r\n        callback(\"Maximize\"); count++;\r\n    }\r\n    else\r\n        xassert(P != P);\r\n    name = row_name(csa, 0);\r\n    line = \" \" + name + \":\";\r\n    len = 0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.coef != 0.0 || col.ptr == null)\r\n        {  len++;\r\n            name = col_name(csa, j);\r\n            if (col.coef == 0.0)\r\n                term = \" + 0 \" + name; /* empty column */\r\n            else if (col.coef == +1.0)\r\n                term = \" + \" + name;\r\n            else if (col.coef == -1.0)\r\n                term = \" - \" + name;\r\n            else if (col.coef > 0.0)\r\n                term = \" + \" + col.coef + \" \" + name;\r\n            else\r\n                term = \" - \" + (-col.coef) + \" \" + name;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n\r\n            line += term;\r\n        }\r\n    }\r\n    if (len == 0)\r\n    {  /* empty objective */\r\n        term = \" 0 \" + col_name(csa, 1);\r\n        line += term;\r\n    }\r\n    callback(line); count++;\r\n    if (P.c0 != 0.0){\r\n        callback(\"\\\\* constant term = \" + P.c0 + \" *\\\\\"); count++;\r\n    }\r\n\r\n    callback(\"\"); count++;\r\n    /* write the constraints section */\r\n    callback(\"Subject To\"); count++;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.type == GLP_FR) continue; /* skip free row */\r\n        name = row_name(csa, i);\r\n        line = \" \" + name + \":\";\r\n        /* linear form */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  name = col_name(csa, aij.col.j);\r\n            if (aij.val == +1.0)\r\n                term =  \" + \" + name;\r\n            else if (aij.val == -1.0)\r\n                term = \" - \" + name;\r\n            else if (aij.val > 0.0)\r\n                term = \" + \" + aij.val + \" \"  + name;\r\n            else\r\n                term = \" - \" + (-aij.val) + \" \" + name;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n\r\n            line += term;\r\n        }\r\n        if (row.type == GLP_DB)\r\n        {  /* double-bounded (ranged) constraint */\r\n            term = \" - ~r_\" + i;\r\n            if (line.length + term.length > 72){\r\n                callback(line); line = \"\"; count++;\r\n            }\r\n            line += term;\r\n        }\r\n        else if (row.ptr == null)\r\n        {  /* empty constraint */\r\n            term = \" 0 \" + col_name(csa, 1);\r\n            line += term;\r\n        }\r\n        /* right hand-side */\r\n        if (row.type == GLP_LO)\r\n            term = \" >= \" + row.lb;\r\n        else if (row.type == GLP_UP)\r\n            term = \" <= \" + row.ub;\r\n        else if (row.type == GLP_DB || row.type == GLP_FX)\r\n            term = \" = \" + row.lb;\r\n        else\r\n            xassert(row != row);\r\n        if (line.length + term.length > 72){\r\n            callback(line); line = \"\"; count++;\r\n        }\r\n        line += term;\r\n        callback(line); count++;\r\n    }\r\n    callback(\"\"); count++;\r\n    /* write the bounds section */\r\n    flag = 0;\r\n    for (i = 1; i <= P.m; i++)\r\n    {  row = P.row[i];\r\n        if (row.type != GLP_DB) continue;\r\n        if (!flag){\r\n            callback(\"Bounds\"); flag = 1; count++;\r\n        }\r\n\r\n        callback(\" 0 <= ~r_\" + i + \" <= \" + (row.ub - row.lb)); count++;\r\n    }\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.type == GLP_LO && col.lb == 0.0) continue;\r\n        if (!flag){\r\n            callback(\"Bounds\"); flag = 1; count++;\r\n        }\r\n        name = col_name(csa, j);\r\n        if (col.type == GLP_FR){\r\n            callback(\" \" + name + \" free\"); count++;\r\n        }\r\n        else if (col.type == GLP_LO){\r\n            callback(\" \" + name + \" >= \" + col.lb); count++;\r\n        }\r\n        else if (col.type == GLP_UP){\r\n            callback(\" -Inf <= \" + name + \" <= \" + col.ub); count++;\r\n        }\r\n        else if (col.type == GLP_DB){\r\n            callback(\" \" + col.lb + \" <= \" + name + \" <= \" + col.ub); count++;\r\n        }\r\n        else if (col.type == GLP_FX){\r\n            callback(\" \" + name + \" = \" + col.lb); count++;\r\n        }\r\n        else\r\n            xassert(col != col);\r\n    }\r\n    if (flag) callback(\"\"); count++;\r\n    /* write the integer section */\r\n    flag = 0;\r\n    for (j = 1; j <= P.n; j++)\r\n    {  col = P.col[j];\r\n        if (col.kind == GLP_CV) continue;\r\n        xassert(col.kind == GLP_IV);\r\n        if (!flag){\r\n            callback(\"Generals\"); flag = 1; count++;\r\n        }\r\n\r\n        callback(\" \" + col_name(csa, j)); count++;\r\n    }\r\n    if (flag) {callback(\"\"); count++}\r\n\r\n    function skip(){\r\n        /* write the end keyword */\r\n        callback(\"End\"); count++;\r\n        /* problem data has been successfully written */\r\n        xprintf(count + \" lines were written\");\r\n        return 0;\r\n    }\r\n    return skip();\r\n};\r\n\r\nvar glp_read_lp_from_string = exports[\"glp_read_lp_from_string\"] = function(P, parm, str){\r\n    var pos = 0;\r\n    return glp_read_lp(P, parm,\r\n        function(){\r\n            if (pos < str.length){\r\n                return str[pos++];\r\n            } else\r\n                return -1;\r\n        }\r\n    )\r\n};\r\n\r\n/* return codes: */\r\nvar\r\n    FHV_ESING   = 1,  /* singular matrix */\r\n    FHV_ECOND   = 2,  /* ill-conditioned matrix */\r\n    FHV_ECHECK  = 3,  /* insufficient accuracy */\r\n    FHV_ELIMIT  = 4,  /* update limit reached */\r\n    FHV_EROOM   = 5;  /* SVA overflow */\r\n\r\nfunction fhv_create_it(){\r\n    var fhv;\r\n    fhv = {};\r\n    fhv.m_max = fhv.m = 0;\r\n    fhv.valid = 0;\r\n    fhv.luf = luf_create_it();\r\n    fhv.hh_max = 50;\r\n    fhv.hh_nfs = 0;\r\n    fhv.hh_ind = fhv.hh_ptr = fhv.hh_len = null;\r\n    fhv.p0_row = fhv.p0_col = null;\r\n    fhv.cc_ind = null;\r\n    fhv.cc_val = null;\r\n    fhv.upd_tol = 1e-6;\r\n    fhv.nnz_h = 0;\r\n    return fhv;\r\n}\r\n\r\nfunction fhv_factorize(fhv, m, col, info){\r\n    var ret;\r\n    if (m < 1)\r\n        xerror(\"fhv_factorize: m = \" + m + \"; invalid parameter\");\r\n    if (m > M_MAX)\r\n        xerror(\"fhv_factorize: m = \" + m + \"; matrix too big\");\r\n    fhv.m = m;\r\n    /* invalidate the factorization */\r\n    fhv.valid = 0;\r\n    /* allocate/reallocate arrays, if necessary */\r\n    if (fhv.hh_ind == null)\r\n        fhv.hh_ind = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.hh_ptr == null)\r\n        fhv.hh_ptr = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.hh_len == null)\r\n        fhv.hh_len = new Int32Array(1+fhv.hh_max);\r\n    if (fhv.m_max < m)\r\n    {\r\n        fhv.m_max = m + 100;\r\n        fhv.p0_row = new Int32Array(1+fhv.m_max);\r\n        fhv.p0_col = new Int32Array(1+fhv.m_max);\r\n        fhv.cc_ind = new Int32Array(1+fhv.m_max);\r\n        fhv.cc_val = new Float64Array(1+fhv.m_max);\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    switch (luf_factorize(fhv.luf, m, col, info))\r\n    {  case 0:\r\n        break;\r\n        case LUF_ESING:\r\n            ret = FHV_ESING;\r\n            return ret;\r\n        case LUF_ECOND:\r\n            ret = FHV_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(fhv != fhv);\r\n    }\r\n    /* the basis matrix has been successfully factorized */\r\n    fhv.valid = 1;\r\n    /* H := I */\r\n    fhv.hh_nfs = 0;\r\n    /* P0 := P */\r\n    xcopyArr(fhv.p0_row, 1, fhv.luf.pp_row, 1, m);\r\n    xcopyArr(fhv.p0_col, 1, fhv.luf.pp_col, 1, m);\r\n    /* currently H has no factors */\r\n    fhv.nnz_h = 0;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction fhv_h_solve(fhv, tr, x){\r\n    var nfs = fhv.hh_nfs;\r\n    var hh_ind = fhv.hh_ind;\r\n    var hh_ptr = fhv.hh_ptr;\r\n    var hh_len = fhv.hh_len;\r\n    var sv_ind = fhv.luf.sv_ind;\r\n    var sv_val = fhv.luf.sv_val;\r\n    var i, k, beg, end, ptr;\r\n    var temp;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_h_solve: the factorization is not valid\");\r\n    if (!tr)\r\n    {  /* solve the system H*x = b */\r\n        for (k = 1; k <= nfs; k++)\r\n        {  i = hh_ind[k];\r\n            temp = x[i];\r\n            beg = hh_ptr[k];\r\n            end = beg + hh_len[k] - 1;\r\n            for (ptr = beg; ptr <= end; ptr++)\r\n                temp -= sv_val[ptr] * x[sv_ind[ptr]];\r\n            x[i] = temp;\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system H'*x = b */\r\n        for (k = nfs; k >= 1; k--)\r\n        {  i = hh_ind[k];\r\n            temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            beg = hh_ptr[k];\r\n            end = beg + hh_len[k] - 1;\r\n            for (ptr = beg; ptr <= end; ptr++)\r\n                x[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n        }\r\n    }\r\n}\r\n\r\nfunction fhv_ftran(fhv, x){\r\n    var pp_row = fhv.luf.pp_row;\r\n    var pp_col = fhv.luf.pp_col;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_ftran: the factorization is not valid\");\r\n    /* B = F*H*V, therefore inv(B) = inv(V)*inv(H)*inv(F) */\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 0, x);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n    fhv_h_solve(fhv, 0, x);\r\n    luf_v_solve(fhv.luf, 0, x);\r\n}\r\n\r\nfunction fhv_btran(fhv, x){\r\n    var pp_row = fhv.luf.pp_row;\r\n    var pp_col = fhv.luf.pp_col;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_btran: the factorization is not valid\");\r\n    /* B = F*H*V, therefore inv(B') = inv(F')*inv(H')*inv(V') */\r\n    luf_v_solve(fhv.luf, 1, x);\r\n    fhv_h_solve(fhv, 1, x);\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 1, x);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n}\r\n\r\nfunction fhv_update_it(fhv, j, len, ind, idx, val){\r\n    var m = fhv.m;\r\n    var luf = fhv.luf;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var pp_row = luf.pp_row;\r\n    var pp_col = luf.pp_col;\r\n    var qq_row = luf.qq_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var work = luf.work;\r\n    var eps_tol = luf.eps_tol;\r\n    var hh_ind = fhv.hh_ind;\r\n    var hh_ptr = fhv.hh_ptr;\r\n    var hh_len = fhv.hh_len;\r\n    var p0_row = fhv.p0_row;\r\n    var p0_col = fhv.p0_col;\r\n    var cc_ind = fhv.cc_ind;\r\n    var cc_val = fhv.cc_val;\r\n    var upd_tol = fhv.upd_tol;\r\n    var i, i_beg, i_end, i_ptr, j_beg, j_end, j_ptr, k, k1, k2, p, q,\r\n        p_beg, p_end, p_ptr, ptr, ret;\r\n    var f, temp;\r\n    if (!fhv.valid)\r\n        xerror(\"fhv_update_it: the factorization is not valid\");\r\n    if (!(1 <= j && j <= m))\r\n        xerror(\"fhv_update_it: j = \" + j + \"; column number out of range\");\r\n    /* check if the new factor of matrix H can be created */\r\n    if (fhv.hh_nfs == fhv.hh_max)\r\n    {  /* maximal number of updates has been reached */\r\n        fhv.valid = 0;\r\n        ret = FHV_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* convert new j-th column of B to dense format */\r\n    for (i = 1; i <= m; i++)\r\n        cc_val[i] = 0.0;\r\n    for (k = 1; k <= len; k++)\r\n    {  i = ind[idx + k];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"fhv_update_it: ind[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        if (cc_val[i] != 0.0)\r\n            xerror(\"fhv_update_it: ind[\" + k + \"] = \" + i + \"; duplicate row index not allowed\");\r\n        if (val[k] == 0.0)\r\n            xerror(\"fhv_update_it: val[\" + k + \"] = \" + val[k] + \"; zero element not allowed\");\r\n        cc_val[i] = val[k];\r\n    }\r\n    /* new j-th column of V := inv(F * H) * (new B[j]) */\r\n    fhv.luf.pp_row = p0_row;\r\n    fhv.luf.pp_col = p0_col;\r\n    luf_f_solve(fhv.luf, 0, cc_val);\r\n    fhv.luf.pp_row = pp_row;\r\n    fhv.luf.pp_col = pp_col;\r\n    fhv_h_solve(fhv, 0, cc_val);\r\n    /* convert new j-th column of V to sparse format */\r\n    len = 0;\r\n    for (i = 1; i <= m; i++)\r\n    {  temp = cc_val[i];\r\n        if (temp == 0.0 || Math.abs(temp) < eps_tol) continue;\r\n        len++; cc_ind[len] = i; cc_val[len] = temp;\r\n    }\r\n    /* clear old content of j-th column of matrix V */\r\n    j_beg = vc_ptr[j];\r\n    j_end = j_beg + vc_len[j] - 1;\r\n    for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n    {  /* get row index of v[i,j] */\r\n        i = sv_ind[j_ptr];\r\n        /* find v[i,j] in the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; sv_ind[i_ptr] != j; i_ptr++){/* nop */}\r\n        xassert(i_ptr <= i_end);\r\n        /* remove v[i,j] from the i-th row */\r\n        sv_ind[i_ptr] = sv_ind[i_end];\r\n        sv_val[i_ptr] = sv_val[i_end];\r\n        vr_len[i]--;\r\n    }\r\n    /* now j-th column of matrix V is empty */\r\n    luf.nnz_v -= vc_len[j];\r\n    vc_len[j] = 0;\r\n    /* add new elements of j-th column of matrix V to corresponding\r\n     row lists; determine indices k1 and k2 */\r\n    k1 = qq_row[j]; k2 = 0;\r\n    for (ptr = 1; ptr <= len; ptr++)\r\n    {  /* get row index of v[i,j] */\r\n        i = cc_ind[ptr];\r\n        /* at least one unused location is needed in i-th row */\r\n        if (vr_len[i] + 1 > vr_cap[i])\r\n        {  if (luf_enlarge_row(luf, i, vr_len[i] + 10))\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n        }\r\n        /* add v[i,j] to i-th row */\r\n        i_ptr = vr_ptr[i] + vr_len[i];\r\n        sv_ind[i_ptr] = j;\r\n        sv_val[i_ptr] = cc_val[ptr];\r\n        vr_len[i]++;\r\n        /* adjust index k2 */\r\n        if (k2 < pp_col[i]) k2 = pp_col[i];\r\n    }\r\n    /* capacity of j-th column (which is currently empty) should be\r\n     not less than len locations */\r\n    if (vc_cap[j] < len)\r\n    {  if (luf_enlarge_col(luf, j, len))\r\n    {  /* overflow of the sparse vector area */\r\n        fhv.valid = 0;\r\n        luf.new_sva = luf.sv_size + luf.sv_size;\r\n        xassert(luf.new_sva > luf.sv_size);\r\n        ret = FHV_EROOM;\r\n        return ret;\r\n    }\r\n    }\r\n    /* add new elements of matrix V to j-th column list */\r\n    j_ptr = vc_ptr[j];\r\n    xcopyArr(sv_ind, j_ptr, cc_ind, 1, len);\r\n    xcopyArr(sv_val, j_ptr, cc_val, 1, len);\r\n    vc_len[j] = len;\r\n    luf.nnz_v += len;\r\n    /* if k1 > k2, diagonal element u[k2,k2] of matrix U is zero and\r\n     therefore the adjacent basis matrix is structurally singular */\r\n    if (k1 > k2)\r\n    {  fhv.valid = 0;\r\n        ret = FHV_ESING;\r\n        return ret;\r\n    }\r\n    /* perform implicit symmetric permutations of rows and columns of\r\n     matrix U */\r\n    i = pp_row[k1]; j = qq_col[k1];\r\n    for (k = k1; k < k2; k++)\r\n    {  pp_row[k] = pp_row[k+1]; pp_col[pp_row[k]] = k;\r\n        qq_col[k] = qq_col[k+1]; qq_row[qq_col[k]] = k;\r\n    }\r\n    pp_row[k2] = i; pp_col[i] = k2;\r\n    qq_col[k2] = j; qq_row[j] = k2;\r\n    /* now i-th row of the matrix V is k2-th row of matrix U; since\r\n     no pivoting is used, only this row will be transformed */\r\n    /* copy elements of i-th row of matrix V to the working array and\r\n     remove these elements from matrix V */\r\n    for (j = 1; j <= m; j++) work[j] = 0.0;\r\n    i_beg = vr_ptr[i];\r\n    i_end = i_beg + vr_len[i] - 1;\r\n    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n    {  /* get column index of v[i,j] */\r\n        j = sv_ind[i_ptr];\r\n        /* store v[i,j] to the working array */\r\n        work[j] = sv_val[i_ptr];\r\n        /* find v[i,j] in the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++){/* nop */}\r\n        xassert(j_ptr <= j_end);\r\n        /* remove v[i,j] from the j-th column */\r\n        sv_ind[j_ptr] = sv_ind[j_end];\r\n        sv_val[j_ptr] = sv_val[j_end];\r\n        vc_len[j]--;\r\n    }\r\n    /* now i-th row of matrix V is empty */\r\n    luf.nnz_v -= vr_len[i];\r\n    vr_len[i] = 0;\r\n    /* create the next row-like factor of the matrix H; this factor\r\n     corresponds to i-th (transformed) row */\r\n    fhv.hh_nfs++;\r\n    hh_ind[fhv.hh_nfs] = i;\r\n    /* hh_ptr[] will be set later */\r\n    hh_len[fhv.hh_nfs] = 0;\r\n    /* up to (k2 - k1) free locations are needed to add new elements\r\n     to the non-trivial row of the row-like factor */\r\n    if (luf.sv_end - luf.sv_beg < k2 - k1)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < k2 - k1)\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = luf.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n    }\r\n    /* eliminate subdiagonal elements of matrix U */\r\n    for (k = k1; k < k2; k++)\r\n    {  /* v[p,q] = u[k,k] */\r\n        p = pp_row[k]; q = qq_col[k];\r\n        /* this is the crucial point, where even tiny non-zeros should\r\n         not be dropped */\r\n        if (work[q] == 0.0) continue;\r\n        /* compute gaussian multiplier f = v[i,q] / v[p,q] */\r\n        f = work[q] / vr_piv[p];\r\n        /* perform gaussian transformation:\r\n         (i-th row) := (i-th row) - f * (p-th row)\r\n         in order to eliminate v[i,q] = u[k2,k] */\r\n        p_beg = vr_ptr[p];\r\n        p_end = p_beg + vr_len[p] - 1;\r\n        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n            work[sv_ind[p_ptr]] -= f * sv_val[p_ptr];\r\n        /* store new element (gaussian multiplier that corresponds to\r\n         p-th row) in the current row-like factor */\r\n        luf.sv_end--;\r\n        sv_ind[luf.sv_end] = p;\r\n        sv_val[luf.sv_end] = f;\r\n        hh_len[fhv.hh_nfs]++;\r\n    }\r\n    /* set pointer to the current row-like factor of the matrix H\r\n     (if no elements were added to this factor, it is unity matrix\r\n     and therefore can be discarded) */\r\n    if (hh_len[fhv.hh_nfs] == 0)\r\n        fhv.hh_nfs--;\r\n    else\r\n    {  hh_ptr[fhv.hh_nfs] = luf.sv_end;\r\n        fhv.nnz_h += hh_len[fhv.hh_nfs];\r\n    }\r\n    /* store new pivot which corresponds to u[k2,k2] */\r\n    vr_piv[i] = work[qq_col[k2]];\r\n    /* new elements of i-th row of matrix V (which are non-diagonal\r\n     elements u[k2,k2+1], ..., u[k2,m] of matrix U = P*V*Q) now are\r\n     contained in the working array; add them to matrix V */\r\n    len = 0;\r\n    for (k = k2+1; k <= m; k++)\r\n    {  /* get column index and value of v[i,j] = u[k2,k] */\r\n        j = qq_col[k];\r\n        temp = work[j];\r\n        /* if v[i,j] is close to zero, skip it */\r\n        if (Math.abs(temp) < eps_tol) continue;\r\n        /* at least one unused location is needed in j-th column */\r\n        if (vc_len[j] + 1 > vc_cap[j])\r\n        {  if (luf_enlarge_col(luf, j, vc_len[j] + 10))\r\n        {  /* overflow of the sparse vector area */\r\n            fhv.valid = 0;\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            ret = FHV_EROOM;\r\n            return ret;\r\n        }\r\n        }\r\n        /* add v[i,j] to j-th column */\r\n        j_ptr = vc_ptr[j] + vc_len[j];\r\n        sv_ind[j_ptr] = i;\r\n        sv_val[j_ptr] = temp;\r\n        vc_len[j]++;\r\n        /* also store v[i,j] to the auxiliary array */\r\n        len++; cc_ind[len] = j; cc_val[len] = temp;\r\n    }\r\n    /* capacity of i-th row (which is currently empty) should be not\r\n     less than len locations */\r\n    if (vr_cap[i] < len)\r\n    {  if (luf_enlarge_row(luf, i, len))\r\n    {  /* overflow of the sparse vector area */\r\n        fhv.valid = 0;\r\n        luf.new_sva = luf.sv_size + luf.sv_size;\r\n        xassert(luf.new_sva > luf.sv_size);\r\n        ret = FHV_EROOM;\r\n        return ret;\r\n    }\r\n    }\r\n    /* add new elements to i-th row list */\r\n    i_ptr = vr_ptr[i];\r\n    xcopyArr(sv_ind, i_ptr, cc_ind, 1, len);\r\n    xcopyArr(sv_val, i_ptr, cc_val, 1, len);\r\n    vr_len[i] = len;\r\n    luf.nnz_v += len;\r\n    /* updating is finished; check that diagonal element u[k2,k2] is\r\n     not very small in absolute value among other elements in k2-th\r\n     row and k2-th column of matrix U = P*V*Q */\r\n    /* temp = max(|u[k2,*]|, |u[*,k2]|) */\r\n    temp = 0.0;\r\n    /* walk through k2-th row of U which is i-th row of V */\r\n    i = pp_row[k2];\r\n    i_beg = vr_ptr[i];\r\n    i_end = i_beg + vr_len[i] - 1;\r\n    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        if (temp < Math.abs(sv_val[i_ptr])) temp = Math.abs(sv_val[i_ptr]);\r\n    /* walk through k2-th column of U which is j-th column of V */\r\n    j = qq_col[k2];\r\n    j_beg = vc_ptr[j];\r\n    j_end = j_beg + vc_len[j] - 1;\r\n    for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n        if (temp < Math.abs(sv_val[j_ptr])) temp = Math.abs(sv_val[j_ptr]);\r\n    /* check that u[k2,k2] is not very small */\r\n    if (Math.abs(vr_piv[i]) < upd_tol * temp)\r\n    {  /* the factorization seems to be inaccurate and therefore must\r\n     be recomputed */\r\n        fhv.valid = 0;\r\n        ret = FHV_ECHECK;\r\n        return ret;\r\n    }\r\n    /* the factorization has been successfully updated */\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction glp_adv_basis(lp, flags){\r\n    function triang(m, n, info, mat, rn, cn){\r\n        var ndx; /* int ndx[1+max(m,n)]; */\r\n        /* this array is used for querying row and column patterns of the\r\n         given matrix A (the third parameter to the routine mat) */\r\n        var rs_len; /* int rs_len[1+m]; */\r\n        /* rs_len[0] is not used;\r\n         rs_len[i], 1 <= i <= m, is number of non-zeros in the i-th row\r\n         of the matrix A, which (non-zeros) belong to the current active\r\n         submatrix */\r\n        var rs_head; /* int rs_head[1+n]; */\r\n        /* rs_head[len], 0 <= len <= n, is the number i of the first row\r\n         of the matrix A, for which rs_len[i] = len */\r\n        var rs_prev; /* int rs_prev[1+m]; */\r\n        /* rs_prev[0] is not used;\r\n         rs_prev[i], 1 <= i <= m, is a number i' of the previous row of\r\n         the matrix A, for which rs_len[i] = rs_len[i'] (zero marks the\r\n         end of this linked list) */\r\n        var rs_next; /* int rs_next[1+m]; */\r\n        /* rs_next[0] is not used;\r\n         rs_next[i], 1 <= i <= m, is a number i' of the next row of the\r\n         matrix A, for which rs_len[i] = rs_len[i'] (zero marks the end\r\n         this linked list) */\r\n        var cs_head;\r\n        /* is a number j of the first column of the matrix A, which has\r\n         maximal number of non-zeros among other columns */\r\n        var cs_prev; /* cs_prev[1+n]; */\r\n        /* cs_prev[0] is not used;\r\n         cs_prev[j], 1 <= j <= n, is a number of the previous column of\r\n         the matrix A with the same or greater number of non-zeros than\r\n         in the j-th column (zero marks the end of this linked list) */\r\n        var cs_next; /* cs_next[1+n]; */\r\n        /* cs_next[0] is not used;\r\n         cs_next[j], 1 <= j <= n, is a number of the next column of\r\n         the matrix A with the same or lesser number of non-zeros than\r\n         in the j-th column (zero marks the end of this linked list) */\r\n        var i, j, ii, jj, k1, k2, len, t, size = 0;\r\n        var head, rn_inv, cn_inv;\r\n        if (!(m > 0 && n > 0))\r\n            xerror(\"triang: m = \" + m + \"; n = \" + n + \"; invalid dimension\");\r\n        /* allocate working arrays */\r\n        ndx = new Int32Array(1+(m >= n ? m : n));\r\n        rs_len = new Int32Array(1+m);\r\n        rs_head = new Int32Array(1+n);\r\n        rs_prev = new Int32Array(1+m);\r\n        rs_next = new Int32Array(1+m);\r\n        cs_prev = new Int32Array(1+n);\r\n        cs_next = new Int32Array(1+n);\r\n        /* build linked lists of columns of the matrix A with the same\r\n         number of non-zeros */\r\n        head = rs_len; /* currently rs_len is used as working array */\r\n        for (j = 1; j <= n; j++)\r\n        {  /* obtain length of the j-th column */\r\n            len = mat(info, -j, ndx);\r\n            xassert(0 <= len && len <= m);\r\n            /* include the j-th column in the corresponding linked list */\r\n            cs_prev[j] = head[len];\r\n            head[len] = j;\r\n        }\r\n        /* merge all linked lists of columns in one linked list, where\r\n         columns are ordered by descending of their lengths */\r\n        cs_head = 0;\r\n        for (len = 0; len <= m; len++)\r\n        {  for (j = head[len]; j != 0; j = cs_prev[j])\r\n        {  cs_next[j] = cs_head;\r\n            cs_head = j;\r\n        }\r\n        }\r\n        jj = 0;\r\n        for (j = cs_head; j != 0; j = cs_next[j])\r\n        {  cs_prev[j] = jj;\r\n            jj = j;\r\n        }\r\n        /* build initial doubly linked lists of rows of the matrix A with\r\n         the same number of non-zeros */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* obtain length of the i-th row */\r\n            rs_len[i] = len = mat(info, +i, ndx);\r\n            xassert(0 <= len && len <= n);\r\n            /* include the i-th row in the correspondng linked list */\r\n            rs_prev[i] = 0;\r\n            rs_next[i] = rs_head[len];\r\n            if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n            rs_head[len] = i;\r\n        }\r\n        /* initially all rows and columns of the matrix A are active */\r\n        for (i = 1; i <= m; i++) rn[i] = 0;\r\n        for (j = 1; j <= n; j++) cn[j] = 0;\r\n        /* set initial bounds of the active submatrix */\r\n        k1 = 1; k2 = n;\r\n        /* main loop starts here */\r\n        while (k1 <= k2)\r\n        {  i = rs_head[1];\r\n            if (i != 0)\r\n            {  /* the i-th row of the matrix A is a row singleton, since\r\n             it has the only non-zero in the active submatrix */\r\n                xassert(rs_len[i] == 1);\r\n                /* determine the number j of an active column of the matrix\r\n                 A, in which this non-zero is placed */\r\n                j = 0;\r\n                t = mat(info, +i, ndx);\r\n                xassert(0 <= t && t <= n);\r\n                for (; t >= 1; t--)\r\n                {  jj = ndx[t];\r\n                    xassert(1 <= jj && jj <= n);\r\n                    if (cn[jj] == 0)\r\n                    {  xassert(j == 0);\r\n                        j = jj;\r\n                    }\r\n                }\r\n                xassert(j != 0);\r\n                /* the singleton is a[i,j]; move a[i,j] to the position\r\n                 b[k1,k1] of the matrix B */\r\n                rn[i] = cn[j] = k1;\r\n                /* shift the left bound of the active submatrix */\r\n                k1++;\r\n                /* increase the size of the lower triangular part */\r\n                size++;\r\n            }\r\n            else\r\n            {  /* the current active submatrix has no row singletons */\r\n                /* remove an active column with maximal number of non-zeros\r\n                 from the active submatrix */\r\n                j = cs_head;\r\n                xassert(j != 0);\r\n                cn[j] = k2;\r\n                /* shift the right bound of the active submatrix */\r\n                k2--;\r\n            }\r\n            /* the j-th column of the matrix A has been removed from the\r\n             active submatrix */\r\n            /* remove the j-th column from the linked list */\r\n            if (cs_prev[j] == 0)\r\n                cs_head = cs_next[j];\r\n            else\r\n                cs_next[cs_prev[j]] = cs_next[j];\r\n            if (cs_next[j] != 0)\r\n                cs_prev[cs_next[j]] = cs_prev[j];\r\n            /* go through non-zeros of the j-th columns and update active\r\n             lengths of the corresponding rows */\r\n            t = mat(info, -j, ndx);\r\n            xassert(0 <= t && t <= m);\r\n            for (; t >= 1; t--)\r\n            {  i = ndx[t];\r\n                xassert(1 <= i && i <= m);\r\n                /* the non-zero a[i,j] has left the active submatrix */\r\n                len = rs_len[i];\r\n                xassert(len >= 1);\r\n                /* remove the i-th row from the linked list of rows with\r\n                 active length len */\r\n                if (rs_prev[i] == 0)\r\n                    rs_head[len] = rs_next[i];\r\n                else\r\n                    rs_next[rs_prev[i]] = rs_next[i];\r\n                if (rs_next[i] != 0)\r\n                    rs_prev[rs_next[i]] = rs_prev[i];\r\n                /* decrease the active length of the i-th row */\r\n                rs_len[i] = --len;\r\n                /* return the i-th row to the corresponding linked list */\r\n                rs_prev[i] = 0;\r\n                rs_next[i] = rs_head[len];\r\n                if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n                rs_head[len] = i;\r\n            }\r\n        }\r\n        /* other rows of the matrix A, which are still active, correspond\r\n         to rows k1, ..., m of the matrix B (in arbitrary order) */\r\n        for (i = 1; i <= m; i++) if (rn[i] == 0) rn[i] = k1++;\r\n        /* but for columns this is not needed, because now the submatrix\r\n         B2 has no columns */\r\n        for (j = 1; j <= n; j++) xassert(cn[j] != 0);\r\n        /* perform some optional checks */\r\n        /* make sure that rn is a permutation of {1, ..., m} and cn is a\r\n         permutation of {1, ..., n} */\r\n        rn_inv = rs_len; /* used as working array */\r\n        for (ii = 1; ii <= m; ii++) rn_inv[ii] = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  ii = rn[i];\r\n            xassert(1 <= ii && ii <= m);\r\n            xassert(rn_inv[ii] == 0);\r\n            rn_inv[ii] = i;\r\n        }\r\n        cn_inv = rs_head; /* used as working array */\r\n        for (jj = 1; jj <= n; jj++) cn_inv[jj] = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  jj = cn[j];\r\n            xassert(1 <= jj && jj <= n);\r\n            xassert(cn_inv[jj] == 0);\r\n            cn_inv[jj] = j;\r\n        }\r\n        /* make sure that the matrix B = P*A*Q really has the form, which\r\n         was declared */\r\n        for (ii = 1; ii <= size; ii++)\r\n        {  var diag = 0;\r\n            i = rn_inv[ii];\r\n            t = mat(info, +i, ndx);\r\n            xassert(0 <= t && t <= n);\r\n            for (; t >= 1; t--)\r\n            {  j = ndx[t];\r\n                xassert(1 <= j && j <= n);\r\n                jj = cn[j];\r\n                if (jj <= size) xassert(jj <= ii);\r\n                if (jj == ii)\r\n                {  xassert(!diag);\r\n                    diag = 1;\r\n                }\r\n            }\r\n            xassert(diag);\r\n        }\r\n        /* return to the calling program */\r\n        return size;\r\n    }\r\n\r\n    function mat(lp, k, ndx){\r\n        /* this auxiliary routine returns the pattern of a given row or\r\n         a given column of the augmented constraint matrix A~ = (I|-A),\r\n         in which columns of fixed variables are implicitly cleared */\r\n        var m = lpx_get_num_rows(lp);\r\n        var n = lpx_get_num_cols(lp);\r\n        var i, j, lll, len = 0;\r\n\r\n        if (k > 0)\r\n        {  /* the pattern of the i-th row is required */\r\n            i = +k;\r\n            xassert(1 <= i && i <= m);\r\n            lll = lpx_get_mat_row(lp, i, ndx, null);\r\n            for (k = 1; k <= lll; k++)\r\n            {\r\n                lpx_get_col_bnds(lp, ndx[k], function(typx){\r\n                        if (typx != LPX_FX) ndx[++len] = m + ndx[k];\r\n                });\r\n\r\n            }\r\n            lpx_get_row_bnds(lp, i, function(typx){\r\n                if (typx != LPX_FX) ndx[++len] = i;\r\n            });\r\n        }\r\n        else\r\n        {  /* the pattern of the j-th column is required */\r\n            j = -k;\r\n            xassert(1 <= j && j <= m+n);\r\n            /* if the (auxiliary or structural) variable x[j] is fixed,\r\n             the pattern of its column is empty */\r\n\r\n            function doit(typx){\r\n                if (typx != LPX_FX)\r\n                {  if (j <= m)\r\n                {  /* x[j] is non-fixed auxiliary variable */\r\n                    ndx[++len] = j;\r\n                }\r\n                else\r\n                {  /* x[j] is non-fixed structural variables */\r\n                    len = lpx_get_mat_col(lp, j-m, ndx, null);\r\n                }\r\n                }\r\n            }\r\n\r\n            if (j <= m)\r\n                lpx_get_row_bnds(lp, j, doit);\r\n            else\r\n                lpx_get_col_bnds(lp, j-m, doit);\r\n\r\n        }\r\n        /* return the length of the row/column pattern */\r\n        return len;\r\n    }\r\n\r\n    function adv_basis(lp){\r\n        var m = lpx_get_num_rows(lp);\r\n        var n = lpx_get_num_cols(lp);\r\n        var i, j, jj, k, size;\r\n        var rn, cn, rn_inv, cn_inv;\r\n        var tagx = new Int32Array(1+m+n);\r\n        xprintf(\"Constructing initial basis...\");\r\n        if (m == 0 || n == 0)\r\n        {  glp_std_basis(lp);\r\n            return;\r\n        }\r\n        /* use the routine triang (see above) to find maximal triangular\r\n         part of the augmented constraint matrix A~ = (I|-A); in order\r\n         to prevent columns of fixed variables to be included in the\r\n         triangular part, such columns are implictly removed from the\r\n         matrix A~ by the routine adv_mat */\r\n        rn = new Int32Array(1+m);\r\n        cn = new Int32Array(1+m+n);\r\n        size = triang(m, m+n, lp, mat, rn, cn);\r\n        if (lpx_get_int_parm(lp, LPX_K_MSGLEV) >= 3)\r\n            xprintf(\"Size of triangular part = \" + size + \"\");\r\n        /* the first size rows and columns of the matrix P*A~*Q (where\r\n         P and Q are permutation matrices defined by the arrays rn and\r\n         cn) form a lower triangular matrix; build the arrays (rn_inv\r\n         and cn_inv), which define the matrices inv(P) and inv(Q) */\r\n        rn_inv = new Int32Array(1+m);\r\n        cn_inv = new Int32Array(1+m+n);\r\n        for (i = 1; i <= m; i++) rn_inv[rn[i]] = i;\r\n        for (j = 1; j <= m+n; j++) cn_inv[cn[j]] = j;\r\n        /* include the columns of the matrix A~, which correspond to the\r\n         first size columns of the matrix P*A~*Q, in the basis */\r\n        for (k = 1; k <= m+n; k++) tagx[k] = -1;\r\n        for (jj = 1; jj <= size; jj++)\r\n        {  j = cn_inv[jj];\r\n            /* the j-th column of A~ is the jj-th column of P*A~*Q */\r\n            tagx[j] = LPX_BS;\r\n        }\r\n        /* if size < m, we need to add appropriate columns of auxiliary\r\n         variables to the basis */\r\n        for (jj = size + 1; jj <= m; jj++)\r\n        {  /* the jj-th column of P*A~*Q should be replaced by the column\r\n         of the auxiliary variable, for which the only unity element\r\n         is placed in the position [jj,jj] */\r\n            i = rn_inv[jj];\r\n            /* the jj-th row of P*A~*Q is the i-th row of A~, but in the\r\n             i-th row of A~ the unity element belongs to the i-th column\r\n             of A~; therefore the disired column corresponds to the i-th\r\n             auxiliary variable (note that this column doesn't belong to\r\n             the triangular part found by the routine triang) */\r\n            xassert(1 <= i && i <= m);\r\n            xassert(cn[i] > size);\r\n            tagx[i] = LPX_BS;\r\n        }\r\n        /* build tags of non-basic variables */\r\n        for (k = 1; k <= m+n; k++){\r\n            if (tagx[k] != LPX_BS){\r\n\r\n                function doit(typx, lb, ub){\r\n                    switch (typx){\r\n                        case LPX_FR:\r\n                            tagx[k] = LPX_NF; break;\r\n                        case LPX_LO:\r\n                            tagx[k] = LPX_NL; break;\r\n                        case LPX_UP:\r\n                            tagx[k] = LPX_NU; break;\r\n                        case LPX_DB:\r\n                            tagx[k] = (Math.abs(lb) <= Math.abs(ub) ? LPX_NL : LPX_NU); break;\r\n                        case LPX_FX:\r\n                            tagx[k] = LPX_NS; break;\r\n                        default:\r\n                            xassert(typx != typx);\r\n                    }\r\n                }\r\n\r\n                if (k <= m)\r\n                    lpx_get_row_bnds(lp, k, doit);\r\n                else\r\n                    lpx_get_col_bnds(lp, k-m, doit);\r\n            }\r\n        }\r\n        for (k = 1; k <= m+n; k++){\r\n            if (k <= m)\r\n                lpx_set_row_stat(lp, k, tagx[k]);\r\n            else\r\n                lpx_set_col_stat(lp, k-m, tagx[k]);\r\n        }\r\n    }\r\n\r\n    if (flags != 0)\r\n        xerror(\"glp_adv_basis: flags = \" + flags + \"; invalid flags\");\r\n    if (lp.m == 0 || lp.n == 0)\r\n        glp_std_basis(lp);\r\n    else\r\n        adv_basis(lp);\r\n}\r\n\r\nfunction cpx_basis(lp){\r\n    /* main routine */\r\n    var C, C2, C3, C4;\r\n    var m, n, i, j, jk, k, l, ll, t, n2, n3, n4, type, len, I, r, ind;\r\n    var alpha, gamma, cmax, temp, v, val;\r\n    xprintf(\"Constructing initial basis...\");\r\n    /* determine the number of rows and columns */\r\n    m = glp_get_num_rows(lp);\r\n    n = glp_get_num_cols(lp);\r\n    /* allocate working arrays */\r\n    C = new Array(1+n);\r\n    I = new Int32Array(1+m);\r\n    r = new Int32Array(1+m);\r\n    v = new Float64Array(1+m);\r\n    ind = new Int32Array(1+m);\r\n    val = new Float64Array(1+m);\r\n    /* make all auxiliary variables non-basic */\r\n    for (i = 1; i <= m; i++)\r\n    {  if (glp_get_row_type(lp, i) != GLP_DB)\r\n        glp_set_row_stat(lp, i, GLP_NS);\r\n    else if (Math.abs(glp_get_row_lb(lp, i)) <=\r\n        Math.abs(glp_get_row_ub(lp, i)))\r\n        glp_set_row_stat(lp, i, GLP_NL);\r\n    else\r\n        glp_set_row_stat(lp, i, GLP_NU);\r\n    }\r\n    /* make all structural variables non-basic */\r\n    for (j = 1; j <= n; j++)\r\n    {  if (glp_get_col_type(lp, j) != GLP_DB)\r\n        glp_set_col_stat(lp, j, GLP_NS);\r\n    else if (Math.abs(glp_get_col_lb(lp, j)) <=\r\n        Math.abs(glp_get_col_ub(lp, j)))\r\n        glp_set_col_stat(lp, j, GLP_NL);\r\n    else\r\n        glp_set_col_stat(lp, j, GLP_NU);\r\n    }\r\n    /* C2 is a set of free structural variables */\r\n    n2 = 0; C2 = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_FR)\r\n        {   n2++;\r\n            C[C2 + n2].j = j;\r\n            C[C2 + n2].q = 0.0;\r\n        }\r\n    }\r\n    /* C3 is a set of structural variables having excatly one (lower\r\n     or upper) bound */\r\n    n3 = 0; C3 = C2 + n2;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_LO)\r\n        {  n3++;\r\n            C[C3 + n3].j = j;\r\n            C[C3 + n3].q = + glp_get_col_lb(lp, j);\r\n        }\r\n        else if (type == GLP_UP)\r\n        {  n3++;\r\n            C[C3 + n3].j = j;\r\n            C[C3 + n3].q = - glp_get_col_ub(lp, j);\r\n        }\r\n    }\r\n    /* C4 is a set of structural variables having both (lower and\r\n     upper) bounds */\r\n    n4 = 0; C4 = C3 + n3;\r\n    for (j = 1; j <= n; j++)\r\n    {  type = glp_get_col_type(lp, j);\r\n        if (type == GLP_DB)\r\n        {  n4++;\r\n            C[C4 + n4].j = j;\r\n            C[C4 + n4].q = glp_get_col_lb(lp, j) - glp_get_col_ub(lp, j);\r\n        }\r\n    }\r\n    /* compute gamma = max{|c[j]|: 1 <= j <= n} */\r\n    gamma = 0.0;\r\n    for (j = 1; j <= n; j++)\r\n    {  temp = Math.abs(glp_get_obj_coef(lp, j));\r\n        if (gamma < temp) gamma = temp;\r\n    }\r\n    /* compute cmax */\r\n    cmax = (gamma == 0.0 ? 1.0 : 1000.0 * gamma);\r\n    /* compute final penalty for all structural variables within sets\r\n     C2, C3, and C4 */\r\n    switch (glp_get_obj_dir(lp))\r\n    {  case GLP_MIN: temp = +1.0; break;\r\n        case GLP_MAX: temp = -1.0; break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    for (k = 1; k <= n2+n3+n4; k++)\r\n    {  j = C[k].j;\r\n        C[k].q += (temp * glp_get_obj_coef(lp, j)) / cmax;\r\n    }\r\n    /* sort structural variables within C2, C3, and C4 in ascending\r\n     order of penalty value */\r\n\r\n    function fcmp(col1, col2){\r\n        /* this routine is passed to the qsort() function */\r\n        if (col1.q < col2.q) return -1;\r\n        if (col1.q > col2.q) return +1;\r\n        return 0;\r\n    }\r\n\r\n    xqsort(C, C2+1+n2, fcmp);\r\n    for (k = 1; k < n2; k++) xassert(C[C2+k].q <= C[C2+k+1].q);\r\n    xqsort(C, C3+1+n3, fcmp);\r\n    for (k = 1; k < n3; k++) xassert(C[C3+k].q <= C[C3+k+1].q);\r\n    xqsort(C, C4+1+n4, fcmp);\r\n    for (k = 1; k < n4; k++) xassert(C[C4+k].q <= C[C4+k+1].q);\r\n    /*** STEP 1 ***/\r\n    for (i = 1; i <= m; i++)\r\n    {  type = glp_get_row_type(lp, i);\r\n        if (type != GLP_FX)\r\n        {  /* row i is either free or inequality constraint */\r\n            glp_set_row_stat(lp, i, GLP_BS);\r\n            I[i] = 1;\r\n            r[i] = 1;\r\n        }\r\n        v[i] = +DBL_MAX;\r\n    }\r\n    /*** STEP 2 ***/\r\n\r\n    function get_column(lp, j, ind, val){\r\n        /* Bixby's algorithm assumes that the constraint matrix is scaled\r\n         such that the maximum absolute value in every non-zero row and\r\n         column is 1 */\r\n        var k;\r\n        var len = glp_get_mat_col(lp, j, ind, val);\r\n        var big = 0.0;\r\n        for (k = 1; k <= len; k++)\r\n            if (big < Math.abs(val[k])) big = Math.abs(val[k]);\r\n        if (big == 0.0) big = 1.0;\r\n        for (k = 1; k <= len; k++) val[k] /= big;\r\n        return len;\r\n    }\r\n\r\n    for (k = 1; k <= n2+n3+n4; k++)\r\n    {  jk = C[k].j;\r\n        len = get_column(lp, jk, ind, val);\r\n        /* let alpha = max{|A[l,jk]|: r[l] = 0} and let l' be such\r\n         that alpha = |A[l',jk]| */\r\n        alpha = 0.0; ll = 0;\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (r[l] == 0 && alpha < Math.abs(val[t])){\r\n                alpha = Math.abs(val[t]); ll = l;\r\n            }\r\n        }\r\n        if (alpha >= 0.99)\r\n        {  /* B := B union {jk} */\r\n            glp_set_col_stat(lp, jk, GLP_BS);\r\n            I[ll] = 1;\r\n            v[ll] = alpha;\r\n            /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\r\n            for (t = 1; t <= len; t++)\r\n            {  l = ind[t];\r\n                if (val[t] != 0.0) r[l]++;\r\n            }\r\n            /* continue to the next k */\r\n            continue;\r\n        }\r\n        /* if |A[l,jk]| > 0.01 * v[l] for some l, continue to the\r\n         next k */\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (Math.abs(val[t]) > 0.01 * v[l]) break;\r\n        }\r\n        if (t <= len) continue;\r\n        /* otherwise, let alpha = max{|A[l,jk]|: I[l] = 0} and let l'\r\n         be such that alpha = |A[l',jk]| */\r\n        alpha = 0.0; ll = 0;\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (I[l] == 0 && alpha < Math.abs(val[t])){\r\n                alpha = Math.abs(val[t]); ll = l;\r\n            }\r\n        }\r\n        /* if alpha = 0, continue to the next k */\r\n        if (alpha == 0.0) continue;\r\n        /* B := B union {jk} */\r\n        glp_set_col_stat(lp, jk, GLP_BS);\r\n        I[ll] = 1;\r\n        v[ll] = alpha;\r\n        /* r[l] := r[l] + 1 for all l such that |A[l,jk]| != 0 */\r\n        for (t = 1; t <= len; t++)\r\n        {  l = ind[t];\r\n            if (val[t] != 0.0) r[l]++;\r\n        }\r\n    }\r\n    /*** STEP 3 ***/\r\n    /* add an artificial variable (auxiliary variable for equality\r\n     constraint) to cover each remaining uncovered row */\r\n    for (i = 1; i <= m; i++)\r\n        if (I[i] == 0) glp_set_row_stat(lp, i, GLP_BS);\r\n}\r\n\r\nfunction glp_cpx_basis(lp){\r\n    if (lp.m == 0 || lp.n == 0)\r\n        glp_std_basis(lp);\r\n    else\r\n        cpx_basis(lp);\r\n}\r\n\r\nfunction new_node(tree, parent){\r\n    /* pull a free slot for the new node */\r\n    var p = get_slot(tree);\r\n    /* create descriptor of the new subproblem */\r\n    var node = {};\r\n    tree.slot[p].node = node;\r\n    node.p = p;\r\n    node.up = parent;\r\n    node.level = (parent == null ? 0 : parent.level + 1);\r\n    node.count = 0;\r\n    node.b_ptr = null;\r\n    node.s_ptr = null;\r\n    node.r_ptr = null;\r\n    node.solved = 0;\r\n    node.lp_obj = (parent == null ? (tree.mip.dir == GLP_MIN ?\r\n        -DBL_MAX : +DBL_MAX) : parent.lp_obj);\r\n    node.bound = (parent == null ? (tree.mip.dir == GLP_MIN ?\r\n        -DBL_MAX : +DBL_MAX) : parent.bound);\r\n    node.br_var = 0;\r\n    node.br_val = 0.0;\r\n    node.ii_cnt = 0;\r\n    node.ii_sum = 0.0;\r\n    node.changed = 0;\r\n    if (tree.parm.cb_size == 0)\r\n        node.data = null;\r\n    else\r\n    {\r\n        node.data = {};\r\n    }\r\n    node.temp = null;\r\n    node.prev = tree.tail;\r\n    node.next = null;\r\n    /* add the new subproblem to the end of the active list */\r\n    if (tree.head == null)\r\n        tree.head = node;\r\n    else\r\n        tree.tail.next = node;\r\n    tree.tail = node;\r\n    tree.a_cnt++;\r\n    tree.n_cnt++;\r\n    tree.t_cnt++;\r\n    /* increase the number of child subproblems */\r\n    if (parent == null)\r\n        xassert(p == 1);\r\n    else\r\n        parent.count++;\r\n    return node;\r\n}\r\n\r\nfunction get_slot(tree){\r\n    var p;\r\n    /* if no free slots are available, increase the room */\r\n    if (tree.avail == 0)\r\n    {  var nslots = tree.nslots;\r\n        var save = tree.slot;\r\n        if (nslots == 0)\r\n            tree.nslots = 20;\r\n        else\r\n        {  tree.nslots = nslots + nslots;\r\n            xassert(tree.nslots > nslots);\r\n        }\r\n        tree.slot = new Array(1+tree.nslots);\r\n        xfillObjArr(tree.slot, 0, 1+tree.nslots);\r\n        if (save != null)\r\n        {\r\n            xcopyArr(tree.slot, 1, save, 1, nslots);\r\n        }\r\n        /* push more free slots into the stack */\r\n        for (p = tree.nslots; p > nslots; p--)\r\n        {  tree.slot[p].node = null;\r\n            tree.slot[p].next = tree.avail;\r\n            tree.avail = p;\r\n        }\r\n    }\r\n    /* pull a free slot from the stack */\r\n    p = tree.avail;\r\n    tree.avail = tree.slot[p].next;\r\n    xassert(tree.slot[p].node == null);\r\n    tree.slot[p].next = 0;\r\n    return p;\r\n}\r\n\r\nfunction ios_create_tree(mip, parm){\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var tree;\r\n    var i, j;\r\n    xassert(mip.tree == null);\r\n    mip.tree = tree = {};\r\n    tree.n = n;\r\n    /* save original problem components */\r\n    tree.orig_m = m;\r\n    tree.orig_type = new Int8Array(1+m+n);\r\n    tree.orig_lb = new Float64Array(1+m+n);\r\n    tree.orig_ub = new Float64Array(1+m+n);\r\n    tree.orig_stat = new Int8Array(1+m+n);\r\n    tree.orig_prim = new Float64Array(1+m+n);\r\n    tree.orig_dual = new Float64Array(1+m+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  var row = mip.row[i];\r\n        tree.orig_type[i] = row.type;\r\n        tree.orig_lb[i] = row.lb;\r\n        tree.orig_ub[i] = row.ub;\r\n        tree.orig_stat[i] = row.stat;\r\n        tree.orig_prim[i] = row.prim;\r\n        tree.orig_dual[i] = row.dual;\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        tree.orig_type[m+j] = col.type;\r\n        tree.orig_lb[m+j] = col.lb;\r\n        tree.orig_ub[m+j] = col.ub;\r\n        tree.orig_stat[m+j] = col.stat;\r\n        tree.orig_prim[m+j] = col.prim;\r\n        tree.orig_dual[m+j] = col.dual;\r\n    }\r\n    tree.orig_obj = mip.obj_val;\r\n    /* initialize the branch-and-bound tree */\r\n    tree.nslots = 0;\r\n    tree.avail = 0;\r\n    tree.slot = null;\r\n    tree.head = tree.tail = null;\r\n    tree.a_cnt = tree.n_cnt = tree.t_cnt = 0;\r\n    /* the root subproblem is not solved yet, so its final components\r\n     are unknown so far */\r\n    tree.root_m = 0;\r\n    tree.root_type = null;\r\n    tree.root_lb = tree.root_ub = null;\r\n    tree.root_stat = null;\r\n    /* the current subproblem does not exist yet */\r\n    tree.curr = null;\r\n    tree.mip = mip;\r\n    /*tree.solved = 0;*/\r\n    tree.non_int = new Int8Array(1+n);\r\n    /* arrays to save parent subproblem components will be allocated\r\n     later */\r\n    tree.pred_m = tree.pred_max = 0;\r\n    tree.pred_type = null;\r\n    tree.pred_lb = tree.pred_ub = null;\r\n    tree.pred_stat = null;\r\n    /* cut generator */\r\n    tree.local = ios_create_pool(tree);\r\n    /*tree.first_attempt = 1;*/\r\n    /*tree.max_added_cuts = 0;*/\r\n    /*tree.min_eff = 0.0;*/\r\n    /*tree.miss = 0;*/\r\n    /*tree.just_selected = 0;*/\r\n    tree.mir_gen = null;\r\n    tree.clq_gen = null;\r\n    /*tree.round = 0;*/\r\n    /* pseudocost branching */\r\n    tree.pcost = null;\r\n    tree.iwrk = new Int32Array(1+n);\r\n    tree.dwrk = new Float64Array(1+n);\r\n    /* initialize control parameters */\r\n    tree.parm = parm;\r\n    tree.tm_beg = xtime();\r\n    tree.tm_lag = 0;\r\n    tree.sol_cnt = 0;\r\n    /* initialize advanced solver interface */\r\n    tree.reason = 0;\r\n    tree.reopt = 0;\r\n    tree.reinv = 0;\r\n    tree.br_var = 0;\r\n    tree.br_sel = 0;\r\n    tree.child = 0;\r\n    tree.next_p = 0;\r\n    /*tree.btrack = null;*/\r\n    tree.stop = 0;\r\n    /* create the root subproblem, which initially is identical to\r\n     the original MIP */\r\n    new_node(tree, null);\r\n    return tree;\r\n}\r\n\r\nfunction ios_revive_node(tree, p){\r\n    var mip = tree.mip;\r\n    var node, root;\r\n    var b, r, s, a;\r\n    /* obtain pointer to the specified subproblem */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* the current subproblem must not exist */\r\n    xassert(tree.curr == null);\r\n    /* the specified subproblem becomes current */\r\n    tree.curr = node;\r\n    /*tree.solved = 0;*/\r\n    /* obtain pointer to the root subproblem */\r\n    root = tree.slot[1].node;\r\n    xassert(root != null);\r\n    /* at this point problem object components correspond to the root\r\n     subproblem, so if the root subproblem should be revived, there\r\n     is nothing more to do */\r\n    if (node == root) return;\r\n    xassert(mip.m == tree.root_m);\r\n    /* build path from the root to the current node */\r\n    node.temp = null;\r\n    for (; node != null; node = node.up)\r\n    {  if (node.up == null)\r\n        xassert(node == root);\r\n    else\r\n        node.up.temp = node;\r\n    }\r\n    /* go down from the root to the current node and make necessary\r\n     changes to restore components of the current subproblem */\r\n    for (node = root; node != null; node = node.temp)\r\n    {  var m = mip.m;\r\n        var n = mip.n;\r\n        /* if the current node is reached, the problem object at this\r\n         point corresponds to its parent, so save attributes of rows\r\n         and columns for the parent subproblem */\r\n        if (node.temp == null)\r\n        {   var i, j;\r\n            tree.pred_m = m;\r\n            /* allocate/reallocate arrays, if necessary */\r\n            if (tree.pred_max < m + n)\r\n            {  var new_size = m + n + 100;\r\n                tree.pred_max = new_size;\r\n                tree.pred_type = new Int8Array(1+new_size);\r\n                tree.pred_lb = new Float64Array(1+new_size);\r\n                tree.pred_ub = new Float64Array(1+new_size);\r\n                tree.pred_stat = new Int8Array(1+new_size);\r\n            }\r\n            /* save row attributes */\r\n            for (i = 1; i <= m; i++)\r\n            {  var row = mip.row[i];\r\n                tree.pred_type[i] = row.type;\r\n                tree.pred_lb[i] = row.lb;\r\n                tree.pred_ub[i] = row.ub;\r\n                tree.pred_stat[i] = row.stat;\r\n            }\r\n            /* save column attributes */\r\n            for (j = 1; j <= n; j++)\r\n            {  var col = mip.col[j];\r\n                tree.pred_type[mip.m+j] = col.type;\r\n                tree.pred_lb[mip.m+j] = col.lb;\r\n                tree.pred_ub[mip.m+j] = col.ub;\r\n                tree.pred_stat[mip.m+j] = col.stat;\r\n            }\r\n        }\r\n        /* change bounds of rows and columns */\r\n        {   for (b = node.b_ptr; b != null; b = b.next)\r\n        {  if (b.k <= m)\r\n            glp_set_row_bnds(mip, b.k, b.type, b.lb, b.ub);\r\n        else\r\n            glp_set_col_bnds(mip, b.k-m, b.type, b.lb, b.ub);\r\n        }\r\n        }\r\n        /* change statuses of rows and columns */\r\n        {   for (s = node.s_ptr; s != null; s = s.next)\r\n        {  if (s.k <= m)\r\n            glp_set_row_stat(mip, s.k, s.stat);\r\n        else\r\n            glp_set_col_stat(mip, s.k-m, s.stat);\r\n        }\r\n        }\r\n        /* add new rows */\r\n        if (node.r_ptr != null)\r\n        {\r\n            var len, ind;\r\n            var val;\r\n            ind = new Int32Array(1+n);\r\n            val = new Float64Array(1+n);\r\n            for (r = node.r_ptr; r != null; r = r.next)\r\n            {  i = glp_add_rows(mip, 1);\r\n                glp_set_row_name(mip, i, r.name);\r\n                xassert(mip.row[i].level == 0);\r\n                mip.row[i].level = node.level;\r\n                mip.row[i].origin = r.origin;\r\n                mip.row[i].klass = r.klass;\r\n                glp_set_row_bnds(mip, i, r.type, r.lb, r.ub);\r\n                len = 0;\r\n                for (a = r.ptr; a != null; a = a.next){\r\n                    len++; ind[len] = a.j; val[len] = a.val;\r\n                }\r\n                glp_set_mat_row(mip, i, len, ind, val);\r\n                glp_set_rii(mip, i, r.rii);\r\n                glp_set_row_stat(mip, i, r.stat);\r\n            }\r\n        }\r\n    }\r\n    /* the specified subproblem has been revived */\r\n    node = tree.curr;\r\n    /* delete its bound change list */\r\n    while (node.b_ptr != null)\r\n    {   b = node.b_ptr;\r\n        node.b_ptr = b.next;\r\n    }\r\n    /* delete its status change list */\r\n    while (node.s_ptr != null)\r\n    {   s = node.s_ptr;\r\n        node.s_ptr = s.next;\r\n    }\r\n    /* delete its row addition list (additional rows may appear, for\r\n     example, due to branching on GUB constraints */\r\n    while (node.r_ptr != null)\r\n    {   r = node.r_ptr;\r\n        node.r_ptr = r.next;\r\n        xassert(r.name == null);\r\n        while (r.ptr != null)\r\n        {   a = r.ptr;\r\n            r.ptr = a.next;\r\n        }\r\n    }\r\n}\r\n\r\nfunction ios_freeze_node(tree){\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    /* obtain pointer to the current subproblem */\r\n    var node = tree.curr;\r\n    xassert(node != null);\r\n\r\n\r\n    var k, i, row, col;\r\n    if (node.up == null)\r\n    {  /* freeze the root subproblem */\r\n        xassert(node.p == 1);\r\n        xassert(tree.root_m == 0);\r\n        xassert(tree.root_type == null);\r\n        xassert(tree.root_lb == null);\r\n        xassert(tree.root_ub == null);\r\n        xassert(tree.root_stat == null);\r\n        tree.root_m = m;\r\n        tree.root_type = new Int8Array(1+m+n);\r\n        tree.root_lb = new Float64Array(1+m+n);\r\n        tree.root_ub = new Float64Array(1+m+n);\r\n        tree.root_stat = new Int8Array(1+m+n);\r\n        for (k = 1; k <= m+n; k++)\r\n        {  if (k <= m)\r\n        {   row = mip.row[k];\r\n            tree.root_type[k] = row.type;\r\n            tree.root_lb[k] = row.lb;\r\n            tree.root_ub[k] = row.ub;\r\n            tree.root_stat[k] = row.stat;\r\n        }\r\n        else\r\n        {   col = mip.col[k-m];\r\n            tree.root_type[k] = col.type;\r\n            tree.root_lb[k] = col.lb;\r\n            tree.root_ub[k] = col.ub;\r\n            tree.root_stat[k] = col.stat;\r\n        }\r\n        }\r\n    }\r\n    else\r\n    {  /* freeze non-root subproblem */\r\n        var root_m = tree.root_m;\r\n        var pred_m = tree.pred_m;\r\n        var j;\r\n        xassert(pred_m <= m);\r\n        /* build change lists for rows and columns which exist in the\r\n         parent subproblem */\r\n        xassert(node.b_ptr == null);\r\n        xassert(node.s_ptr == null);\r\n        for (k = 1; k <= pred_m + n; k++)\r\n        {  var pred_type, pred_stat, type, stat;\r\n            var pred_lb, pred_ub, lb, ub;\r\n            /* determine attributes in the parent subproblem */\r\n            pred_type = tree.pred_type[k];\r\n            pred_lb = tree.pred_lb[k];\r\n            pred_ub = tree.pred_ub[k];\r\n            pred_stat = tree.pred_stat[k];\r\n            /* determine attributes in the current subproblem */\r\n            if (k <= pred_m)\r\n            {   row = mip.row[k];\r\n                type = row.type;\r\n                lb = row.lb;\r\n                ub = row.ub;\r\n                stat = row.stat;\r\n            }\r\n            else\r\n            {   col = mip.col[k - pred_m];\r\n                type = col.type;\r\n                lb = col.lb;\r\n                ub = col.ub;\r\n                stat = col.stat;\r\n            }\r\n            /* save type and bounds of a row/column, if changed */\r\n            if (!(pred_type == type && pred_lb == lb && pred_ub == ub))\r\n            {   var b = {};\r\n                b.k = k;\r\n                b.type = type;\r\n                b.lb = lb;\r\n                b.ub = ub;\r\n                b.next = node.b_ptr;\r\n                node.b_ptr = b;\r\n            }\r\n            /* save status of a row/column, if changed */\r\n            if (pred_stat != stat)\r\n            {   var s = {};\r\n                s.k = k;\r\n                s.stat = stat;\r\n                s.next = node.s_ptr;\r\n                node.s_ptr = s;\r\n            }\r\n        }\r\n        /* save new rows added to the current subproblem */\r\n        xassert(node.r_ptr == null);\r\n        if (pred_m < m)\r\n        {  var len, ind;\r\n            var val;\r\n            ind = new Int32Array(1+n);\r\n            val = new Float64Array(1+n);\r\n            for (i = m; i > pred_m; i--)\r\n            {   row = mip.row[i];\r\n                var r = {};\r\n                var name = glp_get_row_name(mip, i);\r\n                if (name == null)\r\n                    r.name = null;\r\n                else\r\n                {\r\n                    r.name = name;\r\n                }\r\n                r.type = row.type;\r\n                r.lb = row.lb;\r\n                r.ub = row.ub;\r\n                r.ptr = null;\r\n                len = glp_get_mat_row(mip, i, ind, val);\r\n                for (k = 1; k <= len; k++)\r\n                {\r\n                    var a = {};\r\n                    a.j = ind[k];\r\n                    a.val = val[k];\r\n                    a.next = r.ptr;\r\n                    r.ptr = a;\r\n                }\r\n                r.rii = row.rii;\r\n                r.stat = row.stat;\r\n                r.next = node.r_ptr;\r\n                node.r_ptr = r;\r\n            }\r\n        }\r\n        /* remove all rows missing in the root subproblem */\r\n        if (m != root_m)\r\n        {\r\n            var nrs = m - root_m;\r\n            xassert(nrs > 0);\r\n            var num = new Int32Array(1+nrs);\r\n            for (i = 1; i <= nrs; i++) num[i] = root_m + i;\r\n            glp_del_rows(mip, nrs, num);\r\n        }\r\n        m = mip.m;\r\n        /* and restore attributes of all rows and columns for the root\r\n         subproblem */\r\n        xassert(m == root_m);\r\n        for (i = 1; i <= m; i++)\r\n        {  glp_set_row_bnds(mip, i, tree.root_type[i],\r\n            tree.root_lb[i], tree.root_ub[i]);\r\n            glp_set_row_stat(mip, i, tree.root_stat[i]);\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  glp_set_col_bnds(mip, j, tree.root_type[m+j],\r\n            tree.root_lb[m+j], tree.root_ub[m+j]);\r\n            glp_set_col_stat(mip, j, tree.root_stat[m+j]);\r\n        }\r\n    }\r\n    /* the current subproblem has been frozen */\r\n    tree.curr = null;\r\n}\r\n\r\nfunction ios_clone_node(tree, p, nnn, ref){\r\n    var node, k;\r\n    /* obtain pointer to the subproblem to be cloned */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* and must be in the frozen state */\r\n    xassert(tree.curr != node);\r\n    /* remove the specified subproblem from the active list, because\r\n     it becomes inactive */\r\n    if (node.prev == null)\r\n        tree.head = node.next;\r\n    else\r\n        node.prev.next = node.next;\r\n    if (node.next == null)\r\n        tree.tail = node.prev;\r\n    else\r\n        node.next.prev = node.prev;\r\n    node.prev = node.next = null;\r\n    tree.a_cnt--;\r\n    /* create clone subproblems */\r\n    xassert(nnn > 0);\r\n    for (k = 1; k <= nnn; k++)\r\n        ref[k] = new_node(tree, node).p;\r\n}\r\n\r\nfunction ios_delete_node(tree, p){\r\n    var node, temp;\r\n    /* obtain pointer to the subproblem to be deleted */\r\n    xassert(1 <= p && p <= tree.nslots);\r\n    node = tree.slot[p].node;\r\n    xassert(node != null);\r\n    /* the specified subproblem must be active */\r\n    xassert(node.count == 0);\r\n    /* and must be in the frozen state */\r\n    xassert(tree.curr != node);\r\n    /* remove the specified subproblem from the active list, because\r\n     it is gone from the tree */\r\n    if (node.prev == null)\r\n        tree.head = node.next;\r\n    else\r\n        node.prev.next = node.next;\r\n    if (node.next == null)\r\n        tree.tail = node.prev;\r\n    else\r\n        node.next.prev = node.prev;\r\n    node.prev = node.next = null;\r\n    tree.a_cnt--;\r\n    while (true){\r\n        /* recursive deletion starts here */\r\n        /* delete the bound change list */\r\n        {  var b;\r\n            while (node.b_ptr != null)\r\n            {  b = node.b_ptr;\r\n                node.b_ptr = b.next;\r\n            }\r\n        }\r\n        /* delete the status change list */\r\n        {  var s;\r\n            while (node.s_ptr != null)\r\n            {  s = node.s_ptr;\r\n                node.s_ptr = s.next;\r\n            }\r\n        }\r\n        /* delete the row addition list */\r\n        while (node.r_ptr != null)\r\n        {  var r;\r\n            r = node.r_ptr;\r\n            r.name = null;\r\n            while (r.ptr != null)\r\n            {  var a;\r\n                a = r.ptr;\r\n                r.ptr = a.next;\r\n            }\r\n            node.r_ptr = r.next;\r\n        }\r\n        /* free application-specific data */\r\n        if (tree.parm.cb_size == 0)\r\n            xassert(node.data == null);\r\n        /* free the corresponding node slot */\r\n        p = node.p;\r\n        xassert(tree.slot[p].node == node);\r\n        tree.slot[p].node = null;\r\n        tree.slot[p].next = tree.avail;\r\n        tree.avail = p;\r\n        /* save pointer to the parent subproblem */\r\n        temp = node.up;\r\n        /* delete the subproblem descriptor */\r\n        tree.n_cnt--;\r\n        /* take pointer to the parent subproblem */\r\n        node = temp;\r\n        if (node != null)\r\n        {  /* the parent subproblem exists; decrease the number of its\r\n         child subproblems */\r\n            xassert(node.count > 0);\r\n            node.count--;\r\n            /* if now the parent subproblem has no childs, it also must be\r\n             deleted */\r\n            if (node.count == 0) continue;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nfunction ios_delete_tree(tree){\r\n    var mip = tree.mip;\r\n    var i, j;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    xassert(mip.tree == tree);\r\n    /* remove all additional rows */\r\n    if (m != tree.orig_m)\r\n    {  var nrs, num;\r\n        nrs = m - tree.orig_m;\r\n        xassert(nrs > 0);\r\n        num = new Int32Array(1+nrs);\r\n        for (i = 1; i <= nrs; i++) num[i] = tree.orig_m + i;\r\n        glp_del_rows(mip, nrs, num);\r\n    }\r\n    m = tree.orig_m;\r\n    /* restore original attributes of rows and columns */\r\n    xassert(m == tree.orig_m);\r\n    xassert(n == tree.n);\r\n    for (i = 1; i <= m; i++)\r\n    {  glp_set_row_bnds(mip, i, tree.orig_type[i],\r\n        tree.orig_lb[i], tree.orig_ub[i]);\r\n        glp_set_row_stat(mip, i, tree.orig_stat[i]);\r\n        mip.row[i].prim = tree.orig_prim[i];\r\n        mip.row[i].dual = tree.orig_dual[i];\r\n    }\r\n    for (j = 1; j <= n; j++)\r\n    {  glp_set_col_bnds(mip, j, tree.orig_type[m+j],\r\n        tree.orig_lb[m+j], tree.orig_ub[m+j]);\r\n        glp_set_col_stat(mip, j, tree.orig_stat[m+j]);\r\n        mip.col[j].prim = tree.orig_prim[m+j];\r\n        mip.col[j].dual = tree.orig_dual[m+j];\r\n    }\r\n    mip.pbs_stat = mip.dbs_stat = GLP_FEAS;\r\n    mip.obj_val = tree.orig_obj;\r\n    /* delete the branch-and-bound tree */\r\n    xassert(tree.local != null);\r\n    ios_delete_pool(tree.local);\r\n    xassert(tree.mir_gen == null);\r\n    xassert(tree.clq_gen == null);\r\n    mip.tree = null;\r\n}\r\n\r\nfunction ios_eval_degrad(tree, j, callback){\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var len, kase, k, t, stat;\r\n    var alfa, beta, gamma, delta, dz;\r\n    var ind = tree.iwrk;\r\n    var val = tree.dwrk;\r\n    var dn, up;\r\n\r\n    /* current basis must be optimal */\r\n    xassert(glp_get_status(mip) == GLP_OPT);\r\n    /* basis factorization must exist */\r\n    xassert(glp_bf_exists(mip));\r\n    /* obtain (fractional) value of x[j] in optimal basic solution\r\n     to LP relaxation of the current subproblem */\r\n    xassert(1 <= j && j <= n);\r\n    beta = mip.col[j].prim;\r\n    /* since the value of x[j] is fractional, it is basic; compute\r\n     corresponding row of the simplex table */\r\n    len = lpx_eval_tab_row(mip, m+j, ind, val);\r\n    /* kase < 0 means down-branch; kase > 0 means up-branch */\r\n    for (kase = -1; kase <= +1; kase += 2)\r\n    {  /* for down-branch we introduce new upper bound floor(beta)\r\n     for x[j]; similarly, for up-branch we introduce new lower\r\n     bound ceil(beta) for x[j]; in the current basis this new\r\n     upper/lower bound is violated, so in the adjacent basis\r\n     x[j] will leave the basis and go to its new upper/lower\r\n     bound; we need to know which non-basic variable x[k] should\r\n     enter the basis to keep dual feasibility */\r\n        k = lpx_dual_ratio_test(mip, len, ind, val, kase, 1e-9);\r\n        /* if no variable has been chosen, current basis being primal\r\n         infeasible due to the new upper/lower bound of x[j] is dual\r\n         unbounded, therefore, LP relaxation to corresponding branch\r\n         has no primal feasible solution */\r\n        if (k == 0)\r\n        {  if (mip.dir == GLP_MIN)\r\n        {  if (kase < 0)\r\n            dn = +DBL_MAX;\r\n        else\r\n            up = +DBL_MAX;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (kase < 0)\r\n            dn = -DBL_MAX;\r\n        else\r\n            up = -DBL_MAX;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n            continue;\r\n        }\r\n        xassert(1 <= k && k <= m+n);\r\n        /* row of the simplex table corresponding to specified basic\r\n         variable x[j] is the following:\r\n         x[j] = ... + alfa * x[k] + ... ;\r\n         we need to know influence coefficient, alfa, at non-basic\r\n         variable x[k] chosen with the dual ratio test */\r\n        for (t = 1; t <= len; t++)\r\n            if (ind[t] == k) break;\r\n        xassert(1 <= t && t <= len);\r\n        alfa = val[t];\r\n        /* determine status and reduced cost of variable x[k] */\r\n        if (k <= m)\r\n        {  stat = mip.row[k].stat;\r\n            gamma = mip.row[k].dual;\r\n        }\r\n        else\r\n        {  stat = mip.col[k-m].stat;\r\n            gamma = mip.col[k-m].dual;\r\n        }\r\n        /* x[k] cannot be basic or fixed non-basic */\r\n        xassert(stat == GLP_NL || stat == GLP_NU || stat == GLP_NF);\r\n        /* if the current basis is dual degenerative, some reduced\r\n         costs, which are close to zero, may have wrong sign due to\r\n         round-off errors, so correct the sign of gamma */\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (stat == GLP_NL && gamma < 0.0 ||\r\n            stat == GLP_NU && gamma > 0.0 ||\r\n            stat == GLP_NF) gamma = 0.0;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (stat == GLP_NL && gamma > 0.0 ||\r\n            stat == GLP_NU && gamma < 0.0 ||\r\n            stat == GLP_NF) gamma = 0.0;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* determine the change of x[j] in the adjacent basis:\r\n         delta x[j] = new x[j] - old x[j] */\r\n        delta = (kase < 0 ? Math.floor(beta) : Math.ceil(beta)) - beta;\r\n        /* compute the change of x[k] in the adjacent basis:\r\n         delta x[k] = new x[k] - old x[k] = delta x[j] / alfa */\r\n        delta /= alfa;\r\n        /* compute the change of the objective in the adjacent basis:\r\n         delta z = new z - old z = gamma * delta x[k] */\r\n        dz = gamma * delta;\r\n        if (mip.dir == GLP_MIN)\r\n            xassert(dz >= 0.0);\r\n        else if (mip.dir == GLP_MAX)\r\n            xassert(dz <= 0.0);\r\n        else\r\n            xassert(mip != mip);\r\n        /* compute the new objective value in the adjacent basis:\r\n         new z = old z + delta z */\r\n        if (kase < 0)\r\n            dn = mip.obj_val + dz;\r\n        else\r\n            up = mip.obj_val + dz;\r\n    }\r\n    callback(dn, up);\r\n    /*xprintf(\"obj = %g; dn = %g; up = %g\",\r\n     mip.obj_val, *dn, *up);*/\r\n}\r\n\r\nfunction ios_round_bound(tree, bound){\r\n    var mip = tree.mip;\r\n    var n = mip.n;\r\n    var d, j, nn;\r\n    var c = tree.iwrk;\r\n    var s, h;\r\n    /* determine c[j] and compute s */\r\n    nn = 0; s = mip.c0; d = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        if (col.coef == 0.0) continue;\r\n        if (col.type == GLP_FX)\r\n        {  /* fixed variable */\r\n            s += col.coef * col.prim;\r\n        }\r\n        else\r\n        {  /* non-fixed variable */\r\n            if (col.kind != GLP_IV) return bound;\r\n            if (col.coef != Math.floor(col.coef)) return bound;\r\n            if (Math.abs(col.coef) <= INT_MAX)\r\n                c[++nn] = Math.abs(col.coef)|0;\r\n            else\r\n                d = 1;\r\n        }\r\n    }\r\n    /* compute d = gcd(c[1],...c[nn]) */\r\n    if (d == 0)\r\n    {  if (nn == 0) return bound;\r\n        d = gcdn(nn, c);\r\n    }\r\n    xassert(d > 0);\r\n    /* compute new local bound */\r\n    if (mip.dir == GLP_MIN)\r\n    {  if (bound != +DBL_MAX)\r\n    {  h = (bound - s) / d;\r\n        if (h >= Math.floor(h) + 0.001)\r\n        {  /* round up */\r\n            h = Math.ceil(h);\r\n            /*xprintf(\"d = %d; old = %g; \", d, bound);*/\r\n            bound = d * h + s;\r\n            /*xprintf(\"new = %g\", bound);*/\r\n        }\r\n    }\r\n    }\r\n    else if (mip.dir == GLP_MAX)\r\n    {  if (bound != -DBL_MAX)\r\n    {  h = (bound - s) / d;\r\n        if (h <= Math.ceil(h) - 0.001)\r\n        {  /* round down */\r\n            h = Math.floor(h);\r\n            bound = d * h + s;\r\n        }\r\n    }\r\n    }\r\n    else\r\n        xassert(mip != mip);\r\n    return bound;\r\n}\r\n\r\nfunction ios_is_hopeful(tree, bound){\r\n    var mip = tree.mip;\r\n    var ret = 1;\r\n    var eps;\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  eps = tree.parm.tol_obj * (1.0 + Math.abs(mip.mip_obj));\r\n        switch (mip.dir)\r\n        {  case GLP_MIN:\r\n            if (bound >= mip.mip_obj - eps) ret = 0;\r\n            break;\r\n            case GLP_MAX:\r\n                if (bound <= mip.mip_obj + eps) ret = 0;\r\n                break;\r\n            default:\r\n                xassert(mip != mip);\r\n        }\r\n    }\r\n    else\r\n    {  switch (mip.dir)\r\n    {  case GLP_MIN:\r\n            if (bound == +DBL_MAX) ret = 0;\r\n            break;\r\n        case GLP_MAX:\r\n            if (bound == -DBL_MAX) ret = 0;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction ios_best_node(tree){\r\n    var node, best = null;\r\n    switch (tree.mip.dir)\r\n    {  case GLP_MIN:\r\n        /* minimization */\r\n        for (node = tree.head; node != null; node = node.next)\r\n            if (best == null || best.bound > node.bound)\r\n                best = node;\r\n        break;\r\n        case GLP_MAX:\r\n            /* maximization */\r\n            for (node = tree.head; node != null; node = node.next)\r\n                if (best == null || best.bound < node.bound)\r\n                    best = node;\r\n            break;\r\n        default:\r\n            xassert(tree != tree);\r\n    }\r\n    return best == null ? 0 : best.p;\r\n}\r\n\r\nvar ios_relative_gap = exports['glp_ios_relative_gap'] = function(tree){\r\n    var mip = tree.mip;\r\n    var p;\r\n    var best_mip, best_bnd, gap;\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  best_mip = mip.mip_obj;\r\n        p = ios_best_node(tree);\r\n        if (p == 0)\r\n        {  /* the tree is empty */\r\n            gap = 0.0;\r\n        }\r\n        else\r\n        {  best_bnd = tree.slot[p].node.bound;\r\n            gap = Math.abs(best_mip - best_bnd) / (Math.abs(best_mip) +\r\n                DBL_EPSILON);\r\n        }\r\n    }\r\n    else\r\n    {  /* no integer feasible solution has been found yet */\r\n        gap = DBL_MAX;\r\n    }\r\n    return gap;\r\n};\r\n\r\nfunction ios_solve_node(tree){\r\n    var mip = tree.mip;\r\n    var ret;\r\n    /* the current subproblem must exist */\r\n    xassert(tree.curr != null);\r\n    /* set some control parameters */\r\n    var parm = new SMCP();\r\n    // glp_init_smcp(parm);\r\n    switch (tree.parm.msg_lev)\r\n    {  case GLP_MSG_OFF:\r\n        parm.msg_lev = GLP_MSG_OFF; break;\r\n        case GLP_MSG_ERR:\r\n            parm.msg_lev = GLP_MSG_ERR; break;\r\n        case GLP_MSG_ON:\r\n        case GLP_MSG_ALL:\r\n            parm.msg_lev = GLP_MSG_ON; break;\r\n        case GLP_MSG_DBG:\r\n            parm.msg_lev = GLP_MSG_ALL; break;\r\n        default:\r\n            xassert(tree != tree);\r\n    }\r\n    parm.meth = GLP_DUALP;\r\n    if (tree.parm.msg_lev < GLP_MSG_DBG)\r\n        parm.out_dly = tree.parm.out_dly;\r\n    else\r\n        parm.out_dly = 0;\r\n    /* if the incumbent objective value is already known, use it to\r\n     prematurely terminate the dual simplex search */\r\n    if (mip.mip_stat == GLP_FEAS)\r\n    {  switch (tree.mip.dir)\r\n    {  case GLP_MIN:\r\n            parm.obj_ul = mip.mip_obj;\r\n            break;\r\n        case GLP_MAX:\r\n            parm.obj_ll = mip.mip_obj;\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    }\r\n    /* try to solve/re-optimize the LP relaxation */\r\n    ret = glp_simplex(mip, parm);\r\n    tree.curr.solved++;\r\n    return ret;\r\n}\r\n\r\nfunction ios_create_pool(tree){\r\n    /* create cut pool */\r\n    xassert(tree == tree);\r\n    var pool = {};\r\n    pool.size = 0;\r\n    pool.head = pool.tail = null;\r\n    pool.ord = 0; pool.curr = null;\r\n    return pool;\r\n}\r\n\r\nfunction ios_add_row(tree, pool, name, klass, flags, len, ind, val, type, rhs){\r\n    /* add row (constraint) to the cut pool */\r\n    var cut, aij, k;\r\n    xassert(pool != null);\r\n    cut = {};\r\n    if (name == null || name[0] == '\\0')\r\n        cut.name = null;\r\n    else\r\n    {\r\n        cut.name = name;\r\n    }\r\n    if (!(0 <= klass && klass <= 255))\r\n        xerror(\"glp_ios_add_row: klass = \" + klass + \"; invalid cut class\");\r\n    cut.klass = klass;\r\n    if (flags != 0)\r\n        xerror(\"glp_ios_add_row: flags = \" + flags + \"; invalid cut flags\");\r\n    cut.ptr = null;\r\n    if (!(0 <= len && len <= tree.n))\r\n        xerror(\"glp_ios_add_row: len = \" + len + \"; invalid cut length\");\r\n    for (k = 1; k <= len; k++)\r\n    {  aij = {};\r\n        if (!(1 <= ind[k] && ind[k] <= tree.n))\r\n            xerror(\"glp_ios_add_row: ind[\" + k + \"] = \" + ind[k] + \"; column index out of range\");\r\n        aij.j = ind[k];\r\n        aij.val = val[k];\r\n        aij.next = cut.ptr;\r\n        cut.ptr = aij;\r\n    }\r\n    if (!(type == GLP_LO || type == GLP_UP || type == GLP_FX))\r\n        xerror(\"glp_ios_add_row: type = \" + type + \"; invalid cut type\");\r\n    cut.type = type;\r\n    cut.rhs = rhs;\r\n    cut.prev = pool.tail;\r\n    cut.next = null;\r\n    if (cut.prev == null)\r\n        pool.head = cut;\r\n    else\r\n        cut.prev.next = cut;\r\n    pool.tail = cut;\r\n    pool.size++;\r\n    return pool.size;\r\n}\r\n\r\nfunction ios_find_row(pool, i){\r\n    /* find row (constraint) in the cut pool */\r\n    /* (smart linear search) */\r\n    xassert(pool != null);\r\n    xassert(1 <= i && i <= pool.size);\r\n    if (pool.ord == 0)\r\n    {  xassert(pool.curr == null);\r\n        pool.ord = 1;\r\n        pool.curr = pool.head;\r\n    }\r\n    xassert(pool.curr != null);\r\n    if (i < pool.ord)\r\n    {  if (i < pool.ord - i)\r\n    {  pool.ord = 1;\r\n        pool.curr = pool.head;\r\n        while (pool.ord != i)\r\n        {  pool.ord++;\r\n            xassert(pool.curr != null);\r\n            pool.curr = pool.curr.next;\r\n        }\r\n    }\r\n    else\r\n    {  while (pool.ord != i)\r\n    {  pool.ord--;\r\n        xassert(pool.curr != null);\r\n        pool.curr = pool.curr.prev;\r\n    }\r\n    }\r\n    }\r\n    else if (i > pool.ord)\r\n    {  if (i - pool.ord < pool.size - i)\r\n    {  while (pool.ord != i)\r\n    {  pool.ord++;\r\n        xassert(pool.curr != null);\r\n        pool.curr = pool.curr.next;\r\n    }\r\n    }\r\n    else\r\n    {  pool.ord = pool.size;\r\n        pool.curr = pool.tail;\r\n        while (pool.ord != i)\r\n        {  pool.ord--;\r\n            xassert(pool.curr != null);\r\n            pool.curr = pool.curr.prev;\r\n        }\r\n    }\r\n    }\r\n    xassert(pool.ord == i);\r\n    xassert(pool.curr != null);\r\n    return pool.curr;\r\n}\r\n\r\nfunction ios_del_row(pool, i){\r\n    /* remove row (constraint) from the cut pool */\r\n    var cut, aij;\r\n    xassert(pool != null);\r\n    if (!(1 <= i && i <= pool.size))\r\n        xerror(\"glp_ios_del_row: i = \" + i + \"; cut number out of range\");\r\n    cut = ios_find_row(pool, i);\r\n    xassert(pool.curr == cut);\r\n    if (cut.next != null)\r\n        pool.curr = cut.next;\r\n    else if (cut.prev != null){\r\n        pool.ord--; pool.curr = cut.prev;\r\n    }\r\n    else {\r\n        pool.ord = 0; pool.curr = null;\r\n    }\r\n    if (cut.prev == null)\r\n    {  xassert(pool.head == cut);\r\n        pool.head = cut.next;\r\n    }\r\n    else\r\n    {  xassert(cut.prev.next == cut);\r\n        cut.prev.next = cut.next;\r\n    }\r\n    if (cut.next == null)\r\n    {  xassert(pool.tail == cut);\r\n        pool.tail = cut.prev;\r\n    }\r\n    else\r\n    {  xassert(cut.next.prev == cut);\r\n        cut.next.prev = cut.prev;\r\n    }\r\n    while (cut.ptr != null)\r\n    {  aij = cut.ptr;\r\n        cut.ptr = aij.next;\r\n    }\r\n    pool.size--;\r\n\r\n}\r\n\r\nfunction ios_clear_pool(pool){\r\n    /* remove all rows (constraints) from the cut pool */\r\n    xassert(pool != null);\r\n    while (pool.head != null)\r\n    {  var cut = pool.head;\r\n        pool.head = cut.next;\r\n        while (cut.ptr != null)\r\n        {  var aij = cut.ptr;\r\n            cut.ptr = aij.next;\r\n        }\r\n    }\r\n    pool.size = 0;\r\n    pool.head = pool.tail = null;\r\n    pool.ord = 0;\r\n    pool.curr = null;\r\n}\r\n\r\nfunction ios_delete_pool(pool){\r\n    /* delete cut pool */\r\n    xassert(pool != null);\r\n    ios_clear_pool(pool);\r\n}\r\n\r\nfunction ios_preprocess_node(tree, max_pass){\r\n    function prepare_row_info(n, a, l, u, f){\r\n        var j, j_min, j_max;\r\n        var f_min, f_max;\r\n        xassert(n >= 0);\r\n        /* determine f_min and j_min */\r\n        f_min = 0.0; j_min = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (a[j] > 0.0)\r\n        {  if (l[j] == -DBL_MAX)\r\n        {  if (j_min == 0)\r\n            j_min = j;\r\n        else\r\n        {  f_min = -DBL_MAX; j_min = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_min += a[j] * l[j];\r\n        }\r\n        else if (a[j] < 0.0)\r\n        {  if (u[j] == +DBL_MAX)\r\n        {  if (j_min == 0)\r\n            j_min = j;\r\n        else\r\n        {  f_min = -DBL_MAX; j_min = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_min += a[j] * u[j];\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        f.f_min = f_min; f.j_min = j_min;\r\n        /* determine f_max and j_max */\r\n        f_max = 0.0; j_max = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (a[j] > 0.0)\r\n        {  if (u[j] == +DBL_MAX)\r\n        {  if (j_max == 0)\r\n            j_max = j;\r\n        else\r\n        {  f_max = +DBL_MAX; j_max = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_max += a[j] * u[j];\r\n        }\r\n        else if (a[j] < 0.0)\r\n        {  if (l[j] == -DBL_MAX)\r\n        {  if (j_max == 0)\r\n            j_max = j;\r\n        else\r\n        {  f_max = +DBL_MAX; j_max = 0;\r\n            break;\r\n        }\r\n        }\r\n        else\r\n            f_max += a[j] * l[j];\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        f.f_max = f_max; f.j_max = j_max;\r\n    }\r\n\r\n    function row_implied_bounds(f, callback){\r\n        callback((f.j_min == 0 ? f.f_min : -DBL_MAX), (f.j_max == 0 ? f.f_max : +DBL_MAX));\r\n    }\r\n\r\n    function col_implied_bounds(f, n, a, L, U, l, u, k, callback){\r\n        var ilb, iub, ll, uu;\r\n        xassert(n >= 0);\r\n        xassert(1 <= k && k <= n);\r\n        /* determine implied lower bound of term a[k] * x[k] (14) */\r\n        if (L == -DBL_MAX || f.f_max == +DBL_MAX)\r\n            ilb = -DBL_MAX;\r\n        else if (f.j_max == 0)\r\n        {  if (a[k] > 0.0)\r\n        {  xassert(u[k] != +DBL_MAX);\r\n            ilb = L - (f.f_max - a[k] * u[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  xassert(l[k] != -DBL_MAX);\r\n            ilb = L - (f.f_max - a[k] * l[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        else if (f.j_max == k)\r\n            ilb = L - f.f_max;\r\n        else\r\n            ilb = -DBL_MAX;\r\n        /* determine implied upper bound of term a[k] * x[k] (15) */\r\n        if (U == +DBL_MAX || f.f_min == -DBL_MAX)\r\n            iub = +DBL_MAX;\r\n        else if (f.j_min == 0)\r\n        {  if (a[k] > 0.0)\r\n        {  xassert(l[k] != -DBL_MAX);\r\n            iub = U - (f.f_min - a[k] * l[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  xassert(u[k] != +DBL_MAX);\r\n            iub = U - (f.f_min - a[k] * u[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        }\r\n        else if (f.j_min == k)\r\n            iub = U - f.f_min;\r\n        else\r\n            iub = +DBL_MAX;\r\n        /* determine implied bounds of x[k] (16) and (17) */\r\n        /* do not use a[k] if it has small magnitude to prevent wrong\r\n         implied bounds; for example, 1e-15 * x1 >= x2 + x3, where\r\n         x1 >= -10, x2, x3 >= 0, would lead to wrong conclusion that\r\n         x1 >= 0 */\r\n        if (Math.abs(a[k]) < 1e-6){\r\n            ll = -DBL_MAX;\r\n            uu = +DBL_MAX\r\n        } else if (a[k] > 0.0)\r\n        {  ll = (ilb == -DBL_MAX ? -DBL_MAX : ilb / a[k]);\r\n            uu = (iub == +DBL_MAX ? +DBL_MAX : iub / a[k]);\r\n        }\r\n        else if (a[k] < 0.0)\r\n        {  ll = (iub == +DBL_MAX ? -DBL_MAX : iub / a[k]);\r\n            uu = (ilb == -DBL_MAX ? +DBL_MAX : ilb / a[k]);\r\n        }\r\n        else\r\n            xassert(a != a);\r\n        callback(ll, uu);\r\n    }\r\n\r\n    function check_row_bounds(f, L_, Lx, U_, Ux){\r\n        var eps, ret = 0;\r\n        var L = L_[Lx], U = U_[Ux], LL = null, UU = null;\r\n        /* determine implied bounds of the row */\r\n        row_implied_bounds(f, function(a, b){LL = a; UU = b});\r\n        /* check if the original lower bound is infeasible */\r\n        if (L != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(L));\r\n            if (UU < L - eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original upper bound is infeasible */\r\n        if (U != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(U));\r\n            if (LL > U + eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original lower bound is redundant */\r\n        if (L != -DBL_MAX)\r\n        {   eps = 1e-12 * (1.0 + Math.abs(L));\r\n            if (LL > L - eps)\r\n            {  /* it cannot be active, so remove it */\r\n                L_[Lx] = -DBL_MAX;\r\n            }\r\n        }\r\n        /* check if the original upper bound is redundant */\r\n        if (U != +DBL_MAX)\r\n        {   eps = 1e-12 * (1.0 + Math.abs(U));\r\n            if (UU < U + eps)\r\n            {  /* it cannot be active, so remove it */\r\n                U_[Ux] = +DBL_MAX;\r\n            }\r\n        }\r\n        return ret\r\n    }\r\n\r\n    function check_col_bounds(f, n, a, L, U, l, u, flag, j, callback){\r\n        var eps, ret = 0;\r\n        var lj, uj, ll = null, uu = null;\r\n        xassert(n >= 0);\r\n        xassert(1 <= j && j <= n);\r\n        lj = l[j]; uj = u[j];\r\n        /* determine implied bounds of the column */\r\n        col_implied_bounds(f, n, a, L, U, l, u, j, function(a,b){ll = a; uu = b});\r\n        /* if x[j] is integral, round its implied bounds */\r\n        if (flag)\r\n        {  if (ll != -DBL_MAX)\r\n            ll = (ll - Math.floor(ll) < 1e-3 ? Math.floor(ll) : Math.ceil(ll));\r\n            if (uu != +DBL_MAX)\r\n                uu = (Math.ceil(uu) - uu < 1e-3 ? Math.ceil(uu) : Math.floor(uu));\r\n        }\r\n        /* check if the original lower bound is infeasible */\r\n        if (lj != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(lj));\r\n            if (uu < lj - eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original upper bound is infeasible */\r\n        if (uj != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(uj));\r\n            if (ll > uj + eps)\r\n            {  ret = 1;\r\n                return ret;\r\n            }\r\n        }\r\n        /* check if the original lower bound is redundant */\r\n        if (ll != -DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(ll));\r\n            if (lj < ll - eps)\r\n            {  /* it cannot be active, so tighten it */\r\n                lj = ll;\r\n            }\r\n        }\r\n        /* check if the original upper bound is redundant */\r\n        if (uu != +DBL_MAX)\r\n        {   eps = 1e-3 * (1.0 + Math.abs(uu));\r\n            if (uj > uu + eps)\r\n            {  /* it cannot be active, so tighten it */\r\n                uj = uu;\r\n            }\r\n        }\r\n        /* due to round-off errors it may happen that lj > uj (although\r\n         lj < uj + eps, since no primal infeasibility is detected), so\r\n         adjuct the new actual bounds to provide lj <= uj */\r\n        if (!(lj == -DBL_MAX || uj == +DBL_MAX))\r\n        {   var t1 = Math.abs(lj), t2 = Math.abs(uj);\r\n            eps = 1e-10 * (1.0 + (t1 <= t2 ? t1 : t2));\r\n            if (lj > uj - eps)\r\n            {  if (lj == l[j])\r\n                uj = lj;\r\n            else if (uj == u[j])\r\n                lj = uj;\r\n            else if (t1 <= t2)\r\n                uj = lj;\r\n            else\r\n                lj = uj;\r\n            }\r\n        }\r\n        callback(lj, uj);\r\n        return ret;\r\n    }\r\n\r\n    function check_efficiency(flag, l, u, ll, uu){\r\n        var r, eff = 0;\r\n        /* check efficiency for lower bound */\r\n        if (l < ll)\r\n        {  if (flag || l == -DBL_MAX)\r\n            eff++;\r\n        else\r\n        {\r\n            if (u == +DBL_MAX)\r\n                r = 1.0 + Math.abs(l);\r\n            else\r\n                r = 1.0 + (u - l);\r\n            if (ll - l >= 0.25 * r)\r\n                eff++;\r\n        }\r\n        }\r\n        /* check efficiency for upper bound */\r\n        if (u > uu)\r\n        {  if (flag || u == +DBL_MAX)\r\n            eff++;\r\n        else\r\n        {\r\n            if (l == -DBL_MAX)\r\n                r = 1.0 + Math.abs(u);\r\n            else\r\n                r = 1.0 + (u - l);\r\n            if (u - uu >= 0.25 * r)\r\n                eff++;\r\n        }\r\n        }\r\n        return eff;\r\n    }\r\n\r\n    function basic_preprocessing(mip, L, U, l, u, nrs, num, max_pass){\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var f = {};\r\n        var i, j, k, len, size, ret = 0;\r\n        var ind, list, mark, pass;\r\n        var val, lb, ub;\r\n        var aij, col;\r\n        xassert(0 <= nrs && nrs <= m+1);\r\n        xassert(max_pass > 0);\r\n        /* allocate working arrays */\r\n        ind = new Int32Array(1+n);\r\n        list = new Int32Array(1+m+1);\r\n        mark = new Int32Array(1+m+1);\r\n        pass = new Int32Array(1+m+1);\r\n        val = new Float64Array(1+n);\r\n        lb = new Float64Array(1+n);\r\n        ub = new Float64Array(1+n);\r\n        /* initialize the list of rows to be processed */\r\n        size = 0;\r\n        for (k = 1; k <= nrs; k++)\r\n        {  i = num[k];\r\n            xassert(0 <= i && i <= m);\r\n            /* duplicate row numbers are not allowed */\r\n            xassert(!mark[i]);\r\n            list[++size] = i; mark[i] = 1;\r\n        }\r\n        xassert(size == nrs);\r\n        /* process rows in the list until it becomes empty */\r\n        while (size > 0)\r\n        {  /* get a next row from the list */\r\n            i = list[size--]; mark[i] = 0;\r\n            /* increase the row processing count */\r\n            pass[i]++;\r\n            /* if the row is free, skip it */\r\n            if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\r\n            /* obtain coefficients of the row */\r\n            len = 0;\r\n            if (i == 0)\r\n            {   for (j = 1; j <= n; j++)\r\n            {   col = mip.col[j];\r\n                if (col.coef != 0.0){\r\n                    len++; ind[len] = j; val[len] = col.coef;\r\n                }\r\n            }\r\n            }\r\n            else\r\n            {   var row = mip.row[i];\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next){\r\n                    len++; ind[len] = aij.col.j; val[len] = aij.val;\r\n                }\r\n            }\r\n            /* determine lower and upper bounds of columns corresponding\r\n             to non-zero row coefficients */\r\n            for (k = 1; k <= len; k++){\r\n                j = ind[k]; lb[k] = l[j]; ub[k] = u[j];\r\n            }\r\n            /* prepare the row info to determine implied bounds */\r\n            prepare_row_info(len, val, lb, ub, f);\r\n            /* check and relax bounds of the row */\r\n            if (check_row_bounds(f, L, i, U, i))\r\n            {  /* the feasible region is empty */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* if the row became free, drop it */\r\n            if (L[i] == -DBL_MAX && U[i] == +DBL_MAX) continue;\r\n            /* process columns having non-zero coefficients in the row */\r\n            for (k = 1; k <= len; k++){\r\n                var flag, eff;\r\n                var ll = null, uu = null;\r\n                /* take a next column in the row */\r\n                j = ind[k]; col = mip.col[j];\r\n                flag = col.kind != GLP_CV;\r\n                /* check and tighten bounds of the column */\r\n                if (check_col_bounds(f, len, val, L[i], U[i], lb, ub,\r\n                    flag, k, function(a, b){ll = a; uu = b}))\r\n                {  /* the feasible region is empty */\r\n                    ret = 1;\r\n                    return ret;\r\n                }\r\n                /* check if change in the column bounds is efficient */\r\n                eff = check_efficiency(flag, l[j], u[j], ll, uu);\r\n                /* set new actual bounds of the column */\r\n                l[j] = ll; u[j] = uu;\r\n                /* if the change is efficient, add all rows affected by the\r\n                 corresponding column, to the list */\r\n                if (eff > 0)\r\n                {\r\n                    for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    {  var ii = aij.row.i;\r\n                        /* if the row was processed maximal number of times,\r\n                         skip it */\r\n                        if (pass[ii] >= max_pass) continue;\r\n                        /* if the row is free, skip it */\r\n                        if (L[ii] == -DBL_MAX && U[ii] == +DBL_MAX) continue;\r\n                        /* put the row into the list */\r\n                        if (mark[ii] == 0)\r\n                        {  xassert(size <= m);\r\n                            list[++size] = ii; mark[ii] = 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var i, j, nrs, num, ret = 0;\r\n    var L, U, l, u;\r\n    /* the current subproblem must exist */\r\n    xassert(tree.curr != null);\r\n    /* determine original row bounds */\r\n    L = new Float64Array(1+m);\r\n    U = new Float64Array(1+m);\r\n    switch (mip.mip_stat)\r\n    {  case GLP_UNDEF:\r\n        L[0] = -DBL_MAX; U[0] = +DBL_MAX;\r\n        break;\r\n        case GLP_FEAS:\r\n            switch (mip.dir)\r\n            {  case GLP_MIN:\r\n                L[0] = -DBL_MAX; U[0] = mip.mip_obj - mip.c0;\r\n                break;\r\n                case GLP_MAX:\r\n                    L[0] = mip.mip_obj - mip.c0; U[0] = +DBL_MAX;\r\n                    break;\r\n                default:\r\n                    xassert(mip != mip);\r\n            }\r\n            break;\r\n        default:\r\n            xassert(mip != mip);\r\n    }\r\n    for (i = 1; i <= m; i++)\r\n    {  L[i] = glp_get_row_lb(mip, i);\r\n        U[i] = glp_get_row_ub(mip, i);\r\n    }\r\n    /* determine original column bounds */\r\n    l = new Float64Array(1+n);\r\n    u = new Float64Array(1+n);\r\n    for (j = 1; j <= n; j++)\r\n    {  l[j] = glp_get_col_lb(mip, j);\r\n        u[j] = glp_get_col_ub(mip, j);\r\n    }\r\n    /* build the initial list of rows to be analyzed */\r\n    nrs = m + 1;\r\n    num = new Int32Array(1+nrs);\r\n    for (i = 1; i <= nrs; i++) num[i] = i - 1;\r\n    /* perform basic preprocessing */\r\n    if (basic_preprocessing(mip , L, U, l, u, nrs, num, max_pass))\r\n    {  ret = 1;\r\n        return ret;\r\n    }\r\n    /* set new actual (relaxed) row bounds */\r\n    for (i = 1; i <= m; i++)\r\n    {  /* consider only non-active rows to keep dual feasibility */\r\n        if (glp_get_row_stat(mip, i) == GLP_BS)\r\n        {  if (L[i] == -DBL_MAX && U[i] == +DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_FR, 0.0, 0.0);\r\n        else if (U[i] == +DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_LO, L[i], 0.0);\r\n        else if (L[i] == -DBL_MAX)\r\n            glp_set_row_bnds(mip, i, GLP_UP, 0.0, U[i]);\r\n        }\r\n    }\r\n    /* set new actual (tightened) column bounds */\r\n    for (j = 1; j <= n; j++)\r\n    {  var type;\r\n        if (l[j] == -DBL_MAX && u[j] == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (u[j] == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (l[j] == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (l[j] != u[j])\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_col_bnds(mip, j, type, l[j], u[j]);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction ios_driver(T){\r\n    function show_progress(T, bingo){\r\n        var p;\r\n        var temp;\r\n        var best_mip, best_bound, rho, rel_gap;\r\n        /* format the best known integer feasible solution */\r\n        if (T.mip.mip_stat == GLP_FEAS)\r\n            best_mip = String(T.mip.mip_obj);\r\n        else\r\n            best_mip = \"not found yet\";\r\n        /* determine reference number of an active subproblem whose local\r\n         bound is best */\r\n        p = ios_best_node(T);\r\n        /* format the best bound */\r\n        if (p == 0)\r\n            best_bound = \"tree is empty\";\r\n        else\r\n        {  temp = T.slot[p].node.bound;\r\n            if (temp == -DBL_MAX)\r\n                best_bound = \"-inf\";\r\n            else if (temp == +DBL_MAX)\r\n                best_bound = \"+inf\";\r\n            else\r\n                best_bound = temp;\r\n        }\r\n        /* choose the relation sign between global bounds */\r\n        if (T.mip.dir == GLP_MIN)\r\n            rho = \">=\";\r\n        else if (T.mip.dir == GLP_MAX)\r\n            rho = \"<=\";\r\n        else\r\n            xassert(T != T);\r\n        /* format the relative mip gap */\r\n        temp = ios_relative_gap(T);\r\n        if (temp == 0.0)\r\n            rel_gap = \"  0.0%\";\r\n        else if (temp < 0.001)\r\n            rel_gap = \" < 0.1%\";\r\n        else if (temp <= 9.999){\r\n            rel_gap = \"  \" + Number(100.0 * temp).toFixed(1) + \"%\";\r\n        }\r\n        else\r\n            rel_gap = \"\";\r\n        /* display progress of the search */\r\n        xprintf(\"+\" + T.mip.it_cnt + \": \" + (bingo ? \">>>>>\" : \"mip =\") + \" \" + best_mip + \" \" + rho + \" \" + best_bound\r\n            + \" \" + rel_gap + \" (\" + T.a_cnt + \"; \" + (T.t_cnt - T.n_cnt) + \")\");\r\n        T.tm_lag = xtime();\r\n    }\r\n\r\n    function is_branch_hopeful(T, p){\r\n        xassert(1 <= p && p <= T.nslots);\r\n        xassert(T.slot[p].node != null);\r\n        return ios_is_hopeful(T, T.slot[p].node.bound);\r\n    }\r\n\r\n    function check_integrality(T){\r\n        var mip = T.mip;\r\n        var j, type, ii_cnt = 0;\r\n        var lb, ub, x, temp1, temp2, ii_sum = 0.0;\r\n        /* walk through the set of columns (structural variables) */\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            T.non_int[j] = 0;\r\n            /* if the column is not integer, skip it */\r\n            if (col.kind != GLP_IV) continue;\r\n            /* if the column is non-basic, it is integer feasible */\r\n            if (col.stat != GLP_BS) continue;\r\n            /* obtain the type and bounds of the column */\r\n            type = col.type; lb = col.lb; ub = col.ub;\r\n            /* obtain value of the column in optimal basic solution */\r\n            x = col.prim;\r\n            /* if the column's primal value is close to the lower bound,\r\n             the column is integer feasible within given tolerance */\r\n            if (type == GLP_LO || type == GLP_DB || type == GLP_FX)\r\n            {  temp1 = lb - T.parm.tol_int;\r\n                temp2 = lb + T.parm.tol_int;\r\n                if (temp1 <= x && x <= temp2) continue;\r\n                if (x < lb) continue;\r\n            }\r\n            /* if the column's primal value is close to the upper bound,\r\n             the column is integer feasible within given tolerance */\r\n            if (type == GLP_UP || type == GLP_DB || type == GLP_FX)\r\n            {  temp1 = ub - T.parm.tol_int;\r\n                temp2 = ub + T.parm.tol_int;\r\n                if (temp1 <= x && x <= temp2) continue;\r\n                if (x > ub) continue;\r\n            }\r\n            /* if the column's primal value is close to nearest integer,\r\n             the column is integer feasible within given tolerance */\r\n            temp1 = Math.floor(x + 0.5) - T.parm.tol_int;\r\n            temp2 = Math.floor(x + 0.5) + T.parm.tol_int;\r\n            if (temp1 <= x && x <= temp2) continue;\r\n            /* otherwise the column is integer infeasible */\r\n            T.non_int[j] = 1;\r\n            /* increase the number of fractional-valued columns */\r\n            ii_cnt++;\r\n            /* compute the sum of integer infeasibilities */\r\n            temp1 = x - Math.floor(x);\r\n            temp2 = Math.ceil(x) - x;\r\n            xassert(temp1 > 0.0 && temp2 > 0.0);\r\n            ii_sum += (temp1 <= temp2 ? temp1 : temp2);\r\n        }\r\n        /* store ii_cnt and ii_sum to the current problem descriptor */\r\n        xassert(T.curr != null);\r\n        T.curr.ii_cnt = ii_cnt;\r\n        T.curr.ii_sum = ii_sum;\r\n        /* and also display these parameters */\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (ii_cnt == 0)\r\n            xprintf(\"There are no fractional columns\");\r\n        else if (ii_cnt == 1)\r\n            xprintf(\"There is one fractional column, integer infeasibility is \" + ii_sum + \"\");\r\n        else\r\n            xprintf(\"There are \" + ii_cnt + \" fractional columns, integer infeasibility is \" + ii_sum + \"\");\r\n        }\r\n    }\r\n\r\n    function record_solution(T){\r\n        var mip = T.mip;\r\n        var i, j;\r\n        mip.mip_stat = GLP_FEAS;\r\n        mip.mip_obj = mip.obj_val;\r\n        for (i = 1; i <= mip.m; i++)\r\n        {  var row = mip.row[i];\r\n            row.mipx = row.prim;\r\n        }\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            if (col.kind == GLP_CV)\r\n                col.mipx = col.prim;\r\n            else if (col.kind == GLP_IV)\r\n            {  /* value of the integer column must be integral */\r\n                col.mipx = Math.floor(col.prim + 0.5);\r\n            }\r\n            else\r\n                xassert(col != col);\r\n        }\r\n        T.sol_cnt++;\r\n    }\r\n\r\n    function branch_on(T, j, next){\r\n        var mip = T.mip;\r\n        var node;\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var type, dn_type, up_type, dn_bad, up_bad, p, ret, clone = new Array(1+2);\r\n        var lb, ub, beta, new_ub, new_lb, dn_lp = null, up_lp = null, dn_bnd, up_bnd;\r\n        /* determine bounds and value of x[j] in optimal solution to LP\r\n         relaxation of the current subproblem */\r\n        xassert(1 <= j && j <= n);\r\n        type = mip.col[j].type;\r\n        lb = mip.col[j].lb;\r\n        ub = mip.col[j].ub;\r\n        beta = mip.col[j].prim;\r\n        /* determine new bounds of x[j] for down- and up-branches */\r\n        new_ub = Math.floor(beta);\r\n        new_lb = Math.ceil(beta);\r\n        switch (type)\r\n        {  case GLP_FR:\r\n            dn_type = GLP_UP;\r\n            up_type = GLP_LO;\r\n            break;\r\n            case GLP_LO:\r\n                xassert(lb <= new_ub);\r\n                dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\r\n                xassert(lb + 1.0 <= new_lb);\r\n                up_type = GLP_LO;\r\n                break;\r\n            case GLP_UP:\r\n                xassert(new_ub <= ub - 1.0);\r\n                dn_type = GLP_UP;\r\n                xassert(new_lb <= ub);\r\n                up_type = (new_lb == ub ? GLP_FX : GLP_DB);\r\n                break;\r\n            case GLP_DB:\r\n                xassert(lb <= new_ub && new_ub <= ub - 1.0);\r\n                dn_type = (lb == new_ub ? GLP_FX : GLP_DB);\r\n                xassert(lb + 1.0 <= new_lb && new_lb <= ub);\r\n                up_type = (new_lb == ub ? GLP_FX : GLP_DB);\r\n                break;\r\n            default:\r\n                xassert(type != type);\r\n        }\r\n        /* compute local bounds to LP relaxation for both branches */\r\n        ios_eval_degrad(T, j, function(a, b){dn_lp = a; up_lp = b});\r\n        /* and improve them by rounding */\r\n        dn_bnd = ios_round_bound(T, dn_lp);\r\n        up_bnd = ios_round_bound(T, up_lp);\r\n        /* check local bounds for down- and up-branches */\r\n        dn_bad = !ios_is_hopeful(T, dn_bnd);\r\n        up_bad = !ios_is_hopeful(T, up_bnd);\r\n        if (dn_bad && up_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Both down- and up-branches are hopeless\");\r\n            ret = 2;\r\n            return ret;\r\n        }\r\n        else if (up_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Up-branch is hopeless\");\r\n            glp_set_col_bnds(mip, j, dn_type, lb, new_ub);\r\n            T.curr.lp_obj = dn_lp;\r\n            if (mip.dir == GLP_MIN)\r\n            {  if (T.curr.bound < dn_bnd)\r\n                T.curr.bound = dn_bnd;\r\n            }\r\n            else if (mip.dir == GLP_MAX)\r\n            {  if (T.curr.bound > dn_bnd)\r\n                T.curr.bound = dn_bnd;\r\n            }\r\n            else\r\n                xassert(mip != mip);\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        else if (dn_bad)\r\n        {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Down-branch is hopeless\");\r\n            glp_set_col_bnds(mip, j, up_type, new_lb, ub);\r\n            T.curr.lp_obj = up_lp;\r\n            if (mip.dir == GLP_MIN)\r\n            {  if (T.curr.bound < up_bnd)\r\n                T.curr.bound = up_bnd;\r\n            }\r\n            else if (mip.dir == GLP_MAX)\r\n            {  if (T.curr.bound > up_bnd)\r\n                T.curr.bound = up_bnd;\r\n            }\r\n            else\r\n                xassert(mip != mip);\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* both down- and up-branches seem to be hopeful */\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Branching on column \" + j + \", primal value is \" + beta + \"\");\r\n        /* determine the reference number of the current subproblem */\r\n        xassert(T.curr != null);\r\n        p = T.curr.p;\r\n        T.curr.br_var = j;\r\n        T.curr.br_val = beta;\r\n        /* freeze the current subproblem */\r\n        ios_freeze_node(T);\r\n        /* create two clones of the current subproblem; the first clone\r\n         begins the down-branch, the second one begins the up-branch */\r\n        ios_clone_node(T, p, 2, clone);\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n            xprintf(\"Node \" + clone[1] + \" begins down branch, node \" + clone[2] + \" begins up branch \");\r\n        /* set new upper bound of j-th column in the down-branch */\r\n        node = T.slot[clone[1]].node;\r\n        xassert(node != null);\r\n        xassert(node.up != null);\r\n        xassert(node.b_ptr == null);\r\n        node.b_ptr = {};\r\n        node.b_ptr.k = m + j;\r\n        node.b_ptr.type = dn_type;\r\n        node.b_ptr.lb = lb;\r\n        node.b_ptr.ub = new_ub;\r\n        node.b_ptr.next = null;\r\n        node.lp_obj = dn_lp;\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (node.bound < dn_bnd)\r\n            node.bound = dn_bnd;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (node.bound > dn_bnd)\r\n            node.bound = dn_bnd;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* set new lower bound of j-th column in the up-branch */\r\n        node = T.slot[clone[2]].node;\r\n        xassert(node != null);\r\n        xassert(node.up != null);\r\n        xassert(node.b_ptr == null);\r\n        node.b_ptr = {};\r\n        node.b_ptr.k = m + j;\r\n        node.b_ptr.type = up_type;\r\n        node.b_ptr.lb = new_lb;\r\n        node.b_ptr.ub = ub;\r\n        node.b_ptr.next = null;\r\n        node.lp_obj = up_lp;\r\n        if (mip.dir == GLP_MIN)\r\n        {  if (node.bound < up_bnd)\r\n            node.bound = up_bnd;\r\n        }\r\n        else if (mip.dir == GLP_MAX)\r\n        {  if (node.bound > up_bnd)\r\n            node.bound = up_bnd;\r\n        }\r\n        else\r\n            xassert(mip != mip);\r\n        /* suggest the subproblem to be solved next */\r\n        xassert(T.child == 0);\r\n        if (next == GLP_NO_BRNCH)\r\n            T.child = 0;\r\n        else if (next == GLP_DN_BRNCH)\r\n            T.child = clone[1];\r\n        else if (next == GLP_UP_BRNCH)\r\n            T.child = clone[2];\r\n        else\r\n            xassert(next != next);\r\n        ret = 0;\r\n        return ret;\r\n    }\r\n\r\n    function fix_by_red_cost(T){\r\n        var mip = T.mip;\r\n        var j, stat, fixed = 0;\r\n        var obj, lb, ub, dj;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* basic solution of LP relaxation must be optimal */\r\n        xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);\r\n        /* determine the objective function value */\r\n        obj = mip.obj_val;\r\n        /* walk through the column list */\r\n        for (j = 1; j <= mip.n; j++)\r\n        {  var col = mip.col[j];\r\n            /* if the column is not integer, skip it */\r\n            if (col.kind != GLP_IV) continue;\r\n            /* obtain bounds of j-th column */\r\n            lb = col.lb; ub = col.ub;\r\n            /* and determine its status and reduced cost */\r\n            stat = col.stat; dj = col.dual;\r\n            /* analyze the reduced cost */\r\n            switch (mip.dir)\r\n            {  case GLP_MIN:\r\n                /* minimization */\r\n                if (stat == GLP_NL)\r\n                {  /* j-th column is non-basic on its lower bound */\r\n                    if (dj < 0.0) dj = 0.0;\r\n                    if (obj + dj >= mip.mip_obj){\r\n                        glp_set_col_bnds(mip, j, GLP_FX, lb, lb); fixed++;\r\n                    }\r\n                }\r\n                else if (stat == GLP_NU)\r\n                {  /* j-th column is non-basic on its upper bound */\r\n                    if (dj > 0.0) dj = 0.0;\r\n                    if (obj - dj >= mip.mip_obj){\r\n                        glp_set_col_bnds(mip, j, GLP_FX, ub, ub); fixed++;\r\n                    }\r\n                }\r\n                break;\r\n                case GLP_MAX:\r\n                    /* maximization */\r\n                    if (stat == GLP_NL)\r\n                    {  /* j-th column is non-basic on its lower bound */\r\n                        if (dj > 0.0) dj = 0.0;\r\n                        if (obj + dj <= mip.mip_obj){\r\n                            glp_set_col_bnds(mip, j, GLP_FX, lb, lb); fixed++;\r\n                        }\r\n                    }\r\n                    else if (stat == GLP_NU)\r\n                    {  /* j-th column is non-basic on its upper bound */\r\n                        if (dj < 0.0) dj = 0.0;\r\n                        if (obj - dj <= mip.mip_obj){\r\n                            glp_set_col_bnds(mip, j, GLP_FX, ub, ub); fixed++;\r\n                        }\r\n                    }\r\n                    break;\r\n                default:\r\n                    xassert(T != T);\r\n            }\r\n        }\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (fixed == 0)\r\n        {/* nothing to say */}\r\n        else if (fixed == 1)\r\n            xprintf(\"One column has been fixed by reduced cost\");\r\n        else\r\n            xprintf(fixed + \" columns have been fixed by reduced costs\");\r\n        }\r\n        /* fixing non-basic columns on their current bounds does not\r\n         change the basic solution */\r\n        xassert(mip.pbs_stat == GLP_FEAS && mip.dbs_stat == GLP_FEAS);\r\n    }\r\n\r\n\r\n    function remove_cuts(T){\r\n        /* remove inactive cuts (some valueable globally valid cut might\r\n         be saved in the global cut pool) */\r\n        var i, cnt = 0, num = null;\r\n        xassert(T.curr != null);\r\n        for (i = T.orig_m+1; i <= T.mip.m; i++)\r\n        {  if (T.mip.row[i].origin == GLP_RF_CUT &&\r\n            T.mip.row[i].level == T.curr.level &&\r\n            T.mip.row[i].stat == GLP_BS)\r\n        {  if (num == null)\r\n            num = new Int32Array(1+T.mip.m);\r\n            num[++cnt] = i;\r\n        }\r\n        }\r\n        if (cnt > 0)\r\n        {  glp_del_rows(T.mip, cnt, num);\r\n            xassert(glp_factorize(T.mip) == 0);\r\n        }\r\n    }\r\n\r\n    function display_cut_info(T){\r\n        var mip = T.mip;\r\n        var i, gmi = 0, mir = 0, cov = 0, clq = 0, app = 0;\r\n        for (i = mip.m; i > 0; i--)\r\n        {\r\n            var row = mip.row[i];\r\n            /* if (row.level < T.curr.level) break; */\r\n            if (row.origin == GLP_RF_CUT)\r\n            {  if (row.klass == GLP_RF_GMI)\r\n                gmi++;\r\n            else if (row.klass == GLP_RF_MIR)\r\n                mir++;\r\n            else if (row.klass == GLP_RF_COV)\r\n                cov++;\r\n            else if (row.klass == GLP_RF_CLQ)\r\n                clq++;\r\n            else\r\n                app++;\r\n            }\r\n        }\r\n        xassert(T.curr != null);\r\n        if (gmi + mir + cov + clq + app > 0)\r\n        {  xprintf(\"Cuts on level \" + T.curr.level + \":\");\r\n            if (gmi > 0) xprintf(\" gmi = \" + gmi + \";\");\r\n            if (mir > 0) xprintf(\" mir = \" + mir + \";\");\r\n            if (cov > 0) xprintf(\" cov = \" + cov + \";\");\r\n            if (clq > 0) xprintf(\" clq = \" + clq + \";\");\r\n            if (app > 0) xprintf(\" app = \" + app + \";\");\r\n            xprintf(\"\");\r\n        }\r\n    }\r\n\r\n    function generate_cuts(T){\r\n        /* generate generic cuts with built-in generators */\r\n        if (!(T.parm.mir_cuts == GLP_ON ||\r\n            T.parm.gmi_cuts == GLP_ON ||\r\n            T.parm.cov_cuts == GLP_ON ||\r\n            T.parm.clq_cuts == GLP_ON)) return;\r\n        {   var i, max_cuts, added_cuts;\r\n            max_cuts = T.n;\r\n            if (max_cuts < 1000) max_cuts = 1000;\r\n            added_cuts = 0;\r\n            for (i = T.orig_m+1; i <= T.mip.m; i++)\r\n            {  if (T.mip.row[i].origin == GLP_RF_CUT)\r\n                added_cuts++;\r\n            }\r\n            /* xprintf(\"added_cuts = %d\", added_cuts); */\r\n            if (added_cuts >= max_cuts) return;\r\n        }\r\n        /* generate and add to POOL all cuts violated by x* */\r\n        if (T.parm.gmi_cuts == GLP_ON)\r\n        {  if (T.curr.changed < 5)\r\n            ios_gmi_gen(T);\r\n        }\r\n        if (T.parm.mir_cuts == GLP_ON)\r\n        {  xassert(T.mir_gen != null);\r\n            ios_mir_gen(T, T.mir_gen);\r\n        }\r\n        if (T.parm.cov_cuts == GLP_ON)\r\n        {  /* cover cuts works well along with mir cuts */\r\n            /*if (T.round <= 5)*/\r\n            ios_cov_gen(T);\r\n        }\r\n        if (T.parm.clq_cuts == GLP_ON)\r\n        {  if (T.clq_gen != null)\r\n        {  if (T.curr.level == 0 && T.curr.changed < 50 ||\r\n            T.curr.level >  0 && T.curr.changed < 5)\r\n            ios_clq_gen(T, T.clq_gen);\r\n        }\r\n        }\r\n    }\r\n\r\n    function cleanup_the_tree(T){\r\n        var node, next_node;\r\n        var count = 0;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* walk through the list of active subproblems */\r\n        for (node = T.head; node != null; node = next_node)\r\n        {  /* deleting some active problem node may involve deleting its\r\n         parents recursively; however, all its parents being created\r\n         *before* it are always *precede* it in the node list, so\r\n         the next problem node is never affected by such deletion */\r\n            next_node = node.next;\r\n            /* if the branch is hopeless, prune it */\r\n            if (!is_branch_hopeful(T, node.p)){\r\n                ios_delete_node(T, node.p); count++;\r\n            }\r\n        }\r\n        if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n        {  if (count == 1)\r\n            xprintf(\"One hopeless branch has been pruned\");\r\n        else if (count > 1)\r\n            xprintf(count + \" hopeless branches have been pruned\");\r\n        }\r\n    }\r\n\r\n    var p, curr_p, p_stat, d_stat, ret;\r\n    var pred_p = 0;\r\n    /* if the current subproblem has been just created due to\r\n     branching, pred_p is the reference number of its parent\r\n     subproblem, otherwise pred_p is zero */\r\n    var ttt = T.tm_beg;\r\n    /* on entry to the B&B driver it is assumed that the active list\r\n     contains the only active (i.e. root) subproblem, which is the\r\n     original MIP problem to be solved */\r\n\r\n    var\r\n        loop = 0,\r\n        more = 1,\r\n        fath = 2,\r\n        done = 3;\r\n\r\n    var label = loop;\r\n\r\n    while (true){\r\n        var go_to = null;\r\n        switch (label){\r\n            case loop:\r\n                /* main loop starts here */\r\n                /* at this point the current subproblem does not exist */\r\n                xassert(T.curr == null);\r\n                /* if the active list is empty, the search is finished */\r\n                if (T.head == null)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Active list is empty!\");\r\n                    //xassert(Object.keys(T.pool).length == 0);\r\n                    ret = 0;\r\n                    go_to = done; break;\r\n                }\r\n                /* select some active subproblem to continue the search */\r\n                xassert(T.next_p == 0);\r\n                /* let the application program select subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ISELECT;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                if (T.next_p != 0)\r\n                {  /* the application program has selected something */\r\n\r\n                }\r\n                else if (T.a_cnt == 1)\r\n                {  /* the only active subproblem exists, so select it */\r\n                    xassert(T.head.next == null);\r\n                    T.next_p = T.head.p;\r\n                }\r\n                else if (T.child != 0)\r\n                {  /* select one of branching childs suggested by the branching\r\n                 heuristic */\r\n                    T.next_p = T.child;\r\n                }\r\n                else\r\n                {  /* select active subproblem as specified by the backtracking\r\n                 technique option */\r\n                    T.next_p = ios_choose_node(T);\r\n                }\r\n                /* the active subproblem just selected becomes current */\r\n                ios_revive_node(T, T.next_p);\r\n                T.next_p = T.child = 0;\r\n                /* invalidate pred_p, if it is not the reference number of the\r\n                 parent of the current subproblem */\r\n                if (T.curr.up != null && T.curr.up.p != pred_p) pred_p = 0;\r\n                /* determine the reference number of the current subproblem */\r\n                p = T.curr.p;\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                {  xprintf(\"-----------------------------------------------------\" +\r\n                    \"-------------------\");\r\n                    xprintf(\"Processing node \" + p + \" at level \" + T.curr.level + \"\");\r\n                }\r\n                /* if it is the root subproblem, initialize cut generators */\r\n                if (p == 1)\r\n                {  if (T.parm.gmi_cuts == GLP_ON)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Gomory's cuts enabled\");\r\n                }\r\n                    if (T.parm.mir_cuts == GLP_ON)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"MIR cuts enabled\");\r\n                        xassert(T.mir_gen == null);\r\n                        T.mir_gen = ios_mir_init(T);\r\n                    }\r\n                    if (T.parm.cov_cuts == GLP_ON)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"Cover cuts enabled\");\r\n                    }\r\n                    if (T.parm.clq_cuts == GLP_ON)\r\n                    {  xassert(T.clq_gen == null);\r\n                        if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                            xprintf(\"Clique cuts enabled\");\r\n                        T.clq_gen = ios_clq_init(T);\r\n                    }\r\n                }\r\n            case more:\r\n                /* minor loop starts here */\r\n                /* at this point the current subproblem needs either to be solved\r\n                 for the first time or re-optimized due to reformulation */\r\n                /* display current progress of the search */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG ||\r\n                    T.parm.msg_lev >= GLP_MSG_ON &&\r\n                        (T.parm.out_frq - 1) <=\r\n                            1000.0 * xdifftime(xtime(), T.tm_lag))\r\n                    show_progress(T, 0);\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL &&\r\n                    xdifftime(xtime(), ttt) >= 60.0)\r\n                {\r\n                    xprintf(\"Time used: \" + xdifftime(xtime(), T.tm_beg) + \" secs\");\r\n                    ttt = xtime();\r\n                }\r\n                /* check the mip gap */\r\n                if (T.parm.mip_gap > 0.0 &&\r\n                    ios_relative_gap(T) <= T.parm.mip_gap)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Relative gap tolerance reached; search terminated \");\r\n                    ret = GLP_EMIPGAP;\r\n                    go_to = done; break;\r\n                }\r\n                /* check if the time limit has been exhausted */\r\n                if (T.parm.tm_lim < INT_MAX &&\r\n                    (T.parm.tm_lim - 1) <=\r\n                        1000.0 * xdifftime(xtime(), T.tm_beg))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Time limit exhausted; search terminated\");\r\n                    ret = GLP_ETMLIM;\r\n                    go_to = done; break;\r\n                }\r\n                /* let the application program preprocess the subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IPREPRO;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* perform basic preprocessing */\r\n                if (T.parm.pp_tech == GLP_PP_NONE){\r\n\r\n                }\r\n                else if (T.parm.pp_tech == GLP_PP_ROOT)\r\n                {  if (T.curr.level == 0)\r\n                {  if (ios_preprocess_node(T, 100)){\r\n                    go_to  = fath; break;\r\n                }\r\n                }\r\n                }\r\n                else if (T.parm.pp_tech == GLP_PP_ALL)\r\n                {  if (ios_preprocess_node(T, T.curr.level == 0 ? 100 : 10)){\r\n                    go_to = fath; break;\r\n                }\r\n                }\r\n                else\r\n                    xassert(T != T);\r\n                /* preprocessing may improve the global bound */\r\n                if (!is_branch_hopeful(T, p))\r\n                {  xprintf(\"*** not tested yet ***\");\r\n                    go_to = fath; break;\r\n                }\r\n                /* solve LP relaxation of the current subproblem */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Solving LP relaxation...\");\r\n                ret = ios_solve_node(T);\r\n                if (!(ret == 0 || ret == GLP_EOBJLL || ret == GLP_EOBJUL))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"ios_driver: unable to solve current LP relaxation; glp_simplex returned \" + ret + \"\");\r\n                    ret = GLP_EFAIL;\r\n                    go_to = done; break;\r\n                }\r\n                /* analyze status of the basic solution to LP relaxation found */\r\n                p_stat = T.mip.pbs_stat;\r\n                d_stat = T.mip.dbs_stat;\r\n                if (p_stat == GLP_FEAS && d_stat == GLP_FEAS)\r\n                {  /* LP relaxation has optimal solution */\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Found optimal solution to LP relaxation\");\r\n                }\r\n                else if (d_stat == GLP_NOFEAS)\r\n                {  /* LP relaxation has no dual feasible solution */\r\n                    /* since the current subproblem cannot have a larger feasible\r\n                     region than its parent, there is something wrong */\r\n                    if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"ios_driver: current LP relaxation has no dual feasible solution\");\r\n                    ret = GLP_EFAIL;\r\n                    go_to = done; break;\r\n                }\r\n                else if (p_stat == GLP_INFEAS && d_stat == GLP_FEAS)\r\n                {  /* LP relaxation has no primal solution which is better than\r\n                 the incumbent objective value */\r\n                    xassert(T.mip.mip_stat == GLP_FEAS);\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"LP relaxation has no solution better than incumbent objective value\");\r\n                    /* prune the branch */\r\n                    go_to = fath; break;\r\n                }\r\n                else if (p_stat == GLP_NOFEAS)\r\n                {  /* LP relaxation has no primal feasible solution */\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"LP relaxation has no feasible solution\");\r\n                    /* prune the branch */\r\n                    go_to = fath; break;\r\n                }\r\n                else\r\n                {  /* other cases cannot appear */\r\n                    xassert(T.mip != T.mip);\r\n                }\r\n                /* at this point basic solution to LP relaxation of the current\r\n                 subproblem is optimal */\r\n                xassert(p_stat == GLP_FEAS && d_stat == GLP_FEAS);\r\n                xassert(T.curr != null);\r\n                T.curr.lp_obj = T.mip.obj_val;\r\n                /* thus, it defines a local bound to integer optimal solution of\r\n                 the current subproblem */\r\n                {  var bound = T.mip.obj_val;\r\n                    /* some local bound to the current subproblem could be already\r\n                    set before, so we should only improve it */\r\n                    bound = ios_round_bound(T, bound);\r\n                    if (T.mip.dir == GLP_MIN)\r\n                    {  if (T.curr.bound < bound)\r\n                        T.curr.bound = bound;\r\n                    }\r\n                    else if (T.mip.dir == GLP_MAX)\r\n                    {  if (T.curr.bound > bound)\r\n                        T.curr.bound = bound;\r\n                    }\r\n                    else\r\n                        xassert(T.mip != T.mip);\r\n                    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Local bound is \" + bound + \"\");\r\n                }\r\n                /* if the local bound indicates that integer optimal solution of\r\n                 the current subproblem cannot be better than the global bound,\r\n                 prune the branch */\r\n                if (!is_branch_hopeful(T, p))\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Current branch is hopeless and can be pruned\");\r\n                    go_to = fath; break;\r\n                }\r\n                /* let the application program generate additional rows (\"lazy\"\r\n                 constraints) */\r\n                xassert(T.reopt == 0);\r\n                xassert(T.reinv == 0);\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IROWGEN;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                    if (T.reopt)\r\n                    {  /* some rows were added; re-optimization is needed */\r\n                        T.reopt = T.reinv = 0;\r\n                        go_to = more; break;\r\n                    }\r\n                    if (T.reinv)\r\n                    {  /* no rows were added, however, some inactive rows were\r\n                     removed */\r\n                        T.reinv = 0;\r\n                        xassert(glp_factorize(T.mip) == 0);\r\n                    }\r\n                }\r\n                /* check if the basic solution is integer feasible */\r\n                check_integrality(T);\r\n                /* if the basic solution satisfies to all integrality conditions,\r\n                 it is a new, better integer feasible solution */\r\n                if (T.curr.ii_cnt == 0)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"New integer feasible solution found\");\r\n                    if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                        display_cut_info(T);\r\n                    record_solution(T);\r\n                    if (T.parm.msg_lev >= GLP_MSG_ON)\r\n                        show_progress(T, 1);\r\n                    /* make the application program happy */\r\n                    if (T.parm.cb_func != null)\r\n                    {  xassert(T.reason == 0);\r\n                        T.reason = GLP_IBINGO;\r\n                        T.parm.cb_func(T, T.parm.cb_info);\r\n                        T.reason = 0;\r\n                        if (T.stop)\r\n                        {  ret = GLP_ESTOP;\r\n                            go_to = done; break;\r\n                        }\r\n                    }\r\n                    /* since the current subproblem has been fathomed, prune its\r\n                     branch */\r\n                    go_to = fath; break;\r\n                }\r\n                /* at this point basic solution to LP relaxation of the current\r\n                 subproblem is optimal, but integer infeasible */\r\n                /* try to fix some non-basic structural variables of integer kind\r\n                 on their current bounds due to reduced costs */\r\n                if (T.mip.mip_stat == GLP_FEAS)\r\n                    fix_by_red_cost(T);\r\n                /* let the application program try to find some solution to the\r\n                 original MIP with a primal heuristic */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IHEUR;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                    /* check if the current branch became hopeless */\r\n                    if (!is_branch_hopeful(T, p))\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Current branch became hopeless and can be pruned\");\r\n                        go_to = fath; break;\r\n                    }\r\n                }\r\n                /* try to find solution with the feasibility pump heuristic */\r\n                if (T.parm.fp_heur)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_IHEUR;\r\n                    ios_feas_pump(T);\r\n                    T.reason = 0;\r\n                    /* check if the current branch became hopeless */\r\n                    if (!is_branch_hopeful(T, p))\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                        xprintf(\"Current branch became hopeless and can be pruned\");\r\n                        go_to = fath; break;\r\n                    }\r\n                }\r\n                /* it's time to generate cutting planes */\r\n                xassert(T.local != null);\r\n                xassert(T.local.size == 0);\r\n                /* let the application program generate some cuts; note that it\r\n                 can add cuts either to the local cut pool or directly to the\r\n                 current subproblem */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* try to generate generic cuts with built-in generators\r\n                 (as suggested by Matteo Fischetti et al. the built-in cuts\r\n                 are not generated at each branching node; an intense attempt\r\n                 of generating new cuts is only made at the root node, and then\r\n                 a moderate effort is spent after each backtracking step) */\r\n                if (T.curr.level == 0 || pred_p == 0)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    generate_cuts(T);\r\n                    T.reason = 0;\r\n                }\r\n                /* if the local cut pool is not empty, select useful cuts and add\r\n                 them to the current subproblem */\r\n                if (T.local.size > 0)\r\n                {  xassert(T.reason == 0);\r\n                    T.reason = GLP_ICUTGEN;\r\n                    ios_process_cuts(T);\r\n                    T.reason = 0;\r\n                }\r\n                /* clear the local cut pool */\r\n                ios_clear_pool(T.local);\r\n                /* perform re-optimization, if necessary */\r\n                if (T.reopt)\r\n                {  T.reopt = 0;\r\n                    T.curr.changed++;\r\n                    go_to = more; break;\r\n                }\r\n                /* no cuts were generated; remove inactive cuts */\r\n                remove_cuts(T);\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL && T.curr.level == 0)\r\n                    display_cut_info(T);\r\n                /* update history information used on pseudocost branching */\r\n                if (T.pcost != null) ios_pcost_update(T);\r\n                /* it's time to perform branching */\r\n                xassert(T.br_var == 0);\r\n                xassert(T.br_sel == 0);\r\n                /* let the application program choose variable to branch on */\r\n                if (T.parm.cb_func != null)\r\n                {  xassert(T.reason == 0);\r\n                    xassert(T.br_var == 0);\r\n                    xassert(T.br_sel == 0);\r\n                    T.reason = GLP_IBRANCH;\r\n                    T.parm.cb_func(T, T.parm.cb_info);\r\n                    T.reason = 0;\r\n                    if (T.stop)\r\n                    {  ret = GLP_ESTOP;\r\n                        go_to = done; break;\r\n                    }\r\n                }\r\n                /* if nothing has been chosen, choose some variable as specified\r\n                 by the branching technique option */\r\n                if (T.br_var == 0)\r\n                    T.br_var = ios_choose_var(T, function(next){T.br_sel = next});\r\n                /* perform actual branching */\r\n                curr_p = T.curr.p;\r\n                ret = branch_on(T, T.br_var, T.br_sel);\r\n                T.br_var = T.br_sel = 0;\r\n                if (ret == 0)\r\n                {  /* both branches have been created */\r\n                    pred_p = curr_p;\r\n                    go_to = loop; break;\r\n                }\r\n                else if (ret == 1)\r\n                {  /* one branch is hopeless and has been pruned, so now the\r\n                 current subproblem is other branch */\r\n                    /* the current subproblem should be considered as a new one,\r\n                     since one bound of the branching variable was changed */\r\n                    T.curr.solved = T.curr.changed = 0;\r\n                    go_to = more; break;\r\n                }\r\n                else if (ret == 2)\r\n                {  /* both branches are hopeless and have been pruned; new\r\n                 subproblem selection is needed to continue the search */\r\n                    go_to = fath; break;\r\n                }\r\n                else\r\n                    xassert(ret != ret);\r\n            case fath:\r\n                /* the current subproblem has been fathomed */\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"Node \" + p + \" fathomed\");\r\n                /* freeze the current subproblem */\r\n                ios_freeze_node(T);\r\n                /* and prune the corresponding branch of the tree */\r\n                ios_delete_node(T, p);\r\n                /* if a new integer feasible solution has just been found, other\r\n                 branches may become hopeless and therefore must be pruned */\r\n                if (T.mip.mip_stat == GLP_FEAS) cleanup_the_tree(T);\r\n                /* new subproblem selection is needed due to backtracking */\r\n                pred_p = 0;\r\n                go_to = loop; break;\r\n            case done:\r\n                /* display progress of the search on exit from the solver */\r\n                if (T.parm.msg_lev >= GLP_MSG_ON)\r\n                    show_progress(T, 0);\r\n                T.mir_gen = null;\r\n                T.clq_gen = null;\r\n                /* return to the calling program */\r\n                return ret;\r\n        }\r\n        if (go_to == null) break;\r\n        label = go_to;\r\n    }\r\n}\r\n\r\nfunction ios_create_vec(n){\r\n    var v;\r\n    xassert(n >= 0);\r\n    v = {};\r\n    v.n = n;\r\n    v.nnz = 0;\r\n    v.pos = new Int32Array(1+n);\r\n    v.ind = new Int32Array(1+n);\r\n    v.val = new Float64Array(1+n);\r\n    return v;\r\n}\r\n\r\nfunction ios_check_vec(v){\r\n    var j, k, nnz;\r\n    xassert(v.n >= 0);\r\n    nnz = 0;\r\n    for (j = v.n; j >= 1; j--)\r\n    {  k = v.pos[j];\r\n        xassert(0 <= k && k <= v.nnz);\r\n        if (k != 0)\r\n        {  xassert(v.ind[k] == j);\r\n            nnz++;\r\n        }\r\n    }\r\n    xassert(v.nnz == nnz);\r\n}\r\n\r\nfunction ios_get_vj(v, j){\r\n    var k;\r\n    xassert(1 <= j && j <= v.n);\r\n    k = v.pos[j];\r\n    xassert(0 <= k && k <= v.nnz);\r\n    return (k == 0 ? 0.0 : v.val[k]);\r\n}\r\n\r\nfunction ios_set_vj(v, j, val){\r\n    xassert(1 <= j && j <= v.n);\r\n    var k = v.pos[j];\r\n    if (val == 0.0)\r\n    {  if (k != 0)\r\n    {  /* remove j-th component */\r\n        v.pos[j] = 0;\r\n        if (k < v.nnz)\r\n        {  v.pos[v.ind[v.nnz]] = k;\r\n            v.ind[k] = v.ind[v.nnz];\r\n            v.val[k] = v.val[v.nnz];\r\n        }\r\n        v.nnz--;\r\n    }\r\n    }\r\n    else\r\n    {  if (k == 0)\r\n    {  /* create j-th component */\r\n        k = ++(v.nnz);\r\n        v.pos[j] = k;\r\n        v.ind[k] = j;\r\n    }\r\n        v.val[k] = val;\r\n    }\r\n}\r\n\r\nfunction ios_clear_vec(v){\r\n    for (var k = 1; k <= v.nnz; k++)\r\n        v.pos[v.ind[k]] = 0;\r\n    v.nnz = 0;\r\n}\r\n\r\nfunction ios_clean_vec(v, eps){\r\n    var nnz = 0;\r\n    for (var k = 1; k <= v.nnz; k++)\r\n    {  if (Math.abs(v.val[k]) == 0.0 || Math.abs(v.val[k]) < eps)\r\n    {  /* remove component */\r\n        v.pos[v.ind[k]] = 0;\r\n    }\r\n    else\r\n    {  /* keep component */\r\n        nnz++;\r\n        v.pos[v.ind[k]] = nnz;\r\n        v.ind[nnz] = v.ind[k];\r\n        v.val[nnz] = v.val[k];\r\n    }\r\n    }\r\n    v.nnz = nnz;\r\n}\r\n\r\nfunction ios_copy_vec(x, y){\r\n    xassert(x != y);\r\n    xassert(x.n == y.n);\r\n    ios_clear_vec(x);\r\n    x.nnz = y.nnz;\r\n    xcopyArr(x.ind, 1, y.ind, 1, x.nnz);\r\n    xcopyArr(x.val, 1, y.val, 1, x.nnz);\r\n    for (var j = 1; j <= x.nnz; j++)\r\n        x.pos[x.ind[j]] = j;\r\n}\r\n\r\nfunction ios_linear_comb(x, a, y){\r\n    var j, xj, yj;\r\n    xassert(x != y);\r\n    xassert(x.n == y.n);\r\n    for (var k = 1; k <= y.nnz; k++)\r\n    {   j = y.ind[k];\r\n        xj = ios_get_vj(x, j);\r\n        yj = y.val[k];\r\n        ios_set_vj(x, j, xj + a * yj);\r\n    }\r\n}\r\n\r\nfunction ios_gmi_gen(tree){\r\n\r\n    var MAXCUTS = 50;\r\n    /* maximal number of cuts to be generated for one round */\r\n\r\n    function f(x) {return x - Math.floor(x)}\r\n    /* compute fractional part of x */\r\n\r\n    function gen_cut(tree, worka, j){\r\n        /* this routine tries to generate Gomory's mixed integer cut for\r\n         specified structural variable x[m+j] of integer kind, which is\r\n         basic and has fractional value in optimal solution to current\r\n         LP relaxation */\r\n        var mip = tree.mip;\r\n        var m = mip.m;\r\n        var n = mip.n;\r\n        var ind = worka.ind;\r\n        var val = worka.val;\r\n        var phi = worka.phi;\r\n        var i, k, len, kind, stat;\r\n        var lb, ub, alfa, beta, ksi, phi1, rhs;\r\n        var row, col;\r\n        /* compute row of the simplex tableau, which (row) corresponds\r\n         to specified basic variable xB[i] = x[m+j]; see (23) */\r\n        len = glp_eval_tab_row(mip, m+j, ind, val);\r\n        /* determine beta[i], which a value of xB[i] in optimal solution\r\n         to current LP relaxation; note that this value is the same as\r\n         if it would be computed with formula (27); it is assumed that\r\n         beta[i] is fractional enough */\r\n        beta = mip.col[j].prim;\r\n        /* compute cut coefficients phi and right-hand side rho, which\r\n         correspond to formula (30); dense format is used, because rows\r\n         of the simplex tableau is usually dense */\r\n        for (k = 1; k <= m+n; k++) phi[k] = 0.0;\r\n        rhs = f(beta); /* initial value of rho; see (28), (32) */\r\n        for (j = 1; j <= len; j++)\r\n        {  /* determine original number of non-basic variable xN[j] */\r\n            k = ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            /* determine the kind, bounds and current status of xN[j] in\r\n             optimal solution to LP relaxation */\r\n            if (k <= m)\r\n            {  /* auxiliary variable */\r\n                row = mip.row[k];\r\n                kind = GLP_CV;\r\n                lb = row.lb;\r\n                ub = row.ub;\r\n                stat = row.stat;\r\n            }\r\n            else\r\n            {  /* structural variable */\r\n                col = mip.col[k-m];\r\n                kind = col.kind;\r\n                lb = col.lb;\r\n                ub = col.ub;\r\n                stat = col.stat;\r\n            }\r\n            /* xN[j] cannot be basic */\r\n            xassert(stat != GLP_BS);\r\n            /* determine row coefficient ksi[i,j] at xN[j]; see (23) */\r\n            ksi = val[j];\r\n            /* if ksi[i,j] is too large in the magnitude, do not generate\r\n             the cut */\r\n            if (Math.abs(ksi) > 1e+05) return;\r\n            /* if ksi[i,j] is too small in the magnitude, skip it */\r\n            if (Math.abs(ksi) < 1e-10) continue;\r\n            /* compute row coefficient alfa[i,j] at y[j]; see (26) */\r\n            switch (stat)\r\n            {  case GLP_NF:\r\n                /* xN[j] is free (unbounded) having non-zero ksi[i,j];\r\n                 do not generate the cut */\r\n                return;\r\n                case GLP_NL:\r\n                    /* xN[j] has active lower bound */\r\n                    alfa = - ksi;\r\n                    break;\r\n                case GLP_NU:\r\n                    /* xN[j] has active upper bound */\r\n                    alfa = + ksi;\r\n                    break;\r\n                case GLP_NS:\r\n                    /* xN[j] is fixed; skip it */\r\n                    continue;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n            /* compute cut coefficient phi'[j] at y[j]; see (21), (28) */\r\n            switch (kind)\r\n            {  case GLP_IV:\r\n                /* y[j] is integer */\r\n                if (Math.abs(alfa - Math.floor(alfa + 0.5)) < 1e-10)\r\n                {  /* alfa[i,j] is close to nearest integer; skip it */\r\n                    continue;\r\n                }\r\n                else if (f(alfa) <= f(beta))\r\n                    phi1 = f(alfa);\r\n                else\r\n                    phi1 = (f(beta) / (1.0 - f(beta))) * (1.0 - f(alfa));\r\n                break;\r\n                case GLP_CV:\r\n                    /* y[j] is continuous */\r\n                    if (alfa >= 0.0)\r\n                        phi1 = + alfa;\r\n                    else\r\n                        phi1 = (f(beta) / (1.0 - f(beta))) * (- alfa);\r\n                    break;\r\n                default:\r\n                    xassert(kind != kind);\r\n            }\r\n            /* compute cut coefficient phi[j] at xN[j] and update right-\r\n             hand side rho; see (31), (32) */\r\n            switch (stat)\r\n            {  case GLP_NL:\r\n                /* xN[j] has active lower bound */\r\n                phi[k] = + phi1;\r\n                rhs += phi1 * lb;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[j] has active upper bound */\r\n                    phi[k] = - phi1;\r\n                    rhs -= phi1 * ub;\r\n                    break;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n        }\r\n        /* now the cut has the form sum_k phi[k] * x[k] >= rho, where cut\r\n         coefficients are stored in the array phi in dense format;\r\n         x[1,...,m] are auxiliary variables, x[m+1,...,m+n] are struc-\r\n         tural variables; see (30) */\r\n        /* eliminate auxiliary variables in order to express the cut only\r\n         through structural variables; see (33) */\r\n        for (i = 1; i <= m; i++)\r\n        {\r\n            var aij;\r\n            if (Math.abs(phi[i]) < 1e-10) continue;\r\n            /* auxiliary variable x[i] has non-zero cut coefficient */\r\n            row = mip.row[i];\r\n            /* x[i] cannot be fixed */\r\n            xassert(row.type != GLP_FX);\r\n            /* substitute x[i] = sum_j a[i,j] * x[m+j] */\r\n            for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                phi[m+aij.col.j] += phi[i] * aij.val;\r\n        }\r\n        /* convert the final cut to sparse format and substitute fixed\r\n         (structural) variables */\r\n        len = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (Math.abs(phi[m+j]) < 1e-10) continue;\r\n            /* structural variable x[m+j] has non-zero cut coefficient */\r\n            col = mip.col[j];\r\n            if (col.type == GLP_FX)\r\n            {  /* eliminate x[m+j] */\r\n                rhs -= phi[m+j] * col.lb;\r\n            }\r\n            else\r\n            {  len++;\r\n                ind[len] = j;\r\n                val[len] = phi[m+j];\r\n            }\r\n        }\r\n        if (Math.abs(rhs) < 1e-12) rhs = 0.0;\r\n        /* if the cut inequality seems to be badly scaled, reject it to\r\n         avoid numeric difficulties */\r\n        for (k = 1; k <= len; k++)\r\n        {  if (Math.abs(val[k]) < 1e-03) return;\r\n            if (Math.abs(val[k]) > 1e+03) return;\r\n        }\r\n        /* add the cut to the cut pool for further consideration */\r\n        glp_ios_add_row(tree, null, GLP_RF_GMI, 0, len, ind, val, GLP_LO, rhs);\r\n    }\r\n\r\n    /* main routine to generate Gomory's cuts */\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var var_;\r\n    var k, nv, j, size;\r\n    var worka = {};\r\n    /* allocate working arrays */\r\n    var_ = new Array(1+n);\r\n    worka.ind = new Int32Array(1+n);\r\n    worka.val = new Float64Array(1+n);\r\n    worka.phi = new Float64Array(1+m+n);\r\n    /* build the list of integer structural variables, which are\r\n     basic and have fractional value in optimal solution to current\r\n     LP relaxation */\r\n    nv = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var col = mip.col[j];\r\n        var frac;\r\n        if (col.kind != GLP_IV) continue;\r\n        if (col.type == GLP_FX) continue;\r\n        if (col.stat != GLP_BS) continue;\r\n        frac = f(col.prim);\r\n        if (!(0.05 <= frac && frac <= 0.95)) continue;\r\n        /* add variable to the list */\r\n        nv++; var_[nv].j = j; var_[nv].f = frac;\r\n    }\r\n    /* order the list by descending fractionality */\r\n    xqsort(var_, 1, nv,\r\n        function(v1, v2){\r\n            if (v1.f > v2.f) return -1;\r\n            if (v1.f < v2.f) return +1;\r\n            return 0;\r\n        }\r\n    );\r\n    /* try to generate cuts by one for each variable in the list, but\r\n     not more than MAXCUTS cuts */\r\n    size = glp_ios_pool_size(tree);\r\n    for (k = 1; k <= nv; k++)\r\n    {  if (glp_ios_pool_size(tree) - size >= MAXCUTS) break;\r\n        gen_cut(tree, worka, var_[k].j);\r\n    }\r\n}\r\n\r\n\r\nvar _MIR_DEBUG = 0;\r\n\r\nvar MAXAGGR = 5;\r\n/* maximal number of rows which can be aggregated */\r\n\r\nvar\r\n    MIR_N = 0,\r\n    MIR_L = 1,\r\n    MIR_U = 2;\r\n\r\nfunction ios_mir_init(tree){\r\n    function set_row_attrib(tree, mir){\r\n        /* set global row attributes */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var k;\r\n        for (k = 1; k <= m; k++)\r\n        {  var row = mip.row[k];\r\n            mir.skip[k] = 0;\r\n            mir.isint[k] = 0;\r\n            switch (row.type)\r\n            {  case GLP_FR:\r\n                mir.lb[k] = -DBL_MAX; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_LO:\r\n                    mir.lb[k] = row.lb; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_UP:\r\n                    mir.lb[k] = -DBL_MAX; mir.ub[k] = row.ub; break;\r\n                case GLP_DB:\r\n                    mir.lb[k] = row.lb; mir.ub[k] = row.ub; break;\r\n                case GLP_FX:\r\n                    mir.lb[k] = mir.ub[k] = row.lb; break;\r\n                default:\r\n                    xassert(row != row);\r\n            }\r\n            mir.vlb[k] = mir.vub[k] = 0;\r\n        }\r\n    }\r\n\r\n    function set_col_attrib(tree, mir){\r\n        /* set global column attributes */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var k;\r\n        for (k = m+1; k <= m+n; k++)\r\n        {  var col = mip.col[k-m];\r\n            switch (col.kind)\r\n            {  case GLP_CV:\r\n                mir.isint[k] = 0; break;\r\n                case GLP_IV:\r\n                    mir.isint[k] = 1; break;\r\n                default:\r\n                    xassert(col != col);\r\n            }\r\n            switch (col.type)\r\n            {  case GLP_FR:\r\n                mir.lb[k] = -DBL_MAX; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_LO:\r\n                    mir.lb[k] = col.lb; mir.ub[k] = +DBL_MAX; break;\r\n                case GLP_UP:\r\n                    mir.lb[k] = -DBL_MAX; mir.ub[k] = col.ub; break;\r\n                case GLP_DB:\r\n                    mir.lb[k] = col.lb; mir.ub[k] = col.ub; break;\r\n                case GLP_FX:\r\n                    mir.lb[k] = mir.ub[k] = col.lb; break;\r\n                default:\r\n                    xassert(col != col);\r\n            }\r\n            mir.vlb[k] = mir.vub[k] = 0;\r\n        }\r\n    }\r\n\r\n    function set_var_bounds(tree, mir){\r\n        /* set variable bounds */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        var i, k1, k2;\r\n        var a1, a2;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* we need the row to be '>= 0' or '<= 0' */\r\n            if (!(mir.lb[i] == 0.0 && mir.ub[i] == +DBL_MAX ||\r\n                mir.lb[i] == -DBL_MAX && mir.ub[i] == 0.0)) continue;\r\n            /* take first term */\r\n            aij = mip.row[i].ptr;\r\n            if (aij == null) continue;\r\n            k1 = m + aij.col.j; a1 = aij.val;\r\n            /* take second term */\r\n            aij = aij.r_next;\r\n            if (aij == null) continue;\r\n            k2 = m + aij.col.j; a2 = aij.val;\r\n            /* there must be only two terms */\r\n            if (aij.r_next != null) continue;\r\n            /* interchange terms, if needed */\r\n            if (!mir.isint[k1] && mir.isint[k2]){\r\n\r\n            }\r\n            else if (mir.isint[k1] && !mir.isint[k2])\r\n            {  k2 = k1; a2 = a1;\r\n                k1 = m + aij.col.j; a1 = aij.val;\r\n            }\r\n            else\r\n            {  /* both terms are either continuous or integer */\r\n                continue;\r\n            }\r\n            /* x[k2] should be double-bounded */\r\n            if (mir.lb[k2] == -DBL_MAX || mir.ub[k2] == +DBL_MAX ||\r\n                mir.lb[k2] == mir.ub[k2]) continue;\r\n            /* change signs, if necessary */\r\n            if (mir.ub[i] == 0.0){a1 = - a1; a2 = - a2}\r\n            /* now the row has the form a1 * x1 + a2 * x2 >= 0, where x1\r\n             is continuous, x2 is integer */\r\n            if (a1 > 0.0)\r\n            {  /* x1 >= - (a2 / a1) * x2 */\r\n                if (mir.vlb[k1] == 0)\r\n                {  /* set variable lower bound for x1 */\r\n                    mir.lb[k1] = - a2 / a1;\r\n                    mir.vlb[k1] = k2;\r\n                    /* the row should not be used */\r\n                    mir.skip[i] = 1;\r\n                }\r\n            }\r\n            else /* a1 < 0.0 */\r\n            {  /* x1 <= - (a2 / a1) * x2 */\r\n                if (mir.vub[k1] == 0)\r\n                {  /* set variable upper bound for x1 */\r\n                    mir.ub[k1] = - a2 / a1;\r\n                    mir.vub[k1] = k2;\r\n                    /* the row should not be used */\r\n                    mir.skip[i] = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function mark_useless_rows(tree, mir){\r\n        /* mark rows which should not be used */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        var i, k, nv;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* free rows should not be used */\r\n            if (mir.lb[i] == -DBL_MAX && mir.ub[i] == +DBL_MAX)\r\n            {  mir.skip[i] = 1;\r\n                continue;\r\n            }\r\n            nv = 0;\r\n            for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next)\r\n            {  k = m + aij.col.j;\r\n                /* rows with free variables should not be used */\r\n                if (mir.lb[k] == -DBL_MAX && mir.ub[k] == +DBL_MAX)\r\n                {  mir.skip[i] = 1;\r\n                    break;\r\n                }\r\n                /* rows with integer variables having infinite (lower or\r\n                 upper) bound should not be used */\r\n                if (mir.isint[k] && mir.lb[k] == -DBL_MAX ||\r\n                    mir.isint[k] && mir.ub[k] == +DBL_MAX)\r\n                {  mir.skip[i] = 1;\r\n                    break;\r\n                }\r\n                /* count non-fixed variables */\r\n                if (!(mir.vlb[k] == 0 && mir.vub[k] == 0 &&\r\n                    mir.lb[k] == mir.ub[k])) nv++;\r\n            }\r\n            /* rows with all variables fixed should not be used */\r\n            if (nv == 0)\r\n            {  mir.skip[i] = 1;\r\n                //continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* initialize MIR cut generator */\r\n    var mip = tree.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var mir;\r\n    if (_MIR_DEBUG){\r\n        xprintf(\"ios_mir_init: warning: debug mode enabled\");\r\n    }\r\n    /* allocate working area */\r\n    mir = {};\r\n    mir.m = m;\r\n    mir.n = n;\r\n    mir.skip = new Int8Array(1+m);\r\n    mir.isint = new Int8Array(1+m+n);\r\n    mir.lb = new Float64Array(1+m+n);\r\n    mir.vlb = new Int32Array(1+m+n);\r\n    mir.ub = new Float64Array(1+m+n);\r\n    mir.vub = new Int32Array(1+m+n);\r\n    mir.x = new Float64Array(1+m+n);\r\n    mir.agg_row = new Int32Array(1+MAXAGGR);\r\n    mir.agg_vec = ios_create_vec(m+n);\r\n    mir.subst = new Int8Array(1+m+n);\r\n    mir.mod_vec = ios_create_vec(m+n);\r\n    mir.cut_vec = ios_create_vec(m+n);\r\n    /* set global row attributes */\r\n    set_row_attrib(tree, mir);\r\n    /* set global column attributes */\r\n    set_col_attrib(tree, mir);\r\n    /* set variable bounds */\r\n    set_var_bounds(tree, mir);\r\n    /* mark rows which should not be used */\r\n    mark_useless_rows(tree, mir);\r\n    return mir;\r\n}\r\n\r\nfunction ios_mir_gen(tree, mir){\r\n\r\n    var beta, gamma;\r\n\r\n    function cmir_sep(n, a, b, u, x, s, alpha){\r\n\r\n        function cmir_cmp(v1, v2){\r\n            if (v1.v < v2.v) return -1;\r\n            if (v1.v > v2.v) return +1;\r\n            return 0;\r\n        }\r\n\r\n        function cmir_ineq(n, a, b, u, cset, delta, alpha){\r\n\r\n            function mir_ineq(n, a, b, alpha){\r\n                var j;\r\n                var f, t;\r\n                if (Math.abs(b - Math.floor(b + .5)) < 0.01)\r\n                    return 1;\r\n                f = b - Math.floor(b);\r\n                for (j = 1; j <= n; j++)\r\n                {  t = (a[j] - Math.floor(a[j])) - f;\r\n                    if (t <= 0.0)\r\n                        alpha[j] = Math.floor(a[j]);\r\n                    else\r\n                        alpha[j] = Math.floor(a[j]) + t / (1.0 - f);\r\n                }\r\n                beta = Math.floor(b);\r\n                gamma = 1.0 / (1.0 - f);\r\n                return 0;\r\n            }\r\n\r\n\r\n            var j;\r\n            var aa, bb;\r\n\r\n            aa = alpha; bb = b;\r\n            for (j = 1; j <= n; j++)\r\n            {  aa[j] = a[j] / delta;\r\n                if (cset[j])\r\n                    aa[j] = - aa[j]; bb -= a[j] * u[j];\r\n            }\r\n            bb /= delta;\r\n            if (mir_ineq(n, aa, bb, alpha)) return 1;\r\n            for (j = 1; j <= n; j++)\r\n            {  if (cset[j]){\r\n                alpha[j] = - alpha[j];\r\n                beta += alpha[j] * u[j];\r\n            }\r\n\r\n            }\r\n            gamma /= delta;\r\n            return 0;\r\n        }\r\n\r\n        var fail, j, k, nv, v;\r\n        var delta, eps, d_try = new Array(1+3), r, r_best;\r\n        var cset;\r\n        var vset;\r\n\r\n        /* allocate working arrays */\r\n        cset = new Int8Array(1+n);\r\n        vset = new Array(1+n);\r\n        /* choose initial C */\r\n        for (j = 1; j <= n; j++)\r\n            cset[j] = (x[j] >= 0.5 * u[j]);\r\n        /* choose initial delta */\r\n        r_best = delta = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  xassert(a[j] != 0.0);\r\n            /* if x[j] is close to its bounds, skip it */\r\n            eps = 1e-9 * (1.0 + Math.abs(u[j]));\r\n            if (x[j] < eps || x[j] > u[j] - eps) continue;\r\n            /* try delta = |a[j]| to construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, Math.abs(a[j]), alpha);\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; delta = Math.abs(a[j])}\r\n        }\r\n        if (r_best < 0.001) r_best = 0.0;\r\n        if (r_best == 0.0) return r_best;\r\n        xassert(delta > 0.0);\r\n        /* try to increase violation by dividing delta by 2, 4, and 8,\r\n         respectively */\r\n        d_try[1] = delta / 2.0;\r\n        d_try[2] = delta / 4.0;\r\n        d_try[3] = delta / 8.0;\r\n        for (j = 1; j <= 3; j++)\r\n        {  /* construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, d_try[j], alpha);\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; delta = d_try[j]}\r\n        }\r\n        /* build subset of variables lying strictly between their bounds\r\n         and order it by nondecreasing values of |x[j] - u[j]/2| */\r\n        nv = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  /* if x[j] is close to its bounds, skip it */\r\n            eps = 1e-9 * (1.0 + Math.abs(u[j]));\r\n            if (x[j] < eps || x[j] > u[j] - eps) continue;\r\n            /* add x[j] to the subset */\r\n            nv++;\r\n            vset[nv].j = j;\r\n            vset[nv].v = Math.abs(x[j] - 0.5 * u[j]);\r\n        }\r\n        xqsort(vset, 1, nv, cmir_cmp);\r\n        /* try to increase violation by successively complementing each\r\n         variable in the subset */\r\n        for (v = 1; v <= nv; v++)\r\n        {  j = vset[v].j;\r\n            /* replace x[j] by its complement or vice versa */\r\n            cset[j] = !cset[j];\r\n            /* construct c-MIR inequality */\r\n            fail = cmir_ineq(n, a, b, u, cset, delta, alpha);\r\n            /* restore the variable */\r\n            cset[j] = !cset[j];\r\n            /* do not replace the variable in case of failure */\r\n            if (fail) continue;\r\n            /* compute violation */\r\n            r = - beta - gamma * s;\r\n            for (k = 1; k <= n; k++) r += alpha[k] * x[k];\r\n            if (r_best < r){r_best = r; cset[j] = !cset[j]}\r\n        }\r\n        /* construct the best c-MIR inequality chosen */\r\n        fail = cmir_ineq(n, a, b, u, cset, delta, alpha);\r\n        xassert(!fail);\r\n        /* return to the calling routine */\r\n        return r_best;\r\n    }\r\n\r\n    function get_current_point(tree, mir){\r\n        /* obtain current point */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var k;\r\n        for (k = 1; k <= m; k++)\r\n            mir.x[k] = mip.row[k].prim;\r\n        for (k = m+1; k <= m+n; k++)\r\n            mir.x[k] = mip.col[k-m].prim;\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_current_point(mir){\r\n            /* check current point */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var k, kk;\r\n            var lb, ub, eps;\r\n            for (k = 1; k <= m+n; k++)\r\n            {  /* determine lower bound */\r\n                lb = mir.lb[k];\r\n                kk = mir.vlb[k];\r\n                if (kk != 0)\r\n                {  xassert(lb != -DBL_MAX);\r\n                    xassert(!mir.isint[k]);\r\n                    xassert(mir.isint[kk]);\r\n                    lb *= mir.x[kk];\r\n                }\r\n                /* check lower bound */\r\n                if (lb != -DBL_MAX)\r\n                {  eps = 1e-6 * (1.0 + Math.abs(lb));\r\n                    xassert(mir.x[k] >= lb - eps);\r\n                }\r\n                /* determine upper bound */\r\n                ub = mir.ub[k];\r\n                kk = mir.vub[k];\r\n                if (kk != 0)\r\n                {  xassert(ub != +DBL_MAX);\r\n                    xassert(!mir.isint[k]);\r\n                    xassert(mir.isint[kk]);\r\n                    ub *= mir.x[kk];\r\n                }\r\n                /* check upper bound */\r\n                if (ub != +DBL_MAX)\r\n                {  eps = 1e-6 * (1.0 + Math.abs(ub));\r\n                    xassert(mir.x[k] <= ub + eps);\r\n                }\r\n            }\r\n        }\r\n    //}\r\n\r\n    function initial_agg_row(tree, mir, i){\r\n        /* use original i-th row as initial aggregated constraint */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var aij;\r\n        xassert(1 <= i && i <= m);\r\n        xassert(!mir.skip[i]);\r\n        /* mark i-th row in order not to use it in the same aggregated\r\n         constraint */\r\n        mir.skip[i] = 2;\r\n        mir.agg_cnt = 1;\r\n        mir.agg_row[1] = i;\r\n        /* use x[i] - sum a[i,j] * x[m+j] = 0, where x[i] is auxiliary\r\n         variable of row i, x[m+j] are structural variables */\r\n        ios_clear_vec(mir.agg_vec);\r\n        ios_set_vj(mir.agg_vec, i, 1.0);\r\n        for (aij = mip.row[i].ptr; aij != null; aij = aij.r_next)\r\n            ios_set_vj(mir.agg_vec, m + aij.col.j, - aij.val);\r\n        mir.agg_rhs = 0.0;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_agg_row(mir)\r\n        {     /* check aggregated constraint */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k;\r\n            var r, big;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n            {  k = mir.agg_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                r += mir.agg_vec.val[j] * mir.x[k];\r\n                if (big < Math.abs(mir.agg_vec.val[j]))\r\n                    big = Math.abs(mir.agg_vec.val[j]);\r\n            }\r\n            r -= mir.agg_rhs;\r\n            if (big < Math.abs(mir.agg_rhs))\r\n                big = Math.abs(mir.agg_rhs);\r\n            /* the residual must be close to zero */\r\n            xassert(Math.abs(r) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function subst_fixed_vars(mir){\r\n        /* substitute fixed variables into aggregated constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k;\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.vlb[k] == 0 && mir.vub[k] == 0 &&\r\n                mir.lb[k] == mir.ub[k])\r\n            {  /* x[k] is fixed */\r\n                mir.agg_rhs -= mir.agg_vec.val[j] * mir.lb[k];\r\n                mir.agg_vec.val[j] = 0.0;\r\n            }\r\n        }\r\n        /* remove terms corresponding to fixed variables */\r\n        ios_clean_vec(mir.agg_vec, DBL_EPSILON);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n    }\r\n\r\n    function bound_subst_heur(mir){\r\n        /* bound substitution heuristic */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, kk;\r\n        var d1, d2;\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer variable */\r\n            /* compute distance from x[k] to its lower bound */\r\n            kk = mir.vlb[k];\r\n            if (kk == 0)\r\n            {  if (mir.lb[k] == -DBL_MAX)\r\n                d1 = DBL_MAX;\r\n            else\r\n                d1 = mir.x[k] - mir.lb[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                d1 = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            /* compute distance from x[k] to its upper bound */\r\n            kk = mir.vub[k];\r\n            if (kk == 0)\r\n            {  if (mir.vub[k] == +DBL_MAX)\r\n                d2 = DBL_MAX;\r\n            else\r\n                d2 = mir.ub[k] - mir.x[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                d2 = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            /* x[k] cannot be free */\r\n            xassert(d1 != DBL_MAX || d2 != DBL_MAX);\r\n            /* choose the bound which is closer to x[k] */\r\n            xassert(mir.subst[k] == MIR_N);\r\n            if (d1 <= d2)\r\n                mir.subst[k] = MIR_L;\r\n            else\r\n                mir.subst[k] = MIR_U;\r\n        }\r\n    }\r\n\r\n    function build_mod_row(mir){\r\n        /* substitute bounds and build modified constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, jj, k, kk;\r\n        /* initially modified constraint is aggregated constraint */\r\n        ios_copy_vec(mir.mod_vec, mir.agg_vec);\r\n        mir.mod_rhs = mir.agg_rhs;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n        /* substitute bounds for continuous variables; note that due to\r\n         substitution of variable bounds additional terms may appear in\r\n         modified constraint */\r\n        for (j = mir.mod_vec.nnz; j >= 1; j--)\r\n        {  k = mir.mod_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer variable */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x[k] = (lower bound) + x'[k] */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                {  /* x[k] = lb[k] + x'[k] */\r\n                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];\r\n                }\r\n                else\r\n                {  /* x[k] = lb[k] * x[kk] + x'[k] */\r\n                    xassert(mir.isint[kk]);\r\n                    jj = mir.mod_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.mod_vec, kk, 1.0);\r\n                        jj = mir.mod_vec.pos[kk];\r\n                        mir.mod_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.mod_vec.val[jj] +=\r\n                        mir.mod_vec.val[j] * mir.lb[k];\r\n                }\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x[k] = (upper bound) - x'[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                {  /* x[k] = ub[k] - x'[k] */\r\n                    mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];\r\n                }\r\n                else\r\n                {  /* x[k] = ub[k] * x[kk] - x'[k] */\r\n                    xassert(mir.isint[kk]);\r\n                    jj = mir.mod_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.mod_vec, kk, 1.0);\r\n                        jj = mir.mod_vec.pos[kk];\r\n                        mir.mod_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.mod_vec.val[jj] +=\r\n                        mir.mod_vec.val[j] * mir.ub[k];\r\n                }\r\n                mir.mod_vec.val[j] = - mir.mod_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n        /* substitute bounds for integer variables */\r\n        for (j = 1; j <= mir.mod_vec.nnz; j++)\r\n        {  k = mir.mod_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k]) continue; /* skip continuous variable */\r\n            xassert(mir.subst[k] == MIR_N);\r\n            xassert(mir.vlb[k] == 0 && mir.vub[k] == 0);\r\n            xassert(mir.lb[k] != -DBL_MAX && mir.ub[k] != +DBL_MAX);\r\n            if (Math.abs(mir.lb[k]) <= Math.abs(mir.ub[k]))\r\n            {  /* x[k] = lb[k] + x'[k] */\r\n                mir.subst[k] = MIR_L;\r\n                mir.mod_rhs -= mir.mod_vec.val[j] * mir.lb[k];\r\n            }\r\n            else\r\n            {  /* x[k] = ub[k] - x'[k] */\r\n                mir.subst[k] = MIR_U;\r\n                mir.mod_rhs -= mir.mod_vec.val[j] * mir.ub[k];\r\n                mir.mod_vec.val[j] = - mir.mod_vec.val[j];\r\n            }\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.mod_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_mod_row(mir){\r\n            /* check modified constraint */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k, kk;\r\n            var r, big, x;\r\n            /* compute the residual r = sum a'[k] * x'[k] - b' and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.mod_vec.nnz; j++)\r\n            {  k = mir.mod_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                if (mir.subst[k] == MIR_L)\r\n                {  /* x'[k] = x[k] - (lower bound) */\r\n                    xassert(mir.lb[k] != -DBL_MAX);\r\n                    kk = mir.vlb[k];\r\n                    if (kk == 0)\r\n                        x = mir.x[k] - mir.lb[k];\r\n                    else\r\n                        x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n                }\r\n                else if (mir.subst[k] == MIR_U)\r\n                {  /* x'[k] = (upper bound) - x[k] */\r\n                    xassert(mir.ub[k] != +DBL_MAX);\r\n                    kk = mir.vub[k];\r\n                    if (kk == 0)\r\n                        x = mir.ub[k] - mir.x[k];\r\n                    else\r\n                        x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n                }\r\n                else\r\n                    xassert(k != k);\r\n                r += mir.mod_vec.val[j] * x;\r\n                if (big < Math.abs(mir.mod_vec.val[j]))\r\n                    big = Math.abs(mir.mod_vec.val[j]);\r\n            }\r\n            r -= mir.mod_rhs;\r\n            if (big < Math.abs(mir.mod_rhs))\r\n                big = Math.abs(mir.mod_rhs);\r\n            /* the residual must be close to zero */\r\n            xassert(Math.abs(r) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function generate(mir){\r\n        /* try to generate violated c-MIR cut for modified constraint */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, kk, nint;\r\n        var s, u, x, alpha, r_best = 0.0, b, beta = null, gamma = null;\r\n        ios_copy_vec(mir.cut_vec, mir.mod_vec);\r\n        mir.cut_rhs = mir.mod_rhs;\r\n        /* remove small terms, which can appear due to substitution of\r\n         variable bounds */\r\n        ios_clean_vec(mir.cut_vec, DBL_EPSILON);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* remove positive continuous terms to obtain MK relaxation */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k] && mir.cut_vec.val[j] > 0.0)\r\n                mir.cut_vec.val[j] = 0.0;\r\n        }\r\n        ios_clean_vec(mir.cut_vec, 0.0);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* move integer terms to the beginning of the sparse vector and\r\n         determine the number of integer variables */\r\n        nint = 0;\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k])\r\n            {  var temp;\r\n                nint++;\r\n                /* interchange elements [nint] and [j] */\r\n                kk = mir.cut_vec.ind[nint];\r\n                mir.cut_vec.pos[k] = nint;\r\n                mir.cut_vec.pos[kk] = j;\r\n                mir.cut_vec.ind[nint] = k;\r\n                mir.cut_vec.ind[j] = kk;\r\n                temp = mir.cut_vec.val[nint];\r\n                mir.cut_vec.val[nint] = mir.cut_vec.val[j];\r\n                mir.cut_vec.val[j] = temp;\r\n            }\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        /* if there is no integer variable, nothing to generate */\r\n        if (nint == 0) return r_best;\r\n        /* allocate working arrays */\r\n        u = new Float64Array(1+nint);\r\n        x = new Float64Array(1+nint);\r\n        alpha = new Float64Array(1+nint);\r\n        /* determine u and x */\r\n        for (j = 1; j <= nint; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(m+1 <= k && k <= m+n);\r\n            xassert(mir.isint[k]);\r\n            u[j] = mir.ub[k] - mir.lb[k];\r\n            xassert(u[j] >= 1.0);\r\n            if (mir.subst[k] == MIR_L)\r\n                x[j] = mir.x[k] - mir.lb[k];\r\n            else if (mir.subst[k] == MIR_U)\r\n                x[j] = mir.ub[k] - mir.x[k];\r\n            else\r\n                xassert(k != k);\r\n            xassert(x[j] >= -0.001);\r\n            if (x[j] < 0.0) x[j] = 0.0;\r\n        }\r\n        /* compute s = - sum of continuous terms */\r\n        s = 0.0;\r\n        for (j = nint+1; j <= mir.cut_vec.nnz; j++)\r\n        {\r\n            k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            /* must be continuous */\r\n            xassert(!mir.isint[k]);\r\n            if (mir.subst[k] == MIR_L)\r\n            {  xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                    x = mir.x[k] - mir.lb[k];\r\n                else\r\n                    x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                    x = mir.ub[k] - mir.x[k];\r\n                else\r\n                    x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n            xassert(x >= -0.001);\r\n            if (x < 0.0) x = 0.0;\r\n            s -= mir.cut_vec.val[j] * x;\r\n        }\r\n        xassert(s >= 0.0);\r\n        /* apply heuristic to obtain most violated c-MIR inequality */\r\n        b = mir.cut_rhs;\r\n        r_best = cmir_sep(nint, mir.cut_vec.val, b, u, x, s, alpha);\r\n        if (r_best == 0.0) return r_best;\r\n        xassert(r_best > 0.0);\r\n        /* convert to raw cut */\r\n        /* sum alpha[j] * x[j] <= beta + gamma * s */\r\n        for (j = 1; j <= nint; j++)\r\n            mir.cut_vec.val[j] = alpha[j];\r\n        for (j = nint+1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            if (k <= m+n) mir.cut_vec.val[j] *= gamma;\r\n        }\r\n        mir.cut_rhs = beta;\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n        return r_best;\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_raw_cut(mir, r_best){\r\n            /* check raw cut before back bound substitution */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k, kk;\r\n            var r, big, x;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n            {  k = mir.cut_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                if (mir.subst[k] == MIR_L)\r\n                {  xassert(mir.lb[k] != -DBL_MAX);\r\n                    kk = mir.vlb[k];\r\n                    if (kk == 0)\r\n                        x = mir.x[k] - mir.lb[k];\r\n                    else\r\n                        x = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n                }\r\n                else if (mir.subst[k] == MIR_U)\r\n                {  xassert(mir.ub[k] != +DBL_MAX);\r\n                    kk = mir.vub[k];\r\n                    if (kk == 0)\r\n                        x = mir.ub[k] - mir.x[k];\r\n                    else\r\n                        x = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n                }\r\n                else\r\n                    xassert(k != k);\r\n                r += mir.cut_vec.val[j] * x;\r\n                if (big < Math.abs(mir.cut_vec.val[j]))\r\n                    big = Math.abs(mir.cut_vec.val[j]);\r\n            }\r\n            r -= mir.cut_rhs;\r\n            if (big < Math.abs(mir.cut_rhs))\r\n                big = Math.abs(mir.cut_rhs);\r\n            /* the residual must be close to r_best */\r\n            xassert(Math.abs(r - r_best) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function back_subst(mir){\r\n        /* back substitution of original bounds */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, jj, k, kk;\r\n        /* at first, restore bounds of integer variables (because on\r\n         restoring variable bounds of continuous variables we need\r\n         original, not shifted, bounds of integer variables) */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (!mir.isint[k]) continue; /* skip continuous */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x'[k] = x[k] - lb[k] */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                xassert(mir.vlb[k] == 0);\r\n                mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x'[k] = ub[k] - x[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                xassert(mir.vub[k] == 0);\r\n                mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];\r\n                mir.cut_vec.val[j] = - mir.cut_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        /* now restore bounds of continuous variables */\r\n        for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (mir.isint[k]) continue; /* skip integer */\r\n            if (mir.subst[k] == MIR_L)\r\n            {  /* x'[k] = x[k] - (lower bound) */\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                kk = mir.vlb[k];\r\n                if (kk == 0)\r\n                {  /* x'[k] = x[k] - lb[k] */\r\n                    mir.cut_rhs += mir.cut_vec.val[j] * mir.lb[k];\r\n                }\r\n                else\r\n                {  /* x'[k] = x[k] - lb[k] * x[kk] */\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                        jj = mir.cut_vec.pos[kk];\r\n                        xassert(jj != 0);\r\n                        mir.cut_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.cut_vec.val[jj] -= mir.cut_vec.val[j] *\r\n                        mir.lb[k];\r\n                }\r\n            }\r\n            else if (mir.subst[k] == MIR_U)\r\n            {  /* x'[k] = (upper bound) - x[k] */\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                kk = mir.vub[k];\r\n                if (kk == 0)\r\n                {  /* x'[k] = ub[k] - x[k] */\r\n                    mir.cut_rhs -= mir.cut_vec.val[j] * mir.ub[k];\r\n                }\r\n                else\r\n                {  /* x'[k] = ub[k] * x[kk] - x[k] */\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    if (jj == 0)\r\n                    {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                        jj = mir.cut_vec.pos[kk];\r\n                        xassert(jj != 0);\r\n                        mir.cut_vec.val[jj] = 0.0;\r\n                    }\r\n                    mir.cut_vec.val[jj] += mir.cut_vec.val[j] *\r\n                        mir.ub[k];\r\n                }\r\n                mir.cut_vec.val[j] = - mir.cut_vec.val[j];\r\n            }\r\n            else\r\n                xassert(k != k);\r\n        }\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.cut_vec);\r\n        }\r\n    }\r\n\r\n    //if (_MIR_DEBUG){\r\n        function check_cut_row(mir, r_best){\r\n            /* check the cut after back bound substitution or elimination of\r\n             auxiliary variables */\r\n            var m = mir.m;\r\n            var n = mir.n;\r\n            var j, k;\r\n            var r, big;\r\n            /* compute the residual r = sum a[k] * x[k] - b and determine\r\n             big = max(1, |a[k]|, |b|) */\r\n            r = 0.0; big = 1.0;\r\n            for (j = 1; j <= mir.cut_vec.nnz; j++)\r\n            {  k = mir.cut_vec.ind[j];\r\n                xassert(1 <= k && k <= m+n);\r\n                r += mir.cut_vec.val[j] * mir.x[k];\r\n                if (big < Math.abs(mir.cut_vec.val[j]))\r\n                    big = Math.abs(mir.cut_vec.val[j]);\r\n            }\r\n            r -= mir.cut_rhs;\r\n            if (big < Math.abs(mir.cut_rhs))\r\n                big = Math.abs(mir.cut_rhs);\r\n            /* the residual must be close to r_best */\r\n            xassert(Math.abs(r - r_best) <= 1e-6 * big);\r\n        }\r\n    //}\r\n\r\n    function subst_aux_vars(tree, mir){\r\n        /* final substitution to eliminate auxiliary variables */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var aij;\r\n        var j, k, kk, jj;\r\n        for (j = mir.cut_vec.nnz; j >= 1; j--)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (k > m) continue; /* skip structurals */\r\n            for (aij = mip.row[k].ptr; aij != null; aij = aij.r_next)\r\n            {  kk = m + aij.col.j; /* structural */\r\n                jj = mir.cut_vec.pos[kk];\r\n                if (jj == 0)\r\n                {  ios_set_vj(mir.cut_vec, kk, 1.0);\r\n                    jj = mir.cut_vec.pos[kk];\r\n                    mir.cut_vec.val[jj] = 0.0;\r\n                }\r\n                mir.cut_vec.val[jj] += mir.cut_vec.val[j] * aij.val;\r\n            }\r\n            mir.cut_vec.val[j] = 0.0;\r\n        }\r\n        ios_clean_vec(mir.cut_vec, 0.0);\r\n    }\r\n\r\n    function add_cut(tree, mir){\r\n        /* add constructed cut inequality to the cut pool */\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var j, k, len;\r\n        var ind = new Int32Array(1+n);\r\n        var val = new Float64Array(1+n);\r\n        len = 0;\r\n        for (j = mir.cut_vec.nnz; j >= 1; j--)\r\n        {  k = mir.cut_vec.ind[j];\r\n            xassert(m+1 <= k && k <= m+n);\r\n            len++; ind[len] = k - m; val[len] = mir.cut_vec.val[j];\r\n        }\r\n        glp_ios_add_row(tree, null, GLP_RF_MIR, 0, len, ind, val, GLP_UP,\r\n            mir.cut_rhs);\r\n    }\r\n\r\n    function aggregate_row(tree, mir){\r\n        /* try to aggregate another row */\r\n        var mip = tree.mip;\r\n        var m = mir.m;\r\n        var n = mir.n;\r\n        var aij;\r\n        var v;\r\n        var ii, j, jj, k, kk, kappa = 0, ret = 0;\r\n        var d1, d2, d, d_max = 0.0;\r\n        /* choose appropriate structural variable in the aggregated row\r\n         to be substituted */\r\n        for (j = 1; j <= mir.agg_vec.nnz; j++)\r\n        {  k = mir.agg_vec.ind[j];\r\n            xassert(1 <= k && k <= m+n);\r\n            if (k <= m) continue; /* skip auxiliary var */\r\n            if (mir.isint[k]) continue; /* skip integer var */\r\n            if (Math.abs(mir.agg_vec.val[j]) < 0.001) continue;\r\n            /* compute distance from x[k] to its lower bound */\r\n            kk = mir.vlb[k];\r\n            if (kk == 0)\r\n            {  if (mir.lb[k] == -DBL_MAX)\r\n                d1 = DBL_MAX;\r\n            else\r\n                d1 = mir.x[k] - mir.lb[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.lb[k] != -DBL_MAX);\r\n                d1 = mir.x[k] - mir.lb[k] * mir.x[kk];\r\n            }\r\n            /* compute distance from x[k] to its upper bound */\r\n            kk = mir.vub[k];\r\n            if (kk == 0)\r\n            {  if (mir.vub[k] == +DBL_MAX)\r\n                d2 = DBL_MAX;\r\n            else\r\n                d2 = mir.ub[k] - mir.x[k];\r\n            }\r\n            else\r\n            {  xassert(1 <= kk && kk <= m+n);\r\n                xassert(mir.isint[kk]);\r\n                xassert(mir.ub[k] != +DBL_MAX);\r\n                d2 = mir.ub[k] * mir.x[kk] - mir.x[k];\r\n            }\r\n            /* x[k] cannot be free */\r\n            xassert(d1 != DBL_MAX || d2 != DBL_MAX);\r\n            /* d = min(d1, d2) */\r\n            d = (d1 <= d2 ? d1 : d2);\r\n            xassert(d != DBL_MAX);\r\n            /* should not be close to corresponding bound */\r\n            if (d < 0.001) continue;\r\n            if (d_max < d) {d_max = d; kappa = k}\r\n        }\r\n        if (kappa == 0)\r\n        {  /* nothing chosen */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* x[kappa] has been chosen */\r\n        xassert(m+1 <= kappa && kappa <= m+n);\r\n        xassert(!mir.isint[kappa]);\r\n        /* find another row, which have not been used yet, to eliminate\r\n         x[kappa] from the aggregated row */\r\n        for (ii = 1; ii <= m; ii++)\r\n        {  if (mir.skip[ii]) continue;\r\n            for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)\r\n                if (aij.col.j == kappa - m) break;\r\n            if (aij != null && Math.abs(aij.val) >= 0.001) break;\r\n        }\r\n        if (ii > m)\r\n        {  /* nothing found */\r\n            ret = 2;\r\n            return ret;\r\n        }\r\n        /* row ii has been found; include it in the aggregated list */\r\n        mir.agg_cnt++;\r\n        xassert(mir.agg_cnt <= MAXAGGR);\r\n        mir.agg_row[mir.agg_cnt] = ii;\r\n        mir.skip[ii] = 2;\r\n        /* v := new row */\r\n        v = ios_create_vec(m+n);\r\n        ios_set_vj(v, ii, 1.0);\r\n        for (aij = mip.row[ii].ptr; aij != null; aij = aij.r_next)\r\n            ios_set_vj(v, m + aij.col.j, - aij.val);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(v);\r\n        }\r\n        /* perform gaussian elimination to remove x[kappa] */\r\n        j = mir.agg_vec.pos[kappa];\r\n        xassert(j != 0);\r\n        jj = v.pos[kappa];\r\n        xassert(jj != 0);\r\n        ios_linear_comb(mir.agg_vec, - mir.agg_vec.val[j] / v.val[jj], v);\r\n        ios_set_vj(mir.agg_vec, kappa, 0.0);\r\n        if (_MIR_DEBUG){\r\n            ios_check_vec(mir.agg_vec);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /* main routine to generate MIR cuts */\r\n    var mip = tree.mip;\r\n    var m = mir.m;\r\n    var n = mir.n;\r\n    var i, k;\r\n    var r_best;\r\n    xassert(mip.m >= m);\r\n    xassert(mip.n == n);\r\n    /* obtain current point */\r\n    get_current_point(tree, mir);\r\n    if (_MIR_DEBUG){\r\n        /* check current point */\r\n        check_current_point(mir);\r\n    }\r\n    /* reset bound substitution flags */\r\n    xfillArr(mir.subst, 1, MIR_N, m+n);\r\n    /* try to generate a set of violated MIR cuts */\r\n    for (i = 1; i <= m; i++)\r\n    {  if (mir.skip[i]) continue;\r\n        /* use original i-th row as initial aggregated constraint */\r\n        initial_agg_row(tree, mir, i);\r\n        while (true){\r\n            if (_MIR_DEBUG){\r\n                /* check aggregated row */\r\n                check_agg_row(mir);\r\n            }\r\n            /* substitute fixed variables into aggregated constraint */\r\n            subst_fixed_vars(mir);\r\n            if (_MIR_DEBUG){\r\n                /* check aggregated row */\r\n                check_agg_row(mir);\r\n                /* check bound substitution flags */\r\n                {\r\n                    for (k = 1; k <= m+n; k++)\r\n                        xassert(mir.subst[k] == MIR_N);\r\n                }\r\n            }\r\n            /* apply bound substitution heuristic */\r\n            bound_subst_heur(mir);\r\n            /* substitute bounds and build modified constraint */\r\n            build_mod_row(mir);\r\n            if (_MIR_DEBUG){\r\n                /* check modified row */\r\n                check_mod_row(mir);\r\n            }\r\n            /* try to generate violated c-MIR cut for modified row */\r\n            r_best = generate(mir);\r\n            if (r_best > 0.0){\r\n                /* success */\r\n                if (_MIR_DEBUG){\r\n                    /* check raw cut before back bound substitution */\r\n                    check_raw_cut(mir, r_best);\r\n                }\r\n                /* back substitution of original bounds */\r\n                back_subst(mir);\r\n                if (_MIR_DEBUG){\r\n                    /* check the cut after back bound substitution */\r\n                    check_cut_row(mir, r_best);\r\n                }\r\n                /* final substitution to eliminate auxiliary variables */\r\n                subst_aux_vars(tree, mir);\r\n                if (_MIR_DEBUG){\r\n                    /* check the cut after elimination of auxiliaries */\r\n                    check_cut_row(mir, r_best);\r\n                }\r\n                /* add constructed cut inequality to the cut pool */\r\n                add_cut(tree, mir);\r\n            }\r\n            /* reset bound substitution flags */\r\n            {\r\n                for (var j = 1; j <= mir.mod_vec.nnz; j++)\r\n                {  k = mir.mod_vec.ind[j];\r\n                    xassert(1 <= k && k <= m+n);\r\n                    xassert(mir.subst[k] != MIR_N);\r\n                    mir.subst[k] = MIR_N;\r\n                }\r\n            }\r\n            if (r_best == 0.0)\r\n            {  /* failure */\r\n                if (mir.agg_cnt < MAXAGGR)\r\n                {  /* try to aggregate another row */\r\n                    if (aggregate_row(tree, mir) == 0) continue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        /* unmark rows used in the aggregated constraint */\r\n        {  var ii;\r\n            for (k = 1; k <= mir.agg_cnt; k++)\r\n            {  ii = mir.agg_row[k];\r\n                xassert(1 <= ii && ii <= m);\r\n                xassert(mir.skip[ii] == 2);\r\n                mir.skip[ii] = 0;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction lpx_cover_cut(lp, len, ind, val, x){\r\n    var alfa = null, beta = null;\r\n\r\n    var MAXTRY = 1000;\r\n\r\n    function cover2(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut using two-element cover */\r\n        var i, j, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n            {  /* C = {i, j} */\r\n                try_++;\r\n                if (try_ > MAXTRY) return ret;\r\n                /* check if condition (8) is satisfied */\r\n                if (a[i] + a[j] + y > b + eps)\r\n                {  /* compute parameters for inequality (15) */\r\n                    temp = a[i] + a[j] - b;\r\n                    alfa = 1.0 / (temp + u);\r\n                    beta = 2.0 - alfa * temp;\r\n                    /* compute violation of inequality (15) */\r\n                    temp = x[i] + x[j] + alfa * y - beta;\r\n                    /* choose C providing maximum violation */\r\n                    if (rmax < temp)\r\n                    {  rmax = temp;\r\n                        cov[1] = i;\r\n                        cov[2] = j;\r\n                        ret = 1;\r\n                    }\r\n                }\r\n            }\r\n        return ret;\r\n    }\r\n\r\n    function cover3(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut using three-element cover */\r\n        var i, j, k, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n                for (k = j+1; k <= n; k++)\r\n                {  /* C = {i, j, k} */\r\n                    try_++;\r\n                    if (try_ > MAXTRY) return ret;\r\n                    /* check if condition (8) is satisfied */\r\n                    if (a[i] + a[j] + a[k] + y > b + eps)\r\n                    {  /* compute parameters for inequality (15) */\r\n                        temp = a[i] + a[j] + a[k] - b;\r\n                        alfa = 1.0 / (temp + u);\r\n                        beta = 3.0 - alfa * temp;\r\n                        /* compute violation of inequality (15) */\r\n                        temp = x[i] + x[j] + x[k] + alfa * y - beta;\r\n                        /* choose C providing maximum violation */\r\n                        if (rmax < temp)\r\n                        {  rmax = temp;\r\n                            cov[1] = i;\r\n                            cov[2] = j;\r\n                            cov[3] = k;\r\n                            ret = 1;\r\n                        }\r\n                    }\r\n                }\r\n        return ret;\r\n    }\r\n\r\n    function cover4(n, a, b, u, x, y, cov){\r\n        /* try_ to generate mixed cover cut using four-element cover */\r\n        var i, j, k, l, try_ = 0, ret = 0;\r\n        var eps, temp, rmax = 0.001;\r\n        eps = 0.001 * (1.0 + Math.abs(b));\r\n        for (i = 1; i <= n; i++)\r\n            for (j = i+1; j <= n; j++)\r\n                for (k = j+1; k <= n; k++)\r\n                    for (l = k+1; l <= n; l++)\r\n                    {  /* C = {i, j, k, l} */\r\n                        try_++;\r\n                        if (try_ > MAXTRY) return ret;\r\n                        /* check if condition (8) is satisfied */\r\n                        if (a[i] + a[j] + a[k] + a[l] + y > b + eps)\r\n                        {  /* compute parameters for inequality (15) */\r\n                            temp = a[i] + a[j] + a[k] + a[l] - b;\r\n                            alfa = 1.0 / (temp + u);\r\n                            beta = 4.0 - alfa * temp;\r\n                            /* compute violation of inequality (15) */\r\n                            temp = x[i] + x[j] + x[k] + x[l] + alfa * y - beta;\r\n                            /* choose C providing maximum violation */\r\n                            if (rmax < temp)\r\n                            {  rmax = temp;\r\n                                cov[1] = i;\r\n                                cov[2] = j;\r\n                                cov[3] = k;\r\n                                cov[4] = l;\r\n                                ret = 1;\r\n                            }\r\n                        }\r\n                    }\r\n        return ret;\r\n    }\r\n\r\n    function cover(n, a, b, u, x, y, cov){\r\n        /* try to generate mixed cover cut;\r\n         input (see (5)):\r\n         n        is the number of binary variables;\r\n         a[1:n]   are coefficients at binary variables;\r\n         b        is the right-hand side;\r\n         u        is upper bound of continuous variable;\r\n         x[1:n]   are values of binary variables at current point;\r\n         y        is value of continuous variable at current point;\r\n         output (see (15), (16), (17)):\r\n         cov[1:r] are indices of binary variables included in cover C,\r\n         where r is the set cardinality returned on exit;\r\n         alfa     coefficient at continuous variable;\r\n         beta     is the right-hand side; */\r\n        var j;\r\n        /* perform some sanity checks */\r\n        xassert(n >= 2);\r\n        for (j = 1; j <= n; j++) xassert(a[j] > 0.0);\r\n        xassert(b > -1e-5);\r\n        xassert(u >= 0.0);\r\n        for (j = 1; j <= n; j++) xassert(0.0 <= x[j] && x[j] <= 1.0);\r\n        xassert(0.0 <= y && y <= u);\r\n        /* try to generate mixed cover cut */\r\n        if (cover2(n, a, b, u, x, y, cov)) return 2;\r\n        if (cover3(n, a, b, u, x, y, cov)) return 3;\r\n        if (cover4(n, a, b, u, x, y, cov)) return 4;\r\n        return 0;\r\n    }\r\n\r\n\r\n\r\n    var cov = new Array(1+4), j, k, nb, newlen, r;\r\n    var f_min, f_max, u, y;\r\n    /* substitute and remove fixed variables */\r\n    newlen = 0;\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (lpx_get_col_type(lp, j) == LPX_FX)\r\n            val[0] -= val[k] * lpx_get_col_lb(lp, j);\r\n        else\r\n        {  newlen++;\r\n            ind[newlen] = ind[k];\r\n            val[newlen] = val[k];\r\n        }\r\n    }\r\n    len = newlen;\r\n    /* move binary variables to the beginning of the list so that\r\n     elements 1, 2, ..., nb correspond to binary variables, and\r\n     elements nb+1, nb+2, ..., len correspond to rest variables */\r\n    nb = 0;\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (lpx_get_col_kind(lp, j) == LPX_IV &&\r\n            lpx_get_col_type(lp, j) == LPX_DB &&\r\n            lpx_get_col_lb(lp, j) == 0.0 &&\r\n            lpx_get_col_ub(lp, j) == 1.0)\r\n        {  /* binary variable */\r\n            var ind_k;\r\n            var val_k;\r\n            nb++;\r\n            ind_k = ind[nb]; val_k = val[nb];\r\n            ind[nb] = ind[k]; val[nb] = val[k];\r\n            ind[k] = ind_k; val[k] = val_k;\r\n        }\r\n    }\r\n    /* now the specified row has the form:\r\n     sum a[j]*x[j] + sum a[j]*y[j] <= b,\r\n     where x[j] are binary variables, y[j] are rest variables */\r\n    /* at least two binary variables are needed */\r\n    if (nb < 2) return 0;\r\n    /* compute implied lower and upper bounds for sum a[j]*y[j] */\r\n    f_min = f_max = 0.0;\r\n    for (k = nb+1; k <= len; k++)\r\n    {  j = ind[k];\r\n        /* both bounds must be finite */\r\n        if (lpx_get_col_type(lp, j) != LPX_DB) return 0;\r\n        if (val[k] > 0.0)\r\n        {  f_min += val[k] * lpx_get_col_lb(lp, j);\r\n            f_max += val[k] * lpx_get_col_ub(lp, j);\r\n        }\r\n        else\r\n        {  f_min += val[k] * lpx_get_col_ub(lp, j);\r\n            f_max += val[k] * lpx_get_col_lb(lp, j);\r\n        }\r\n    }\r\n    /* sum a[j]*x[j] + sum a[j]*y[j] <= b ===>\r\n     sum a[j]*x[j] + (sum a[j]*y[j] - f_min) <= b - f_min ===>\r\n     sum a[j]*x[j] + y <= b - f_min,\r\n     where y = sum a[j]*y[j] - f_min;\r\n     note that 0 <= y <= u, u = f_max - f_min */\r\n    /* determine upper bound of y */\r\n    u = f_max - f_min;\r\n    /* determine value of y at the current point */\r\n    y = 0.0;\r\n    for (k = nb+1; k <= len; k++)\r\n    {  j = ind[k];\r\n        y += val[k] * lpx_get_col_prim(lp, j);\r\n    }\r\n    y -= f_min;\r\n    if (y < 0.0) y = 0.0;\r\n    if (y > u) y = u;\r\n    /* modify the right-hand side b */\r\n    val[0] -= f_min;\r\n    /* now the transformed row has the form:\r\n     sum a[j]*x[j] + y <= b, where 0 <= y <= u */\r\n    /* determine values of x[j] at the current point */\r\n    for (k = 1; k <= nb; k++)\r\n    {  j = ind[k];\r\n        x[k] = lpx_get_col_prim(lp, j);\r\n        if (x[k] < 0.0) x[k] = 0.0;\r\n        if (x[k] > 1.0) x[k] = 1.0;\r\n    }\r\n    /* if a[j] < 0, replace x[j] by its complement 1 - x'[j] */\r\n    for (k = 1; k <= nb; k++)\r\n    {  if (val[k] < 0.0)\r\n    {  ind[k] = - ind[k];\r\n        val[k] = - val[k];\r\n        val[0] += val[k];\r\n        x[k] = 1.0 - x[k];\r\n    }\r\n    }\r\n    /* try to generate a mixed cover cut for the transformed row */\r\n    r = cover(nb, val, val[0], u, x, y, cov);\r\n    if (r == 0) return 0;\r\n    xassert(2 <= r && r <= 4);\r\n    /* now the cut is in the form:\r\n     sum{j in C} x[j] + alfa * y <= beta */\r\n    /* store the right-hand side beta */\r\n    ind[0] = 0; val[0] = beta;\r\n    /* restore the original ordinal numbers of x[j] */\r\n    for (j = 1; j <= r; j++) cov[j] = ind[cov[j]];\r\n    /* store cut coefficients at binary variables complementing back\r\n     the variables having negative row coefficients */\r\n    xassert(r <= nb);\r\n    for (k = 1; k <= r; k++)\r\n    {  if (cov[k] > 0)\r\n    {  ind[k] = +cov[k];\r\n        val[k] = +1.0;\r\n    }\r\n    else\r\n    {  ind[k] = -cov[k];\r\n        val[k] = -1.0;\r\n        val[0] -= 1.0;\r\n    }\r\n    }\r\n    /* substitute y = sum a[j]*y[j] - f_min */\r\n    for (k = nb+1; k <= len; k++)\r\n    {  r++;\r\n        ind[r] = ind[k];\r\n        val[r] = alfa * val[k];\r\n    }\r\n    val[0] += alfa * f_min;\r\n    xassert(r <= len);\r\n    len = r;\r\n    return len;\r\n}\r\n\r\nfunction lpx_eval_row(lp, len, ind, val){\r\n    var n = lpx_get_num_cols(lp);\r\n    var j, k;\r\n    var sum = 0.0;\r\n    if (len < 0)\r\n        xerror(\"lpx_eval_row: len = \" + len + \"; invalid row length\");\r\n    for (k = 1; k <= len; k++)\r\n    {  j = ind[k];\r\n        if (!(1 <= j && j <= n))\r\n            xerror(\"lpx_eval_row: j = \" + j + \"; column number out of range\");\r\n        sum += val[k] * lpx_get_col_prim(lp, j);\r\n    }\r\n    return sum;\r\n}\r\n\r\nfunction ios_cov_gen(tree){\r\n    var prob = tree.mip;\r\n    var m = lpx_get_num_rows(prob);\r\n    var n = lpx_get_num_cols(prob);\r\n    var i, k, type, kase, len, ind;\r\n    var r, val, work;\r\n    xassert(lpx_get_status(prob) == LPX_OPT);\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    work = new Float64Array(1+n);\r\n    /* look through all rows */\r\n    for (i = 1; i <= m; i++)\r\n        for (kase = 1; kase <= 2; kase++)\r\n        {  type = lpx_get_row_type(prob, i);\r\n            if (kase == 1)\r\n            {  /* consider rows of '<=' type */\r\n                if (!(type == LPX_UP || type == LPX_DB)) continue;\r\n                len = lpx_get_mat_row(prob, i, ind, val);\r\n                val[0] = lpx_get_row_ub(prob, i);\r\n            }\r\n            else\r\n            {  /* consider rows of '>=' type */\r\n                if (!(type == LPX_LO || type == LPX_DB)) continue;\r\n                len = lpx_get_mat_row(prob, i, ind, val);\r\n                for (k = 1; k <= len; k++) val[k] = - val[k];\r\n                val[0] = - lpx_get_row_lb(prob, i);\r\n            }\r\n            /* generate mixed cover cut:\r\n             sum{j in J} a[j] * x[j] <= b */\r\n            len = lpx_cover_cut(prob, len, ind, val, work);\r\n            if (len == 0) continue;\r\n            /* at the current point the cut inequality is violated, i.e.\r\n             sum{j in J} a[j] * x[j] - b > 0 */\r\n            r = lpx_eval_row(prob, len, ind, val) - val[0];\r\n            if (r < 1e-3) continue;\r\n            /* add the cut to the cut pool */\r\n            glp_ios_add_row(tree, null, GLP_RF_COV, 0, len, ind, val,\r\n                GLP_UP, val[0]);\r\n        }\r\n}\r\n\r\n\r\nfunction lpx_create_cog(lp){\r\n    var MAX_NB = 4000;\r\n    var MAX_ROW_LEN = 500;\r\n\r\n    function get_row_lb(lp, i){\r\n        /* this routine returns lower bound of row i or -DBL_MAX if the\r\n         row has no lower bound */\r\n        var lb;\r\n        switch (lpx_get_row_type(lp, i))\r\n        {  case LPX_FR:\r\n            case LPX_UP:\r\n                lb = -DBL_MAX;\r\n                break;\r\n            case LPX_LO:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                lb = lpx_get_row_lb(lp, i);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return lb;\r\n    }\r\n\r\n    function get_row_ub(lp, i){\r\n        /* this routine returns upper bound of row i or +DBL_MAX if the\r\n         row has no upper bound */\r\n        var ub;\r\n        switch (lpx_get_row_type(lp, i))\r\n        {  case LPX_FR:\r\n            case LPX_LO:\r\n                ub = +DBL_MAX;\r\n                break;\r\n            case LPX_UP:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                ub = lpx_get_row_ub(lp, i);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return ub;\r\n    }\r\n\r\n    function get_col_lb(lp, j){\r\n        /* this routine returns lower bound of column j or -DBL_MAX if\r\n         the column has no lower bound */\r\n        var lb;\r\n        switch (lpx_get_col_type(lp, j))\r\n        {  case LPX_FR:\r\n            case LPX_UP:\r\n                lb = -DBL_MAX;\r\n                break;\r\n            case LPX_LO:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                lb = lpx_get_col_lb(lp, j);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return lb;\r\n    }\r\n\r\n    function get_col_ub(lp, j){\r\n        /* this routine returns upper bound of column j or +DBL_MAX if\r\n         the column has no upper bound */\r\n        var ub;\r\n        switch (lpx_get_col_type(lp, j))\r\n        {  case LPX_FR:\r\n            case LPX_LO:\r\n                ub = +DBL_MAX;\r\n                break;\r\n            case LPX_UP:\r\n            case LPX_DB:\r\n            case LPX_FX:\r\n                ub = lpx_get_col_ub(lp, j);\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        return ub;\r\n    }\r\n\r\n    function is_binary(lp, j){\r\n        /* this routine checks if variable x[j] is binary */\r\n        return lpx_get_col_kind(lp, j) == LPX_IV &&\r\n            lpx_get_col_type(lp, j) == LPX_DB &&\r\n            lpx_get_col_lb(lp, j) == 0.0 && lpx_get_col_ub(lp, j) == 1.0;\r\n    }\r\n\r\n    function eval_lf_min(lp, len, ind, val){\r\n        /* this routine computes the minimum of a specified linear form\r\n\r\n         sum a[j]*x[j]\r\n         j\r\n\r\n         using the formula:\r\n\r\n         min =   sum   a[j]*lb[j] +   sum   a[j]*ub[j],\r\n         j in J+              j in J-\r\n\r\n         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]\r\n         are lower and upper bound of variable x[j], resp. */\r\n        var j, t;\r\n        var lb, ub, sum;\r\n        sum = 0.0;\r\n        for (t = 1; t <= len; t++)\r\n        {  j = ind[t];\r\n            if (val[t] > 0.0)\r\n            {  lb = get_col_lb(lp, j);\r\n                if (lb == -DBL_MAX)\r\n                {  sum = -DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * lb;\r\n            }\r\n            else if (val[t] < 0.0)\r\n            {  ub = get_col_ub(lp, j);\r\n                if (ub == +DBL_MAX)\r\n                {  sum = -DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * ub;\r\n            }\r\n            else\r\n                xassert(val != val);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function eval_lf_max(lp, len, ind, val){\r\n        /* this routine computes the maximum of a specified linear form\r\n\r\n         sum a[j]*x[j]\r\n         j\r\n\r\n         using the formula:\r\n\r\n         max =   sum   a[j]*ub[j] +   sum   a[j]*lb[j],\r\n         j in J+              j in J-\r\n\r\n         where J+ = {j: a[j] > 0}, J- = {j: a[j] < 0}, lb[j] and ub[j]\r\n         are lower and upper bound of variable x[j], resp. */\r\n        var j, t;\r\n        var lb, ub, sum;\r\n        sum = 0.0;\r\n        for (t = 1; t <= len; t++)\r\n        {  j = ind[t];\r\n            if (val[t] > 0.0)\r\n            {  ub = get_col_ub(lp, j);\r\n                if (ub == +DBL_MAX)\r\n                {  sum = +DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * ub;\r\n            }\r\n            else if (val[t] < 0.0)\r\n            {  lb = get_col_lb(lp, j);\r\n                if (lb == -DBL_MAX)\r\n                {  sum = +DBL_MAX;\r\n                    break;\r\n                }\r\n                sum += val[t] * lb;\r\n            }\r\n            else\r\n                xassert(val != val);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function probing(len, val, L, U, lf_min, lf_max, p, set, q){\r\n        var temp;\r\n        xassert(1 <= p && p < q && q <= len);\r\n        /* compute L' (3) */\r\n        if (L != -DBL_MAX && set) L -= val[p];\r\n        /* compute U' (4) */\r\n        if (U != +DBL_MAX && set) U -= val[p];\r\n        /* compute MIN (9) */\r\n        if (lf_min != -DBL_MAX)\r\n        {  if (val[p] < 0.0) lf_min -= val[p];\r\n            if (val[q] < 0.0) lf_min -= val[q];\r\n        }\r\n        /* compute MAX (10) */\r\n        if (lf_max != +DBL_MAX)\r\n        {  if (val[p] > 0.0) lf_max -= val[p];\r\n            if (val[q] > 0.0) lf_max -= val[q];\r\n        }\r\n        /* compute implied lower bound of x[q]; see (7), (8) */\r\n        if (val[q] > 0.0)\r\n        {  if (L == -DBL_MAX || lf_max == +DBL_MAX)\r\n            temp = -DBL_MAX;\r\n        else\r\n            temp = (L - lf_max) / val[q];\r\n        }\r\n        else\r\n        {  if (U == +DBL_MAX || lf_min == -DBL_MAX)\r\n            temp = -DBL_MAX;\r\n        else\r\n            temp = (U - lf_min) / val[q];\r\n        }\r\n        if (temp > 0.001) return 2;\r\n        /* compute implied upper bound of x[q]; see (7), (8) */\r\n        if (val[q] > 0.0)\r\n        {  if (U == +DBL_MAX || lf_min == -DBL_MAX)\r\n            temp = +DBL_MAX;\r\n        else\r\n            temp = (U - lf_min) / val[q];\r\n        }\r\n        else\r\n        {  if (L == -DBL_MAX || lf_max == +DBL_MAX)\r\n            temp = +DBL_MAX;\r\n        else\r\n            temp = (L - lf_max) / val[q];\r\n        }\r\n        if (temp < 0.999) return 1;\r\n        /* there is no logical relation between x[p] and x[q] */\r\n        return 0;\r\n    }\r\n\r\n    var cog = null;\r\n    var m, n, nb, i, j, p, q, len, ind, vert, orig;\r\n    var L, U, lf_min, lf_max, val;\r\n    xprintf(\"Creating the conflict graph...\");\r\n    m = lpx_get_num_rows(lp);\r\n    n = lpx_get_num_cols(lp);\r\n    /* determine which binary variables should be included in the\r\n     conflict graph */\r\n    nb = 0;\r\n    vert = new Int32Array(1+n);\r\n    orig = new Int32Array(1+n);\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    for (i = 1; i <= m; i++)\r\n    {  L = get_row_lb(lp, i);\r\n        U = get_row_ub(lp, i);\r\n        if (L == -DBL_MAX && U == +DBL_MAX) continue;\r\n        len = lpx_get_mat_row(lp, i, ind, val);\r\n        if (len > MAX_ROW_LEN) continue;\r\n        lf_min = eval_lf_min(lp, len, ind, val);\r\n        lf_max = eval_lf_max(lp, len, ind, val);\r\n        for (p = 1; p <= len; p++)\r\n        {  if (!is_binary(lp, ind[p])) continue;\r\n            for (q = p+1; q <= len; q++)\r\n            {  if (!is_binary(lp, ind[q])) continue;\r\n                if (probing(len, val, L, U, lf_min, lf_max, p, 0, q) ||\r\n                    probing(len, val, L, U, lf_min, lf_max, p, 1, q))\r\n                {  /* there is a logical relation */\r\n                    /* include the first variable in the graph */\r\n                    j = ind[p];\r\n                    if (vert[j] == 0) {nb++; vert[j] = nb; orig[nb] = j}\r\n                    /* incude the second variable in the graph */\r\n                    j = ind[q];\r\n                    if (vert[j] == 0) {nb++; vert[j] = nb; orig[nb] = j}\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /* if the graph is either empty or has too many vertices, do not\r\n     create it */\r\n    if (nb == 0 || nb > MAX_NB)\r\n    {  xprintf(\"The conflict graph is either empty or too big\");\r\n       return cog;\r\n    }\r\n    /* create the conflict graph */\r\n    cog = {};\r\n    cog.n = n;\r\n    cog.nb = nb;\r\n    cog.ne = 0;\r\n    cog.vert = vert;\r\n    cog.orig = orig;\r\n    len = nb + nb; /* number of vertices */\r\n    len = (len * (len - 1)) / 2; /* number of entries in triangle */\r\n    len = (len + (CHAR_BIT - 1)) / CHAR_BIT; /* bytes needed */\r\n    cog.a = new Array(len);\r\n    for (j = 1; j <= nb; j++)\r\n    {  /* add edge between variable and its complement */\r\n        lpx_add_cog_edge(cog, +orig[j], -orig[j]);\r\n    }\r\n    for (i = 1; i <= m; i++)\r\n    {  L = get_row_lb(lp, i);\r\n        U = get_row_ub(lp, i);\r\n        if (L == -DBL_MAX && U == +DBL_MAX) continue;\r\n        len = lpx_get_mat_row(lp, i, ind, val);\r\n        if (len > MAX_ROW_LEN) continue;\r\n        lf_min = eval_lf_min(lp, len, ind, val);\r\n        lf_max = eval_lf_max(lp, len, ind, val);\r\n        for (p = 1; p <= len; p++)\r\n        {  if (!is_binary(lp, ind[p])) continue;\r\n            for (q = p+1; q <= len; q++)\r\n            {  if (!is_binary(lp, ind[q])) continue;\r\n                /* set x[p] to 0 and examine x[q] */\r\n                switch (probing(len, val, L, U, lf_min, lf_max, p, 0, q))\r\n                {  case 0:\r\n                    /* no logical relation */\r\n                    break;\r\n                    case 1:\r\n                        /* x[p] = 0 implies x[q] = 0 */\r\n                        lpx_add_cog_edge(cog, -ind[p], +ind[q]);\r\n                        break;\r\n                    case 2:\r\n                        /* x[p] = 0 implies x[q] = 1 */\r\n                        lpx_add_cog_edge(cog, -ind[p], -ind[q]);\r\n                        break;\r\n                    default:\r\n                        xassert(lp != lp);\r\n                }\r\n                /* set x[p] to 1 and examine x[q] */\r\n                switch (probing(len, val, L, U, lf_min, lf_max, p, 1, q))\r\n                {  case 0:\r\n                    /* no logical relation */\r\n                    break;\r\n                    case 1:\r\n                        /* x[p] = 1 implies x[q] = 0 */\r\n                        lpx_add_cog_edge(cog, +ind[p], +ind[q]);\r\n                        break;\r\n                    case 2:\r\n                        /* x[p] = 1 implies x[q] = 1 */\r\n                        lpx_add_cog_edge(cog, +ind[p], -ind[q]);\r\n                        break;\r\n                    default:\r\n                        xassert(lp != lp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    xprintf(\"The conflict graph has 2*\" + cog.nb + \" vertices and \" + cog.ne + \" edges\");\r\n    return cog;\r\n}\r\n\r\nfunction lpx_add_cog_edge(cog, i, j){\r\n    var k;\r\n    xassert(i != j);\r\n    /* determine indices of corresponding vertices */\r\n    if (i > 0)\r\n    {  xassert(1 <= i && i <= cog.n);\r\n        i = cog.vert[i];\r\n        xassert(i != 0);\r\n    }\r\n    else\r\n    {  i = -i;\r\n        xassert(1 <= i && i <= cog.n);\r\n        i = cog.vert[i];\r\n        xassert(i != 0);\r\n        i += cog.nb;\r\n    }\r\n    if (j > 0)\r\n    {  xassert(1 <= j && j <= cog.n);\r\n        j = cog.vert[j];\r\n        xassert(j != 0);\r\n    }\r\n    else\r\n    {  j = -j;\r\n        xassert(1 <= j && j <= cog.n);\r\n        j = cog.vert[j];\r\n        xassert(j != 0);\r\n        j += cog.nb;\r\n    }\r\n    /* only lower triangle is stored, so we need i > j */\r\n    if (i < j){k = i; i = j; j = k}\r\n    k = ((i - 1) * (i - 2)) / 2 + (j - 1);\r\n    cog.a[k / CHAR_BIT] |=\r\n        (1 << ((CHAR_BIT - 1) - k % CHAR_BIT));\r\n    cog.ne++;\r\n}\r\n\r\nfunction lpx_clique_cut(lp, cog, ind, val){\r\n\r\n    function is_edge(dsa, i, j) { return i == j ? 0 : i > j ? is_edge1(dsa, i, j) : is_edge1(dsa, j, i)}\r\n    function is_edge1(dsa, i, j) {return is_edge2(dsa, (i * (i - 1)) / 2 + j)}\r\n    function is_edge2(dsa, k){return (dsa.a[k / CHAR_BIT] & (1 << ((CHAR_BIT - 1) - k % CHAR_BIT)))}\r\n\r\n    function sub(dsa, ct, table, level, weight, l_weight){\r\n        var i, j, k, curr_weight, left_weight, p1, p2, newtable;\r\n        newtable = new Int32Array(dsa.n);\r\n        if (ct <= 0)\r\n        {  /* 0 or 1 elements left; include these */\r\n            if (ct == 0)\r\n            {  dsa.set[level++] = table[0];\r\n                weight += l_weight;\r\n            }\r\n            if (weight > dsa.record)\r\n            {  dsa.record = weight;\r\n                dsa.rec_level = level;\r\n                for (i = 0; i < level; i++) dsa.rec[i+1] = dsa.set[i];\r\n            }\r\n            return;\r\n        }\r\n        for (i = ct; i >= 0; i--)\r\n        {  if ((level == 0) && (i < ct)) return;\r\n            k = table[i];\r\n            if ((level > 0) && (dsa.clique[k] <= (dsa.record - weight)))\r\n                return; /* prune */\r\n            dsa.set[level] = k;\r\n            curr_weight = weight + dsa.wt[k+1];\r\n            l_weight -= dsa.wt[k+1];\r\n            if (l_weight <= (dsa.record - curr_weight))\r\n                return; /* prune */\r\n            p1 = 0;\r\n            p2 = 0;\r\n            left_weight = 0;\r\n            while (p2 < table + i)\r\n            {  j = table[p2]; p2++;\r\n                if (is_edge(dsa, j, k))\r\n                {  newtable[p1] = j; p1++;\r\n                    left_weight += dsa.wt[j+1];\r\n                }\r\n            }\r\n            if (left_weight <= (dsa.record - curr_weight)) continue;\r\n            sub(dsa, p1 - 1, newtable, level + 1, curr_weight, left_weight);\r\n        }\r\n    }\r\n\r\n    function wclique(_n, w, _a, sol){\r\n        var dsa = {};\r\n        var i, j, p, max_wt, max_nwt, wth, used, nwt, pos;\r\n        var timer;\r\n        dsa.n = _n;\r\n        dsa.wt = w;\r\n        dsa.a = _a;\r\n        dsa.record = 0;\r\n        dsa.rec_level = 0;\r\n        dsa.rec = sol;\r\n        dsa.clique = new Int32Array(dsa.n);\r\n        dsa.set = new Int32Array(dsa.n);\r\n        used = new Int32Array(dsa.n);\r\n        nwt = new Int32Array(dsa.n);\r\n        pos = new Int32Array(dsa.n);\r\n        /* start timer */\r\n        timer = xtime();\r\n        /* order vertices */\r\n        for (i = 0; i < dsa.n; i++)\r\n        {  nwt[i] = 0;\r\n            for (j = 0; j < dsa.n; j++)\r\n                if (is_edge(dsa, i, j)) nwt[i] += dsa.wt[j+1];\r\n        }\r\n        for (i = 0; i < dsa.n; i++)\r\n            used[i] = 0;\r\n        for (i = dsa.n-1; i >= 0; i--)\r\n        {  max_wt = -1;\r\n            max_nwt = -1;\r\n            for (j = 0; j < dsa.n; j++)\r\n            {  if ((!used[j]) && ((dsa.wt[j+1] > max_wt) || (dsa.wt[j+1] == max_wt\r\n                && nwt[j] > max_nwt)))\r\n            {  max_wt = dsa.wt[j+1];\r\n                max_nwt = nwt[j];\r\n                p = j;\r\n            }\r\n            }\r\n            pos[i] = p;\r\n            used[p] = 1;\r\n            for (j = 0; j < dsa.n; j++)\r\n                if ((!used[j]) && (j != p) && (is_edge(dsa, p, j)))\r\n                    nwt[j] -= dsa.wt[p+1];\r\n        }\r\n        /* main routine */\r\n        wth = 0;\r\n        for (i = 0; i < dsa.n; i++)\r\n        {  wth += dsa.wt[pos[i]+1];\r\n            sub(dsa, i, pos, 0, 0, wth);\r\n            dsa.clique[pos[i]] = dsa.record;\r\n            if (xdifftime(xtime(), timer) >= 5.0 - 0.001)\r\n            {  /* print current record and reset timer */\r\n                xprintf(\"level = \" + i+1 + \" (\" + dsa.n + \"); best = \" + dsa.record + \"\");\r\n                timer = xtime();\r\n            }\r\n        }\r\n        /* return the solution found */\r\n        for (i = 1; i <= dsa.rec_level; i++) sol[i]++;\r\n        return dsa.rec_level;\r\n    }\r\n\r\n    var n = lpx_get_num_cols(lp);\r\n    var j, t, v, card, temp, len = 0, w, sol;\r\n    var x, sum, b, vec;\r\n    /* allocate working arrays */\r\n    w = new Int32Array(1 + 2 * cog.nb);\r\n    sol = new Int32Array(1 + 2 * cog.nb);\r\n    vec = new Float64Array(1+n);\r\n    /* assign weights to vertices of the conflict graph */\r\n    for (t = 1; t <= cog.nb; t++)\r\n    {  j = cog.orig[t];\r\n        x = lpx_get_col_prim(lp, j);\r\n        temp = (100.0 * x + 0.5)|0;\r\n        if (temp < 0) temp = 0;\r\n        if (temp > 100) temp = 100;\r\n        w[t] = temp;\r\n        w[cog.nb + t] = 100 - temp;\r\n    }\r\n    /* find a clique of maximum weight */\r\n    card = wclique(2 * cog.nb, w, cog.a, sol);\r\n    /* compute the clique weight for unscaled values */\r\n    sum = 0.0;\r\n    for ( t = 1; t <= card; t++)\r\n    {  v = sol[t];\r\n        xassert(1 <= v && v <= 2 * cog.nb);\r\n        if (v <= cog.nb)\r\n        {  /* vertex v corresponds to binary variable x[j] */\r\n            j = cog.orig[v];\r\n            x = lpx_get_col_prim(lp, j);\r\n            sum += x;\r\n        }\r\n        else\r\n        {  /* vertex v corresponds to the complement of x[j] */\r\n            j = cog.orig[v - cog.nb];\r\n            x = lpx_get_col_prim(lp, j);\r\n            sum += 1.0 - x;\r\n        }\r\n    }\r\n    /* if the sum of binary variables and their complements in the\r\n     clique greater than 1, the clique cut is violated */\r\n    if (sum >= 1.01)\r\n    {  /* construct the inquality */\r\n        b = 1.0;\r\n        for (t = 1; t <= card; t++)\r\n        {  v = sol[t];\r\n            if (v <= cog.nb)\r\n            {  /* vertex v corresponds to binary variable x[j] */\r\n                j = cog.orig[v];\r\n                xassert(1 <= j && j <= n);\r\n                vec[j] += 1.0;\r\n            }\r\n            else\r\n            {  /* vertex v corresponds to the complement of x[j] */\r\n                j = cog.orig[v - cog.nb];\r\n                xassert(1 <= j && j <= n);\r\n                vec[j] -= 1.0;\r\n                b -= 1.0;\r\n            }\r\n        }\r\n        xassert(len == 0);\r\n        for (j = 1; j <= n; j++)\r\n        {  if (vec[j] != 0.0)\r\n        {  len++;\r\n            ind[len] = j; val[len] = vec[j];\r\n        }\r\n        }\r\n        ind[0] = 0; val[0] = b;\r\n    }\r\n    /* return to the calling program */\r\n    return len;\r\n}\r\n\r\nfunction ios_clq_init(tree){\r\n    /* initialize clique cut generator */\r\n    var mip = tree.mip;\r\n    xassert(mip != null);\r\n    return lpx_create_cog(mip);\r\n}\r\n\r\nfunction ios_clq_gen(tree, gen){\r\n    var n = lpx_get_num_cols(tree.mip);\r\n    var len, ind;\r\n    var val;\r\n    xassert(gen != null);\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    len = lpx_clique_cut(tree.mip, gen, ind, val);\r\n    if (len > 0)\r\n    {  /* xprintf(\"len = %d\", len); */\r\n        glp_ios_add_row(tree, null, GLP_RF_CLQ, 0, len, ind, val, GLP_UP, val[0]);\r\n    }\r\n}\r\n\r\nfunction ios_choose_var(T, callback){\r\n    var j;\r\n    if (T.parm.br_tech == GLP_BR_FFV)\r\n    {  /* branch on first fractional variable */\r\n        j = branch_first(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_LFV)\r\n    {  /* branch on last fractional variable */\r\n        j = branch_last(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_MFV)\r\n    {  /* branch on most fractional variable */\r\n        j = branch_mostf(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_DTH)\r\n    {  /* branch using the heuristic by Dreebeck and Tomlin */\r\n        j = branch_drtom(T, callback);\r\n    }\r\n    else if (T.parm.br_tech == GLP_BR_PCH)\r\n    {  /* hybrid pseudocost heuristic */\r\n        j = ios_pcost_branch(T, callback);\r\n    }\r\n    else\r\n        xassert(T != T);\r\n    return j;\r\n}\r\n\r\nfunction branch_first(T, callback){\r\n    var j, next;\r\n    var beta;\r\n    /* choose the column to branch on */\r\n    for (j = 1; j <= T.n; j++)\r\n        if (T.non_int[j]) break;\r\n    xassert(1 <= j && j <= T.n);\r\n    /* select the branch to be solved next */\r\n    beta = glp_get_col_prim(T.mip, j);\r\n    if (beta - Math.floor(beta) < Math.ceil(beta) - beta)\r\n        next = GLP_DN_BRNCH;\r\n    else\r\n        next = GLP_UP_BRNCH;\r\n    callback(next);\r\n    return j;\r\n}\r\n\r\nfunction branch_last(T, callback){\r\n    var j, next;\r\n    var beta;\r\n    /* choose the column to branch on */\r\n    for (j = T.n; j >= 1; j--)\r\n        if (T.non_int[j]) break;\r\n    xassert(1 <= j && j <= T.n);\r\n    /* select the branch to be solved next */\r\n    beta = glp_get_col_prim(T.mip, j);\r\n    if (beta - Math.floor(beta) < Math.ceil(beta) - beta)\r\n        next = GLP_DN_BRNCH;\r\n    else\r\n        next = GLP_UP_BRNCH;\r\n    callback(next);\r\n    return j;\r\n}\r\n\r\nfunction branch_mostf(T, callback){\r\n    var j, jj, next;\r\n    var beta, most, temp;\r\n    /* choose the column to branch on */\r\n    jj = 0; most = DBL_MAX;\r\n    for (j = 1; j <= T.n; j++)\r\n    {  if (T.non_int[j])\r\n    {  beta = glp_get_col_prim(T.mip, j);\r\n        temp = Math.floor(beta) + 0.5;\r\n        if (most > Math.abs(beta - temp))\r\n        {  jj = j; most = Math.abs(beta - temp);\r\n            if (beta < temp)\r\n                next = GLP_DN_BRNCH;\r\n            else\r\n                next = GLP_UP_BRNCH;\r\n        }\r\n    }\r\n    }\r\n    callback(next);\r\n    return jj;\r\n}\r\n\r\nfunction branch_drtom(T, callback){\r\n    var mip = T.mip;\r\n    var m = mip.m;\r\n    var n = mip.n;\r\n    var non_int = T.non_int;\r\n    var j, jj, k, t, next, kase, len, stat, ind;\r\n    var x, dk, alfa, delta_j, delta_k, delta_z, dz_dn, dz_up,\r\n        dd_dn, dd_up, degrad, val;\r\n    /* basic solution of LP relaxation must be optimal */\r\n    xassert(glp_get_status(mip) == GLP_OPT);\r\n    /* allocate working arrays */\r\n    ind = new Int32Array(1+n);\r\n    val = new Float64Array(1+n);\r\n    /* nothing has been chosen so far */\r\n    jj = 0; degrad = -1.0;\r\n    /* walk through the list of columns (structural variables) */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* if j-th column is not marked as fractional, skip it */\r\n        if (!non_int[j]) continue;\r\n        /* obtain (fractional) value of j-th column in basic solution\r\n         of LP relaxation */\r\n        x = glp_get_col_prim(mip, j);\r\n        /* since the value of j-th column is fractional, the column is\r\n         basic; compute corresponding row of the simplex table */\r\n        len = glp_eval_tab_row(mip, m+j, ind, val);\r\n        /* the following fragment computes a change in the objective\r\n         function: delta Z = new Z - old Z, where old Z is the\r\n         objective value in the current optimal basis, and new Z is\r\n         the objective value in the adjacent basis, for two cases:\r\n         1) if new upper bound ub' = Math.floor(x[j]) is introduced for\r\n         j-th column (down branch);\r\n         2) if new lower bound lb' = Math.ceil(x[j]) is introduced for\r\n         j-th column (up branch);\r\n         since in both cases the solution remaining dual feasible\r\n         becomes primal infeasible, one implicit simplex iteration\r\n         is performed to determine the change delta Z;\r\n         it is obvious that new Z, which is never better than old Z,\r\n         is a lower (minimization) or upper (maximization) bound of\r\n         the objective function for down- and up-branches. */\r\n        for (kase = -1; kase <= +1; kase += 2)\r\n        {  /* if kase < 0, the new upper bound of x[j] is introduced;\r\n         in this case x[j] should decrease in order to leave the\r\n         basis and go to its new upper bound */\r\n            /* if kase > 0, the new lower bound of x[j] is introduced;\r\n             in this case x[j] should increase in order to leave the\r\n             basis and go to its new lower bound */\r\n            /* apply the dual ratio test in order to determine which\r\n             auxiliary or structural variable should enter the basis\r\n             to keep dual feasibility */\r\n            k = glp_dual_rtest(mip, len, ind, val, kase, 1e-9);\r\n            if (k != 0) k = ind[k];\r\n            /* if no non-basic variable has been chosen, LP relaxation\r\n             of corresponding branch being primal infeasible and dual\r\n             unbounded has no primal feasible solution; in this case\r\n             the change delta Z is formally set to infinity */\r\n            if (k == 0)\r\n            {  delta_z =\r\n                (T.mip.dir == GLP_MIN ? +DBL_MAX : -DBL_MAX);\r\n            } else {\r\n                /* row of the simplex table that corresponds to non-basic\r\n                 variable x[k] choosen by the dual ratio test is:\r\n                 x[j] = ... + alfa * x[k] + ...\r\n                 where alfa is the influence coefficient (an element of\r\n                 the simplex table row) */\r\n                /* determine the coefficient alfa */\r\n                for (t = 1; t <= len; t++) if (ind[t] == k) break;\r\n                xassert(1 <= t && t <= len);\r\n                alfa = val[t];\r\n                /* since in the adjacent basis the variable x[j] becomes\r\n                 non-basic, knowing its value in the current basis we can\r\n                 determine its change delta x[j] = new x[j] - old x[j] */\r\n                delta_j = (kase < 0 ? Math.floor(x) : Math.ceil(x)) - x;\r\n                /* and knowing the coefficient alfa we can determine the\r\n                 corresponding change delta x[k] = new x[k] - old x[k],\r\n                 where old x[k] is a value of x[k] in the current basis,\r\n                 and new x[k] is a value of x[k] in the adjacent basis */\r\n                delta_k = delta_j / alfa;\r\n                /* Tomlin noticed that if the variable x[k] is of integer\r\n                 kind, its change cannot be less (eventually) than one in\r\n                 the magnitude */\r\n                if (k > m && glp_get_col_kind(mip, k-m) != GLP_CV)\r\n                {  /* x[k] is structural integer variable */\r\n                    if (Math.abs(delta_k - Math.floor(delta_k + 0.5)) > 1e-3)\r\n                    {  if (delta_k > 0.0)\r\n                        delta_k = Math.ceil(delta_k);  /* +3.14 . +4 */\r\n                    else\r\n                        delta_k = Math.floor(delta_k); /* -3.14 . -4 */\r\n                    }\r\n                }\r\n                /* now determine the status and reduced cost of x[k] in the\r\n                 current basis */\r\n                if (k <= m)\r\n                {  stat = glp_get_row_stat(mip, k);\r\n                    dk = glp_get_row_dual(mip, k);\r\n                }\r\n                else\r\n                {  stat = glp_get_col_stat(mip, k-m);\r\n                    dk = glp_get_col_dual(mip, k-m);\r\n                }\r\n                /* if the current basis is dual degenerate, some reduced\r\n                 costs which are close to zero may have wrong sign due to\r\n                 round-off errors, so correct the sign of d[k] */\r\n                switch (T.mip.dir)\r\n                {  case GLP_MIN:\r\n                    if (stat == GLP_NL && dk < 0.0 ||\r\n                        stat == GLP_NU && dk > 0.0 ||\r\n                        stat == GLP_NF) dk = 0.0;\r\n                    break;\r\n                    case GLP_MAX:\r\n                        if (stat == GLP_NL && dk > 0.0 ||\r\n                            stat == GLP_NU && dk < 0.0 ||\r\n                            stat == GLP_NF) dk = 0.0;\r\n                        break;\r\n                    default:\r\n                        xassert(T != T);\r\n                }\r\n                /* now knowing the change of x[k] and its reduced cost d[k]\r\n                 we can compute the corresponding change in the objective\r\n                 function delta Z = new Z - old Z = d[k] * delta x[k];\r\n                 note that due to Tomlin's modification new Z can be even\r\n                 worse than in the adjacent basis */\r\n                delta_z = dk * delta_k;\r\n            }\r\n\r\n            /* new Z is never better than old Z, therefore the change\r\n            delta Z is always non-negative (in case of minimization)\r\n            or non-positive (in case of maximization) */\r\n               switch (T.mip.dir)\r\n               {  case GLP_MIN: xassert(delta_z >= 0.0); break;\r\n                   case GLP_MAX: xassert(delta_z <= 0.0); break;\r\n                   default: xassert(T != T);\r\n               }\r\n            /* save the change in the objective fnction for down- and\r\n               up-branches, respectively */\r\n            if (kase < 0) dz_dn = delta_z; else dz_up = delta_z;\r\n        }\r\n        /* thus, in down-branch no integer feasible solution can be\r\n         better than Z + dz_dn, and in up-branch no integer feasible\r\n         solution can be better than Z + dz_up, where Z is value of\r\n         the objective function in the current basis */\r\n        /* following the heuristic by Driebeck and Tomlin we choose a\r\n         column (i.e. structural variable) which provides largest\r\n         degradation of the objective function in some of branches;\r\n         besides, we select the branch with smaller degradation to\r\n         be solved next and keep other branch with larger degradation\r\n         in the active list hoping to minimize the number of further\r\n         backtrackings */\r\n        if (degrad < Math.abs(dz_dn) || degrad < Math.abs(dz_up))\r\n        {  jj = j;\r\n            if (Math.abs(dz_dn) < Math.abs(dz_up))\r\n            {  /* select down branch to be solved next */\r\n                next = GLP_DN_BRNCH;\r\n                degrad = Math.abs(dz_up);\r\n            }\r\n            else\r\n            {  /* select up branch to be solved next */\r\n                next = GLP_UP_BRNCH;\r\n                degrad = Math.abs(dz_dn);\r\n            }\r\n            /* save the objective changes for printing */\r\n            dd_dn = dz_dn; dd_up = dz_up;\r\n            /* if down- or up-branch has no feasible solution, we does\r\n             not need to consider other candidates (in principle, the\r\n             corresponding branch could be pruned right now) */\r\n            if (degrad == DBL_MAX) break;\r\n        }\r\n    }\r\n    /* something must be chosen */\r\n    xassert(1 <= jj && jj <= n);\r\n    if (degrad < 1e-6 * (1.0 + 0.001 * Math.abs(mip.obj_val)))\r\n    {  jj = branch_mostf(T, callback);\r\n        return jj;\r\n    }\r\n    if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n    {  xprintf(\"branch_drtom: column \" + jj + \" chosen to branch on\");\r\n        if (Math.abs(dd_dn) == DBL_MAX)\r\n            xprintf(\"branch_drtom: down-branch is infeasible\");\r\n        else\r\n            xprintf(\"branch_drtom: down-branch bound is \" + (lpx_get_obj_val(mip) + dd_dn) + \"\");\r\n        if (Math.abs(dd_up) == DBL_MAX)\r\n            xprintf(\"branch_drtom: up-branch   is infeasible\");\r\n        else\r\n            xprintf(\"branch_drtom: up-branch   bound is \" + (lpx_get_obj_val(mip) + dd_up) + \"\");\r\n    }\r\n    callback(next);\r\n    return jj;\r\n}\r\n\r\nfunction ios_pcost_init(tree){\r\n    /* initialize working data used on pseudocost branching */\r\n    var n = tree.n, j;\r\n    var csa = {};\r\n    csa.dn_cnt = new Int32Array(1+n);\r\n    csa.dn_sum = new Float64Array(1+n);\r\n    csa.up_cnt = new Int32Array(1+n);\r\n    csa.up_sum = new Float64Array(1+n);\r\n    for (j = 1; j <= n; j++)\r\n    {  csa.dn_cnt[j] = csa.up_cnt[j] = 0;\r\n        csa.dn_sum[j] = csa.up_sum[j] = 0.0;\r\n    }\r\n    return csa;\r\n}\r\n\r\n\r\nfunction ios_pcost_update(tree){\r\n    /* update history information for pseudocost branching */\r\n    /* this routine is called every time when LP relaxation of the\r\n     current subproblem has been solved to optimality with all lazy\r\n     and cutting plane constraints included */\r\n    var j;\r\n    var dx, dz, psi;\r\n    var csa = tree.pcost;\r\n    xassert(csa != null);\r\n    xassert(tree.curr != null);\r\n    /* if the current subproblem is the root, skip updating */\r\n    if (tree.curr.up == null) return;\r\n    /* determine branching variable x[j], which was used in the\r\n     parent subproblem to create the current subproblem */\r\n    j = tree.curr.up.br_var;\r\n    xassert(1 <= j && j <= tree.n);\r\n    /* determine the change dx[j] = new x[j] - old x[j],\r\n     where new x[j] is a value of x[j] in optimal solution to LP\r\n     relaxation of the current subproblem, old x[j] is a value of\r\n     x[j] in optimal solution to LP relaxation of the parent\r\n     subproblem */\r\n    dx = tree.mip.col[j].prim - tree.curr.up.br_val;\r\n    xassert(dx != 0.0);\r\n    /* determine corresponding change dz = new dz - old dz in the\r\n     objective function value */\r\n    dz = tree.mip.obj_val - tree.curr.up.lp_obj;\r\n    /* determine per unit degradation of the objective function */\r\n    psi = Math.abs(dz / dx);\r\n    /* update history information */\r\n    if (dx < 0.0)\r\n    {  /* the current subproblem is down-branch */\r\n        csa.dn_cnt[j]++;\r\n        csa.dn_sum[j] += psi;\r\n    }\r\n    else /* dx > 0.0 */\r\n    {  /* the current subproblem is up-branch */\r\n        csa.up_cnt[j]++;\r\n        csa.up_sum[j] += psi;\r\n    }\r\n}\r\n\r\nfunction ios_pcost_free(tree){\r\n    /* free working area used on pseudocost branching */\r\n    var csa = tree.pcost;\r\n    xassert(csa != null);\r\n    tree.pcost = null;\r\n}\r\n\r\nfunction ios_pcost_branch(T, callback){\r\n    function eval_degrad(P, j, bnd){\r\n        /* compute degradation of the objective on fixing x[j] at given\r\n         value with a limited number of dual simplex iterations */\r\n        /* this routine fixes column x[j] at specified value bnd,\r\n         solves resulting LP, and returns a lower bound to degradation\r\n         of the objective, degrad >= 0 */\r\n        var lp;\r\n        var ret;\r\n        var degrad;\r\n        /* the current basis must be optimal */\r\n        xassert(glp_get_status(P) == GLP_OPT);\r\n        /* create a copy of P */\r\n        lp = glp_create_prob();\r\n        glp_copy_prob(lp, P, 0);\r\n        /* fix column x[j] at specified value */\r\n        glp_set_col_bnds(lp, j, GLP_FX, bnd, bnd);\r\n        /* try to solve resulting LP */\r\n        var parm = new SMCP();\r\n        //glp_init_smcp(parm);\r\n        parm.msg_lev = GLP_MSG_OFF;\r\n        parm.meth = GLP_DUAL;\r\n        parm.it_lim = 30;\r\n        parm.out_dly = 1000;\r\n        parm.meth = GLP_DUAL;\r\n        ret = glp_simplex(lp, parm);\r\n        if (ret == 0 || ret == GLP_EITLIM)\r\n        {  if (glp_get_prim_stat(lp) == GLP_NOFEAS)\r\n        {  /* resulting LP has no primal feasible solution */\r\n            degrad = DBL_MAX;\r\n        }\r\n        else if (glp_get_dual_stat(lp) == GLP_FEAS)\r\n        {  /* resulting basis is optimal or at least dual feasible,\r\n         so we have the correct lower bound to degradation */\r\n            if (P.dir == GLP_MIN)\r\n                degrad = lp.obj_val - P.obj_val;\r\n            else if (P.dir == GLP_MAX)\r\n                degrad = P.obj_val - lp.obj_val;\r\n            else\r\n                xassert(P != P);\r\n            /* degradation cannot be negative by definition */\r\n            /* note that the lower bound to degradation may be close\r\n             to zero even if its exact value is zero due to round-off\r\n             errors on computing the objective value */\r\n            if (degrad < 1e-6 * (1.0 + 0.001 * Math.abs(P.obj_val)))\r\n                degrad = 0.0;\r\n        }\r\n        else\r\n        {  /* the final basis reported by the simplex solver is dual\r\n         infeasible, so we cannot determine a non-trivial lower\r\n         bound to degradation */\r\n            degrad = 0.0;\r\n        }\r\n        }\r\n        else\r\n        {  /* the simplex solver failed */\r\n            degrad = 0.0;\r\n        }\r\n        return degrad;\r\n    }\r\n\r\n    function eval_psi(T, j, brnch){\r\n        /* compute estimation of pseudocost of variable x[j] for down-\r\n         or up-branch */\r\n        var csa = T.pcost;\r\n        var beta, degrad, psi;\r\n        xassert(csa != null);\r\n        xassert(1 <= j && j <= T.n);\r\n        if (brnch == GLP_DN_BRNCH)\r\n        {  /* down-branch */\r\n            if (csa.dn_cnt[j] == 0)\r\n            {  /* initialize down pseudocost */\r\n                beta = T.mip.col[j].prim;\r\n                degrad = eval_degrad(T.mip, j, Math.floor(beta));\r\n                if (degrad == DBL_MAX)\r\n                {  psi = DBL_MAX;\r\n                    return psi;\r\n                }\r\n                csa.dn_cnt[j] = 1;\r\n                csa.dn_sum[j] = degrad / (beta - Math.floor(beta));\r\n            }\r\n            psi = csa.dn_sum[j] / csa.dn_cnt[j];\r\n        }\r\n        else if (brnch == GLP_UP_BRNCH)\r\n        {  /* up-branch */\r\n            if (csa.up_cnt[j] == 0)\r\n            {  /* initialize up pseudocost */\r\n                beta = T.mip.col[j].prim;\r\n                degrad = eval_degrad(T.mip, j, Math.ceil(beta));\r\n                if (degrad == DBL_MAX)\r\n                {  psi = DBL_MAX;\r\n                    return psi;\r\n                }\r\n                csa.up_cnt[j] = 1;\r\n                csa.up_sum[j] = degrad / (Math.ceil(beta) - beta);\r\n            }\r\n            psi = csa.up_sum[j] / csa.up_cnt[j];\r\n        }\r\n        else\r\n            xassert(brnch != brnch);\r\n        return psi;\r\n    }\r\n\r\n    function progress(T){\r\n        /* display progress of pseudocost initialization */\r\n        var csa = T.pcost;\r\n        var j, nv = 0, ni = 0;\r\n        for (j = 1; j <= T.n; j++)\r\n        {  if (glp_ios_can_branch(T, j))\r\n        {  nv++;\r\n            if (csa.dn_cnt[j] > 0 && csa.up_cnt[j] > 0) ni++;\r\n        }\r\n        }\r\n        xprintf(\"Pseudocosts initialized for \" + ni + \" of \" + nv + \" variables\");\r\n    }\r\n\r\n    /* choose branching variable with pseudocost branching */\r\n    var t = xtime();\r\n    var j, jjj, sel;\r\n    var beta, psi, d1, d2, d, dmax;\r\n    /* initialize the working arrays */\r\n    if (T.pcost == null)\r\n        T.pcost = ios_pcost_init(T);\r\n    /* nothing has been chosen so far */\r\n    jjj = 0; dmax = -1.0;\r\n    /* go through the list of branching candidates */\r\n    for (j = 1; j <= T.n; j++)\r\n    {  if (!glp_ios_can_branch(T, j)) continue;\r\n        /* determine primal value of x[j] in optimal solution to LP\r\n         relaxation of the current subproblem */\r\n        beta = T.mip.col[j].prim;\r\n        /* estimate pseudocost of x[j] for down-branch */\r\n        psi = eval_psi(T, j, GLP_DN_BRNCH);\r\n        if (psi == DBL_MAX)\r\n        {  /* down-branch has no primal feasible solution */\r\n            jjj = j; sel = GLP_DN_BRNCH;\r\n            callback(sel);\r\n            return jjj;\r\n        }\r\n        /* estimate degradation of the objective for down-branch */\r\n        d1 = psi * (beta - Math.floor(beta));\r\n        /* estimate pseudocost of x[j] for up-branch */\r\n        psi = eval_psi(T, j, GLP_UP_BRNCH);\r\n        if (psi == DBL_MAX)\r\n        {  /* up-branch has no primal feasible solution */\r\n            jjj = j; sel = GLP_UP_BRNCH;\r\n            callback(sel);\r\n            return jjj;\r\n        }\r\n        /* estimate degradation of the objective for up-branch */\r\n        d2 = psi * (Math.ceil(beta) - beta);\r\n        /* determine d = max(d1, d2) */\r\n        d = (d1 > d2 ? d1 : d2);\r\n        /* choose x[j] which provides maximal estimated degradation of\r\n         the objective either in down- or up-branch */\r\n        if (dmax < d)\r\n        {  dmax = d;\r\n            jjj = j;\r\n            /* continue the search from a subproblem, where degradation\r\n             is less than in other one */\r\n            sel = (d1 <= d2 ? GLP_DN_BRNCH : GLP_UP_BRNCH);\r\n        }\r\n        /* display progress of pseudocost initialization */\r\n        if (T.parm.msg_lev >= GLP_ON)\r\n        {  if (xdifftime(xtime(), t) >= 10.0)\r\n        {  progress(T);\r\n            t = xtime();\r\n        }\r\n        }\r\n    }\r\n    if (dmax == 0.0)\r\n    {  /* no degradation is indicated; choose a variable having most\r\n     fractional value */\r\n        jjj = branch_mostf(T, callback);\r\n        return jjj;\r\n    }\r\n    callback(sel);\r\n    return jjj;\r\n}\r\n\r\nfunction ios_feas_pump(T){\r\n    var P = T.mip;\r\n    var n = P.n;\r\n    var lp = null;\r\n    var var_ = null;\r\n    var rand = null;\r\n    var col;\r\n    var parm;\r\n    var j, k, new_x, nfail, npass, nv, ret, stalling;\r\n    var dist, tol;\r\n\r\n    var\r\n        start = 0,\r\n        more = 1,\r\n        pass = 2,\r\n        loop = 3,\r\n        skip = 4,\r\n        done = 5;\r\n\r\n    var label = start;\r\n\r\n    while (true){\r\n        var go_to = null;\r\n        switch (label){\r\n            case start:\r\n                xassert(glp_get_status(P) == GLP_OPT);\r\n                /* this heuristic is applied only once on the root level */\r\n                if (!(T.curr.level == 0 && T.curr.solved == 1)){go_to = done; break}\r\n                /* determine number of binary variables */\r\n                nv = 0;\r\n                for (j = 1; j <= n; j++)\r\n                {  col = P.col[j];\r\n                    /* if x[j] is continuous, skip it */\r\n                    if (col.kind == GLP_CV) continue;\r\n                    /* if x[j] is fixed, skip it */\r\n                    if (col.type == GLP_FX) continue;\r\n                    /* x[j] is non-fixed integer */\r\n                    xassert(col.kind == GLP_IV);\r\n                    if (col.type == GLP_DB && col.lb == 0.0 && col.ub == 1.0)\r\n                    {  /* x[j] is binary */\r\n                        nv++;\r\n                    }\r\n                    else\r\n                    {  /* x[j] is general integer */\r\n                        if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                            xprintf(\"FPUMP heuristic cannot be applied due to genera\"+\r\n                                \"l integer variables\");\r\n                        go_to = done;\r\n                        break;\r\n                    }\r\n                }\r\n                if (go_to != null) break;\r\n\r\n                /* there must be at least one binary variable */\r\n                if (nv == 0) {go_to = done; break}\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Applying FPUMP heuristic...\");\r\n                /* build the list of binary variables */\r\n                var_ = new Array(1+nv);\r\n                xfillObjArr(var_, 1, nv);\r\n                k = 0;\r\n                for (j = 1; j <= n; j++)\r\n                {  col = P.col[j];\r\n                    if (col.kind == GLP_IV && col.type == GLP_DB)\r\n                        var_[++k].j = j;\r\n                }\r\n                xassert(k == nv);\r\n                /* create working problem object */\r\n                lp = glp_create_prob();\r\n            case more:\r\n                /* copy the original problem object to keep it intact */\r\n                glp_copy_prob(lp, P, GLP_OFF);\r\n                /* we are interested to find an integer feasible solution, which\r\n                 is better than the best known one */\r\n                if (P.mip_stat == GLP_FEAS)\r\n                {  var ind;\r\n                    var val, bnd;\r\n                    /* add a row and make it identical to the objective row */\r\n                    glp_add_rows(lp, 1);\r\n                    ind = new Int32Array(1+n);\r\n                    val = new Float64Array(1+n);\r\n                    for (j = 1; j <= n; j++)\r\n                    {  ind[j] = j;\r\n                        val[j] = P.col[j].coef;\r\n                    }\r\n                    glp_set_mat_row(lp, lp.m, n, ind, val);\r\n\r\n                    /* introduce upper (minimization) or lower (maximization)\r\n                     bound to the original objective function; note that this\r\n                     additional constraint is not violated at the optimal point\r\n                     to LP relaxation */\r\n                    bnd = 0.1 * P.obj_val + 0.9 * P.mip_obj;\r\n                    /* xprintf(\"bnd = %f\", bnd); */\r\n                    if (P.dir == GLP_MIN)\r\n                        glp_set_row_bnds(lp, lp.m, GLP_UP, 0.0, bnd - P.c0);\r\n                    else if (P.dir == GLP_MAX)\r\n                        glp_set_row_bnds(lp, lp.m, GLP_LO, bnd - P.c0, 0.0);\r\n                    else\r\n                        xassert(P != P);\r\n                }\r\n                /* reset pass count */\r\n                npass = 0;\r\n                /* invalidate the rounded point */\r\n                for (k = 1; k <= nv; k++)\r\n                    var_[k].x = -1;\r\n            case pass:\r\n                /* next pass starts here */\r\n                npass++;\r\n                if (T.parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"Pass \" + npass + \"\");\r\n                /* initialize minimal distance between the basic point and the\r\n                 rounded one obtained during this pass */\r\n                dist = DBL_MAX;\r\n                /* reset failure count (the number of succeeded iterations failed\r\n                 to improve the distance) */\r\n                nfail = 0;\r\n                /* if it is not the first pass, perturb the last rounded point\r\n                 rather than construct it from the basic solution */\r\n                if (npass > 1)\r\n                {  var rho, temp;\r\n                    if (rand == null)\r\n                        rand = rng_create_rand();\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  j = var_[k].j;\r\n                        col = lp.col[j];\r\n                        rho = rng_uniform(rand, -0.3, 0.7);\r\n                        if (rho < 0.0) rho = 0.0;\r\n                        temp = Math.abs(var_[k].x - col.prim);\r\n                        if (temp + rho > 0.5) var_[k].x = 1 - var_[k].x;\r\n                    }\r\n                    go_to = skip;\r\n                    break;\r\n                }\r\n            case loop:\r\n                /* innermost loop begins here */\r\n                /* round basic solution (which is assumed primal feasible) */\r\n                stalling = 1;\r\n                for (k = 1; k <= nv; k++)\r\n                {  col = lp.col[var_[k].j];\r\n                    if (col.prim < 0.5)\r\n                    {  /* rounded value is 0 */\r\n                        new_x = 0;\r\n                    }\r\n                    else\r\n                    {  /* rounded value is 1 */\r\n                        new_x = 1;\r\n                    }\r\n                    if (var_[k].x != new_x)\r\n                    {  stalling = 0;\r\n                        var_[k].x = new_x;\r\n                    }\r\n                }\r\n                /* if the rounded point has not changed (stalling), choose and\r\n                 flip some its entries heuristically */\r\n                if (stalling)\r\n                {  /* compute d[j] = |x[j] - round(x[j])| */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  col = lp.col[var_[k].j];\r\n                        var_[k].d = Math.abs(col.prim - var_[k].x);\r\n                    }\r\n                    /* sort the list of binary variables by descending d[j] */\r\n                    xqsort(var_, 1, nv,\r\n                        function(vx, vy){\r\n                            /* comparison routine */\r\n                            if (vx.d > vy.d)\r\n                                return -1;\r\n                            else if (vx.d < vy.d)\r\n                                return +1;\r\n                            else\r\n                                return 0;\r\n                        }\r\n                    );\r\n                    /* choose and flip some rounded components */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  if (k >= 5 && var_[k].d < 0.35 || k >= 10) break;\r\n                        var_[k].x = 1 - var_[k].x;\r\n                    }\r\n                }\r\n            case skip:\r\n                /* check if the time limit has been exhausted */\r\n                if (T.parm.tm_lim < INT_MAX &&\r\n                    (T.parm.tm_lim - 1) <=\r\n                        1000.0 * xdifftime(xtime(), T.tm_beg)) {go_to = done; break}\r\n                /* build the objective, which is the distance between the current\r\n                 (basic) point and the rounded one */\r\n                lp.dir = GLP_MIN;\r\n                lp.c0 = 0.0;\r\n                for (j = 1; j <= n; j++)\r\n                    lp.col[j].coef = 0.0;\r\n                for (k = 1; k <= nv; k++)\r\n                {  j = var_[k].j;\r\n                    if (var_[k].x == 0)\r\n                        lp.col[j].coef = +1.0;\r\n                    else\r\n                    {  lp.col[j].coef = -1.0;\r\n                        lp.c0 += 1.0;\r\n                    }\r\n                }\r\n                /* minimize the distance with the simplex method */\r\n                parm = new SMCP();\r\n                //glp_init_smcp(parm);\r\n                if (T.parm.msg_lev <= GLP_MSG_ERR)\r\n                    parm.msg_lev = T.parm.msg_lev;\r\n                else if (T.parm.msg_lev <= GLP_MSG_ALL)\r\n                {  parm.msg_lev = GLP_MSG_ON;\r\n                    parm.out_dly = 10000;\r\n                }\r\n                ret = glp_simplex(lp, parm);\r\n                if (ret != 0)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: glp_simplex returned \" + ret + \"\");\r\n                    go_to = done; break;\r\n                }\r\n                ret = glp_get_status(lp);\r\n                if (ret != GLP_OPT)\r\n                {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: glp_get_status returned \" + ret + \"\");\r\n                    go_to = done; break;\r\n                }\r\n                if (T.parm.msg_lev >= GLP_MSG_DBG)\r\n                    xprintf(\"delta = \" + lp.obj_val + \"\");\r\n                /* check if the basic solution is integer feasible; note that it\r\n                 may be so even if the minimial distance is positive */\r\n                tol = 0.3 * T.parm.tol_int;\r\n                for (k = 1; k <= nv; k++)\r\n                {  col = lp.col[var_[k].j];\r\n                    if (tol < col.prim && col.prim < 1.0 - tol) break;\r\n                }\r\n                if (k > nv)\r\n                {  /* okay; the basic solution seems to be integer feasible */\r\n                    var x = new Float64Array(1+n);\r\n                    for (j = 1; j <= n; j++)\r\n                    {  x[j] = lp.col[j].prim;\r\n                        if (P.col[j].kind == GLP_IV) x[j] = Math.floor(x[j] + 0.5);\r\n                    }\r\n                    /* reset direction and right-hand side of objective */\r\n                    lp.c0  = P.c0;\r\n                    lp.dir = P.dir;\r\n                    /* fix integer variables */\r\n                    for (k = 1; k <= nv; k++)\r\n                    {  lp.col[var_[k].j].lb   = x[var_[k].j];\r\n                        lp.col[var_[k].j].ub   = x[var_[k].j];\r\n                        lp.col[var_[k].j].type = GLP_FX;\r\n                    }\r\n                    /* copy original objective function */\r\n                    for (j = 1; j <= n; j++)\r\n                        lp.col[j].coef = P.col[j].coef;\r\n                    /* solve original LP and copy result */\r\n                    ret = glp_simplex(lp, parm);\r\n                    if (ret != 0)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"Warning: glp_simplex returned \" + ret + \"\");\r\n                        go_to = done; break;\r\n                    }\r\n                    ret = glp_get_status(lp);\r\n                    if (ret != GLP_OPT)\r\n                    {  if (T.parm.msg_lev >= GLP_MSG_ERR)\r\n                        xprintf(\"Warning: glp_get_status returned \" + ret + \"\");\r\n                        go_to = done; break;\r\n                    }\r\n                    for (j = 1; j <= n; j++)\r\n                        if (P.col[j].kind != GLP_IV) x[j] = lp.col[j].prim;\r\n                    ret = glp_ios_heur_sol(T, x);\r\n                    if (ret == 0)\r\n                    {  /* the integer solution is accepted */\r\n                        if (ios_is_hopeful(T, T.curr.bound))\r\n                        {  /* it is reasonable to apply the heuristic once again */\r\n                            go_to = more; break;\r\n                        }\r\n                        else\r\n                        {  /* the best known integer feasible solution just found\r\n                         is close to optimal solution to LP relaxation */\r\n                            go_to = done; break;\r\n                        }\r\n                    }\r\n                }\r\n                /* the basic solution is fractional */\r\n                if (dist == DBL_MAX ||\r\n                    lp.obj_val <= dist - 1e-6 * (1.0 + dist))\r\n                {  /* the distance is reducing */\r\n                    nfail = 0; dist = lp.obj_val;\r\n                }\r\n                else\r\n                {  /* improving the distance failed */\r\n                    nfail++;\r\n                }\r\n                if (nfail < 3) {go_to = loop; break}\r\n                if (npass < 5) {go_to = pass; break}\r\n            case done:\r\n\r\n\r\n        }\r\n        if (go_to == null) break;\r\n        label = go_to;\r\n    }\r\n}\r\n\r\nfunction ios_process_cuts(T){\r\n\r\n    function parallel(a, b, work){\r\n        var aij;\r\n        var s = 0.0, sa = 0.0, sb = 0.0, temp;\r\n        for (aij = a.ptr; aij != null; aij = aij.next)\r\n        {  work[aij.j] = aij.val;\r\n            sa += aij.val * aij.val;\r\n        }\r\n        for (aij = b.ptr; aij != null; aij = aij.next)\r\n        {  s += work[aij.j] * aij.val;\r\n            sb += aij.val * aij.val;\r\n        }\r\n        for (aij = a.ptr; aij != null; aij = aij.next)\r\n            work[aij.j] = 0.0;\r\n        temp = Math.sqrt(sa) * Math.sqrt(sb);\r\n        if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\r\n        return s / temp;\r\n    }\r\n\r\n    var pool;\r\n    var cut;\r\n    var aij;\r\n    var info;\r\n    var k, kk, max_cuts, len, ret, ind;\r\n    var val, work;\r\n    /* the current subproblem must exist */\r\n    xassert(T.curr != null);\r\n    /* the pool must exist and be non-empty */\r\n    pool = T.local;\r\n    xassert(pool != null);\r\n    xassert(pool.size > 0);\r\n    /* allocate working arrays */\r\n    info = new Array(1+pool.size);\r\n    ind = new Int32Array(1+T.n);\r\n    val = new Float64Array(1+T.n);\r\n    work = new Float64Array(1+T.n);\r\n    /* build the list of cuts stored in the cut pool */\r\n    for (k = 0, cut = pool.head; cut != null; cut = cut.next){\r\n        k++; info[k].cut = cut; info[k].flag = 0;\r\n    }\r\n    xassert(k == pool.size);\r\n    /* estimate efficiency of all cuts in the cut pool */\r\n    for (k = 1; k <= pool.size; k++)\r\n    {  var temp, dy = null, dz = null;\r\n        cut = info[k].cut;\r\n        /* build the vector of cut coefficients and compute its\r\n         Euclidean norm */\r\n        len = 0; temp = 0.0;\r\n        for (aij = cut.ptr; aij != null; aij = aij.next)\r\n        {  xassert(1 <= aij.j && aij.j <= T.n);\r\n            len++; ind[len] = aij.j; val[len] = aij.val;\r\n            temp += aij.val * aij.val;\r\n        }\r\n        if (temp < DBL_EPSILON * DBL_EPSILON) temp = DBL_EPSILON;\r\n        /* transform the cut to express it only through non-basic\r\n         (auxiliary and structural) variables */\r\n        len = glp_transform_row(T.mip, len, ind, val);\r\n        /* determine change in the cut value and in the objective\r\n         value for the adjacent basis by simulating one step of the\r\n         dual simplex */\r\n        ret = _glp_analyze_row(T.mip, len, ind, val, cut.type,\r\n            cut.rhs, 1e-9,  function(piv, x, dx, y, dy_, dz_){dy = dy_; dz = dz_});\r\n        /* determine normalized residual and lower bound to objective\r\n         degradation */\r\n        if (ret == 0)\r\n        {  info[k].eff = Math.abs(dy) / Math.sqrt(temp);\r\n            /* if some reduced costs violates (slightly) their zero\r\n             bounds (i.e. have wrong signs) due to round-off errors,\r\n             dz also may have wrong sign being close to zero */\r\n            if (T.mip.dir == GLP_MIN)\r\n            {  if (dz < 0.0) dz = 0.0;\r\n                info[k].deg = + dz;\r\n            }\r\n            else /* GLP_MAX */\r\n            {  if (dz > 0.0) dz = 0.0;\r\n                info[k].deg = - dz;\r\n            }\r\n        }\r\n        else if (ret == 1)\r\n        {  /* the constraint is not violated at the current point */\r\n            info[k].eff = info[k].deg = 0.0;\r\n        }\r\n        else if (ret == 2)\r\n        {  /* no dual feasible adjacent basis exists */\r\n            info[k].eff = 1.0;\r\n            info[k].deg = DBL_MAX;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n        /* if the degradation is too small, just ignore it */\r\n        if (info[k].deg < 0.01) info[k].deg = 0.0;\r\n    }\r\n    /* sort the list of cuts by decreasing objective degradation and\r\n     then by decreasing efficacy */\r\n\r\n\r\n\r\n    xqsort(info, 1, pool.size,\r\n        function(info1, info2){\r\n            if (info1.deg == 0.0 && info2.deg == 0.0)\r\n            {  if (info1.eff > info2.eff) return -1;\r\n                if (info1.eff < info2.eff) return +1;\r\n            }\r\n            else\r\n            {  if (info1.deg > info2.deg) return -1;\r\n                if (info1.deg < info2.deg) return +1;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    /* only first (most efficient) max_cuts in the list are qualified\r\n     as candidates to be added to the current subproblem */\r\n    max_cuts = (T.curr.level == 0 ? 90 : 10);\r\n    if (max_cuts > pool.size) max_cuts = pool.size;\r\n    /* add cuts to the current subproblem */\r\n    for (k = 1; k <= max_cuts; k++)\r\n    {  var i;\r\n        /* if this cut seems to be inefficient, skip it */\r\n        if (info[k].deg < 0.01 && info[k].eff < 0.01) continue;\r\n        /* if the angle between this cut and every other cut included\r\n         in the current subproblem is small, skip this cut */\r\n        for (kk = 1; kk < k; kk++)\r\n        {  if (info[kk].flag)\r\n        {  if (parallel(info[k].cut, info[kk].cut, work) > 0.90)\r\n            break;\r\n        }\r\n        }\r\n        if (kk < k) continue;\r\n        /* add this cut to the current subproblem */\r\n        cut = info[k].cut; info[k].flag = 1;\r\n        i = glp_add_rows(T.mip, 1);\r\n        if (cut.name != null)\r\n            glp_set_row_name(T.mip, i, cut.name);\r\n        xassert(T.mip.row[i].origin == GLP_RF_CUT);\r\n        T.mip.row[i].klass = cut.klass;\r\n        len = 0;\r\n        for (aij = cut.ptr; aij != null; aij = aij.next){\r\n            len++; ind[len] = aij.j; val[len] = aij.val;\r\n        }\r\n        glp_set_mat_row(T.mip, i, len, ind, val);\r\n        xassert(cut.type == GLP_LO || cut.type == GLP_UP);\r\n        glp_set_row_bnds(T.mip, i, cut.type, cut.rhs, cut.rhs);\r\n    }\r\n}\r\n\r\n\r\nfunction ios_choose_node(T){\r\n    function most_feas(T){\r\n        /* select subproblem whose parent has minimal sum of integer\r\n         infeasibilities */\r\n        var node;\r\n        var p;\r\n        var best;\r\n        p = 0; best = DBL_MAX;\r\n        for (node = T.head; node != null; node = node.next)\r\n        {  xassert(node.up != null);\r\n            if (best > node.up.ii_sum){\r\n                p = node.p; best = node.up.ii_sum;\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function best_proj(T){\r\n        /* select subproblem using the best projection heuristic */\r\n        var root, node;\r\n        var p;\r\n        var best, deg, obj;\r\n        /* the global bound must exist */\r\n        xassert(T.mip.mip_stat == GLP_FEAS);\r\n        /* obtain pointer to the root node, which must exist */\r\n        root = T.slot[1].node;\r\n        xassert(root != null);\r\n        /* deg estimates degradation of the objective function per unit\r\n         of the sum of integer infeasibilities */\r\n        xassert(root.ii_sum > 0.0);\r\n        deg = (T.mip.mip_obj - root.bound) / root.ii_sum;\r\n        /* nothing has been selected so far */\r\n        p = 0; best = DBL_MAX;\r\n        /* walk through the list of active subproblems */\r\n        for (node = T.head; node != null; node = node.next)\r\n        {  xassert(node.up != null);\r\n            /* obj estimates optimal objective value if the sum of integer\r\n             infeasibilities were zero */\r\n            obj = node.up.bound + deg * node.up.ii_sum;\r\n            if (T.mip.dir == GLP_MAX) obj = - obj;\r\n            /* select the subproblem which has the best estimated optimal\r\n             objective value */\r\n            if (best > obj){p = node.p; best = obj}\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function best_node(T){\r\n        /* select subproblem with best local bound */\r\n        var node, best = null;\r\n        var bound, eps;\r\n        switch (T.mip.dir)\r\n        {  case GLP_MIN:\r\n            bound = +DBL_MAX;\r\n            for (node = T.head; node != null; node = node.next)\r\n                if (bound > node.bound) bound = node.bound;\r\n            xassert(bound != +DBL_MAX);\r\n            eps = 0.001 * (1.0 + Math.abs(bound));\r\n            for (node = T.head; node != null; node = node.next)\r\n            {  if (node.bound <= bound + eps)\r\n            {  xassert(node.up != null);\r\n                if (best == null ||\r\n                    best.up.ii_sum > node.up.ii_sum) best = node;\r\n            }\r\n            }\r\n            break;\r\n            case GLP_MAX:\r\n                bound = -DBL_MAX;\r\n                for (node = T.head; node != null; node = node.next)\r\n                    if (bound < node.bound) bound = node.bound;\r\n                xassert(bound != -DBL_MAX);\r\n                eps = 0.001 * (1.0 + Math.abs(bound));\r\n                for (node = T.head; node != null; node = node.next)\r\n                {  if (node.bound >= bound - eps)\r\n                {  xassert(node.up != null);\r\n                    if (best == null ||\r\n                        best.lp_obj < node.lp_obj) best = node;\r\n                }\r\n                }\r\n                break;\r\n            default:\r\n                xassert(T != T);\r\n        }\r\n        xassert(best != null);\r\n        return best.p;\r\n    }\r\n\r\n    var p;\r\n    if (T.parm.bt_tech == GLP_BT_DFS)\r\n    {  /* depth first search */\r\n        xassert(T.tail != null);\r\n        p = T.tail.p;\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BFS)\r\n    {  /* breadth first search */\r\n        xassert(T.head != null);\r\n        p = T.head.p;\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BLB)\r\n    {  /* select node with best local bound */\r\n        p = best_node(T);\r\n    }\r\n    else if (T.parm.bt_tech == GLP_BT_BPH)\r\n    {  if (T.mip.mip_stat == GLP_UNDEF)\r\n    {  /* \"most integer feasible\" subproblem */\r\n        p = most_feas(T);\r\n    }\r\n    else\r\n    {  /* best projection heuristic */\r\n        p = best_proj(T);\r\n    }\r\n    }\r\n    else\r\n        xassert(T != T);\r\n    return p;\r\n}\r\n\r\n/* library version numbers: */\r\nvar\r\n    GLP_MAJOR_VERSION = exports[\"GLP_MAJOR_VERSION\"] = 4,\r\n    GLP_MINOR_VERSION = exports[\"GLP_MINOR_VERSION\"] = 49,\r\n\r\n/* optimization direction flag: */\r\n    /** @const */GLP_MIN = exports[\"GLP_MIN\"] = 1, /* minimization */\r\n    /** @const */GLP_MAX = exports[\"GLP_MAX\"] = 2, /* maximization */\r\n\r\n/* kind of structural variable: */\r\n    /** @const */GLP_CV = exports[\"GLP_CV\"] = 1, /* continuous variable */\r\n    /** @const */GLP_IV = exports[\"GLP_IV\"] = 2, /* integer variable */\r\n    /** @const */GLP_BV = exports[\"GLP_BV\"] = 3, /* binary variable */\r\n\r\n/* type of auxiliary/structural variable: */\r\n    /** @const */GLP_FR = exports[\"GLP_FR\"] = 1, /* free variable */\r\n    /** @const */GLP_LO = exports[\"GLP_LO\"] = 2, /* variable with lower bound */\r\n    /** @const */GLP_UP = exports[\"GLP_UP\"] = 3, /* variable with upper bound */\r\n    /** @const */GLP_DB = exports[\"GLP_DB\"] = 4, /* double-bounded variable */\r\n    /** @const */GLP_FX = exports[\"GLP_FX\"] = 5, /* fixed variable */\r\n\r\n/* status of auxiliary/structural variable: */\r\n    /** @const */GLP_BS = exports[\"GLP_BS\"] = 1, /* basic variable */\r\n    /** @const */GLP_NL = exports[\"GLP_NL\"] = 2, /* non-basic variable on lower bound */\r\n    /** @const */GLP_NU = exports[\"GLP_NU\"] = 3, /* non-basic variable on upper bound */\r\n    /** @const */GLP_NF = exports[\"GLP_NF\"] = 4, /* non-basic free variable */\r\n    /** @const */GLP_NS = exports[\"GLP_NS\"] = 5, /* non-basic fixed variable */\r\n\r\n/* scaling options: */\r\n    /** @const */GLP_SF_GM = exports[\"GLP_SF_GM\"] = 0x01, /* perform geometric mean scaling */\r\n    /** @const */GLP_SF_EQ = exports[\"GLP_SF_EQ\"] = 0x10, /* perform equilibration scaling */\r\n    /** @const */GLP_SF_2N = exports[\"GLP_SF_2N\"] = 0x20, /* round scale factors to power of two */\r\n    /** @const */GLP_SF_SKIP = exports[\"GLP_SF_SKIP\"] = 0x40, /* skip if problem is well scaled */\r\n    /** @const */GLP_SF_AUTO = exports[\"GLP_SF_AUTO\"] = 0x80, /* choose scaling options automatically */\r\n\r\n/* solution indicator: */\r\n    /** @const */GLP_SOL = exports[\"GLP_SOL\"] = 1, /* basic solution */\r\n    /** @const */GLP_IPT = exports[\"GLP_IPT\"] = 2, /* interior-point solution */\r\n    /** @const */GLP_MIP = exports[\"GLP_MIP\"] = 3, /* mixed integer solution */\r\n\r\n/* solution status: */\r\n    /** @const */GLP_UNDEF = exports[\"GLP_UNDEF\"] = 1, /* solution is undefined */\r\n    /** @const */GLP_FEAS = exports[\"GLP_FEAS\"] = 2, /* solution is feasible */\r\n    /** @const */GLP_INFEAS = exports[\"GLP_INFEAS\"] = 3, /* solution is infeasible */\r\n    /** @const */GLP_NOFEAS = exports[\"GLP_NOFEAS\"] = 4, /* no feasible solution exists */\r\n    /** @const */GLP_OPT = exports[\"GLP_OPT\"] = 5, /* solution is optimal */\r\n    /** @const */GLP_UNBND = exports[\"GLP_UNBND\"] = 6, /* solution is unbounded */\r\n\r\n/* basis factorization control parameters */\r\n    /** @const */GLP_BF_FT = exports[\"GLP_BF_FT\"] = 1, /* LUF + Forrest-Tomlin */\r\n    /** @const */GLP_BF_BG = exports[\"GLP_BF_BG\"] = 2, /* LUF + Schur compl. + Bartels-Golub */\r\n    /** @const */GLP_BF_GR = exports[\"GLP_BF_GR\"] = 3, /* LUF + Schur compl. + Givens rotation */\r\n\r\n/* simplex method control parameters */\r\n    /** @const */GLP_MSG_OFF = exports[\"GLP_MSG_OFF\"] = 0, /* no output */\r\n    /** @const */GLP_MSG_ERR = exports[\"GLP_MSG_ERR\"] = 1, /* warning and error messages only */\r\n    /** @const */GLP_MSG_ON = exports[\"GLP_MSG_ON\"] = 2, /* normal output */\r\n    /** @const */GLP_MSG_ALL = exports[\"GLP_MSG_ALL\"] = 3, /* full output */\r\n    /** @const */GLP_MSG_DBG = exports[\"GLP_MSG_DBG\"] = 4, /* debug output */\r\n\r\n    /** @const */GLP_PRIMAL = exports[\"GLP_PRIMAL\"] = 1, /* use primal simplex */\r\n    /** @const */GLP_DUALP = exports[\"GLP_DUALP\"] = 2, /* use dual; if it fails, use primal */\r\n    /** @const */GLP_DUAL = exports[\"GLP_DUAL\"] = 3, /* use dual simplex */\r\n\r\n    /** @const */GLP_PT_STD = exports[\"GLP_PT_STD\"] = 0x11, /* standard (Dantzig rule) */\r\n    /** @const */GLP_PT_PSE = exports[\"GLP_PT_PSE\"] = 0x22, /* projected steepest edge */\r\n\r\n    /** @const */GLP_RT_STD = exports[\"GLP_RT_STD\"] = 0x11, /* standard (textbook) */\r\n    /** @const */GLP_RT_HAR = exports[\"GLP_RT_HAR\"] = 0x22, /* two-pass Harris' ratio test */\r\n\r\n/* interior-point solver control parameters */\r\n    /** @const */GLP_ORD_NONE = exports[\"GLP_ORD_NONE\"] = 0, /* natural (original) ordering */\r\n    /** @const */GLP_ORD_QMD = exports[\"GLP_ORD_QMD\"] = 1, /* quotient minimum degree (QMD) */\r\n    /** @const */GLP_ORD_AMD = exports[\"GLP_ORD_AMD\"] = 2, /* approx. minimum degree (AMD) */\r\n    /** @const */GLP_ORD_SYMAMD = exports[\"GLP_ORD_SYMAMD\"] = 3, /* approx. minimum degree (SYMAMD) */\r\n\r\n/* integer optimizer control parameters */\r\n    /** @const */GLP_BR_FFV = exports[\"GLP_BR_FFV\"] = 1, /* first fractional variable */\r\n    /** @const */GLP_BR_LFV = exports[\"GLP_BR_LFV\"] = 2, /* last fractional variable */\r\n    /** @const */GLP_BR_MFV = exports[\"GLP_BR_MFV\"] = 3, /* most fractional variable */\r\n    /** @const */GLP_BR_DTH = exports[\"GLP_BR_DTH\"] = 4, /* heuristic by Driebeck and Tomlin */\r\n    /** @const */GLP_BR_PCH = exports[\"GLP_BR_PCH\"] = 5, /* hybrid pseudocost heuristic */\r\n\r\n    /** @const */GLP_BT_DFS = exports[\"GLP_BT_DFS\"] = 1, /* depth first search */\r\n    /** @const */GLP_BT_BFS = exports[\"GLP_BT_BFS\"] = 2, /* breadth first search */\r\n    /** @const */GLP_BT_BLB = exports[\"GLP_BT_BLB\"] = 3, /* best local bound */\r\n    /** @const */GLP_BT_BPH = exports[\"GLP_BT_BPH\"] = 4, /* best projection heuristic */\r\n\r\n    /** @const */GLP_PP_NONE = exports[\"GLP_PP_NONE\"] = 0, /* disable preprocessing */\r\n    /** @const */GLP_PP_ROOT = exports[\"GLP_PP_ROOT\"] = 1, /* preprocessing only on root level */\r\n    /** @const */GLP_PP_ALL = exports[\"GLP_PP_ALL\"] = 2, /* preprocessing on all levels */\r\n\r\n/* additional row attributes */\r\n    /** @const */GLP_RF_REG = exports[\"GLP_RF_REG\"] = 0, /* regular constraint */\r\n    /** @const */GLP_RF_LAZY = exports[\"GLP_RF_LAZY\"] = 1, /* \"lazy\" constraint */\r\n    /** @const */GLP_RF_CUT = exports[\"GLP_RF_CUT\"] = 2, /* cutting plane constraint */\r\n\r\n/* row class descriptor: */\r\n    /** @const */GLP_RF_GMI = exports[\"GLP_RF_GMI\"] = 1, /* Gomory's mixed integer cut */\r\n    /** @const */GLP_RF_MIR = exports[\"GLP_RF_MIR\"] = 2, /* mixed integer rounding cut */\r\n    /** @const */GLP_RF_COV = exports[\"GLP_RF_COV\"] = 3, /* mixed cover cut */\r\n    /** @const */GLP_RF_CLQ = exports[\"GLP_RF_CLQ\"] = 4, /* clique cut */\r\n\r\n/* enable/disable flag: */\r\n    /** @const */GLP_ON = exports[\"GLP_ON\"] = 1, /* enable something */\r\n    /** @const */GLP_OFF = exports[\"GLP_OFF\"] = 0, /* disable something */\r\n\r\n/* reason codes: */\r\n    /** @const */GLP_IROWGEN = exports[\"GLP_IROWGEN\"] = 0x01, /* request for row generation */\r\n    /** @const */GLP_IBINGO = exports[\"GLP_IBINGO\"] = 0x02, /* better integer solution found */\r\n    /** @const */GLP_IHEUR = exports[\"GLP_IHEUR\"] = 0x03, /* request for heuristic solution */\r\n    /** @const */GLP_ICUTGEN = exports[\"GLP_ICUTGEN\"] = 0x04, /* request for cut generation */\r\n    /** @const */GLP_IBRANCH = exports[\"GLP_IBRANCH\"] = 0x05, /* request for branching */\r\n    /** @const */GLP_ISELECT = exports[\"GLP_ISELECT\"] = 0x06, /* request for subproblem selection */\r\n    /** @const */GLP_IPREPRO = exports[\"GLP_IPREPRO\"] = 0x07, /* request for preprocessing */\r\n\r\n/* branch selection indicator: */\r\n    /** @const */GLP_NO_BRNCH = exports[\"GLP_NO_BRNCH\"] = 0, /* select no branch */\r\n    /** @const */GLP_DN_BRNCH = exports[\"GLP_DN_BRNCH\"] = 1, /* select down-branch */\r\n    /** @const */GLP_UP_BRNCH = exports[\"GLP_UP_BRNCH\"] = 2, /* select up-branch */\r\n\r\n/* return codes: */\r\n    /** @const */GLP_EBADB = exports[\"GLP_EBADB\"] = 0x01, /* invalid basis */\r\n    /** @const */GLP_ESING = exports[\"GLP_ESING\"] = 0x02, /* singular matrix */\r\n    /** @const */GLP_ECOND = exports[\"GLP_ECOND\"] = 0x03, /* ill-conditioned matrix */\r\n    /** @const */GLP_EBOUND = exports[\"GLP_EBOUND\"] = 0x04, /* invalid bounds */\r\n    /** @const */GLP_EFAIL = exports[\"GLP_EFAIL\"] = 0x05, /* solver failed */\r\n    /** @const */GLP_EOBJLL = exports[\"GLP_EOBJLL\"] = 0x06, /* objective lower limit reached */\r\n    /** @const */GLP_EOBJUL = exports[\"GLP_EOBJUL\"] = 0x07, /* objective upper limit reached */\r\n    /** @const */GLP_EITLIM = exports[\"GLP_EITLIM\"] = 0x08, /* iteration limit exceeded */\r\n    /** @const */GLP_ETMLIM = exports[\"GLP_ETMLIM\"] = 0x09, /* time limit exceeded */\r\n    /** @const */GLP_ENOPFS = exports[\"GLP_ENOPFS\"] = 0x0A, /* no primal feasible solution */\r\n    /** @const */GLP_ENODFS = exports[\"GLP_ENODFS\"] = 0x0B, /* no dual feasible solution */\r\n    /** @const */GLP_EROOT = exports[\"GLP_EROOT\"] = 0x0C, /* root LP optimum not provided */\r\n    /** @const */GLP_ESTOP = exports[\"GLP_ESTOP\"] = 0x0D, /* search terminated by application */\r\n    /** @const */GLP_EMIPGAP = exports[\"GLP_EMIPGAP\"] = 0x0E, /* relative mip gap tolerance reached */\r\n    /** @const */GLP_ENOFEAS = exports[\"GLP_ENOFEAS\"] = 0x0F, /* no primal/dual feasible solution */\r\n    /** @const */GLP_ENOCVG = exports[\"GLP_ENOCVG\"] = 0x10, /* no convergence */\r\n    /** @const */GLP_EINSTAB = exports[\"GLP_EINSTAB\"] = 0x11, /* numerical instability */\r\n    /** @const */GLP_EDATA = exports[\"GLP_EDATA\"] = 0x12, /* invalid data */\r\n    /** @const */GLP_ERANGE = exports[\"GLP_ERANGE\"] = 0x13, /* result out of range */\r\n\r\n/* condition indicator: */\r\n    /** @const */GLP_KKT_PE = exports[\"GLP_KKT_PE\"] = 1, /* primal equalities */\r\n    /** @const */GLP_KKT_PB = exports[\"GLP_KKT_PB\"] = 2, /* primal bounds */\r\n    /** @const */GLP_KKT_DE = exports[\"GLP_KKT_DE\"] = 3, /* dual equalities */\r\n    /** @const */GLP_KKT_DB = exports[\"GLP_KKT_DB\"] = 4, /* dual bounds */\r\n    /** @const */GLP_KKT_CS = exports[\"GLP_KKT_CS\"] = 5, /* complementary slackness */\r\n\r\n/* MPS file format: */\r\n    /** @const */GLP_MPS_DECK = exports[\"GLP_MPS_DECK\"] = 1, /* fixed (ancient) */\r\n    /** @const */GLP_MPS_FILE = exports[\"GLP_MPS_FILE\"] = 2, /* free (modern) */\r\n\r\n/* assignment problem formulation: */\r\n    /** @const */GLP_ASN_MIN = exports[\"GLP_ASN_MIN\"] = 1, /* perfect matching (minimization) */\r\n    /** @const */GLP_ASN_MAX = exports[\"GLP_ASN_MAX\"] = 2, /* perfect matching (maximization) */\r\n    /** @const */GLP_ASN_MMP = exports[\"GLP_ASN_MMP\"] = 3; /* maximum matching */\r\nfunction gcd(x, y){\r\n    var r;\r\n    xassert(x > 0 && y > 0);\r\n    while (y > 0){\r\n        r = x % y;\r\n        x = y;\r\n        y = r;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction gcdn(n, x){\r\n    var d = 0, j;\r\n    xassert(n > 0);\r\n    for (j = 1; j <= n; j++)\r\n    {  xassert(x[j] > 0);\r\n        if (j == 1)\r\n            d = x[1];\r\n        else\r\n            d = gcd(d, x[j]);\r\n        if (d == 1) break;\r\n    }\r\n    return d;\r\n}\r\n\r\nfunction round2n(x){\r\n    xassert(x > 0.0);\r\n    var e = Math.floor(Math.log(x) / Math.log(2)) + 1;\r\n    var f = x / Math.pow(2, e);\r\n    return Math.pow(2, f <= 0.75 ? e-1 : e);\r\n}\r\n\r\n/*  0 - no error;\r\n *  1 - value out of range;\r\n *  2 - character string is syntactically incorrect.\r\n */\r\nfunction str2num(str, callback){\r\n    var ret = Number(str);\r\n    if (isNaN(ret)) return 2;\r\n    switch (ret){\r\n        case Number.POSITIVE_INFINITY:\r\n        case Number.NEGATIVE_INFINITY:\r\n            return 1;\r\n        default:\r\n            callback(ret);\r\n            return 0;\r\n    }\r\n}\r\n\r\nfunction str2int(str, callback){\r\n    var ret = Number(str);\r\n    if (isNaN(ret)) return 2;\r\n    switch (ret){\r\n        case Number.POSITIVE_INFINITY:\r\n        case Number.NEGATIVE_INFINITY:\r\n            return 1;\r\n        default:\r\n            if (ret % 1 == 0){\r\n                callback(ret);\r\n                return 0;\r\n            } else {\r\n                return 2\r\n            }\r\n    }\r\n}\r\n\r\nfunction jday(d, m, y){\r\n    var c, ya, j, dd;\r\n    if (!(1 <= d && d <= 31 && 1 <= m && m <= 12 && 1 <= y && y <= 4000))\r\n        return -1;\r\n    if (m >= 3)m -= 3;else{m += 9;y--;}\r\n    c = (y / 100)|0;\r\n    ya = y - 100 * c;\r\n    j = ((146097 * c) / 4)|0;\r\n    j += ((1461 * ya) / 4)|0;\r\n    j += ((153 * m + 2) / 5)|0;\r\n    j += d + 1721119;\r\n    jdate(j, function(d){dd = d});\r\n    if (d != dd) j = -1;\r\n    return j;\r\n}\r\n\r\nfunction jdate(j, callback)\r\n{\r\n    var d, m, y, ret = 0;\r\n    if (!(1721426 <= j && j <= 3182395))\r\n      return 1;\r\n    j -= 1721119;\r\n    y = ((4 * j - 1) / 146097)|0;\r\n    j = (4 * j - 1) % 146097;\r\n    d = (j / 4)|0;\r\n    j = ((4 * d + 3) / 1461)|0;\r\n    d = (4 * d + 3) % 1461;\r\n    d = ((d + 4) / 4)|0;\r\n    m = ((5 * d - 3) / 153)|0;\r\n    d = (5 * d - 3) % 153;\r\n    d = ((d + 5) / 5)|0;\r\n    y = 100 * y + j;\r\n    if (m <= 9)\r\n        m += 3;\r\n    else{\r\n        m -= 9; y++;\r\n    }\r\n    callback(d, m, y);\r\n    return ret;\r\n}\r\n\r\n/* return codes: */\r\nvar\r\n    LPF_ESING    = 1;  /* singular matrix */\r\n    LPF_ECOND    = 2;  /* ill-conditioned matrix */\r\n    LPF_ELIMIT   = 3;  /* update limit reached */\r\n\r\n\r\nvar _GLPLPF_DEBUG = 0;\r\n\r\nfunction lpf_create_it(){\r\n    var lpf;\r\n    if (_GLPLPF_DEBUG){\r\n        xprintf(\"lpf_create_it: warning: debug mode enabled\");\r\n    }\r\n    lpf = {};\r\n    lpf.valid = 0;\r\n    lpf.m0_max = lpf.m0 = 0;\r\n    lpf.luf = luf_create_it();\r\n    lpf.m = 0;\r\n    lpf.B = null;\r\n    lpf.n_max = 50;\r\n    lpf.n = 0;\r\n    lpf.R_ptr = lpf.R_len = null;\r\n    lpf.S_ptr = lpf.S_len = null;\r\n    lpf.scf = null;\r\n    lpf.P_row = lpf.P_col = null;\r\n    lpf.Q_row = lpf.Q_col = null;\r\n    lpf.v_size = 1000;\r\n    lpf.v_ptr = 0;\r\n    lpf.v_ind = null;\r\n    lpf.v_val = null;\r\n    lpf.work1 = lpf.work2 = null;\r\n    return lpf;\r\n}\r\n\r\nfunction lpf_factorize(lpf, m, bh, col, info){\r\n    var k, ret;\r\n    if (_GLPLPF_DEBUG){\r\n        var i, j, len, ind;\r\n        var B, val;\r\n    }\r\n    xassert(bh == bh);\r\n    if (m < 1)\r\n        xerror(\"lpf_factorize: m = \" + m + \"; invalid parameter\");\r\n    if (m > M_MAX)\r\n        xerror(\"lpf_factorize: m = \" + m + \"; matrix too big\");\r\n    lpf.m0 = lpf.m = m;\r\n    /* invalidate the factorization */\r\n    lpf.valid = 0;\r\n    /* allocate/reallocate arrays, if necessary */\r\n    if (lpf.R_ptr == null)\r\n        lpf.R_ptr = new Int32Array(1+lpf.n_max);\r\n    if (lpf.R_len == null)\r\n        lpf.R_len = new Int32Array(1+lpf.n_max);\r\n    if (lpf.S_ptr == null)\r\n        lpf.S_ptr = new Int32Array(1+lpf.n_max);\r\n    if (lpf.S_len == null)\r\n        lpf.S_len = new Int32Array(1+lpf.n_max);\r\n    if (lpf.scf == null)\r\n        lpf.scf = scf_create_it(lpf.n_max);\r\n    if (lpf.v_ind == null)\r\n        lpf.v_ind = new Int32Array(1+lpf.v_size);\r\n    if (lpf.v_val == null)\r\n        lpf.v_val = new Float64Array(1+lpf.v_size);\r\n    if (lpf.m0_max < m)\r\n    {\r\n        lpf.m0_max = m + 100;\r\n        lpf.P_row = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.P_col = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.Q_row = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.Q_col = new Int32Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.work1 = new Float64Array(1+lpf.m0_max+lpf.n_max);\r\n        lpf.work2 = new Float64Array(1+lpf.m0_max+lpf.n_max);\r\n    }\r\n    /* try to factorize the basis matrix */\r\n    switch (luf_factorize(lpf.luf, m, col, info))\r\n    {  case 0:\r\n        break;\r\n        case LUF_ESING:\r\n            ret = LPF_ESING;\r\n            return ret;\r\n        case LUF_ECOND:\r\n            ret = LPF_ECOND;\r\n            return ret;\r\n        default:\r\n            xassert(lpf != lpf);\r\n    }\r\n    /* the basis matrix has been successfully factorized */\r\n    lpf.valid = 1;\r\n    if (_GLPLPF_DEBUG){\r\n        /* store the basis matrix for debugging */\r\n        xassert(m <= 32767);\r\n        lpf.B = B = new Float64Array(1+m*m);\r\n        ind = new Int32Array(1+m);\r\n        val = new Float64Array(1+m);\r\n        for (k = 1; k <= m * m; k++)\r\n            B[k] = 0.0;\r\n        for (j = 1; j <= m; j++)\r\n        {  len = col(info, j, ind, val);\r\n            xassert(0 <= len && len <= m);\r\n            for (k = 1; k <= len; k++)\r\n            {  i = ind[k];\r\n                xassert(1 <= i && i <= m);\r\n                xassert(B[(i - 1) * m + j] == 0.0);\r\n                xassert(val[k] != 0.0);\r\n                B[(i - 1) * m + j] = val[k];\r\n            }\r\n        }\r\n    }\r\n    /* B = B0, so there are no additional rows/columns */\r\n    lpf.n = 0;\r\n    /* reset the Schur complement factorization */\r\n    scf_reset_it(lpf.scf);\r\n    /* P := Q := I */\r\n    for (k = 1; k <= m; k++)\r\n    {  lpf.P_row[k] = lpf.P_col[k] = k;\r\n        lpf.Q_row[k] = lpf.Q_col[k] = k;\r\n    }\r\n    /* make all SVA locations free */\r\n    lpf.v_ptr = 1;\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction r_prod(lpf, y, a, x, idx){\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var j, beg, end, ptr;\r\n    var t;\r\n    for (j = 1; j <= n; j++)\r\n    {  if (x[j+idx] == 0.0) continue;\r\n        /* y := y + alpha * R[j] * x[j] */\r\n        t = a * x[j+idx];\r\n        beg = R_ptr[j];\r\n        end = beg + R_len[j];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            y[v_ind[ptr]] += t * v_val[ptr];\r\n    }\r\n}\r\n\r\nfunction rt_prod(lpf, y, idx, a, x){\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var j, beg, end, ptr;\r\n    var t;\r\n    for (j = 1; j <= n; j++)\r\n    {  /* t := (j-th column of R) * x */\r\n        t = 0.0;\r\n        beg = R_ptr[j];\r\n        end = beg + R_len[j];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            t += v_val[ptr] * x[v_ind[ptr]];\r\n        /* y[j] := y[j] + alpha * t */\r\n        y[j+idx] += a * t;\r\n    }\r\n}\r\n\r\nfunction s_prod(lpf, y, idx, a, x){\r\n    var n = lpf.n;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var i, beg, end, ptr;\r\n    var t;\r\n    for (i = 1; i <= n; i++)\r\n    {  /* t := (i-th row of S) * x */\r\n        t = 0.0;\r\n        beg = S_ptr[i];\r\n        end = beg + S_len[i];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            t += v_val[ptr] * x[v_ind[ptr]];\r\n        /* y[i] := y[i] + alpha * t */\r\n        y[i+idx] += a * t;\r\n    }\r\n}\r\n\r\nfunction st_prod(lpf, y, a, x, idx){\r\n    var n = lpf.n;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var i, beg, end, ptr;\r\n    var t;\r\n    for (i = 1; i <= n; i++)\r\n    {  if (x[i+idx] == 0.0) continue;\r\n        /* y := y + alpha * S'[i] * x[i] */\r\n        t = a * x[i+idx];\r\n        beg = S_ptr[i];\r\n        end = beg + S_len[i];\r\n        for (ptr = beg; ptr < end; ptr++)\r\n            y[v_ind[ptr]] += t * v_val[ptr];\r\n    }\r\n}\r\n\r\nif (_GLPLPF_DEBUG){\r\n    /***********************************************************************\r\n     *  The routine check_error computes the maximal relative error between\r\n     *  left- and right-hand sides for the system B * x = b (if tr is zero)\r\n     *  or B' * x = b (if tr is non-zero), where B' is a matrix transposed\r\n     *  to B. (This routine is intended for debugging only.) */\r\n\r\n    function check_error(lpf, tr, x, b){\r\n        var m = lpf.m;\r\n        var B = lpf.B;\r\n        var i, j;\r\n        var d, dmax = 0.0, s, t, tmax;\r\n        for (i = 1; i <= m; i++)\r\n        {  s = 0.0;\r\n            tmax = 1.0;\r\n            for (j = 1; j <= m; j++)\r\n            {  if (!tr)\r\n                t = B[m * (i - 1) + j] * x[j];\r\n            else\r\n                t = B[m * (j - 1) + i] * x[j];\r\n                if (tmax < Math.abs(t)) tmax = Math.abs(t);\r\n                s += t;\r\n            }\r\n            d = Math.abs(s - b[i]) / tmax;\r\n            if (dmax < d) dmax = d;\r\n        }\r\n        if (dmax > 1e-8)\r\n            xprintf((!tr ? \"lpf_ftran\" : \"lpf_btran\") + \": dmax = \" + dmax + \"; relative error too large\");\r\n    }\r\n}\r\n\r\nfunction lpf_ftran(lpf, x){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    var n  = lpf.n;\r\n    var P_col = lpf.P_col;\r\n    var Q_col = lpf.Q_col;\r\n    var fg = lpf.work1;\r\n    var f = fg;\r\n    var g = fg;\r\n    var i, ii;\r\n    if (_GLPLPF_DEBUG){var b}\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_ftran: the factorization is not valid\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    if (_GLPLPF_DEBUG){\r\n        /* save the right-hand side vector */\r\n        b = new Float64Array(1+m);\r\n        for (i = 1; i <= m; i++) b[i] = x[i];\r\n    }\r\n    /* (f g) := inv(P) * (b 0) */\r\n    for (i = 1; i <= m0 + n; i++)\r\n        fg[i] = ((ii = P_col[i]) <= m ? x[ii] : 0.0);\r\n    /* f1 := inv(L0) * f */\r\n    luf_f_solve(lpf.luf, 0, f);\r\n    /* g1 := g - S * f1 */\r\n    s_prod(lpf, g, m0, -1.0, f);\r\n    /* g2 := inv(C) * g1 */\r\n    scf_solve_it(lpf.scf, 0, g, m0);\r\n    /* f2 := inv(U0) * (f1 - R * g2) */\r\n    r_prod(lpf, f, -1.0, g, m0);\r\n    luf_v_solve(lpf.luf, 0, f);\r\n    /* (x y) := inv(Q) * (f2 g2) */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] = fg[Q_col[i]];\r\n    if (_GLPLPF_DEBUG){\r\n        /* check relative error in solution */\r\n        check_error(lpf, 0, x, b);\r\n    }\r\n}\r\n\r\nfunction lpf_btran(lpf, x){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    var n = lpf.n;\r\n    var P_row = lpf.P_row;\r\n    var Q_row = lpf.Q_row;\r\n    var fg = lpf.work1;\r\n    var f = fg;\r\n    var g = fg;\r\n    var i, ii;\r\n    if (_GLPLPF_DEBUG){var b}\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_btran: the factorization is not valid\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    if (_GLPLPF_DEBUG){\r\n        /* save the right-hand side vector */\r\n        b = new Float64Array(1+m);\r\n        for (i = 1; i <= m; i++) b[i] = x[i];\r\n    }\r\n    /* (f g) := Q * (b 0) */\r\n    for (i = 1; i <= m0 + n; i++)\r\n        fg[i] = ((ii = Q_row[i]) <= m ? x[ii] : 0.0);\r\n    /* f1 := inv(U'0) * f */\r\n    luf_v_solve(lpf.luf, 1, f);\r\n    /* g1 := inv(C') * (g - R' * f1) */\r\n    rt_prod(lpf, g, m0, -1.0, f);\r\n    scf_solve_it(lpf.scf, 1, g, m0);\r\n    /* g2 := g1 */\r\n    //g = g;\r\n    /* f2 := inv(L'0) * (f1 - S' * g2) */\r\n    st_prod(lpf, f, -1.0, g, m0);\r\n    luf_f_solve(lpf.luf, 1, f);\r\n    /* (x y) := P * (f2 g2) */\r\n    for (i = 1; i <= m; i++)\r\n        x[i] = fg[P_row[i]];\r\n    if (_GLPLPF_DEBUG){\r\n        /* check relative error in solution */\r\n        check_error(lpf, 1, x, b);\r\n    }\r\n}\r\n\r\nfunction enlarge_sva(lpf, new_size){\r\n    var v_size = lpf.v_size;\r\n    var used = lpf.v_ptr - 1;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    xassert(v_size < new_size);\r\n    while (v_size < new_size) v_size += v_size;\r\n    lpf.v_size = v_size;\r\n    lpf.v_ind = new Int32Array(1+v_size);\r\n    lpf.v_val = new Float64Array(1+v_size);\r\n    xassert(used >= 0);\r\n    xcopyArr(lpf.v_ind, 1, v_ind, 1, used);\r\n    xcopyArr(lpf.v_val, 1, v_val, 1, used);\r\n}\r\n\r\nfunction lpf_update_it(lpf, j, bh, len, ind, idx, val){\r\n    var m0 = lpf.m0;\r\n    var m = lpf.m;\r\n    if (_GLPLPF_DEBUG){var B = lpf.B}\r\n    var n = lpf.n;\r\n    var R_ptr = lpf.R_ptr;\r\n    var R_len = lpf.R_len;\r\n    var S_ptr = lpf.S_ptr;\r\n    var S_len = lpf.S_len;\r\n    var P_row = lpf.P_row;\r\n    var P_col = lpf.P_col;\r\n    var Q_row = lpf.Q_row;\r\n    var Q_col = lpf.Q_col;\r\n    var v_ptr = lpf.v_ptr;\r\n    var v_ind = lpf.v_ind;\r\n    var v_val = lpf.v_val;\r\n    var a = lpf.work2; /* new column */\r\n    var fg = lpf.work1, f = fg, g = fg;\r\n    var vw = lpf.work2, v = vw, w = vw;\r\n    var x = g, y = w, z;\r\n    var i, ii, k, ret;\r\n    xassert(bh == bh);\r\n    if (!lpf.valid)\r\n        xerror(\"lpf_update_it: the factorization is not valid\");\r\n    if (!(1 <= j && j <= m))\r\n        xerror(\"lpf_update_it: j = \" + j + \"; column number out of range\");\r\n    xassert(0 <= m && m <= m0 + n);\r\n    /* check if the basis factorization can be expanded */\r\n    if (n == lpf.n_max)\r\n    {  lpf.valid = 0;\r\n        ret = LPF_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* convert new j-th column of B to dense format */\r\n    for (i = 1; i <= m; i++)\r\n        a[i] = 0.0;\r\n    for (k = 1; k <= len; k++)\r\n    {  i = ind[idx + k];\r\n        if (!(1 <= i && i <= m))\r\n            xerror(\"lpf_update_it: ind[\" + k + \"] = \" + i + \"; row number out of range\");\r\n        if (a[i] != 0.0)\r\n            xerror(\"lpf_update_it: ind[\" + k + \"] = \" + i + \"; duplicate row index not allowed\");\r\n        if (val[k] == 0.0)\r\n            xerror(\"lpf_update_it: val[\" + k + \"] = \" + val[k] + \"; zero element not allowed\");\r\n        a[i] = val[k];\r\n    }\r\n    if (_GLPLPF_DEBUG){\r\n        /* change column in the basis matrix for debugging */\r\n        for (i = 1; i <= m; i++)\r\n            B[(i - 1) * m + j] = a[i];\r\n    }\r\n    /* (f g) := inv(P) * (a 0) */\r\n    for (i = 1; i <= m0+n; i++)\r\n        fg[i] = ((ii = P_col[i]) <= m ? a[ii] : 0.0);\r\n    /* (v w) := Q * (ej 0) */\r\n    for (i = 1; i <= m0+n; i++) vw[i] = 0.0;\r\n    vw[Q_col[j]] = 1.0;\r\n    /* f1 := inv(L0) * f (new column of R) */\r\n    luf_f_solve(lpf.luf, 0, f);\r\n    /* v1 := inv(U'0) * v (new row of S) */\r\n    luf_v_solve(lpf.luf, 1, v);\r\n    /* we need at most 2 * m0 available locations in the SVA to store\r\n     new column of matrix R and new row of matrix S */\r\n    if (lpf.v_size < v_ptr + m0 + m0)\r\n    {  enlarge_sva(lpf, v_ptr + m0 + m0);\r\n        v_ind = lpf.v_ind;\r\n        v_val = lpf.v_val;\r\n    }\r\n    /* store new column of R */\r\n    R_ptr[n+1] = v_ptr;\r\n    for (i = 1; i <= m0; i++)\r\n    {  if (f[i] != 0.0){\r\n        v_ind[v_ptr] = i; v_val[v_ptr] = f[i]; v_ptr++;\r\n    }\r\n\r\n    }\r\n    R_len[n+1] = v_ptr - lpf.v_ptr;\r\n    lpf.v_ptr = v_ptr;\r\n    /* store new row of S */\r\n    S_ptr[n+1] = v_ptr;\r\n    for (i = 1; i <= m0; i++)\r\n    {  if (v[i] != 0.0){\r\n        v_ind[v_ptr] = i; v_val[v_ptr] = v[i]; v_ptr++;\r\n    }\r\n\r\n    }\r\n    S_len[n+1] = v_ptr - lpf.v_ptr;\r\n    lpf.v_ptr = v_ptr;\r\n    /* x := g - S * f1 (new column of C) */\r\n    s_prod(lpf, x, 0, -1.0, f);\r\n    /* y := w - R' * v1 (new row of C) */\r\n    rt_prod(lpf, y, 0, -1.0, v);\r\n    /* z := - v1 * f1 (new diagonal element of C) */\r\n    z = 0.0;\r\n    for (i = 1; i <= m0; i++) z -= v[i] * f[i];\r\n    /* update factorization of new matrix C */\r\n    switch (scf_update_exp(lpf.scf, x, m0, y, m0, z))\r\n    {  case 0:\r\n        break;\r\n        case SCF_ESING:\r\n            lpf.valid = 0;\r\n            ret = LPF_ESING;\r\n            return ret;\r\n        case SCF_ELIMIT:\r\n            xassert(lpf != lpf);\r\n        default:\r\n            xassert(lpf != lpf);\r\n    }\r\n    /* expand matrix P */\r\n    P_row[m0+n+1] = P_col[m0+n+1] = m0+n+1;\r\n    /* expand matrix Q */\r\n    Q_row[m0+n+1] = Q_col[m0+n+1] = m0+n+1;\r\n    /* permute j-th and last (just added) column of matrix Q */\r\n    i = Q_col[j]; ii = Q_col[m0+n+1];\r\n    Q_row[i] = m0+n+1; Q_col[m0+n+1] = i;\r\n    Q_row[ii] = j; Q_col[j] = ii;\r\n    /* increase the number of additional rows and columns */\r\n    lpf.n++;\r\n    xassert(lpf.n <= lpf.n_max);\r\n    /* the factorization has been successfully updated */\r\n    ret = 0;\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nvar\r\n/* problem class: */\r\n/** @const */LPX_LP = exports[\"LPX_LP\"] = 100, /* linear programming (LP) */\r\n/** @const */LPX_MIP = exports[\"LPX_MIP\"] = 101, /* mixed integer programming (MIP) */\r\n\r\n    /* type of auxiliary/structural variable: */\r\n/** @const */LPX_FR = exports[\"LPX_FR\"] = 110, /* free variable */\r\n/** @const */LPX_LO = exports[\"LPX_LO\"] = 111, /* variable with lower bound */\r\n/** @const */LPX_UP = exports[\"LPX_UP\"] = 112, /* variable with upper bound */\r\n/** @const */LPX_DB = exports[\"LPX_DB\"] = 113, /* double-bounded variable */\r\n/** @const */LPX_FX = exports[\"LPX_FX\"] = 114, /* fixed variable */\r\n\r\n    /* optimization direction flag: */\r\n/** @const */LPX_MIN = exports[\"LPX_MIN\"] = 120, /* minimization */\r\n/** @const */LPX_MAX = exports[\"LPX_MAX\"] = 121, /* maximization */\r\n\r\n    /* status of primal basic solution: */\r\n/** @const */LPX_P_UNDEF = exports[\"LPX_P_UNDEF\"] = 132, /* primal solution is undefined */\r\n/** @const */LPX_P_FEAS = exports[\"LPX_P_FEAS\"] = 133, /* solution is primal feasible */\r\n/** @const */LPX_P_INFEAS = exports[\"LPX_P_INFEAS\"] = 134, /* solution is primal infeasible */\r\n/** @const */LPX_P_NOFEAS = exports[\"LPX_P_NOFEAS\"] = 135, /* no primal feasible solution exists */\r\n\r\n    /* status of dual basic solution: */\r\n/** @const */LPX_D_UNDEF = exports[\"LPX_D_UNDEF\"] = 136, /* dual solution is undefined */\r\n/** @const */LPX_D_FEAS = exports[\"LPX_D_FEAS\"] = 137, /* solution is dual feasible */\r\n/** @const */LPX_D_INFEAS = exports[\"LPX_D_INFEAS\"] = 138, /* solution is dual infeasible */\r\n/** @const */LPX_D_NOFEAS = exports[\"LPX_D_NOFEAS\"] = 139, /* no dual feasible solution exists */\r\n\r\n    /* status of auxiliary/structural variable: */\r\n/** @const */LPX_BS = exports[\"LPX_BS\"] = 140, /* basic variable */\r\n/** @const */LPX_NL = exports[\"LPX_NL\"] = 141, /* non-basic variable on lower bound */\r\n/** @const */LPX_NU = exports[\"LPX_NU\"] = 142, /* non-basic variable on upper bound */\r\n/** @const */LPX_NF = exports[\"LPX_NF\"] = 143, /* non-basic free variable */\r\n/** @const */LPX_NS = exports[\"LPX_NS\"] = 144, /* non-basic fixed variable */\r\n\r\n    /* status of interior-point solution: */\r\n/** @const */LPX_T_UNDEF = exports[\"LPX_T_UNDEF\"] = 150, /* interior solution is undefined */\r\n/** @const */LPX_T_OPT = exports[\"LPX_T_OPT\"] = 151, /* interior solution is optimal */\r\n\r\n    /* kind of structural variable: */\r\n/** @const */LPX_CV = exports[\"LPX_CV\"] = 160, /* continuous variable */\r\n/** @const */LPX_IV = exports[\"LPX_IV\"] = 161, /* integer variable */\r\n\r\n    /* status of integer solution: */\r\n/** @const */LPX_I_UNDEF = exports[\"LPX_I_UNDEF\"] = 170, /* integer solution is undefined */\r\n/** @const */LPX_I_OPT = exports[\"LPX_I_OPT\"] = 171, /* integer solution is optimal */\r\n/** @const */LPX_I_FEAS = exports[\"LPX_I_FEAS\"] = 172, /* integer solution is feasible */\r\n/** @const */LPX_I_NOFEAS = exports[\"LPX_I_NOFEAS\"] = 173, /* no integer solution exists */\r\n\r\n    /* status codes reported by the routine lpx_get_status: */\r\n/** @const */LPX_OPT = exports[\"LPX_OPT\"] = 180, /* optimal */\r\n/** @const */LPX_FEAS = exports[\"LPX_FEAS\"] = 181, /* feasible */\r\n/** @const */LPX_INFEAS = exports[\"LPX_INFEAS\"] = 182, /* infeasible */\r\n/** @const */LPX_NOFEAS = exports[\"LPX_NOFEAS\"] = 183, /* no feasible */\r\n/** @const */LPX_UNBND = exports[\"LPX_UNBND\"] = 184, /* unbounded */\r\n/** @const */LPX_UNDEF = exports[\"LPX_UNDEF\"] = 185, /* undefined */\r\n\r\n    /* exit codes returned by solver routines: */\r\n/** @const */LPX_E_OK = exports[\"LPX_E_OK\"] = 200, /* success */\r\n/** @const */LPX_E_EMPTY = exports[\"LPX_E_EMPTY\"] = 201, /* empty problem */\r\n/** @const */LPX_E_BADB = exports[\"LPX_E_BADB\"] = 202, /* invalid initial basis */\r\n/** @const */LPX_E_INFEAS = exports[\"LPX_E_INFEAS\"] = 203, /* infeasible initial solution */\r\n/** @const */LPX_E_FAULT = exports[\"LPX_E_FAULT\"] = 204, /* unable to start the search */\r\n/** @const */LPX_E_OBJLL = exports[\"LPX_E_OBJLL\"] = 205, /* objective lower limit reached */\r\n/** @const */LPX_E_OBJUL = exports[\"LPX_E_OBJUL\"] = 206, /* objective upper limit reached */\r\n/** @const */LPX_E_ITLIM = exports[\"LPX_E_ITLIM\"] = 207, /* iterations limit exhausted */\r\n/** @const */LPX_E_TMLIM = exports[\"LPX_E_TMLIM\"] = 208, /* time limit exhausted */\r\n/** @const */LPX_E_NOFEAS = exports[\"LPX_E_NOFEAS\"] = 209, /* no feasible solution */\r\n/** @const */LPX_E_INSTAB = exports[\"LPX_E_INSTAB\"] = 210, /* numerical instability */\r\n/** @const */LPX_E_SING = exports[\"LPX_E_SING\"] = 211, /* problems with basis matrix */\r\n/** @const */LPX_E_NOCONV = exports[\"LPX_E_NOCONV\"] = 212, /* no convergence (interior) */\r\n/** @const */LPX_E_NOPFS = exports[\"LPX_E_NOPFS\"] = 213, /* no primal feas. sol. (LP presolver) */\r\n/** @const */LPX_E_NODFS = exports[\"LPX_E_NODFS\"] = 214, /* no dual feas. sol. (LP presolver) */\r\n/** @const */LPX_E_MIPGAP = exports[\"LPX_E_MIPGAP\"] = 215, /* relative mip gap tolerance reached */\r\n\r\n    /* control parameter identifiers: */\r\n/** @const */LPX_K_MSGLEV = exports[\"LPX_K_MSGLEV\"] = 300, /* lp.msg_lev */\r\n/** @const */LPX_K_SCALE = exports[\"LPX_K_SCALE\"] = 301, /* lp.scale */\r\n/** @const */LPX_K_DUAL = exports[\"LPX_K_DUAL\"] = 302, /* lp.dual */\r\n/** @const */LPX_K_PRICE = exports[\"LPX_K_PRICE\"] = 303, /* lp.price */\r\n/** @const */LPX_K_RELAX = exports[\"LPX_K_RELAX\"] = 304, /* lp.relax */\r\n/** @const */LPX_K_TOLBND = exports[\"LPX_K_TOLBND\"] = 305, /* lp.tol_bnd */\r\n/** @const */LPX_K_TOLDJ = exports[\"LPX_K_TOLDJ\"] = 306, /* lp.tol_dj */\r\n/** @const */LPX_K_TOLPIV = exports[\"LPX_K_TOLPIV\"] = 307, /* lp.tol_piv */\r\n/** @const */LPX_K_ROUND = exports[\"LPX_K_ROUND\"] = 308, /* lp.round */\r\n/** @const */LPX_K_OBJLL = exports[\"LPX_K_OBJLL\"] = 309, /* lp.obj_ll */\r\n/** @const */LPX_K_OBJUL = exports[\"LPX_K_OBJUL\"] = 310, /* lp.obj_ul */\r\n/** @const */LPX_K_ITLIM = exports[\"LPX_K_ITLIM\"] = 311, /* lp.it_lim */\r\n/** @const */LPX_K_ITCNT = exports[\"LPX_K_ITCNT\"] = 312, /* lp.it_cnt */\r\n/** @const */LPX_K_TMLIM = exports[\"LPX_K_TMLIM\"] = 313, /* lp.tm_lim */\r\n/** @const */LPX_K_OUTFRQ = exports[\"LPX_K_OUTFRQ\"] = 314, /* lp.out_frq */\r\n/** @const */LPX_K_OUTDLY = exports[\"LPX_K_OUTDLY\"] = 315, /* lp.out_dly */\r\n/** @const */LPX_K_BRANCH = exports[\"LPX_K_BRANCH\"] = 316, /* lp.branch */\r\n/** @const */LPX_K_BTRACK = exports[\"LPX_K_BTRACK\"] = 317, /* lp.btrack */\r\n/** @const */LPX_K_TOLINT = exports[\"LPX_K_TOLINT\"] = 318, /* lp.tol_int */\r\n/** @const */LPX_K_TOLOBJ = exports[\"LPX_K_TOLOBJ\"] = 319, /* lp.tol_obj */\r\n/** @const */LPX_K_MPSINFO = exports[\"LPX_K_MPSINFO\"] = 320, /* lp.mps_info */\r\n/** @const */LPX_K_MPSOBJ = exports[\"LPX_K_MPSOBJ\"] = 321, /* lp.mps_obj */\r\n/** @const */LPX_K_MPSORIG = exports[\"LPX_K_MPSORIG\"] = 322, /* lp.mps_orig */\r\n/** @const */LPX_K_MPSWIDE = exports[\"LPX_K_MPSWIDE\"] = 323, /* lp.mps_wide */\r\n/** @const */LPX_K_MPSFREE = exports[\"LPX_K_MPSFREE\"] = 324, /* lp.mps_free */\r\n/** @const */LPX_K_MPSSKIP = exports[\"LPX_K_MPSSKIP\"] = 325, /* lp.mps_skip */\r\n/** @const */LPX_K_LPTORIG = exports[\"LPX_K_LPTORIG\"] = 326, /* lp.lpt_orig */\r\n/** @const */LPX_K_PRESOL = exports[\"LPX_K_PRESOL\"] = 327, /* lp.presol */\r\n/** @const */LPX_K_BINARIZE = exports[\"LPX_K_BINARIZE\"] = 328, /* lp.binarize */\r\n/** @const */LPX_K_USECUTS = exports[\"LPX_K_USECUTS\"] = 329, /* lp.use_cuts */\r\n/** @const */LPX_K_BFTYPE = exports[\"LPX_K_BFTYPE\"] = 330, /* lp.bfcp.type */\r\n/** @const */LPX_K_MIPGAP = exports[\"LPX_K_MIPGAP\"] = 331, /* lp.mip_gap */\r\n\r\n/** @const */LPX_C_COVER = exports[\"LPX_C_COVER\"] = 0x01, /* mixed cover cuts */\r\n/** @const */LPX_C_CLIQUE = exports[\"LPX_C_CLIQUE\"] = 0x02, /* clique cuts */\r\n/** @const */LPX_C_GOMORY = exports[\"LPX_C_GOMORY\"] = 0x04, /* Gomory's mixed integer cuts */\r\n/** @const */LPX_C_MIR = exports[\"LPX_C_MIR\"] = 0x08, /* mixed integer rounding cuts */\r\n/** @const */LPX_C_ALL = exports[\"LPX_C_ALL\"] = 0xFF;\r\nfunction lpx_create_prob(){\r\n    /* create problem object */\r\n    return glp_create_prob();\r\n}\r\n\r\nfunction lpx_set_prob_name(lp, name)\r\n{     /* assign (change) problem name */\r\n    glp_set_prob_name(lp, name);\r\n}\r\n\r\nfunction lpx_set_obj_name(lp, name){\r\n    /* assign (change) objective function name */\r\n    glp_set_obj_name(lp, name);\r\n}\r\n\r\nfunction lpx_set_obj_dir(lp, dir){\r\n    /* set (change) optimization direction flag */\r\n    glp_set_obj_dir(lp, dir - LPX_MIN + GLP_MIN);\r\n}\r\n\r\nfunction lpx_add_rows(lp, nrs){\r\n    /* add new rows to problem object */\r\n    return glp_add_rows(lp, nrs);\r\n}\r\n\r\nfunction lpx_add_cols(lp, ncs){\r\n    /* add new columns to problem object */\r\n    return glp_add_cols(lp, ncs);\r\n}\r\n\r\nfunction lpx_set_row_name(lp, i, name)\r\n{     /* assign (change) row name */\r\n    glp_set_row_name(lp, i, name);\r\n}\r\n\r\nfunction lpx_set_col_name(lp, j, name){\r\n    /* assign (change) column name */\r\n    glp_set_col_name(lp, j, name);\r\n}\r\n\r\nfunction lpx_set_row_bnds(lp, i, type, lb, ub){\r\n    /* set (change) row bounds */\r\n    glp_set_row_bnds(lp, i, type - LPX_FR + GLP_FR, lb, ub);\r\n}\r\n\r\nfunction lpx_set_col_bnds(lp, j, type, lb, ub){\r\n    /* set (change) column bounds */\r\n    glp_set_col_bnds(lp, j, type - LPX_FR + GLP_FR, lb, ub);\r\n}\r\n\r\nfunction lpx_set_obj_coef(lp, j, coef){\r\n    /* set (change) obj. coefficient or constant term */\r\n    glp_set_obj_coef(lp, j, coef);\r\n}\r\n\r\nfunction lpx_set_mat_row(lp, i, len, ind, val){\r\n    /* set (replace) row of the constraint matrix */\r\n    glp_set_mat_row(lp, i, len, ind, val);\r\n}\r\n\r\nfunction lpx_set_mat_col(lp, j, len, ind, val){\r\n    /* set (replace) column of the constraint matrix */\r\n    glp_set_mat_col(lp, j, len, ind, val);\r\n}\r\n\r\nfunction lpx_load_matrix(lp, ne, ia, ja, ar){\r\n    /* load (replace) the whole constraint matrix */\r\n    glp_load_matrix(lp, ne, ia, ja, ar);\r\n}\r\n\r\nfunction lpx_del_rows(lp, nrs, num){\r\n    /* delete specified rows from problem object */\r\n    glp_del_rows(lp, nrs, num);\r\n}\r\n\r\nfunction lpx_del_cols(lp, ncs, num){\r\n    /* delete specified columns from problem object */\r\n    glp_del_cols(lp, ncs, num);\r\n}\r\n\r\nfunction lpx_get_prob_name(lp){\r\n    /* retrieve problem name */\r\n    return glp_get_prob_name(lp);\r\n}\r\n\r\nfunction lpx_get_obj_name(lp){\r\n    /* retrieve objective function name */\r\n    return glp_get_obj_name(lp);\r\n}\r\n\r\nfunction lpx_get_obj_dir(lp){\r\n    /* retrieve optimization direction flag */\r\n    return glp_get_obj_dir(lp) - GLP_MIN + LPX_MIN;\r\n}\r\n\r\nfunction lpx_get_num_rows(lp){\r\n    /* retrieve number of rows */\r\n    return glp_get_num_rows(lp);\r\n}\r\n\r\nfunction lpx_get_num_cols(lp){\r\n    /* retrieve number of columns */\r\n    return glp_get_num_cols(lp);\r\n}\r\n\r\nfunction lpx_get_row_name(lp, i){\r\n    /* retrieve row name */\r\n    return glp_get_row_name(lp, i);\r\n}\r\n\r\nfunction lpx_get_col_name(lp, j){\r\n    /* retrieve column name */\r\n    return glp_get_col_name(lp, j);\r\n}\r\n\r\nfunction lpx_get_row_type(lp, i){\r\n    /* retrieve row type */\r\n    return glp_get_row_type(lp, i) - GLP_FR + LPX_FR;\r\n}\r\n\r\nfunction lpx_get_row_lb(lp, i){\r\n    /* retrieve row lower bound */\r\n    var lb = glp_get_row_lb(lp, i);\r\n    if (lb == -DBL_MAX) lb = 0.0;\r\n    return lb;\r\n}\r\n\r\nfunction lpx_get_row_ub(lp, i){\r\n    /* retrieve row upper bound */\r\n    var ub = glp_get_row_ub(lp, i);\r\n    if (ub == +DBL_MAX) ub = 0.0;\r\n    return ub;\r\n}\r\n\r\nfunction lpx_get_row_bnds(lp, i, callback){\r\n    /* retrieve row bounds */\r\n    callback(lpx_get_row_type(lp, i), lpx_get_row_lb(lp, i), lpx_get_row_ub(lp, i));\r\n}\r\n\r\nfunction lpx_get_col_type(lp, j){\r\n    /* retrieve column type */\r\n    return glp_get_col_type(lp, j) - GLP_FR + LPX_FR;\r\n}\r\n\r\nfunction lpx_get_col_lb(lp, j){\r\n    /* retrieve column lower bound */\r\n    var lb = glp_get_col_lb(lp, j);\r\n    if (lb == -DBL_MAX) lb = 0.0;\r\n    return lb;\r\n}\r\n\r\nfunction lpx_get_col_ub(lp, j){\r\n    /* retrieve column upper bound */\r\n    var ub = glp_get_col_ub(lp, j);\r\n    if (ub == +DBL_MAX) ub = 0.0;\r\n    return ub;\r\n}\r\n\r\nfunction lpx_get_col_bnds(lp, j, callback)\r\n{     /* retrieve column bounds */\r\n    callback(lpx_get_col_type(lp, j), lpx_get_col_lb(lp, j), lpx_get_col_ub(lp, j));\r\n}\r\n\r\nfunction lpx_get_obj_coef(lp, j){\r\n    /* retrieve obj. coefficient or constant term */\r\n    return glp_get_obj_coef(lp, j);\r\n}\r\n\r\nfunction lpx_get_num_nz(lp){\r\n    /* retrieve number of constraint coefficients */\r\n    return glp_get_num_nz(lp);\r\n}\r\n\r\nfunction lpx_get_mat_row(lp, i, ind, val){\r\n    /* retrieve row of the constraint matrix */\r\n    return glp_get_mat_row(lp, i, ind, val);\r\n}\r\n\r\nfunction lpx_get_mat_col(lp, j, ind, val){\r\n    /* retrieve column of the constraint matrix */\r\n    return glp_get_mat_col(lp, j, ind, val);\r\n}\r\n\r\nfunction lpx_create_index(lp){\r\n    /* create the name index */\r\n    glp_create_index(lp);\r\n}\r\n\r\nfunction lpx_find_row(lp, name){\r\n    /* find row by its name */\r\n    return glp_find_row(lp, name);\r\n}\r\n\r\nfunction lpx_find_col(lp, name){\r\n    /* find column by its name */\r\n    return glp_find_col(lp, name);\r\n}\r\n\r\nfunction lpx_delete_index(lp){\r\n    /* delete the name index */\r\n    glp_delete_index(lp);\r\n}\r\n\r\nfunction lpx_scale_prob(lp){\r\n    /* scale problem data */\r\n    switch (lpx_get_int_parm(lp, LPX_K_SCALE))\r\n    {  case 0:\r\n        /* no scaling */\r\n        glp_unscale_prob(lp);\r\n        break;\r\n        case 1:\r\n            /* equilibration scaling */\r\n            glp_scale_prob(lp, GLP_SF_EQ);\r\n            break;\r\n        case 2:\r\n            /* geometric mean scaling */\r\n            glp_scale_prob(lp, GLP_SF_GM);\r\n            break;\r\n        case 3:\r\n            /* geometric mean scaling, then equilibration scaling */\r\n            glp_scale_prob(lp, GLP_SF_GM | GLP_SF_EQ);\r\n            break;\r\n        default:\r\n            xassert(lp != lp);\r\n    }\r\n}\r\n\r\nfunction lpx_unscale_prob(lp){\r\n    /* unscale problem data */\r\n    glp_unscale_prob(lp);\r\n}\r\n\r\nfunction lpx_set_row_stat(lp, i, stat){\r\n    /* set (change) row status */\r\n    glp_set_row_stat(lp, i, stat - LPX_BS + GLP_BS);\r\n}\r\n\r\nfunction lpx_set_col_stat(lp, j, stat){\r\n    /* set (change) column status */\r\n    glp_set_col_stat(lp, j, stat - LPX_BS + GLP_BS);\r\n}\r\n\r\nfunction lpx_std_basis(lp){\r\n    /* construct standard initial LP basis */\r\n    glp_std_basis(lp);\r\n}\r\n\r\nfunction lpx_adv_basis(lp){\r\n    /* construct advanced initial LP basis */\r\n    glp_adv_basis(lp, 0);\r\n}\r\n\r\nfunction lpx_cpx_basis(lp){\r\n    /* construct Bixby's initial LP basis */\r\n    glp_cpx_basis(lp);\r\n}\r\n\r\nfunction fill_smcp(lp, parm){\r\n    //glp_init_smcp(parm);\r\n    switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\r\n    {  case 0:  parm.msg_lev = GLP_MSG_OFF;   break;\r\n        case 1:  parm.msg_lev = GLP_MSG_ERR;   break;\r\n        case 2:  parm.msg_lev = GLP_MSG_ON;    break;\r\n        case 3:  parm.msg_lev = GLP_MSG_ALL;   break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_DUAL))\r\n    {  case 0:  parm.meth = GLP_PRIMAL;       break;\r\n        case 1:  parm.meth = GLP_DUAL;         break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_PRICE))\r\n    {  case 0:  parm.pricing = GLP_PT_STD;    break;\r\n        case 1:  parm.pricing = GLP_PT_PSE;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    if (lpx_get_real_parm(lp, LPX_K_RELAX) == 0.0)\r\n        parm.r_test = GLP_RT_STD;\r\n    else\r\n        parm.r_test = GLP_RT_HAR;\r\n    parm.tol_bnd = lpx_get_real_parm(lp, LPX_K_TOLBND);\r\n    parm.tol_dj  = lpx_get_real_parm(lp, LPX_K_TOLDJ);\r\n    parm.tol_piv = lpx_get_real_parm(lp, LPX_K_TOLPIV);\r\n    parm.obj_ll  = lpx_get_real_parm(lp, LPX_K_OBJLL);\r\n    parm.obj_ul  = lpx_get_real_parm(lp, LPX_K_OBJUL);\r\n    if (lpx_get_int_parm(lp, LPX_K_ITLIM) < 0)\r\n        parm.it_lim = INT_MAX;\r\n    else\r\n        parm.it_lim = lpx_get_int_parm(lp, LPX_K_ITLIM);\r\n    if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0)\r\n        parm.tm_lim = INT_MAX;\r\n    else\r\n        parm.tm_lim = (1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM))|0;\r\n    parm.out_frq = lpx_get_int_parm(lp, LPX_K_OUTFRQ);\r\n    parm.out_dly = (1000.0 * lpx_get_real_parm(lp, LPX_K_OUTDLY))|0;\r\n    switch (lpx_get_int_parm(lp, LPX_K_PRESOL))\r\n    {  case 0:  parm.presolve = GLP_OFF;      break;\r\n        case 1:  parm.presolve = GLP_ON;       break;\r\n        default: xassert(lp != lp);\r\n    }\r\n}\r\n\r\nfunction lpx_simplex(lp){\r\n    /* easy-to-use driver to the simplex method */\r\n    var parm = new SMCP();\r\n    var ret;\r\n    fill_smcp(lp, parm);\r\n    ret = glp_simplex(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EBADB:\r\n        case GLP_ESING:\r\n        case GLP_ECOND:\r\n        case GLP_EBOUND:  ret = LPX_E_FAULT;   break;\r\n        case GLP_EFAIL:   ret = LPX_E_SING;    break;\r\n        case GLP_EOBJLL:  ret = LPX_E_OBJLL;   break;\r\n        case GLP_EOBJUL:  ret = LPX_E_OBJUL;   break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\r\n        case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_exact(lp){\r\n    /* easy-to-use driver to the exact simplex method */\r\n    var parm = new SMCP();\r\n    var ret;\r\n    fill_smcp(lp, parm);\r\n    ret = glp_exact(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EBADB:\r\n        case GLP_ESING:\r\n        case GLP_EBOUND:\r\n        case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_get_status(lp){\r\n    /* retrieve generic status of basic solution */\r\n    var status;\r\n    switch (glp_get_status(lp))\r\n    {  case GLP_OPT:    status = LPX_OPT;    break;\r\n        case GLP_FEAS:   status = LPX_FEAS;   break;\r\n        case GLP_INFEAS: status = LPX_INFEAS; break;\r\n        case GLP_NOFEAS: status = LPX_NOFEAS; break;\r\n        case GLP_UNBND:  status = LPX_UNBND;  break;\r\n        case GLP_UNDEF:  status = LPX_UNDEF;  break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_get_prim_stat(lp){\r\n    /* retrieve status of primal basic solution */\r\n    return glp_get_prim_stat(lp) - GLP_UNDEF + LPX_P_UNDEF;\r\n}\r\n\r\nfunction lpx_get_dual_stat(lp){\r\n    /* retrieve status of dual basic solution */\r\n    return glp_get_dual_stat(lp) - GLP_UNDEF + LPX_D_UNDEF;\r\n}\r\n\r\nfunction lpx_get_obj_val(lp){\r\n    /* retrieve objective value (basic solution) */\r\n    return glp_get_obj_val(lp);\r\n}\r\n\r\nfunction lpx_get_row_stat(lp, i){\r\n    /* retrieve row status (basic solution) */\r\n    return glp_get_row_stat(lp, i) - GLP_BS + LPX_BS;\r\n}\r\n\r\nfunction lpx_get_row_prim(lp, i){\r\n    /* retrieve row primal value (basic solution) */\r\n    return glp_get_row_prim(lp, i);\r\n}\r\n\r\nfunction lpx_get_row_dual(lp, i){\r\n    /* retrieve row dual value (basic solution) */\r\n    return glp_get_row_dual(lp, i);\r\n}\r\n\r\nfunction lpx_get_row_info(lp, i, callback){\r\n    /* obtain row solution information */\r\n    callback(lpx_get_row_stat(lp, i), lpx_get_row_prim(lp, i), lpx_get_row_dual(lp, i))\r\n}\r\n\r\nfunction lpx_get_col_stat(lp, j){\r\n    /* retrieve column status (basic solution) */\r\n    return glp_get_col_stat(lp, j) - GLP_BS + LPX_BS;\r\n}\r\n\r\nfunction lpx_get_col_prim(lp, j){\r\n    /* retrieve column primal value (basic solution) */\r\n    return glp_get_col_prim(lp, j);\r\n}\r\n\r\nfunction lpx_get_col_dual(lp, j){\r\n    /* retrieve column dual value (basic solution) */\r\n    return glp_get_col_dual(lp, j);\r\n}\r\n\r\nfunction lpx_get_col_info(lp, j, callback){\r\n    /* obtain column solution information */\r\n    callback(lpx_get_col_stat(lp, j), lpx_get_col_prim(lp, j), lpx_get_col_dual(lp, j));\r\n}\r\n\r\nfunction lpx_get_ray_info(lp){\r\n    /* determine what causes primal unboundness */\r\n    return glp_get_unbnd_ray(lp);\r\n}\r\n\r\nfunction lpx_check_kkt(lp, scaled, kkt){\r\n    /* check Karush-Kuhn-Tucker conditions */\r\n    xassert(scaled == scaled);\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_PE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pe_ae_max = ae_max;\r\n            kkt.pe_ae_row = ae_ind;\r\n            kkt.pe_re_max = re_max;\r\n            kkt.pe_re_row = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pe_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pe_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pe_quality = 'L';\r\n            else\r\n                kkt.pe_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_PB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pb_ae_max = ae_max;\r\n            kkt.pb_ae_ind = ae_ind;\r\n            kkt.pb_re_max = re_max;\r\n            kkt.pb_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pb_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pb_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pb_quality = 'L';\r\n            else\r\n                kkt.pb_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_DE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.de_ae_max = ae_max;\r\n            if (ae_ind == 0)\r\n                kkt.de_ae_col = 0;\r\n            else\r\n                kkt.de_ae_col = ae_ind - lp.m;\r\n            kkt.de_re_max = re_max;\r\n            if (re_ind == 0)\r\n                kkt.de_re_col = 0;\r\n            else\r\n                kkt.de_re_col = ae_ind - lp.m;\r\n            if (re_max <= 1e-9)\r\n                kkt.de_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.de_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.de_quality = 'L';\r\n            else\r\n                kkt.de_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_SOL, GLP_KKT_DB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.db_ae_max = ae_max;\r\n            kkt.db_ae_ind = ae_ind;\r\n            kkt.db_re_max = re_max;\r\n            kkt.db_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.db_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.db_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.db_quality = 'L';\r\n            else\r\n                kkt.db_quality = '?';\r\n            kkt.cs_ae_max = 0.0; kkt.cs_ae_ind = 0;\r\n            kkt.cs_re_max = 0.0; kkt.cs_re_ind = 0;\r\n            kkt.cs_quality = 'H';\r\n        }\r\n    );\r\n}\r\n\r\nfunction lpx_warm_up(lp){\r\n    /* \"warm up\" LP basis */\r\n    var ret = glp_warm_up(lp);\r\n    if (ret == 0)\r\n        ret = LPX_E_OK;\r\n    else if (ret == GLP_EBADB)\r\n        ret = LPX_E_BADB;\r\n    else if (ret == GLP_ESING)\r\n        ret = LPX_E_SING;\r\n    else if (ret == GLP_ECOND)\r\n        ret = LPX_E_SING;\r\n    else\r\n        xassert(ret != ret);\r\n    return ret;\r\n}\r\n\r\nfunction lpx_eval_tab_row(lp, k, ind, val){\r\n    /* compute row of the simplex tableau */\r\n    return glp_eval_tab_row(lp, k, ind, val);\r\n}\r\n\r\nfunction lpx_eval_tab_col(lp, k, ind, val){\r\n    /* compute column of the simplex tableau */\r\n    return glp_eval_tab_col(lp, k, ind, val);\r\n}\r\n\r\nfunction lpx_transform_row(lp, len, ind, val){\r\n    /* transform explicitly specified row */\r\n    return glp_transform_row(lp, len, ind, val);\r\n}\r\n\r\nfunction lpx_transform_col(lp, len, ind, val){\r\n    /* transform explicitly specified column */\r\n    return glp_transform_col(lp, len, ind, val);\r\n}\r\n\r\nfunction lpx_prim_ratio_test(lp, len, ind, val, how, tol){\r\n    /* perform primal ratio test */\r\n    var piv = glp_prim_rtest(lp, len, ind, val, how, tol);\r\n    xassert(0 <= piv && piv <= len);\r\n    return piv == 0 ? 0 : ind[piv];\r\n}\r\n\r\nfunction lpx_dual_ratio_test(lp, len, ind, val, how, tol){\r\n    /* perform dual ratio test */\r\n    var piv = glp_dual_rtest(lp, len, ind, val, how, tol);\r\n    xassert(0 <= piv && piv <= len);\r\n    return piv == 0 ? 0 : ind[piv];\r\n}\r\n\r\nfunction lpx_interior(lp){\r\n    /* easy-to-use driver to the interior-point method */\r\n    var ret = glp_interior(lp, null);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_EFAIL:   ret = LPX_E_FAULT;   break;\r\n        case GLP_ENOFEAS: ret = LPX_E_NOFEAS;  break;\r\n        case GLP_ENOCVG:  ret = LPX_E_NOCONV;  break;\r\n        case GLP_EITLIM:  ret = LPX_E_ITLIM;   break;\r\n        case GLP_EINSTAB: ret = LPX_E_INSTAB;  break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_ipt_status(lp){\r\n    /* retrieve status of interior-point solution */\r\n    var status;\r\n    switch (glp_ipt_status(lp))\r\n    {  case GLP_UNDEF:  status = LPX_T_UNDEF;  break;\r\n        case GLP_OPT:    status = LPX_T_OPT;    break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_ipt_obj_val(lp){\r\n    /* retrieve objective value (interior point) */\r\n    return glp_ipt_obj_val(lp);\r\n}\r\n\r\nfunction lpx_ipt_row_prim(lp, i){\r\n    /* retrieve row primal value (interior point) */\r\n    return glp_ipt_row_prim(lp, i);\r\n}\r\n\r\nfunction lpx_ipt_row_dual(lp, i){\r\n    /* retrieve row dual value (interior point) */\r\n    return glp_ipt_row_dual(lp, i);\r\n}\r\n\r\nfunction lpx_ipt_col_prim(lp, j){\r\n    /* retrieve column primal value (interior point) */\r\n    return glp_ipt_col_prim(lp, j);\r\n}\r\n\r\nfunction lpx_ipt_col_dual(lp, j){\r\n    /* retrieve column dual value (interior point) */\r\n    return glp_ipt_col_dual(lp, j);\r\n}\r\n\r\nfunction lpx_set_class(lp, klass){\r\n    /* set problem class */\r\n    xassert(lp == lp);\r\n    if (!(klass == LPX_LP || klass == LPX_MIP))\r\n        xerror(\"lpx_set_class: invalid problem class\");\r\n}\r\n\r\nfunction lpx_get_class(lp){\r\n    /* determine problem klass */\r\n    return glp_get_num_int(lp) == 0 ? LPX_LP : LPX_MIP;\r\n}\r\n\r\nfunction lpx_set_col_kind(lp, j, kind){\r\n    /* set (change) column kind */\r\n    glp_set_col_kind(lp, j, kind - LPX_CV + GLP_CV);\r\n}\r\n\r\nfunction lpx_get_col_kind(lp, j){\r\n    /* retrieve column kind */\r\n    return glp_get_col_kind(lp, j) == GLP_CV ? LPX_CV : LPX_IV;\r\n}\r\n\r\nfunction lpx_get_num_int(lp){\r\n    /* retrieve number of integer columns */\r\n    return glp_get_num_int(lp);\r\n}\r\n\r\nfunction lpx_get_num_bin(lp){\r\n    /* retrieve number of binary columns */\r\n    return glp_get_num_bin(lp);\r\n}\r\n\r\nfunction solve_mip(lp, presolve){\r\n    var parm = new IOCP();\r\n    var ret;\r\n    //glp_init_iocp(parm);\r\n    switch (lpx_get_int_parm(lp, LPX_K_MSGLEV))\r\n    {  case 0:  parm.msg_lev = GLP_MSG_OFF;   break;\r\n        case 1:  parm.msg_lev = GLP_MSG_ERR;   break;\r\n        case 2:  parm.msg_lev = GLP_MSG_ON;    break;\r\n        case 3:  parm.msg_lev = GLP_MSG_ALL;   break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_BRANCH))\r\n    {  case 0:  parm.br_tech = GLP_BR_FFV;    break;\r\n        case 1:  parm.br_tech = GLP_BR_LFV;    break;\r\n        case 2:  parm.br_tech = GLP_BR_DTH;    break;\r\n        case 3:  parm.br_tech = GLP_BR_MFV;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    switch (lpx_get_int_parm(lp, LPX_K_BTRACK))\r\n    {  case 0:  parm.bt_tech = GLP_BT_DFS;    break;\r\n        case 1:  parm.bt_tech = GLP_BT_BFS;    break;\r\n        case 2:  parm.bt_tech = GLP_BT_BPH;    break;\r\n        case 3:  parm.bt_tech = GLP_BT_BLB;    break;\r\n        default: xassert(lp != lp);\r\n    }\r\n    parm.tol_int = lpx_get_real_parm(lp, LPX_K_TOLINT);\r\n    parm.tol_obj = lpx_get_real_parm(lp, LPX_K_TOLOBJ);\r\n    if (lpx_get_real_parm(lp, LPX_K_TMLIM) < 0.0 ||\r\n        lpx_get_real_parm(lp, LPX_K_TMLIM) > 1e6)\r\n        parm.tm_lim = INT_MAX;\r\n    else\r\n        parm.tm_lim = (1000.0 * lpx_get_real_parm(lp, LPX_K_TMLIM))|0;\r\n    parm.mip_gap = lpx_get_real_parm(lp, LPX_K_MIPGAP);\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_GOMORY)\r\n        parm.gmi_cuts = GLP_ON;\r\n    else\r\n        parm.gmi_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_MIR)\r\n        parm.mir_cuts = GLP_ON;\r\n    else\r\n        parm.mir_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_COVER)\r\n        parm.cov_cuts = GLP_ON;\r\n    else\r\n        parm.cov_cuts = GLP_OFF;\r\n    if (lpx_get_int_parm(lp, LPX_K_USECUTS) & LPX_C_CLIQUE)\r\n        parm.clq_cuts = GLP_ON;\r\n    else\r\n        parm.clq_cuts = GLP_OFF;\r\n    parm.presolve = presolve;\r\n    if (lpx_get_int_parm(lp, LPX_K_BINARIZE))\r\n        parm.binarize = GLP_ON;\r\n    ret = glp_intopt(lp, parm);\r\n    switch (ret)\r\n    {  case 0:           ret = LPX_E_OK;      break;\r\n        case GLP_ENOPFS:  ret = LPX_E_NOPFS;   break;\r\n        case GLP_ENODFS:  ret = LPX_E_NODFS;   break;\r\n        case GLP_EBOUND:\r\n        case GLP_EROOT:   ret = LPX_E_FAULT;   break;\r\n        case GLP_EFAIL:   ret = LPX_E_SING;    break;\r\n        case GLP_EMIPGAP: ret = LPX_E_MIPGAP;  break;\r\n        case GLP_ETMLIM:  ret = LPX_E_TMLIM;   break;\r\n        default:          xassert(ret != ret);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction lpx_integer(lp){\r\n    /* easy-to-use driver to the branch-and-bound method */\r\n    return solve_mip(lp, GLP_OFF);\r\n}\r\n\r\nfunction lpx_intopt(lp){\r\n    /* easy-to-use driver to the branch-and-bound method */\r\n    return solve_mip(lp, GLP_ON);\r\n}\r\n\r\nfunction lpx_mip_status(lp){\r\n    /* retrieve status of MIP solution */\r\n    var status;\r\n    switch (glp_mip_status(lp))\r\n    {  case GLP_UNDEF:  status = LPX_I_UNDEF;  break;\r\n        case GLP_OPT:    status = LPX_I_OPT;    break;\r\n        case GLP_FEAS:   status = LPX_I_FEAS;   break;\r\n        case GLP_NOFEAS: status = LPX_I_NOFEAS; break;\r\n        default:         xassert(lp != lp);\r\n    }\r\n    return status;\r\n}\r\n\r\nfunction lpx_mip_obj_val(lp){\r\n    /* retrieve objective value (MIP solution) */\r\n    return glp_mip_obj_val(lp);\r\n}\r\n\r\nfunction lpx_mip_row_val(lp, i){\r\n    /* retrieve row value (MIP solution) */\r\n    return glp_mip_row_val(lp, i);\r\n}\r\n\r\nfunction lpx_mip_col_val(lp, j){\r\n    /* retrieve column value (MIP solution) */\r\n    return glp_mip_col_val(lp, j);\r\n}\r\n\r\nfunction lpx_check_int(lp, kkt){\r\n    /* check integer feasibility conditions */\r\n    glp_check_kkt(lp, GLP_MIP, GLP_KKT_PE,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pe_ae_max = ae_max;\r\n            kkt.pe_ae_row = ae_ind;\r\n            kkt.pe_re_max = re_max;\r\n            kkt.pe_re_row = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pe_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pe_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pe_quality = 'L';\r\n            else\r\n                kkt.pe_quality = '?';\r\n        }\r\n    );\r\n\r\n    glp_check_kkt(lp, GLP_MIP, GLP_KKT_PB,\r\n        function(ae_max, ae_ind, re_max, re_ind){\r\n            kkt.pb_ae_max = ae_max;\r\n            kkt.pb_ae_ind = ae_ind;\r\n            kkt.pb_re_max = re_max;\r\n            kkt.pb_re_ind = re_ind;\r\n            if (re_max <= 1e-9)\r\n                kkt.pb_quality = 'H';\r\n            else if (re_max <= 1e-6)\r\n                kkt.pb_quality = 'M';\r\n            else if (re_max <= 1e-3)\r\n                kkt.pb_quality = 'L';\r\n            else\r\n                kkt.pb_quality = '?';\r\n        }\r\n    );\r\n}\r\n\r\nfunction reset_parms(lp){\r\n    /* reset control parameters to default values */\r\n    var cps = lp.parms;\r\n    xassert(cps != null);\r\n    cps.msg_lev  = 3;\r\n    cps.scale    = 1;\r\n    cps.dual     = 0;\r\n    cps.price    = 1;\r\n    cps.relax    = 0.07;\r\n    cps.tol_bnd  = 1e-7;\r\n    cps.tol_dj   = 1e-7;\r\n    cps.tol_piv  = 1e-9;\r\n    cps.round    = 0;\r\n    cps.obj_ll   = -DBL_MAX;\r\n    cps.obj_ul   = +DBL_MAX;\r\n    cps.it_lim   = -1;\r\n    cps.tm_lim   = -1.0;\r\n    cps.out_frq  = 200;\r\n    cps.out_dly  = 0.0;\r\n    cps.branch   = 2;\r\n    cps.btrack   = 3;\r\n    cps.tol_int  = 1e-5;\r\n    cps.tol_obj  = 1e-7;\r\n    cps.mps_info = 1;\r\n    cps.mps_obj  = 2;\r\n    cps.mps_orig = 0;\r\n    cps.mps_wide = 1;\r\n    cps.mps_free = 0;\r\n    cps.mps_skip = 0;\r\n    cps.lpt_orig = 0;\r\n    cps.presol = 0;\r\n    cps.binarize = 0;\r\n    cps.use_cuts = 0;\r\n    cps.mip_gap = 0.0;\r\n}\r\n\r\nfunction access_parms(lp){\r\n    /* allocate and initialize control parameters, if necessary */\r\n    if (lp.parms == null)\r\n    {  lp.parms = {};\r\n        reset_parms(lp);\r\n    }\r\n    return lp.parms;\r\n}\r\n\r\nfunction lpx_reset_parms(lp){\r\n    /* reset control parameters to default values */\r\n    access_parms(lp);\r\n    reset_parms(lp);\r\n}\r\n\r\nfunction lpx_set_int_parm(lp, parm, val){\r\n    /* set (change) integer control parameter */\r\n    var cps = access_parms(lp);\r\n    switch (parm)\r\n    {  case LPX_K_MSGLEV:\r\n        if (!(0 <= val && val <= 3))\r\n            xerror(\"lpx_set_int_parm: MSGLEV = \" + val + \"; invalid value\");\r\n        cps.msg_lev = val;\r\n        break;\r\n        case LPX_K_SCALE:\r\n            if (!(0 <= val && val <= 3))\r\n                xerror(\"lpx_set_int_parm: SCALE = \" + val + \"; invalid value\");\r\n            cps.scale = val;\r\n            break;\r\n        case LPX_K_DUAL:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: DUAL = \" + val + \"; invalid value\");\r\n            cps.dual = val;\r\n            break;\r\n        case LPX_K_PRICE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: PRICE = \" + val + \"; invalid value\");\r\n            cps.price = val;\r\n            break;\r\n        case LPX_K_ROUND:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: ROUND = \" + val + \"; invalid value\");\r\n            cps.round = val;\r\n            break;\r\n        case LPX_K_ITLIM:\r\n            cps.it_lim = val;\r\n            break;\r\n        case LPX_K_ITCNT:\r\n            lp.it_cnt = val;\r\n            break;\r\n        case LPX_K_OUTFRQ:\r\n            if (!(val > 0))\r\n                xerror(\"lpx_set_int_parm: OUTFRQ = \" + val + \"; invalid value\");\r\n            cps.out_frq = val;\r\n            break;\r\n        case LPX_K_BRANCH:\r\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\r\n                xerror(\"lpx_set_int_parm: BRANCH = \" + val + \"; invalid value\");\r\n            cps.branch = val;\r\n            break;\r\n        case LPX_K_BTRACK:\r\n            if (!(val == 0 || val == 1 || val == 2 || val == 3))\r\n                xerror(\"lpx_set_int_parm: BTRACK = \" + val + \"; invalid value\");\r\n            cps.btrack = val;\r\n            break;\r\n        case LPX_K_MPSINFO:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSINFO = \" + val + \"; invalid value\");\r\n            cps.mps_info = val;\r\n            break;\r\n        case LPX_K_MPSOBJ:\r\n            if (!(val == 0 || val == 1 || val == 2))\r\n                xerror(\"lpx_set_int_parm: MPSOBJ = \" + val + \"; invalid value\");\r\n            cps.mps_obj = val;\r\n            break;\r\n        case LPX_K_MPSORIG:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSORIG = \" + val + \"; invalid value\");\r\n            cps.mps_orig = val;\r\n            break;\r\n        case LPX_K_MPSWIDE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSWIDE = \" + val + \"; invalid value\");\r\n            cps.mps_wide = val;\r\n            break;\r\n        case LPX_K_MPSFREE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSFREE = \" + val + \"; invalid value\");\r\n            cps.mps_free = val;\r\n            break;\r\n        case LPX_K_MPSSKIP:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: MPSSKIP = \" + val + \"; invalid value\");\r\n            cps.mps_skip = val;\r\n            break;\r\n        case LPX_K_LPTORIG:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: LPTORIG = \" + val + \"; invalid value\");\r\n            cps.lpt_orig = val;\r\n            break;\r\n        case LPX_K_PRESOL:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: PRESOL = \" + val + \"; invalid value\");\r\n            cps.presol = val;\r\n            break;\r\n        case LPX_K_BINARIZE:\r\n            if (!(val == 0 || val == 1))\r\n                xerror(\"lpx_set_int_parm: BINARIZE = \" + val + \"; invalid value\");\r\n            cps.binarize = val;\r\n            break;\r\n        case LPX_K_USECUTS:\r\n            if (val & ~LPX_C_ALL)\r\n                xerror(\"lpx_set_int_parm: USECUTS = \" + val + \"; invalid value\");\r\n            cps.use_cuts = val;\r\n            break;\r\n        case LPX_K_BFTYPE:\r\n        {   parm = {};\r\n            glp_get_bfcp(lp, parm);\r\n            switch (val)\r\n            {  case 1:\r\n                parm.type = GLP_BF_FT; break;\r\n                case 2:\r\n                    parm.type = GLP_BF_BG; break;\r\n                case 3:\r\n                    parm.type = GLP_BF_GR; break;\r\n                default:\r\n                    xerror(\"lpx_set_int_parm: BFTYPE = \" + val + \"; invalid value\");\r\n            }\r\n            glp_set_bfcp(lp, parm);\r\n        }\r\n            break;\r\n        default:\r\n            xerror(\"lpx_set_int_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n}\r\n\r\nfunction lpx_get_int_parm(lp, parm){\r\n    /* query integer control parameter */\r\n    var cps = access_parms(lp);\r\n    var val = 0;\r\n    switch (parm)\r\n    {  case LPX_K_MSGLEV:\r\n        val = cps.msg_lev; break;\r\n        case LPX_K_SCALE:\r\n            val = cps.scale; break;\r\n        case LPX_K_DUAL:\r\n            val = cps.dual; break;\r\n        case LPX_K_PRICE:\r\n            val = cps.price; break;\r\n        case LPX_K_ROUND:\r\n            val = cps.round; break;\r\n        case LPX_K_ITLIM:\r\n            val = cps.it_lim; break;\r\n        case LPX_K_ITCNT:\r\n            val = lp.it_cnt; break;\r\n        case LPX_K_OUTFRQ:\r\n            val = cps.out_frq; break;\r\n        case LPX_K_BRANCH:\r\n            val = cps.branch; break;\r\n        case LPX_K_BTRACK:\r\n            val = cps.btrack; break;\r\n        case LPX_K_MPSINFO:\r\n            val = cps.mps_info; break;\r\n        case LPX_K_MPSOBJ:\r\n            val = cps.mps_obj; break;\r\n        case LPX_K_MPSORIG:\r\n            val = cps.mps_orig; break;\r\n        case LPX_K_MPSWIDE:\r\n            val = cps.mps_wide; break;\r\n        case LPX_K_MPSFREE:\r\n            val = cps.mps_free; break;\r\n        case LPX_K_MPSSKIP:\r\n            val = cps.mps_skip; break;\r\n        case LPX_K_LPTORIG:\r\n            val = cps.lpt_orig; break;\r\n        case LPX_K_PRESOL:\r\n            val = cps.presol; break;\r\n        case LPX_K_BINARIZE:\r\n            val = cps.binarize; break;\r\n        case LPX_K_USECUTS:\r\n            val = cps.use_cuts; break;\r\n        case LPX_K_BFTYPE:\r\n        {   parm = {};\r\n            glp_get_bfcp(lp, parm);\r\n            switch (parm.type)\r\n            {  case GLP_BF_FT:\r\n                val = 1; break;\r\n                case GLP_BF_BG:\r\n                    val = 2; break;\r\n                case GLP_BF_GR:\r\n                    val = 3; break;\r\n                default:\r\n                    xassert(lp != lp);\r\n            }\r\n        }\r\n            break;\r\n        default:\r\n            xerror(\"lpx_get_int_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n    return val;\r\n}\r\n\r\nfunction lpx_set_real_parm(lp, parm, val){\r\n    /* set (change) real control parameter */\r\n    var cps = access_parms(lp);\r\n    switch (parm)\r\n    {  case LPX_K_RELAX:\r\n        if (!(0.0 <= val && val <= 1.0))\r\n            xerror(\"lpx_set_real_parm: RELAX = \" + val + \"; invalid value\");\r\n        cps.relax = val;\r\n        break;\r\n        case LPX_K_TOLBND:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLBND = \" + val + \"; invalid value\");\r\n            cps.tol_bnd = val;\r\n            break;\r\n        case LPX_K_TOLDJ:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLDJ = \" + val + \"; invalid value\");\r\n            cps.tol_dj = val;\r\n            break;\r\n        case LPX_K_TOLPIV:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLPIV = \" + val + \"; invalid value\");\r\n            cps.tol_piv = val;\r\n            break;\r\n        case LPX_K_OBJLL:\r\n            cps.obj_ll = val;\r\n            break;\r\n        case LPX_K_OBJUL:\r\n            cps.obj_ul = val;\r\n            break;\r\n        case LPX_K_TMLIM:\r\n            cps.tm_lim = val;\r\n            break;\r\n        case LPX_K_OUTDLY:\r\n            cps.out_dly = val;\r\n            break;\r\n        case LPX_K_TOLINT:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLINT = \" + val + \"; invalid value\");\r\n            cps.tol_int = val;\r\n            break;\r\n        case LPX_K_TOLOBJ:\r\n            if (!(DBL_EPSILON <= val && val <= 0.001))\r\n                xerror(\"lpx_set_real_parm: TOLOBJ = \" + val + \"; invalid value\");\r\n            cps.tol_obj = val;\r\n            break;\r\n        case LPX_K_MIPGAP:\r\n            if (val < 0.0)\r\n                xerror(\"lpx_set_real_parm: MIPGAP = \" + val + \"; invalid value\");\r\n            cps.mip_gap = val;\r\n            break;\r\n        default:\r\n            xerror(\"lpx_set_real_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n}\r\n\r\nfunction lpx_get_real_parm(lp, parm){\r\n    /* query real control parameter */\r\n    var cps = access_parms(lp);\r\n    var val = 0.0;\r\n    switch (parm)\r\n    {  case LPX_K_RELAX:\r\n        val = cps.relax;\r\n        break;\r\n        case LPX_K_TOLBND:\r\n            val = cps.tol_bnd;\r\n            break;\r\n        case LPX_K_TOLDJ:\r\n            val = cps.tol_dj;\r\n            break;\r\n        case LPX_K_TOLPIV:\r\n            val = cps.tol_piv;\r\n            break;\r\n        case LPX_K_OBJLL:\r\n            val = cps.obj_ll;\r\n            break;\r\n        case LPX_K_OBJUL:\r\n            val = cps.obj_ul;\r\n            break;\r\n        case LPX_K_TMLIM:\r\n            val = cps.tm_lim;\r\n            break;\r\n        case LPX_K_OUTDLY:\r\n            val = cps.out_dly;\r\n            break;\r\n        case LPX_K_TOLINT:\r\n            val = cps.tol_int;\r\n            break;\r\n        case LPX_K_TOLOBJ:\r\n            val = cps.tol_obj;\r\n            break;\r\n        case LPX_K_MIPGAP:\r\n            val = cps.mip_gap;\r\n            break;\r\n        default:\r\n            xerror(\"lpx_get_real_parm: parm = \" + parm + \"; invalid parameter\");\r\n    }\r\n    return val;\r\n}\r\n\r\nfunction lpx_read_mps(fname){\r\n    /* read problem data in fixed MPS format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_mps(lp, GLP_MPS_DECK, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_mps(lp, fname){\r\n    /* write problem data in fixed MPS format */\r\n    return glp_write_mps(lp, GLP_MPS_DECK, null, fname);\r\n}\r\n\r\nfunction lpx_read_bas(lp, fname){\r\n    /* read LP basis in fixed MPS format */\r\n    xassert(lp == lp);\r\n    xassert(fname == fname);\r\n    xerror(\"lpx_read_bas: operation not supported\");\r\n    return 0;\r\n}\r\n\r\nfunction lpx_write_bas(lp, fname){\r\n    /* write LP basis in fixed MPS format */\r\n    xassert(lp == lp);\r\n    xassert(fname == fname);\r\n    xerror(\"lpx_write_bas: operation not supported\");\r\n    return 0;\r\n}\r\n\r\nfunction lpx_read_freemps(fname){\r\n    /* read problem data in free MPS format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_mps(lp, GLP_MPS_FILE, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_freemps(lp, fname){\r\n    /* write problem data in free MPS format */\r\n    return glp_write_mps(lp, GLP_MPS_FILE, null, fname);\r\n}\r\n\r\nfunction lpx_read_cpxlp(fname){\r\n    /* read problem data in CPLEX LP format */\r\n    var lp = lpx_create_prob();\r\n    if (glp_read_lp(lp, null, fname)){\r\n        lp = null;\r\n    }\r\n    return lp;\r\n}\r\n\r\nfunction lpx_write_cpxlp(lp, fname){\r\n    /* write problem data in CPLEX LP format */\r\n    return glp_write_lp(lp, null, fname);\r\n}\r\n\r\nfunction lpx_read_model(model, data, output, tablecb){\r\n    /* read LP/MIP model written in GNU MathProg language */\r\n    var lp = null;\r\n    /* allocate the translator workspace */\r\n    var tran = glp_mpl_alloc_wksp();\r\n    /* read model section and optional data section */\r\n    if (glp_mpl_read_model(tran, model, data != null)) return done();\r\n    /* read separate data section, if required */\r\n    if (data != null)\r\n        if (glp_mpl_read_data(tran, data)) return done();\r\n    /* generate the model */\r\n    if (glp_mpl_generate(tran, output, tablecb)) return done();\r\n    /* build the problem instance from the model */\r\n    lp = glp_create_prob();\r\n    glp_mpl_build_prob(tran, lp);\r\n    function done(){\r\n        /* bring the problem object to the calling program */\r\n        return lp;\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction lpx_print_prob(lp, fname){\r\n    /* write problem data in plain text format */\r\n    return glp_write_lp(lp, null, fname);\r\n}\r\n\r\nfunction lpx_print_sol(lp, fname){\r\n    /* write LP problem solution in printable format */\r\n    return glp_print_sol(lp, fname);\r\n}\r\n\r\nfunction lpx_print_sens_bnds(lp, fname){\r\n    /* write bounds sensitivity information */\r\n    if (glp_get_status(lp) == GLP_OPT && !glp_bf_exists(lp))\r\n        glp_factorize(lp);\r\n    return glp_print_ranges(lp, 0, null, 0, fname);\r\n}\r\n\r\nfunction lpx_print_ips(lp, fname){\r\n    /* write interior point solution in printable format */\r\n    return glp_print_ipt(lp, fname);\r\n}\r\n\r\nfunction lpx_print_mip(lp, fname){\r\n    /* write MIP problem solution in printable format */\r\n    return glp_print_mip(lp, fname);\r\n}\r\n\r\nfunction lpx_is_b_avail(lp){\r\n    /* check if LP basis is available */\r\n    return glp_bf_exists(lp);\r\n}\r\n\r\nfunction lpx_main(argc, argv)\r\n{     /* stand-alone LP/MIP solver */\r\n    return glp_main(argc, argv);\r\n}\r\n\r\n/* return codes: */\r\nvar\r\n    LUF_ESING   = 1,  /* singular matrix */\r\n    LUF_ECOND   = 2;  /* ill-conditioned matrix */\r\n\r\nfunction luf_create_it(){\r\n    var luf = {};\r\n    luf.n_max = luf.n = 0;\r\n    luf.valid = 0;\r\n    luf.fr_ptr = luf.fr_len = null;\r\n    luf.fc_ptr = luf.fc_len = null;\r\n    luf.vr_ptr = luf.vr_len = luf.vr_cap = null;\r\n    luf.vr_piv = null;\r\n    luf.vc_ptr = luf.vc_len = luf.vc_cap = null;\r\n    luf.pp_row = luf.pp_col = null;\r\n    luf.qq_row = luf.qq_col = null;\r\n    luf.sv_size = 0;\r\n    luf.sv_beg = luf.sv_end = 0;\r\n    luf.sv_ind = null;\r\n    luf.sv_val = null;\r\n    luf.sv_head = luf.sv_tail = 0;\r\n    luf.sv_prev = luf.sv_next = null;\r\n    luf.vr_max = null;\r\n    luf.rs_head = luf.rs_prev = luf.rs_next = null;\r\n    luf.cs_head = luf.cs_prev = luf.cs_next = null;\r\n    luf.flag = null;\r\n    luf.work = null;\r\n    luf.new_sva = 0;\r\n    luf.piv_tol = 0.10;\r\n    luf.piv_lim = 4;\r\n    luf.suhl = 1;\r\n    luf.eps_tol = 1e-15;\r\n    luf.max_gro = 1e+10;\r\n    luf.nnz_a = luf.nnz_f = luf.nnz_v = 0;\r\n    luf.max_a = luf.big_v = 0.0;\r\n    luf.rank = 0;\r\n    return luf;\r\n}\r\n\r\nfunction luf_defrag_sva(luf){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_next = luf.sv_next;\r\n    var sv_beg = 1;\r\n    var i, j, k;\r\n    /* skip rows and columns, which do not need to be relocated */\r\n    for (k = luf.sv_head; k != 0; k = sv_next[k])\r\n    {  if (k <= n)\r\n    {  /* i-th row of the matrix V */\r\n        i = k;\r\n        if (vr_ptr[i] != sv_beg) break;\r\n        vr_cap[i] = vr_len[i];\r\n        sv_beg += vr_cap[i];\r\n    }\r\n    else\r\n    {  /* j-th column of the matrix V */\r\n        j = k - n;\r\n        if (vc_ptr[j] != sv_beg) break;\r\n        vc_cap[j] = vc_len[j];\r\n        sv_beg += vc_cap[j];\r\n    }\r\n    }\r\n    /* relocate other rows and columns in order to gather all unused\r\n     locations in one continuous extent */\r\n    for (; k != 0; k = sv_next[k])\r\n    {  if (k <= n)\r\n    {  /* i-th row of the matrix V */\r\n        i = k;\r\n        xcopyArr(sv_ind, sv_beg, sv_ind, vr_ptr[i], vr_len[i]);\r\n        xcopyArr(sv_val, sv_beg, sv_val, vr_ptr[i], vr_len[i]);\r\n        vr_ptr[i] = sv_beg;\r\n        vr_cap[i] = vr_len[i];\r\n        sv_beg += vr_cap[i];\r\n    }\r\n    else\r\n    {  /* j-th column of the matrix V */\r\n        j = k - n;\r\n        xcopyArr(sv_ind, sv_beg, sv_ind, vc_ptr[j], vc_len[j]);\r\n        xcopyArr(sv_val, sv_beg, sv_val ,vc_ptr[j], vc_len[j]);\r\n        vc_ptr[j] = sv_beg;\r\n        vc_cap[j] = vc_len[j];\r\n        sv_beg += vc_cap[j];\r\n    }\r\n    }\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg = sv_beg;\r\n}\r\n\r\nfunction luf_enlarge_row(luf, i, cap){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var cur, k, kk;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(vr_cap[i] < cap);\r\n    /* if there are less than cap free locations, defragment SVA */\r\n    if (luf.sv_end - luf.sv_beg < cap)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < cap)\r\n        {  ret = 1;\r\n            return ret;\r\n        }\r\n    }\r\n    /* save current capacity of the i-th row */\r\n    cur = vr_cap[i];\r\n    /* copy existing elements to the beginning of the free part */\r\n    xcopyArr(sv_ind, luf.sv_beg, sv_ind, vr_ptr[i], vr_len[i]);\r\n    xcopyArr(sv_val, luf.sv_beg, sv_val, vr_ptr[i], vr_len[i]);\r\n    /* set new pointer and new capacity of the i-th row */\r\n    vr_ptr[i] = luf.sv_beg;\r\n    vr_cap[i] = cap;\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg += cap;\r\n    /* now the i-th row starts in the rightmost location among other\r\n     rows and columns of the matrix V, so its node should be moved\r\n     to the end of the row/column linked list */\r\n    k = i;\r\n    /* remove the i-th row node from the linked list */\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n    {  /* capacity of the previous row/column can be increased at the\r\n     expense of old locations of the i-th row */\r\n        kk = sv_prev[k];\r\n        if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    }\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* insert the i-th row node to the end of the linked list */\r\n    sv_prev[k] = luf.sv_tail;\r\n    sv_next[k] = 0;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = k;\r\n    else\r\n        sv_next[sv_prev[k]] = k;\r\n    luf.sv_tail = k;\r\n    return ret;\r\n}\r\n\r\nfunction luf_enlarge_col(luf, j, cap){\r\n    var n = luf.n;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var cur, k, kk;\r\n    xassert(1 <= j && j <= n);\r\n    xassert(vc_cap[j] < cap);\r\n    /* if there are less than cap free locations, defragment SVA */\r\n    if (luf.sv_end - luf.sv_beg < cap)\r\n    {  luf_defrag_sva(luf);\r\n        if (luf.sv_end - luf.sv_beg < cap)\r\n        {  ret = 1;\r\n            return ret;\r\n        }\r\n    }\r\n    /* save current capacity of the j-th column */\r\n    cur = vc_cap[j];\r\n    /* copy existing elements to the beginning of the free part */\r\n    xcopyArr(sv_ind, luf.sv_beg, sv_ind, vc_ptr[j], vc_len[j]);\r\n    xcopyArr(sv_val, luf.sv_beg, sv_val, vc_ptr[j], vc_len[j]);\r\n    /* set new pointer and new capacity of the j-th column */\r\n    vc_ptr[j] = luf.sv_beg;\r\n    vc_cap[j] = cap;\r\n    /* set new pointer to the beginning of the free part */\r\n    luf.sv_beg += cap;\r\n    /* now the j-th column starts in the rightmost location among\r\n     other rows and columns of the matrix V, so its node should be\r\n     moved to the end of the row/column linked list */\r\n    k = n + j;\r\n    /* remove the j-th column node from the linked list */\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n    {  /* capacity of the previous row/column can be increased at the\r\n     expense of old locations of the j-th column */\r\n        kk = sv_prev[k];\r\n        if (kk <= n) vr_cap[kk] += cur; else vc_cap[kk-n] += cur;\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    }\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* insert the j-th column node to the end of the linked list */\r\n    sv_prev[k] = luf.sv_tail;\r\n    sv_next[k] = 0;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = k;\r\n    else\r\n        sv_next[sv_prev[k]] = k;\r\n    luf.sv_tail = k;\r\n    return ret;\r\n}\r\n\r\nfunction reallocate(luf, n){\r\n    var n_max = luf.n_max;\r\n    luf.n = n;\r\n    if (n <= n_max) return;\r\n    luf.n_max = n_max = n + 100;\r\n    luf.fr_ptr = new Int32Array(1+n_max);\r\n    luf.fr_len = new Int32Array(1+n_max);\r\n    luf.fc_ptr = new Int32Array(1+n_max);\r\n    luf.fc_len = new Int32Array(1+n_max);\r\n    luf.vr_ptr = new Int32Array(1+n_max);\r\n    luf.vr_len = new Int32Array(1+n_max);\r\n    luf.vr_cap = new Int32Array(1+n_max);\r\n    luf.vr_piv = new Float64Array(1+n_max);\r\n    luf.vc_ptr = new Int32Array(1+n_max);\r\n    luf.vc_len = new Int32Array(1+n_max);\r\n    luf.vc_cap = new Int32Array(1+n_max);\r\n    luf.pp_row = new Int32Array(1+n_max);\r\n    luf.pp_col = new Int32Array(1+n_max);\r\n    luf.qq_row = new Int32Array(1+n_max);\r\n    luf.qq_col = new Int32Array(1+n_max);\r\n    luf.sv_prev = new Int32Array(1+n_max+n_max);\r\n    luf.sv_next = new Int32Array(1+n_max+n_max);\r\n    luf.vr_max = new Float64Array(1+n_max);\r\n    luf.rs_head = new Int32Array(1+n_max);\r\n    luf.rs_prev = new Int32Array(1+n_max);\r\n    luf.rs_next = new Int32Array(1+n_max);\r\n    luf.cs_head = new Int32Array(1+n_max);\r\n    luf.cs_prev = new Int32Array(1+n_max);\r\n    luf.cs_next = new Int32Array(1+n_max);\r\n    luf.flag = new Int32Array(1+n_max);\r\n    luf.work = new Float64Array(1+n_max);\r\n}\r\n\r\nfunction initialize(luf, col, info){\r\n    var n = luf.n;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var pp_row = luf.pp_row;\r\n    var pp_col = luf.pp_col;\r\n    var qq_row = luf.qq_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_prev = luf.rs_prev;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var flag = luf.flag;\r\n    var work = luf.work;\r\n    var ret = 0;\r\n    var i, i_ptr, j, j_beg, j_end, k, len, nnz, sv_beg, sv_end, ptr;\r\n    var big, val;\r\n    /* free all locations of the sparse vector area */\r\n    sv_beg = 1;\r\n    sv_end = luf.sv_size + 1;\r\n    /* (row-wise representation of the matrix F is not initialized,\r\n     because it is not used at the factorization stage) */\r\n    /* build the matrix F in column-wise format (initially F = I) */\r\n    for (j = 1; j <= n; j++)\r\n    {  fc_ptr[j] = sv_end;\r\n        fc_len[j] = 0;\r\n    }\r\n    /* clear rows of the matrix V; clear the flag array */\r\n    for (i = 1; i <= n; i++)\r\n        vr_len[i] = vr_cap[i] = 0, flag[i] = 0;\r\n    /* build the matrix V in column-wise format (initially V = A);\r\n     count non-zeros in rows of this matrix; count total number of\r\n     non-zeros; compute largest of absolute values of elements */\r\n    nnz = 0;\r\n    big = 0.0;\r\n    for (j = 1; j <= n; j++)\r\n    {  var rn = pp_row;\r\n        var aj = work;\r\n        /* obtain j-th column of the matrix A */\r\n        len = col(info, j, rn, aj);\r\n        if (!(0 <= len && len <= n))\r\n            xerror(\"luf_factorize: j = \" + j + \"; len = \" + len + \"; invalid column length\");\r\n        /* check for free locations */\r\n        if (sv_end - sv_beg < len)\r\n        {  /* overflow of the sparse vector area */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* set pointer to the j-th column */\r\n        vc_ptr[j] = sv_beg;\r\n        /* set length of the j-th column */\r\n        vc_len[j] = vc_cap[j] = len;\r\n        /* count total number of non-zeros */\r\n        nnz += len;\r\n        /* walk through elements of the j-th column */\r\n        for (ptr = 1; ptr <= len; ptr++)\r\n        {  /* get row index and numerical value of a[i,j] */\r\n            i = rn[ptr];\r\n            val = aj[ptr];\r\n            if (!(1 <= i && i <= n))\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; invalid row index\");\r\n            if (flag[i])\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; duplicate element not allowed\");\r\n            if (val == 0.0)\r\n                xerror(\"luf_factorize: i = \" + i + \"; j = \" + j + \"; zero element not allowed\");\r\n            /* add new element v[i,j] = a[i,j] to j-th column */\r\n            sv_ind[sv_beg] = i;\r\n            sv_val[sv_beg] = val;\r\n            sv_beg++;\r\n            /* big := max(big, |a[i,j]|) */\r\n            if (val < 0.0) val = - val;\r\n            if (big < val) big = val;\r\n            /* mark non-zero in the i-th position of the j-th column */\r\n            flag[i] = 1;\r\n            /* increase length of the i-th row */\r\n            vr_cap[i]++;\r\n        }\r\n        /* reset all non-zero marks */\r\n        for (ptr = 1; ptr <= len; ptr++) flag[rn[ptr]] = 0;\r\n    }\r\n    /* allocate rows of the matrix V */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* get length of the i-th row */\r\n        len = vr_cap[i];\r\n        /* check for free locations */\r\n        if (sv_end - sv_beg < len)\r\n        {  /* overflow of the sparse vector area */\r\n            ret = 1;\r\n            return ret;\r\n        }\r\n        /* set pointer to the i-th row */\r\n        vr_ptr[i] = sv_beg;\r\n        /* reserve locations for the i-th row */\r\n        sv_beg += len;\r\n    }\r\n    /* build the matrix V in row-wise format using representation of\r\n     this matrix in column-wise format */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (k = j_beg; k <= j_end; k++)\r\n        {  /* get row index and numerical value of v[i,j] */\r\n            i = sv_ind[k];\r\n            val = sv_val[k];\r\n            /* store element in the i-th row */\r\n            i_ptr = vr_ptr[i] + vr_len[i];\r\n            sv_ind[i_ptr] = j;\r\n            sv_val[i_ptr] = val;\r\n            /* increase count of the i-th row */\r\n            vr_len[i]++;\r\n        }\r\n    }\r\n    /* initialize the matrices P and Q (initially P = Q = I) */\r\n    for (k = 1; k <= n; k++)\r\n        pp_row[k] = pp_col[k] = qq_row[k] = qq_col[k] = k;\r\n    /* set sva partitioning pointers */\r\n    luf.sv_beg = sv_beg;\r\n    luf.sv_end = sv_end;\r\n    /* the initial physical order of rows and columns of the matrix V\r\n     is n+1, ..., n+n, 1, ..., n (firstly columns, then rows) */\r\n    luf.sv_head = n+1;\r\n    luf.sv_tail = n;\r\n    for (i = 1; i <= n; i++)\r\n    {  sv_prev[i] = i-1;\r\n        sv_next[i] = i+1;\r\n    }\r\n    sv_prev[1] = n+n;\r\n    sv_next[n] = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  sv_prev[n+j] = n+j-1;\r\n        sv_next[n+j] = n+j+1;\r\n    }\r\n    sv_prev[n+1] = 0;\r\n    sv_next[n+n] = 1;\r\n    /* clear working arrays */\r\n    for (k = 1; k <= n; k++)\r\n    {  flag[k] = 0;\r\n        work[k] = 0.0;\r\n    }\r\n    /* initialize some statistics */\r\n    luf.nnz_a = nnz;\r\n    luf.nnz_f = 0;\r\n    luf.nnz_v = nnz;\r\n    luf.max_a = big;\r\n    luf.big_v = big;\r\n    luf.rank = -1;\r\n    /* initially the active submatrix is the entire matrix V */\r\n    /* largest of absolute values of elements in each active row is\r\n     unknown yet */\r\n    for (i = 1; i <= n; i++) vr_max[i] = -1.0;\r\n    /* build linked lists of active rows */\r\n    for (len = 0; len <= n; len++) rs_head[len] = 0;\r\n    for (i = 1; i <= n; i++)\r\n    {  len = vr_len[i];\r\n        rs_prev[i] = 0;\r\n        rs_next[i] = rs_head[len];\r\n        if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n        rs_head[len] = i;\r\n    }\r\n    /* build linked lists of active columns */\r\n    for (len = 0; len <= n; len++) cs_head[len] = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  len = vc_len[j];\r\n        cs_prev[j] = 0;\r\n        cs_next[j] = cs_head[len];\r\n        if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;\r\n        cs_head[len] = j;\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction find_pivot(luf, callback){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var piv_tol = luf.piv_tol;\r\n    var piv_lim = luf.piv_lim;\r\n    var suhl = luf.suhl;\r\n    var p, q, len, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr,\r\n        ncand, next_j, min_p, min_q, min_len;\r\n    var best, cost, big, temp;\r\n    /* initially no pivot candidates have been found so far */\r\n    p = q = 0; best = DBL_MAX; ncand = 0;\r\n    /* if in the active submatrix there is a column that has the only\r\n     non-zero (column singleton), choose it as pivot */\r\n    j = cs_head[1];\r\n    if (j != 0)\r\n    {  xassert(vc_len[j] == 1);\r\n        p = sv_ind[vc_ptr[j]]; q = j;\r\n        return done();\r\n    }\r\n    /* if in the active submatrix there is a row that has the only\r\n     non-zero (row singleton), choose it as pivot */\r\n    i = rs_head[1];\r\n    if (i != 0)\r\n    {  xassert(vr_len[i] == 1);\r\n        p = i; q = sv_ind[vr_ptr[i]];\r\n        return done();\r\n    }\r\n    /* there are no singletons in the active submatrix; walk through\r\n     other non-empty rows and columns */\r\n    for (len = 2; len <= n; len++)\r\n    {  /* consider active columns that have len non-zeros */\r\n        for (j = cs_head[len]; j != 0; j = next_j)\r\n        {  /* the j-th column has len non-zeros */\r\n            j_beg = vc_ptr[j];\r\n            j_end = j_beg + vc_len[j] - 1;\r\n            /* save pointer to the next column with the same length */\r\n            next_j = cs_next[j];\r\n            /* find an element in the j-th column, which is placed in a\r\n             row with minimal number of non-zeros and satisfies to the\r\n             stability condition (such element may not exist) */\r\n            min_p = min_q = 0; min_len = INT_MAX;\r\n            for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n            {  /* get row index of v[i,j] */\r\n                i = sv_ind[j_ptr];\r\n                i_beg = vr_ptr[i];\r\n                i_end = i_beg + vr_len[i] - 1;\r\n                /* if the i-th row is not shorter than that one, where\r\n                 minimal element is currently placed, skip v[i,j] */\r\n                if (vr_len[i] >= min_len) continue;\r\n                /* determine the largest of absolute values of elements\r\n                 in the i-th row */\r\n                big = vr_max[i];\r\n                if (big < 0.0)\r\n                {  /* the largest value is unknown yet; compute it */\r\n                    for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n                    {  temp = sv_val[i_ptr];\r\n                        if (temp < 0.0) temp = - temp;\r\n                        if (big < temp) big = temp;\r\n                    }\r\n                    vr_max[i] = big;\r\n                }\r\n                /* find v[i,j] in the i-th row */\r\n                for (i_ptr = vr_ptr[i]; sv_ind[i_ptr] != j; i_ptr++){}\r\n                xassert(i_ptr <= i_end);\r\n                /* if v[i,j] doesn't satisfy to the stability condition,\r\n                 skip it */\r\n                temp = sv_val[i_ptr];\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp < piv_tol * big) continue;\r\n                /* v[i,j] is better than the current minimal element */\r\n                min_p = i; min_q = j; min_len = vr_len[i];\r\n                /* if Markowitz cost of the current minimal element is\r\n                 not greater than (len-1)**2, it can be chosen right\r\n                 now; this heuristic reduces the search and works well\r\n                 in many cases */\r\n                if (min_len <= len)\r\n                {  p = min_p; q = min_q;\r\n                    return done();\r\n                }\r\n            }\r\n            /* the j-th column has been scanned */\r\n            if (min_p != 0)\r\n            {  /* the minimal element is a next pivot candidate */\r\n                ncand++;\r\n                /* compute its Markowitz cost */\r\n                cost = (min_len - 1) * (len - 1);\r\n                /* choose between the minimal element and the current\r\n                 candidate */\r\n                if (cost < best) {p = min_p; q = min_q; best = cost}\r\n                /* if piv_lim candidates have been considered, there are\r\n                 doubts that a much better candidate exists; therefore\r\n                 it's time to terminate the search */\r\n                if (ncand == piv_lim) return done();\r\n            }\r\n            else\r\n            {  /* the j-th column has no elements, which satisfy to the\r\n             stability condition; Uwe Suhl suggests to exclude such\r\n             column from the further consideration until it becomes\r\n             a column singleton; in hard cases this significantly\r\n             reduces a time needed for pivot searching */\r\n                if (suhl)\r\n                {  /* remove the j-th column from the active set */\r\n                    if (cs_prev[j] == 0)\r\n                        cs_head[len] = cs_next[j];\r\n                    else\r\n                        cs_next[cs_prev[j]] = cs_next[j];\r\n                    if (cs_next[j] == 0){\r\n                        /* nop */\r\n                    }\r\n                    else\r\n                        cs_prev[cs_next[j]] = cs_prev[j];\r\n                    /* the following assignment is used to avoid an error\r\n                     when the routine eliminate (see below) will try to\r\n                     remove the j-th column from the active set */\r\n                    cs_prev[j] = cs_next[j] = j;\r\n                }\r\n            }\r\n        }\r\n        /* consider active rows that have len non-zeros */\r\n        for (i = rs_head[len]; i != 0; i = rs_next[i])\r\n        {  /* the i-th row has len non-zeros */\r\n            i_beg = vr_ptr[i];\r\n            i_end = i_beg + vr_len[i] - 1;\r\n            /* determine the largest of absolute values of elements in\r\n             the i-th row */\r\n            big = vr_max[i];\r\n            if (big < 0.0)\r\n            {  /* the largest value is unknown yet; compute it */\r\n                for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n                {  temp = sv_val[i_ptr];\r\n                    if (temp < 0.0) temp = - temp;\r\n                    if (big < temp) big = temp;\r\n                }\r\n                vr_max[i] = big;\r\n            }\r\n            /* find an element in the i-th row, which is placed in a\r\n             column with minimal number of non-zeros and satisfies to\r\n             the stability condition (such element always exists) */\r\n            min_p = min_q = 0; min_len = INT_MAX;\r\n            for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n            {  /* get column index of v[i,j] */\r\n                j = sv_ind[i_ptr];\r\n                /* if the j-th column is not shorter than that one, where\r\n                 minimal element is currently placed, skip v[i,j] */\r\n                if (vc_len[j] >= min_len) continue;\r\n                /* if v[i,j] doesn't satisfy to the stability condition,\r\n                 skip it */\r\n                temp = sv_val[i_ptr];\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp < piv_tol * big) continue;\r\n                /* v[i,j] is better than the current minimal element */\r\n                min_p = i; min_q = j; min_len = vc_len[j];\r\n                /* if Markowitz cost of the current minimal element is\r\n                 not greater than (len-1)**2, it can be chosen right\r\n                 now; this heuristic reduces the search and works well\r\n                 in many cases */\r\n                if (min_len <= len)\r\n                {  p = min_p; q = min_q;\r\n                    return done();\r\n                }\r\n            }\r\n            /* the i-th row has been scanned */\r\n            if (min_p != 0)\r\n            {  /* the minimal element is a next pivot candidate */\r\n                ncand++;\r\n                /* compute its Markowitz cost */\r\n                cost = (len - 1) * (min_len - 1);\r\n                /* choose between the minimal element and the current\r\n                 candidate */\r\n                if (cost < best) {p = min_p; q = min_q; best = cost}\r\n                /* if piv_lim candidates have been considered, there are\r\n                 doubts that a much better candidate exists; therefore\r\n                 it's time to terminate the search */\r\n                if (ncand == piv_lim) return done();\r\n            }\r\n            else\r\n            {  /* this can't be because this can never be */\r\n                xassert(min_p != min_p);\r\n            }\r\n        }\r\n    }\r\n    function done(){\r\n        /* bring the pivot to the factorizing routine */\r\n        callback(p, q);\r\n        return (p == 0);\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction eliminate(luf, p, q){\r\n    var n = luf.n;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_cap = luf.vr_cap;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var vr_max = luf.vr_max;\r\n    var rs_head = luf.rs_head;\r\n    var rs_prev = luf.rs_prev;\r\n    var rs_next = luf.rs_next;\r\n    var cs_head = luf.cs_head;\r\n    var cs_prev = luf.cs_prev;\r\n    var cs_next = luf.cs_next;\r\n    var flag = luf.flag;\r\n    var work = luf.work;\r\n    var eps_tol = luf.eps_tol;\r\n    /* at this stage the row-wise representation of the matrix F is\r\n     not used, so fr_len can be used as a working array */\r\n    var ndx = luf.fr_len;\r\n    var ret = 0;\r\n    var len, fill, i, i_beg, i_end, i_ptr, j, j_beg, j_end, j_ptr, k,\r\n        p_beg, p_end, p_ptr, q_beg, q_end, q_ptr;\r\n    var fip, val, vpq, temp;\r\n    xassert(1 <= p && p <= n);\r\n    xassert(1 <= q && q <= n);\r\n    /* remove the p-th (pivot) row from the active set; this row will\r\n     never return there */\r\n    if (rs_prev[p] == 0)\r\n        rs_head[vr_len[p]] = rs_next[p];\r\n    else\r\n        rs_next[rs_prev[p]] = rs_next[p];\r\n    if (rs_next[p] == 0){\r\n\r\n    }\r\n    else\r\n        rs_prev[rs_next[p]] = rs_prev[p];\r\n    /* remove the q-th (pivot) column from the active set; this column\r\n     will never return there */\r\n    if (cs_prev[q] == 0)\r\n        cs_head[vc_len[q]] = cs_next[q];\r\n    else\r\n        cs_next[cs_prev[q]] = cs_next[q];\r\n    if (cs_next[q] == 0){\r\n\r\n    }\r\n    else\r\n        cs_prev[cs_next[q]] = cs_prev[q];\r\n    /* find the pivot v[p,q] = u[k,k] in the p-th row */\r\n    p_beg = vr_ptr[p];\r\n    p_end = p_beg + vr_len[p] - 1;\r\n    for (p_ptr = p_beg; sv_ind[p_ptr] != q; p_ptr++){/* nop */}\r\n    xassert(p_ptr <= p_end);\r\n    /* store value of the pivot */\r\n    vpq = (vr_piv[p] = sv_val[p_ptr]);\r\n    /* remove the pivot from the p-th row */\r\n    sv_ind[p_ptr] = sv_ind[p_end];\r\n    sv_val[p_ptr] = sv_val[p_end];\r\n    vr_len[p]--;\r\n    p_end--;\r\n    /* find the pivot v[p,q] = u[k,k] in the q-th column */\r\n    q_beg = vc_ptr[q];\r\n    q_end = q_beg + vc_len[q] - 1;\r\n    for (q_ptr = q_beg; sv_ind[q_ptr] != p; q_ptr++){/* nop */}\r\n    xassert(q_ptr <= q_end);\r\n    /* remove the pivot from the q-th column */\r\n    sv_ind[q_ptr] = sv_ind[q_end];\r\n    vc_len[q]--;\r\n    q_end--;\r\n    /* walk through the p-th (pivot) row, which doesn't contain the\r\n     pivot v[p,q] already, and do the following... */\r\n    for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n    {  /* get column index of v[p,j] */\r\n        j = sv_ind[p_ptr];\r\n        /* store v[p,j] to the working array */\r\n        flag[j] = 1;\r\n        work[j] = sv_val[p_ptr];\r\n        /* remove the j-th column from the active set; this column will\r\n         return there later with new length */\r\n        if (cs_prev[j] == 0)\r\n            cs_head[vc_len[j]] = cs_next[j];\r\n        else\r\n            cs_next[cs_prev[j]] = cs_next[j];\r\n        if (cs_next[j] == 0){\r\n\r\n        }\r\n        else\r\n            cs_prev[cs_next[j]] = cs_prev[j];\r\n        /* find v[p,j] in the j-th column */\r\n        j_beg = vc_ptr[j];\r\n        j_end = j_beg + vc_len[j] - 1;\r\n        for (j_ptr = j_beg; sv_ind[j_ptr] != p; j_ptr++){/* nop */}\r\n        xassert(j_ptr <= j_end);\r\n        /* since v[p,j] leaves the active submatrix, remove it from the\r\n         j-th column; however, v[p,j] is kept in the p-th row */\r\n        sv_ind[j_ptr] = sv_ind[j_end];\r\n        vc_len[j]--;\r\n    }\r\n    /* walk through the q-th (pivot) column, which doesn't contain the\r\n     pivot v[p,q] already, and perform gaussian elimination */\r\n    while (q_beg <= q_end)\r\n    {  /* element v[i,q] should be eliminated */\r\n        /* get row index of v[i,q] */\r\n        i = sv_ind[q_beg];\r\n        /* remove the i-th row from the active set; later this row will\r\n         return there with new length */\r\n        if (rs_prev[i] == 0)\r\n            rs_head[vr_len[i]] = rs_next[i];\r\n        else\r\n            rs_next[rs_prev[i]] = rs_next[i];\r\n        if (rs_next[i] == 0){\r\n\r\n        }\r\n        else\r\n            rs_prev[rs_next[i]] = rs_prev[i];\r\n        /* find v[i,q] in the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; sv_ind[i_ptr] != q; i_ptr++){/* nop */}\r\n        xassert(i_ptr <= i_end);\r\n        /* compute gaussian multiplier f[i,p] = v[i,q] / v[p,q] */\r\n        fip = sv_val[i_ptr] / vpq;\r\n        /* since v[i,q] should be eliminated, remove it from the i-th\r\n         row */\r\n        sv_ind[i_ptr] = sv_ind[i_end];\r\n        sv_val[i_ptr] = sv_val[i_end];\r\n        vr_len[i]--;\r\n        i_end--;\r\n        /* and from the q-th column */\r\n        sv_ind[q_beg] = sv_ind[q_end];\r\n        vc_len[q]--;\r\n        q_end--;\r\n        /* perform gaussian transformation:\r\n         (i-th row) := (i-th row) - f[i,p] * (p-th row)\r\n         note that now the p-th row, which is in the working array,\r\n         doesn't contain the pivot v[p,q], and the i-th row doesn't\r\n         contain the eliminated element v[i,q] */\r\n        /* walk through the i-th row and transform existing non-zero\r\n         elements */\r\n        fill = vr_len[p];\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        {  /* get column index of v[i,j] */\r\n            j = sv_ind[i_ptr];\r\n            /* v[i,j] := v[i,j] - f[i,p] * v[p,j] */\r\n            if (flag[j])\r\n            {  /* v[p,j] != 0 */\r\n                temp = (sv_val[i_ptr] -= fip * work[j]);\r\n                if (temp < 0.0) temp = - temp;\r\n                flag[j] = 0;\r\n                fill--; /* since both v[i,j] and v[p,j] exist */\r\n                if (temp == 0.0 || temp < eps_tol)\r\n                {  /* new v[i,j] is closer to zero; replace it by exact\r\n                 zero, i.e. remove it from the active submatrix */\r\n                    /* remove v[i,j] from the i-th row */\r\n                    sv_ind[i_ptr] = sv_ind[i_end];\r\n                    sv_val[i_ptr] = sv_val[i_end];\r\n                    vr_len[i]--;\r\n                    i_ptr--;\r\n                    i_end--;\r\n                    /* find v[i,j] in the j-th column */\r\n                    j_beg = vc_ptr[j];\r\n                    j_end = j_beg + vc_len[j] - 1;\r\n                    for (j_ptr = j_beg; sv_ind[j_ptr] != i; j_ptr++){}\r\n                    xassert(j_ptr <= j_end);\r\n                    /* remove v[i,j] from the j-th column */\r\n                    sv_ind[j_ptr] = sv_ind[j_end];\r\n                    vc_len[j]--;\r\n                }\r\n                else\r\n                {  /* v_big := max(v_big, |v[i,j]|) */\r\n                    if (luf.big_v < temp) luf.big_v = temp;\r\n                }\r\n            }\r\n        }\r\n        /* now flag is the pattern of the set v[p,*] \\ v[i,*], and fill\r\n         is number of non-zeros in this set; therefore up to fill new\r\n         non-zeros may appear in the i-th row */\r\n        if (vr_len[i] + fill > vr_cap[i])\r\n        {  /* enlarge the i-th row */\r\n            if (luf_enlarge_row(luf, i, vr_len[i] + fill))\r\n            {  /* overflow of the sparse vector area */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* defragmentation may change row and column pointers of the\r\n             matrix V */\r\n            p_beg = vr_ptr[p];\r\n            p_end = p_beg + vr_len[p] - 1;\r\n            q_beg = vc_ptr[q];\r\n            q_end = q_beg + vc_len[q] - 1;\r\n        }\r\n        /* walk through the p-th (pivot) row and create new elements\r\n         of the i-th row that appear due to fill-in; column indices\r\n         of these new elements are accumulated in the array ndx */\r\n        len = 0;\r\n        for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n        {  /* get column index of v[p,j], which may cause fill-in */\r\n            j = sv_ind[p_ptr];\r\n            if (flag[j])\r\n            {  /* compute new non-zero v[i,j] = 0 - f[i,p] * v[p,j] */\r\n                temp = (val = - fip * work[j]);\r\n                if (temp < 0.0) temp = - temp;\r\n                if (temp == 0.0 || temp < eps_tol){\r\n                    /* if v[i,j] is closer to zero; just ignore it */\r\n                }\r\n                else\r\n                {  /* add v[i,j] to the i-th row */\r\n                    i_ptr = vr_ptr[i] + vr_len[i];\r\n                    sv_ind[i_ptr] = j;\r\n                    sv_val[i_ptr] = val;\r\n                    vr_len[i]++;\r\n                    /* remember column index of v[i,j] */\r\n                    ndx[++len] = j;\r\n                    /* big_v := max(big_v, |v[i,j]|) */\r\n                    if (luf.big_v < temp) luf.big_v = temp;\r\n                }\r\n            }\r\n            else\r\n            {  /* there is no fill-in, because v[i,j] already exists in\r\n             the i-th row; restore the flag of the element v[p,j],\r\n             which was reset before */\r\n                flag[j] = 1;\r\n            }\r\n        }\r\n        /* add new non-zeros v[i,j] to the corresponding columns */\r\n        for (k = 1; k <= len; k++)\r\n        {  /* get column index of new non-zero v[i,j] */\r\n            j = ndx[k];\r\n            /* one free location is needed in the j-th column */\r\n            if (vc_len[j] + 1 > vc_cap[j])\r\n            {  /* enlarge the j-th column */\r\n                if (luf_enlarge_col(luf, j, vc_len[j] + 10))\r\n                {  /* overflow of the sparse vector area */\r\n                    ret = 1;\r\n                    return ret;\r\n                }\r\n                /* defragmentation may change row and column pointers of\r\n                 the matrix V */\r\n                p_beg = vr_ptr[p];\r\n                p_end = p_beg + vr_len[p] - 1;\r\n                q_beg = vc_ptr[q];\r\n                q_end = q_beg + vc_len[q] - 1;\r\n            }\r\n            /* add new non-zero v[i,j] to the j-th column */\r\n            j_ptr = vc_ptr[j] + vc_len[j];\r\n            sv_ind[j_ptr] = i;\r\n            vc_len[j]++;\r\n        }\r\n        /* now the i-th row has been completely transformed, therefore\r\n         it can return to the active set with new length */\r\n        rs_prev[i] = 0;\r\n        rs_next[i] = rs_head[vr_len[i]];\r\n        if (rs_next[i] != 0) rs_prev[rs_next[i]] = i;\r\n        rs_head[vr_len[i]] = i;\r\n        /* the largest of absolute values of elements in the i-th row\r\n         is currently unknown */\r\n        vr_max[i] = -1.0;\r\n        /* at least one free location is needed to store the gaussian\r\n         multiplier */\r\n        if (luf.sv_end - luf.sv_beg < 1)\r\n        {  /* there are no free locations at all; defragment SVA */\r\n            luf_defrag_sva(luf);\r\n            if (luf.sv_end - luf.sv_beg < 1)\r\n            {  /* overflow of the sparse vector area */\r\n                ret = 1;\r\n                return ret;\r\n            }\r\n            /* defragmentation may change row and column pointers of the\r\n             matrix V */\r\n            p_beg = vr_ptr[p];\r\n            p_end = p_beg + vr_len[p] - 1;\r\n            q_beg = vc_ptr[q];\r\n            q_end = q_beg + vc_len[q] - 1;\r\n        }\r\n        /* add the element f[i,p], which is the gaussian multiplier,\r\n         to the matrix F */\r\n        luf.sv_end--;\r\n        sv_ind[luf.sv_end] = i;\r\n        sv_val[luf.sv_end] = fip;\r\n        fc_len[p]++;\r\n        /* end of elimination loop */\r\n    }\r\n    /* at this point the q-th (pivot) column should be empty */\r\n    xassert(vc_len[q] == 0);\r\n    /* reset capacity of the q-th column */\r\n    vc_cap[q] = 0;\r\n    /* remove node of the q-th column from the addressing list */\r\n    k = n + q;\r\n    if (sv_prev[k] == 0)\r\n        luf.sv_head = sv_next[k];\r\n    else\r\n        sv_next[sv_prev[k]] = sv_next[k];\r\n    if (sv_next[k] == 0)\r\n        luf.sv_tail = sv_prev[k];\r\n    else\r\n        sv_prev[sv_next[k]] = sv_prev[k];\r\n    /* the p-th column of the matrix F has been completely built; set\r\n     its pointer */\r\n    fc_ptr[p] = luf.sv_end;\r\n    /* walk through the p-th (pivot) row and do the following... */\r\n    for (p_ptr = p_beg; p_ptr <= p_end; p_ptr++)\r\n    {  /* get column index of v[p,j] */\r\n        j = sv_ind[p_ptr];\r\n        /* erase v[p,j] from the working array */\r\n        flag[j] = 0;\r\n        work[j] = 0.0;\r\n        /* the j-th column has been completely transformed, therefore\r\n         it can return to the active set with new length; however\r\n         the special case c_prev[j] = c_next[j] = j means that the\r\n         routine find_pivot excluded the j-th column from the active\r\n         set due to Uwe Suhl's rule, and therefore in this case the\r\n         column can return to the active set only if it is a column\r\n         singleton */\r\n        if (!(vc_len[j] != 1 && cs_prev[j] == j && cs_next[j] == j))\r\n        {  cs_prev[j] = 0;\r\n            cs_next[j] = cs_head[vc_len[j]];\r\n            if (cs_next[j] != 0) cs_prev[cs_next[j]] = j;\r\n            cs_head[vc_len[j]] = j;\r\n        }\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction build_v_cols(luf){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var vc_cap = luf.vc_cap;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var sv_prev = luf.sv_prev;\r\n    var sv_next = luf.sv_next;\r\n    var ret = 0;\r\n    var i, i_beg, i_end, i_ptr, j, j_ptr, k, nnz;\r\n    /* it is assumed that on entry all columns of the matrix V are\r\n     empty, i.e. vc_len[j] = vc_cap[j] = 0 for all j = 1, ..., n,\r\n     and have been removed from the addressing list */\r\n    /* count non-zeros in columns of the matrix V; count total number\r\n     of non-zeros in this matrix */\r\n    nnz = 0;\r\n    for (i = 1; i <= n; i++)\r\n    {  /* walk through elements of the i-th row and count non-zeros\r\n     in the corresponding columns */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n            vc_cap[sv_ind[i_ptr]]++;\r\n        /* count total number of non-zeros */\r\n        nnz += vr_len[i];\r\n    }\r\n    /* store total number of non-zeros */\r\n    luf.nnz_v = nnz;\r\n    /* check for free locations */\r\n    if (luf.sv_end - luf.sv_beg < nnz)\r\n    {  /* overflow of the sparse vector area */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n    /* allocate columns of the matrix V */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* set pointer to the j-th column */\r\n        vc_ptr[j] = luf.sv_beg;\r\n        /* reserve locations for the j-th column */\r\n        luf.sv_beg += vc_cap[j];\r\n    }\r\n    /* build the matrix V in column-wise format using this matrix in\r\n     row-wise format */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* walk through elements of the i-th row */\r\n        i_beg = vr_ptr[i];\r\n        i_end = i_beg + vr_len[i] - 1;\r\n        for (i_ptr = i_beg; i_ptr <= i_end; i_ptr++)\r\n        {  /* get column index */\r\n            j = sv_ind[i_ptr];\r\n            /* store element in the j-th column */\r\n            j_ptr = vc_ptr[j] + vc_len[j];\r\n            sv_ind[j_ptr] = i;\r\n            sv_val[j_ptr] = sv_val[i_ptr];\r\n            /* increase length of the j-th column */\r\n            vc_len[j]++;\r\n        }\r\n    }\r\n    /* now columns are placed in the sparse vector area behind rows\r\n     in the order n+1, n+2, ..., n+n; so insert column nodes in the\r\n     addressing list using this order */\r\n    for (k = n+1; k <= n+n; k++)\r\n    {  sv_prev[k] = k-1;\r\n        sv_next[k] = k+1;\r\n    }\r\n    sv_prev[n+1] = luf.sv_tail;\r\n    sv_next[luf.sv_tail] = n+1;\r\n    sv_next[n+n] = 0;\r\n    luf.sv_tail = n+n;\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction build_f_rows(luf){\r\n    var n = luf.n;\r\n    var fr_ptr = luf.fr_ptr;\r\n    var fr_len = luf.fr_len;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var ret = 0;\r\n    var i, j, j_beg, j_end, j_ptr, ptr, nnz;\r\n    /* clear rows of the matrix F */\r\n    for (i = 1; i <= n; i++) fr_len[i] = 0;\r\n    /* count non-zeros in rows of the matrix F; count total number of\r\n     non-zeros in this matrix */\r\n    nnz = 0;\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column and count non-zeros\r\n     in the corresponding rows */\r\n        j_beg = fc_ptr[j];\r\n        j_end = j_beg + fc_len[j] - 1;\r\n        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n            fr_len[sv_ind[j_ptr]]++;\r\n        /* increase total number of non-zeros */\r\n        nnz += fc_len[j];\r\n    }\r\n    /* store total number of non-zeros */\r\n    luf.nnz_f = nnz;\r\n    /* check for free locations */\r\n    if (luf.sv_end - luf.sv_beg < nnz)\r\n    {  /* overflow of the sparse vector area */\r\n        ret = 1;\r\n        return ret;\r\n    }\r\n    /* allocate rows of the matrix F */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* set pointer to the end of the i-th row; later this pointer\r\n     will be set to the beginning of the i-th row */\r\n        fr_ptr[i] = luf.sv_end;\r\n        /* reserve locations for the i-th row */\r\n        luf.sv_end -= fr_len[i];\r\n    }\r\n    /* build the matrix F in row-wise format using this matrix in\r\n     column-wise format */\r\n    for (j = 1; j <= n; j++)\r\n    {  /* walk through elements of the j-th column */\r\n        j_beg = fc_ptr[j];\r\n        j_end = j_beg + fc_len[j] - 1;\r\n        for (j_ptr = j_beg; j_ptr <= j_end; j_ptr++)\r\n        {  /* get row index */\r\n            i = sv_ind[j_ptr];\r\n            /* store element in the i-th row */\r\n            ptr = --fr_ptr[i];\r\n            sv_ind[ptr] = j;\r\n            sv_val[ptr] = sv_val[j_ptr];\r\n        }\r\n    }\r\n    /* return to the factorizing routine */\r\n    return ret;\r\n}\r\n\r\nfunction luf_factorize(luf, n, col, info){\r\n    var pp_row, pp_col, qq_row, qq_col;\r\n    var max_gro = luf.max_gro;\r\n    var i, j, k, p, q, t, ret = null;\r\n    if (n < 1)\r\n        xerror(\"luf_factorize: n = \" + n + \"; invalid parameter\");\r\n    if (n > N_MAX)\r\n        xerror(\"luf_factorize: n = \" + n + \"; matrix too big\");\r\n    /* invalidate the factorization */\r\n    luf.valid = 0;\r\n    /* reallocate arrays, if necessary */\r\n    reallocate(luf, n);\r\n    pp_row = luf.pp_row;\r\n    pp_col = luf.pp_col;\r\n    qq_row = luf.qq_row;\r\n    qq_col = luf.qq_col;\r\n    /* estimate initial size of the SVA, if not specified */\r\n    if (luf.sv_size == 0 && luf.new_sva == 0)\r\n        luf.new_sva = 5 * (n + 10);\r\n\r\n\r\n    function more(){\r\n        /* reallocate the sparse vector area, if required */\r\n        if (luf.new_sva > 0)\r\n        {   luf.sv_size = luf.new_sva;\r\n            luf.sv_ind = new Int32Array(1+luf.sv_size);\r\n            luf.sv_val = new Float64Array(1+luf.sv_size);\r\n            luf.new_sva = 0;\r\n        }\r\n        /* initialize LU-factorization data structures */\r\n        if (initialize(luf, col, info))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        /* main elimination loop */\r\n        for (k = 1; k <= n; k++)\r\n        {  /* choose a pivot element v[p,q] */\r\n            if (find_pivot(luf, function(_p, _q){p = _p; q = _q}))\r\n            {  /* no pivot can be chosen, because the active submatrix is\r\n             exactly zero */\r\n                luf.rank = k - 1;\r\n                ret = LUF_ESING;\r\n                return false;\r\n            }\r\n            /* let v[p,q] correspond to u[i',j']; permute k-th and i'-th\r\n             rows and k-th and j'-th columns of the matrix U = P*V*Q to\r\n             move the element u[i',j'] to the position u[k,k] */\r\n            i = pp_col[p]; j = qq_row[q];\r\n            xassert(k <= i && i <= n && k <= j && j <= n);\r\n            /* permute k-th and i-th rows of the matrix U */\r\n            t = pp_row[k];\r\n            pp_row[i] = t; pp_col[t] = i;\r\n            pp_row[k] = p; pp_col[p] = k;\r\n            /* permute k-th and j-th columns of the matrix U */\r\n            t = qq_col[k];\r\n            qq_col[j] = t; qq_row[t] = j;\r\n            qq_col[k] = q; qq_row[q] = k;\r\n            /* eliminate subdiagonal elements of k-th column of the matrix\r\n             U = P*V*Q using the pivot element u[k,k] = v[p,q] */\r\n            if (eliminate(luf, p, q))\r\n            {  /* overflow of the sparse vector area */\r\n                luf.new_sva = luf.sv_size + luf.sv_size;\r\n                xassert(luf.new_sva > luf.sv_size);\r\n                return true;\r\n            }\r\n            /* check relative growth of elements of the matrix V */\r\n            if (luf.big_v > max_gro * luf.max_a)\r\n            {  /* the growth is too intensive, therefore most probably the\r\n             matrix A is ill-conditioned */\r\n                luf.rank = k - 1;\r\n                ret = LUF_ECOND;\r\n                return false;\r\n            }\r\n        }\r\n        /* now the matrix U = P*V*Q is upper triangular, the matrix V has\r\n         been built in row-wise format, and the matrix F has been built\r\n         in column-wise format */\r\n        /* defragment the sparse vector area in order to merge all free\r\n         locations in one continuous extent */\r\n        luf_defrag_sva(luf);\r\n        /* build the matrix V in column-wise format */\r\n        if (build_v_cols(luf))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        /* build the matrix F in row-wise format */\r\n        if (build_f_rows(luf))\r\n        {  /* overflow of the sparse vector area */\r\n            luf.new_sva = luf.sv_size + luf.sv_size;\r\n            xassert(luf.new_sva > luf.sv_size);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    while (more()){}\r\n    if (ret != null)\r\n        return ret;\r\n\r\n    /* the LU-factorization has been successfully computed */\r\n    luf.valid = 1;\r\n    luf.rank = n;\r\n    ret = 0;\r\n    /* if there are few free locations in the sparse vector area, try\r\n     increasing its size in the future */\r\n    t = 3 * (n + luf.nnz_v) + 2 * luf.nnz_f;\r\n    if (luf.sv_size < t)\r\n    {  luf.new_sva = luf.sv_size;\r\n        while (luf.new_sva < t)\r\n        {  k = luf.new_sva;\r\n            luf.new_sva = k + k;\r\n            xassert(luf.new_sva > k);\r\n        }\r\n    }\r\n    /* return to the calling program */\r\n    return ret;\r\n}\r\n\r\nfunction luf_f_solve(luf, tr, x){\r\n    var n = luf.n;\r\n    var fr_ptr = luf.fr_ptr;\r\n    var fr_len = luf.fr_len;\r\n    var fc_ptr = luf.fc_ptr;\r\n    var fc_len = luf.fc_len;\r\n    var pp_row = luf.pp_row;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var i, j, k, beg, end, ptr;\r\n    var xk;\r\n    if (!luf.valid)\r\n        xerror(\"luf_f_solve: LU-factorization is not valid\");\r\n    if (!tr)\r\n    {  /* solve the system F*x = b */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = pp_row[j];\r\n            xk = x[k];\r\n            if (xk != 0.0)\r\n            {  beg = fc_ptr[k];\r\n                end = beg + fc_len[k] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    x[sv_ind[ptr]] -= sv_val[ptr] * xk;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system F'*x = b */\r\n        for (i = n; i >= 1; i--)\r\n        {  k = pp_row[i];\r\n            xk = x[k];\r\n            if (xk != 0.0)\r\n            {  beg = fr_ptr[k];\r\n                end = beg + fr_len[k] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    x[sv_ind[ptr]] -= sv_val[ptr] * xk;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction luf_v_solve(luf, tr, x){\r\n    var n = luf.n;\r\n    var vr_ptr = luf.vr_ptr;\r\n    var vr_len = luf.vr_len;\r\n    var vr_piv = luf.vr_piv;\r\n    var vc_ptr = luf.vc_ptr;\r\n    var vc_len = luf.vc_len;\r\n    var pp_row = luf.pp_row;\r\n    var qq_col = luf.qq_col;\r\n    var sv_ind = luf.sv_ind;\r\n    var sv_val = luf.sv_val;\r\n    var b = luf.work;\r\n    var i, j, k, beg, end, ptr;\r\n    var temp;\r\n    if (!luf.valid)\r\n        xerror(\"luf_v_solve: LU-factorization is not valid\");\r\n    for (k = 1; k <= n; k++){b[k] = x[k]; x[k] = 0.0}\r\n    if (!tr)\r\n    {  /* solve the system V*x = b */\r\n        for (k = n; k >= 1; k--)\r\n        {  i = pp_row[k]; j = qq_col[k];\r\n            temp = b[i];\r\n            if (temp != 0.0)\r\n            {  x[j] = (temp /= vr_piv[i]);\r\n                beg = vc_ptr[j];\r\n                end = beg + vc_len[j] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    b[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {  /* solve the system V'*x = b */\r\n        for (k = 1; k <= n; k++)\r\n        {  i = pp_row[k]; j = qq_col[k];\r\n            temp = b[j];\r\n            if (temp != 0.0)\r\n            {  x[i] = (temp /= vr_piv[i]);\r\n                beg = vr_ptr[i];\r\n                end = beg + vr_len[i] - 1;\r\n                for (ptr = beg; ptr <= end; ptr++)\r\n                    b[sv_ind[ptr]] -= sv_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction luf_a_solve(luf, tr, x){\r\n    if (!luf.valid)\r\n        xerror(\"luf_a_solve: LU-factorization is not valid\");\r\n    if (!tr)\r\n    {  /* A = F*V, therefore inv(A) = inv(V)*inv(F) */\r\n        luf_f_solve(luf, 0, x);\r\n        luf_v_solve(luf, 0, x);\r\n    }\r\n    else\r\n    {  /* A' = V'*F', therefore inv(A') = inv(F')*inv(V') */\r\n        luf_v_solve(luf, 1, x);\r\n        luf_f_solve(luf, 1, x);\r\n    }\r\n}\r\n\r\nvar\r\n    MPL_EOF = -1;\r\n\r\nvar\r\n    A_BINARY       = 101,   /* something binary */\r\n    A_CHECK        = 102,   /* check statement */\r\n    A_CONSTRAINT   = 103,   /* model constraint */\r\n    A_DISPLAY      = 104,   /* display statement */\r\n    A_ELEMCON      = 105,   /* elemental constraint/objective */\r\n    A_ELEMSET      = 106,   /* elemental set */\r\n    A_ELEMVAR      = 107,   /* elemental variable */\r\n    A_EXPRESSION   = 108,   /* expression */\r\n    A_FOR          = 109,   /* for statement */\r\n    A_FORMULA      = 110,   /* formula */\r\n    A_INDEX        = 111,   /* dummy index */\r\n    A_INPUT        = 112,   /* input table */\r\n    A_INTEGER      = 113,   /* something integer */\r\n    A_LOGICAL      = 114,   /* something logical */\r\n    A_MAXIMIZE     = 115,   /* objective has to be maximized */\r\n    A_MINIMIZE     = 116,   /* objective has to be minimized */\r\n    A_NONE         = 117,   /* nothing */\r\n    A_NUMERIC      = 118,   /* something numeric */\r\n    A_OUTPUT       = 119,   /* output table */\r\n    A_PARAMETER    = 120,   /* model parameter */\r\n    A_PRINTF       = 121,   /* printf statement */\r\n    A_SET          = 122,   /* model set */\r\n    A_SOLVE        = 123,   /* solve statement */\r\n    A_SYMBOLIC     = 124,   /* something symbolic */\r\n    A_TABLE        = 125,   /* data table */\r\n    A_TUPLE        = 126,   /* n-tuple */\r\n    A_VARIABLE     = 127;   /* model variable */\r\n\r\n/* size limit is not necessary\r\n var\r\n    MAX_LENGTH = 100;\r\n maximal length of any symbolic value (this includes symbolic names,\r\n numeric and string literals, and all symbolic values that may appear\r\n during the evaluation phase) */\r\n\r\nvar CONTEXT_SIZE = 60;\r\n/* size of the context queue, in characters */\r\n\r\nvar OUTBUF_SIZE = 1024;\r\n/* size of the output buffer, in characters */\r\n\r\nvar\r\n    T_EOF          = 201,   /* end of file */\r\n    T_NAME         = 202,   /* symbolic name (model section only) */\r\n    T_SYMBOL       = 203,   /* symbol (data section only) */\r\n    T_NUMBER       = 204,   /* numeric literal */\r\n    T_STRING       = 205,   /* string literal */\r\n    T_AND          = 206,   /* and && */\r\n    T_BY           = 207,   /* by */\r\n    T_CROSS        = 208,   /* cross */\r\n    T_DIFF         = 209,   /* diff */\r\n    T_DIV          = 210,   /* div */\r\n    T_ELSE         = 211,   /* else */\r\n    T_IF           = 212,   /* if */\r\n    T_IN           = 213,   /* in */\r\n    T_INFINITY     = 214,   /* Infinity */\r\n    T_INTER        = 215,   /* inter */\r\n    T_LESS         = 216,   /* less */\r\n    T_MOD          = 217,   /* mod */\r\n    T_NOT          = 218,   /* not ! */\r\n    T_OR           = 219,   /* or || */\r\n    T_SPTP         = 220,   /* s.t. */\r\n    T_SYMDIFF      = 221,   /* symdiff */\r\n    T_THEN         = 222,   /* then */\r\n    T_UNION        = 223,   /* union */\r\n    T_WITHIN       = 224,   /* within */\r\n    T_PLUS         = 225,   /* + */\r\n    T_MINUS        = 226,   /* - */\r\n    T_ASTERISK     = 227,   /* * */\r\n    T_SLASH        = 228,   /* / */\r\n    T_POWER        = 229,   /* ^ ** */\r\n    T_LT           = 230,   /* <  */\r\n    T_LE           = 231,   /* <= */\r\n    T_EQ           = 232,   /* = == */\r\n    T_GE           = 233,   /* >= */\r\n    T_GT           = 234,   /* >  */\r\n    T_NE           = 235,   /* <> != */\r\n    T_CONCAT       = 236,   /* & */\r\n    T_BAR          = 237,   /* | */\r\n    T_POINT        = 238,   /* . */\r\n    T_COMMA        = 239,   /* , */\r\n    T_COLON        = 240,   /* : */\r\n    T_SEMICOLON    = 241,   /* ; */\r\n    T_ASSIGN       = 242,   /* := */\r\n    T_DOTS         = 243,   /* .. */\r\n    T_LEFT         = 244,   /* ( */\r\n    T_RIGHT        = 245,   /* ) */\r\n    T_LBRACKET     = 246,   /* [ */\r\n    T_RBRACKET     = 247,   /* ] */\r\n    T_LBRACE       = 248,   /* { */\r\n    T_RBRACE       = 249,   /* } */\r\n    T_APPEND       = 250,   /* >> */\r\n    T_TILDE        = 251,   /* ~ */\r\n    T_INPUT        = 252;   /* <- */\r\n\r\n            /* suffix specified: */\r\nvar\r\n    DOT_NONE       = 0x00,  /* none     (means variable itself) */\r\n    DOT_LB         = 0x01,  /* .lb      (lower bound) */\r\n    DOT_UB         = 0x02,  /* .ub      (upper bound) */\r\n    DOT_STATUS     = 0x03,  /* .status  (status) */\r\n    DOT_VAL        = 0x04,  /* .val     (primal value) */\r\n    DOT_DUAL       = 0x05;  /* .dual    (dual value) */\r\n\r\n        /* operation code: */\r\nvar\r\n    O_NUMBER       = 301,   /* take floating-point number */\r\n    O_STRING       = 302,   /* take character string */\r\n    O_INDEX        = 303,   /* take dummy index */\r\n    O_MEMNUM       = 304,   /* take member of numeric parameter */\r\n    O_MEMSYM       = 305,   /* take member of symbolic parameter */\r\n    O_MEMSET       = 306,   /* take member of set */\r\n    O_MEMVAR       = 307,   /* take member of variable */\r\n    O_MEMCON       = 308,   /* take member of constraint */\r\n    O_TUPLE        = 309,   /* make n-tuple */\r\n    O_MAKE         = 310,   /* make elemental set of n-tuples */\r\n    O_SLICE        = 311,   /* define domain block (dummy op) */\r\n      /* 0-ary operations --------------------*/\r\n    O_IRAND224     = 312,   /* pseudo-random in [0, 2^24-1] */\r\n    O_UNIFORM01    = 313,   /* pseudo-random in [0, 1) */\r\n    O_NORMAL01     = 314,   /* gaussian random, mu = 0, sigma = 1 */\r\n    O_GMTIME       = 315,   /* current calendar time (UTC) */\r\n        /* unary operations --------------------*/\r\n    O_CVTNUM       = 316,   /* conversion to numeric */\r\n    O_CVTSYM       = 317,   /* conversion to symbolic */\r\n    O_CVTLOG       = 318,   /* conversion to logical */\r\n    O_CVTTUP       = 319,   /* conversion to 1-tuple */\r\n    O_CVTLFM       = 320,   /* conversion to linear form */\r\n    O_PLUS         = 321,   /* unary plus */\r\n    O_MINUS        = 322,   /* unary minus */\r\n    O_NOT          = 323,   /* negation (logical \"not\") */\r\n    O_ABS          = 324,   /* absolute value */\r\n    O_CEIL         = 325,   /* round upward (\"ceiling of x\") */\r\n    O_FLOOR        = 326,   /* round downward (\"floor of x\") */\r\n    O_EXP          = 327,   /* base-e exponential */\r\n    O_LOG          = 328,   /* natural logarithm */\r\n    O_LOG10        = 329,   /* common (decimal) logarithm */\r\n    O_SQRT         = 330,   /* square root */\r\n    O_SIN          = 331,   /* trigonometric sine */\r\n    O_COS          = 332,   /* trigonometric cosine */\r\n    O_ATAN         = 333,   /* trigonometric arctangent */\r\n    O_ROUND        = 334,   /* round to nearest integer */\r\n    O_TRUNC        = 335,   /* truncate to nearest integer */\r\n    O_CARD         = 336,   /* cardinality of set */\r\n    O_LENGTH       = 337,   /* length of symbolic value */\r\n        /* binary operations -------------------*/\r\n    O_ADD          = 338,   /* addition */\r\n    O_SUB          = 339,   /* subtraction */\r\n    O_LESS         = 340,   /* non-negative subtraction */\r\n    O_MUL          = 341,   /* multiplication */\r\n    O_DIV          = 342,   /* division */\r\n    O_IDIV         = 343,   /* quotient of exact division */\r\n    O_MOD          = 344,   /* remainder of exact division */\r\n    O_POWER        = 345,   /* exponentiation (raise to power) */\r\n    O_ATAN2        = 346,   /* trigonometric arctangent */\r\n    O_ROUND2       = 347,   /* round to n fractional digits */\r\n    O_TRUNC2       = 348,   /* truncate to n fractional digits */\r\n    O_UNIFORM      = 349,   /* pseudo-random in [a, b) */\r\n    O_NORMAL       = 350,   /* gaussian random, given mu and sigma */\r\n    O_CONCAT       = 351,   /* concatenation */\r\n    O_LT           = 352,   /* comparison on 'less than' */\r\n    O_LE           = 353,   /* comparison on 'not greater than' */\r\n    O_EQ           = 354,   /* comparison on 'equal to' */\r\n    O_GE           = 355,   /* comparison on 'not less than' */\r\n    O_GT           = 356,   /* comparison on 'greater than' */\r\n    O_NE           = 357,   /* comparison on 'not equal to' */\r\n    O_AND          = 358,   /* conjunction (logical \"and\") */\r\n    O_OR           = 359,   /* disjunction (logical \"or\") */\r\n    O_UNION        = 360,   /* union */\r\n    O_DIFF         = 361,   /* difference */\r\n    O_SYMDIFF      = 362,   /* symmetric difference */\r\n    O_INTER        = 363,   /* intersection */\r\n    O_CROSS        = 364,   /* cross (Cartesian) product */\r\n    O_IN           = 365,   /* test on 'x in Y' */\r\n    O_NOTIN        = 366,   /* test on 'x not in Y' */\r\n    O_WITHIN       = 367,   /* test on 'X within Y' */\r\n    O_NOTWITHIN    = 368,   /* test on 'X not within Y' */\r\n    O_SUBSTR       = 369,   /* substring */\r\n    O_STR2TIME     = 370,   /* convert string to time */\r\n    O_TIME2STR     = 371,   /* convert time to string */\r\n        /* ternary operations ------------------*/\r\n    O_DOTS         = 372,   /* build \"arithmetic\" set */\r\n    O_FORK         = 373,   /* if-then-else */\r\n    O_SUBSTR3      = 374,   /* substring */\r\n        /* n-ary operations --------------------*/\r\n    O_MIN          = 375,   /* minimal value (n-ary) */\r\n    O_MAX          = 376,   /* maximal value (n-ary) */\r\n        /* iterated operations -----------------*/\r\n    O_SUM          = 377,   /* summation */\r\n    O_PROD         = 378,   /* multiplication */\r\n    O_MINIMUM      = 379,   /* minimum */\r\n    O_MAXIMUM      = 380,   /* maximum */\r\n    O_FORALL       = 381,   /* conjunction (A-quantification) */\r\n    O_EXISTS       = 382,   /* disjunction (E-quantification) */\r\n    O_SETOF        = 383,   /* compute elemental set */\r\n    O_BUILD        = 384;   /* build elemental set */\r\n\r\n    /**********************************************************************/\r\n    /* * *                      SOLVER INTERFACE                      * * */\r\n    /**********************************************************************/\r\nvar\r\n    MPL_FR         = 401,   /* free (unbounded) */\r\n    MPL_LO         = 402,   /* lower bound */\r\n    MPL_UP         = 403,   /* upper bound */\r\n    MPL_DB         = 404,   /* both lower and upper bounds */\r\n    MPL_FX         = 405,   /* fixed */\r\n    MPL_ST         = 411,   /* constraint */\r\n    MPL_MIN        = 412,   /* objective (minimization) */\r\n    MPL_MAX        = 413,   /* objective (maximization) */\r\n    MPL_NUM        = 421,   /* continuous */\r\n    MPL_INT        = 422,   /* integer */\r\n    MPL_BIN        = 423;   /* binary */\r\n\r\nfunction mpl_internal_create_operands(){\r\n    return {index: {},par: {},set: {},var_: {},con: {},arg: {},loop: {}};\r\n}\r\n\r\n/* glpmpl01.c */\r\n\r\n/**********************************************************************/\r\n/* * *                  PROCESSING MODEL SECTION                  * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_enter_context(mpl){\r\n    var image;\r\n    if (mpl.token == T_EOF)\r\n        image = \"_|_\";\r\n    else if (mpl.token == T_STRING)\r\n        image = \"'...'\";\r\n    else\r\n        image = mpl.image;\r\n    xassert(0 <= mpl.c_ptr && mpl.c_ptr < CONTEXT_SIZE);\r\n    mpl.context[mpl.c_ptr++] = ' ';\r\n    if (mpl.c_ptr == CONTEXT_SIZE) mpl.c_ptr = 0;\r\n    for (var s = 0; s < image.length; s++)\r\n    {   mpl.context[mpl.c_ptr++] = image[s];\r\n        if (mpl.c_ptr == CONTEXT_SIZE) mpl.c_ptr = 0;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_print_context(mpl){\r\n    var c;\r\n    while (mpl.c_ptr > 0)\r\n    {  mpl.c_ptr--;\r\n        c = mpl.context[0];\r\n        xcopyArr(mpl.context, 0, mpl.context, 1, CONTEXT_SIZE-1);\r\n        mpl.context[CONTEXT_SIZE-1] = c;\r\n    }\r\n    xprintf(\"Context: \" + mpl.line + \" > \" +  (mpl.context[0] == ' ' ? \"\" : \"...\") + mpl.context.join('').trim());\r\n}\r\n\r\nfunction mpl_internal_get_char(mpl){\r\n    var c;\r\n    if (mpl.c == MPL_EOF) return;\r\n    if (mpl.c == '\\n'){\r\n        mpl.line++;\r\n        mpl.column = 0;\r\n    }\r\n    c = mpl_internal_read_char(mpl);\r\n    mpl.column++;\r\n    if (c == MPL_EOF)\r\n    {  if (mpl.c == '\\n')\r\n        mpl.line--;\r\n    else\r\n        mpl_internal_warning(mpl, \"final NL missing before end of file\");\r\n    }\r\n    else if (c == '\\n'){\r\n\r\n    }\r\n    else if (isspace(c))\r\n        c = ' ';\r\n    else if (iscntrl(c))\r\n    {  mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"control character \" + c + \" not allowed\");\r\n    }\r\n    mpl.c = c;\r\n}\r\n\r\nfunction mpl_internal_append_char(mpl){\r\n    xassert(0 <= mpl.imlen /*&& mpl.imlen <= MAX_LENGTH*/);\r\n/*\r\n    if (mpl.imlen >= MAX_LENGTH)\r\n    {  switch (mpl.token)\r\n    {  case T_NAME:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbolic name \" + mpl.image + \"... too long\");\r\n            break;\r\n        case T_SYMBOL:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbol \" + mpl.image + \"... too long\");\r\n            break;\r\n        case T_NUMBER:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"numeric literal \" + mpl.image + \"... too long\");\r\n            break;\r\n\r\n        case T_STRING:\r\n            mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"string literal too long\");\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    }\r\n*/\r\n    mpl.image += mpl.c ;\r\n    mpl.imlen++;\r\n    mpl_internal_get_char(mpl);\r\n}\r\n\r\nfunction mpl_internal_get_token(mpl){\r\n\r\n    function sptp(){\r\n        mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"keyword s.t. incomplete\");\r\n    }\r\n\r\n    function err(){\r\n        mpl_internal_enter_context(mpl);\r\n        mpl_internal_error(mpl, \"cannot convert numeric literal \" + mpl.image + \" to floating-point number\");\r\n    }\r\n\r\n    function scanDecimal(){\r\n        /* scan optional decimal exponent */\r\n        if (mpl.c == 'e' || mpl.c == 'E')\r\n        {   mpl_internal_append_char(mpl);\r\n            if (mpl.c == '+' || mpl.c == '-') mpl_internal_append_char(mpl);\r\n            if (!isdigit(mpl.c))\r\n            {  mpl_internal_enter_context(mpl);\r\n                mpl_internal_error(mpl, \"numeric literal \" + mpl.image + \" incomplete\");\r\n            }\r\n            while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n        }\r\n        /* there must be no letter following the numeric literal */\r\n        if (isalpha(mpl.c) || mpl.c == '_')\r\n        {   mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"symbol \" + mpl.image + mpl.c + \"... should be enclosed in quotes\");\r\n        }\r\n    }\r\n\r\n    /* save the current token */\r\n    mpl.b_token = mpl.token;\r\n    mpl.b_imlen = mpl.imlen;\r\n    mpl.b_image = mpl.image;\r\n    mpl.b_value = mpl.value;\r\n    /* if the next token is already scanned, make it current */\r\n    if (mpl.f_scan)\r\n    {   mpl.f_scan = 0;\r\n        mpl.token = mpl.f_token;\r\n        mpl.imlen = mpl.f_imlen;\r\n        mpl.image = mpl.f_image;\r\n        mpl.value = mpl.f_value;\r\n        return;\r\n    }\r\n    /* nothing has been scanned so far */\r\n    while (true){\r\n        mpl.token = 0;\r\n        mpl.imlen = 0;\r\n        mpl.image = '';\r\n        mpl.value = 0.0;\r\n        /* skip any uninteresting characters */\r\n        while (mpl.c == ' ' || mpl.c == '\\n') mpl_internal_get_char(mpl);\r\n        /* recognize and construct the token */\r\n        if (mpl.c == MPL_EOF)\r\n        {  /* end-of-file reached */\r\n            mpl.token = T_EOF;\r\n        }\r\n        else if (mpl.c == '#')\r\n        {  /* comment; skip anything until end-of-line */\r\n            while (mpl.c != '\\n' && mpl.c != MPL_EOF) mpl_internal_get_char(mpl);\r\n            continue;\r\n        }\r\n        else if (!mpl.flag_d && (isalpha(mpl.c) || mpl.c == '_'))\r\n        {  /* symbolic name or reserved keyword */\r\n            mpl.token = T_NAME;\r\n            while (isalnum(mpl.c) || mpl.c == '_') mpl_internal_append_char(mpl);\r\n            if (mpl.image == \"and\")\r\n                mpl.token = T_AND;\r\n            else if (mpl.image == \"by\")\r\n                mpl.token = T_BY;\r\n            else if (mpl.image == \"cross\")\r\n                mpl.token = T_CROSS;\r\n            else if (mpl.image == \"diff\")\r\n                mpl.token = T_DIFF;\r\n            else if (mpl.image == \"div\")\r\n                mpl.token = T_DIV;\r\n            else if (mpl.image == \"else\")\r\n                mpl.token = T_ELSE;\r\n            else if (mpl.image == \"if\")\r\n                mpl.token = T_IF;\r\n            else if (mpl.image == \"in\")\r\n                mpl.token = T_IN;\r\n            else if (mpl.image == \"Infinity\")\r\n                mpl.token = T_INFINITY;\r\n            else if (mpl.image == \"inter\")\r\n                mpl.token = T_INTER;\r\n            else if (mpl.image == \"less\")\r\n                mpl.token = T_LESS;\r\n            else if (mpl.image == \"mod\")\r\n                mpl.token = T_MOD;\r\n            else if (mpl.image == \"not\")\r\n                mpl.token = T_NOT;\r\n            else if (mpl.image == \"or\")\r\n                mpl.token = T_OR;\r\n            else if (mpl.image == \"s\" && mpl.c == '.')\r\n            {   mpl.token = T_SPTP;\r\n                mpl_internal_append_char(mpl);\r\n                if (mpl.c != 't') sptp();\r\n                mpl_internal_append_char(mpl);\r\n                if (mpl.c != '.') sptp();\r\n                mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.image == \"symdiff\")\r\n                mpl.token = T_SYMDIFF;\r\n            else if (mpl.image == \"then\")\r\n                mpl.token = T_THEN;\r\n            else if (mpl.image == \"union\")\r\n                mpl.token = T_UNION;\r\n            else if (mpl.image == \"within\")\r\n                mpl.token = T_WITHIN;\r\n        }\r\n        else if (!mpl.flag_d && isdigit(mpl.c))\r\n        {   /* numeric literal */\r\n            mpl.token = T_NUMBER;\r\n            /* scan integer part */\r\n            while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n            /* scan optional fractional part */\r\n            var skip = false;\r\n            if (mpl.c == '.')\r\n            {   mpl_internal_append_char(mpl);\r\n                if (mpl.c == '.')\r\n                {  /* hmm, it is not the fractional part, it is dots that\r\n                 follow the integer part */\r\n                    mpl.imlen--;\r\n                    mpl.image = mpl.image.substr(0,mpl.image.length-1);\r\n                    mpl.f_dots = 1;\r\n                    skip = true;\r\n                } else{\r\n                    while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n                }\r\n            }\r\n            if (!skip)\r\n                scanDecimal();\r\n            /* convert numeric literal to floating-point */\r\n            if (str2num(mpl.image, function(v){mpl.value = v})) err();\r\n        }\r\n        else if (mpl.c == '\\'' || mpl.c == '\"')\r\n        {   /* character string */\r\n            var quote = mpl.c;\r\n            var triple = false;\r\n            mpl.token = T_STRING;\r\n            mpl_internal_get_char(mpl);\r\n\r\n\r\n            function eat(){\r\n                for (;;)\r\n                {   if ((mpl.c == '\\n' && !triple) || mpl.c == MPL_EOF)\r\n                    {   mpl_internal_enter_context(mpl);\r\n                        mpl_internal_error(mpl, \"unexpected end of line; string literal incomplete\");\r\n                    }\r\n                    if (mpl.c == quote)\r\n                    {   mpl_internal_get_char(mpl);\r\n                        if (mpl.c == quote)\r\n                        {   if (triple)\r\n                            {   mpl_internal_get_char(mpl);\r\n                                if (mpl.c == quote)\r\n                                {\r\n                                    mpl_internal_get_char(mpl);\r\n                                    break;\r\n                                } else {\r\n                                    mpl.image += '\"\"' ;\r\n                                    mpl.imlen += 2;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            if (triple)\r\n                            {\r\n                                mpl.image += '\"' ;\r\n                                mpl.imlen++;\r\n                            } else\r\n                                break;\r\n                        }\r\n\r\n                    }\r\n                    mpl_internal_append_char(mpl);\r\n                }\r\n            }\r\n\r\n            if (mpl.c == quote){\r\n                mpl_internal_get_char(mpl);\r\n                if (mpl.c == quote){\r\n                    triple = true;\r\n                    mpl_internal_get_char(mpl);\r\n                    eat();\r\n                } else {\r\n                    // empty string\r\n                }\r\n            } else {\r\n                eat()\r\n            }\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '+'){\r\n            mpl.token = T_PLUS; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '-'){\r\n            mpl.token = T_MINUS; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '*')\r\n        {   mpl.token = T_ASTERISK; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '*'){\r\n                mpl.token = T_POWER; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '/')\r\n        {   mpl.token = T_SLASH; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '*')\r\n            {  /* comment sequence */\r\n                mpl_internal_get_char(mpl);\r\n                for (;;)\r\n                {  if (mpl.c == MPL_EOF)\r\n                {  /* do not call enter_context at this point */\r\n                    mpl_internal_error(mpl, \"unexpected end of file; comment sequence incomplete\");\r\n                }\r\n                else if (mpl.c == '*')\r\n                {  mpl_internal_get_char(mpl);\r\n                    if (mpl.c == '/') break;\r\n                }\r\n                else\r\n                    mpl_internal_get_char(mpl);\r\n                }\r\n                mpl_internal_get_char(mpl);\r\n                continue;\r\n            }\r\n        }\r\n        else if (mpl.c == '^'){\r\n            mpl.token = T_POWER; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '<')\r\n        {   mpl.token = T_LT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_LE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '>'){\r\n                mpl.token = T_NE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '-'){\r\n                mpl.token = T_INPUT; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '=')\r\n        {   mpl.token = T_EQ; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '=') mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '>')\r\n        {   mpl.token = T_GT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_GE; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (mpl.c == '>'){\r\n                mpl.token = T_APPEND; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '!')\r\n        {   mpl.token = T_NOT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_NE; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '&')\r\n        {   mpl.token = T_CONCAT; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '&'){\r\n                mpl.token = T_AND; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == '|')\r\n        {   mpl.token = T_BAR; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '|'){\r\n                mpl.token = T_OR; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (!mpl.flag_d && mpl.c == '.')\r\n        {   mpl.token = T_POINT; mpl_internal_append_char(mpl);\r\n            if (mpl.f_dots)\r\n            {  /* dots; the first dot was read on the previous call to the\r\n             scanner, so the current character is the second dot */\r\n                mpl.token = T_DOTS;\r\n                mpl.imlen = 2;\r\n                mpl.image = \"..\";\r\n                mpl.f_dots = 0;\r\n            }\r\n            else if (mpl.c == '.'){\r\n                mpl.token = T_DOTS; mpl_internal_append_char(mpl);\r\n            }\r\n            else if (isdigit(mpl.c))\r\n            {  /* numeric literal that begins with the decimal point */\r\n                mpl.token = T_NUMBER; mpl_internal_append_char(mpl);\r\n                while (isdigit(mpl.c)) mpl_internal_append_char(mpl);\r\n                scanDecimal();\r\n                /* convert numeric literal to floating-point */\r\n                if (str2num(mpl.image, function(v){mpl.value = v})) err();\r\n            }\r\n        }\r\n        else if (mpl.c == ','){\r\n            mpl.token = T_COMMA; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ':')\r\n        {  mpl.token = T_COLON; mpl_internal_append_char(mpl);\r\n            if (mpl.c == '='){\r\n                mpl.token = T_ASSIGN; mpl_internal_append_char(mpl);\r\n            }\r\n        }\r\n        else if (mpl.c == ';'){\r\n            mpl.token = T_SEMICOLON; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '('){\r\n            mpl.token = T_LEFT; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ')'){\r\n            mpl.token = T_RIGHT; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '['){\r\n            mpl.token = T_LBRACKET; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == ']'){\r\n            mpl.token = T_RBRACKET; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '{'){\r\n            mpl.token = T_LBRACE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '}'){\r\n            mpl.token = T_RBRACE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (mpl.c == '~'){\r\n            mpl.token = T_TILDE; mpl_internal_append_char(mpl);\r\n        }\r\n        else if (isalnum(mpl.c) || strchr(\"+-._\", mpl.c) >= 0)\r\n        {   /* symbol */\r\n            xassert(mpl.flag_d);\r\n            mpl.token = T_SYMBOL;\r\n            while (isalnum(mpl.c) || strchr(\"+-._\", mpl.c) >= 0)\r\n                mpl_internal_append_char(mpl);\r\n            switch (str2num(mpl.image, function(v){mpl.value = v})){\r\n                case 0:\r\n                    mpl.token = T_NUMBER;\r\n                    break;\r\n                case 1:\r\n                    err();\r\n                    break;\r\n                case 2:\r\n                    break;\r\n                default:\r\n                    xassert(mpl != mpl);\r\n            }\r\n        }\r\n        else\r\n        {   mpl_internal_enter_context(mpl);\r\n            mpl_internal_error(mpl, \"character \" + mpl.c + \" not allowed\");\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    /* enter the current token into the context queue */\r\n    mpl_internal_enter_context(mpl);\r\n    /* reset the flag, which may be set by indexing_expression() and\r\n     is used by expression_list() */\r\n    mpl.flag_x = 0;\r\n}\r\n\r\nfunction mpl_internal_unget_token(mpl){\r\n    /* save the current token, which becomes the next one */\r\n    xassert(!mpl.f_scan);\r\n    mpl.f_scan = 1;\r\n    mpl.f_token = mpl.token;\r\n    mpl.f_imlen = mpl.imlen;\r\n    mpl.f_image = mpl.image;\r\n    mpl.f_value = mpl.value;\r\n    /* restore the previous token, which becomes the current one */\r\n    mpl.token = mpl.b_token;\r\n    mpl.imlen = mpl.b_imlen;\r\n    mpl.image = mpl.b_image;\r\n    mpl.value = mpl.b_value;\r\n}\r\n\r\nfunction mpl_internal_is_keyword(mpl, keyword){\r\n    return mpl.token == T_NAME && mpl.image == keyword;\r\n}\r\n\r\nfunction mpl_internal_is_reserved(mpl){\r\n    return mpl.token == T_AND && mpl.image[0] == 'a' ||\r\n        mpl.token == T_BY ||\r\n        mpl.token == T_CROSS ||\r\n        mpl.token == T_DIFF ||\r\n        mpl.token == T_DIV ||\r\n        mpl.token == T_ELSE ||\r\n        mpl.token == T_IF ||\r\n        mpl.token == T_IN ||\r\n        mpl.token == T_INTER ||\r\n        mpl.token == T_LESS ||\r\n        mpl.token == T_MOD ||\r\n        mpl.token == T_NOT && mpl.image[0] == 'n' ||\r\n        mpl.token == T_OR && mpl.image[0] == 'o' ||\r\n        mpl.token == T_SYMDIFF ||\r\n        mpl.token == T_THEN ||\r\n        mpl.token == T_UNION ||\r\n        mpl.token == T_WITHIN;\r\n}\r\n\r\nfunction mpl_internal_make_code(mpl, op, arg, type, dim){\r\n    var code = {};\r\n    var domain;\r\n    var block;\r\n    var e;\r\n    /* generate pseudo-code */\r\n    code.op = op;\r\n    code.vflag = 0; /* is inherited from operand(s) */\r\n    /* copy operands and also make them referring to the pseudo-code\r\n     being generated, because the latter becomes the parent for all\r\n     its operands */\r\n    code.arg = mpl_internal_create_operands();\r\n    code.value = {};\r\n    switch (op)\r\n    {   case O_NUMBER:\r\n        code.arg.num = arg.num;\r\n        break;\r\n        case O_STRING:\r\n            code.arg.str = arg.str;\r\n            break;\r\n        case O_INDEX:\r\n            code.arg.index.slot = arg.index.slot;\r\n            code.arg.index.next = arg.index.next;\r\n            break;\r\n        case O_MEMNUM:\r\n        case O_MEMSYM:\r\n            for (e = arg.par.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.par.par = arg.par.par;\r\n            code.arg.par.list = arg.par.list;\r\n            break;\r\n        case O_MEMSET:\r\n            for (e = arg.set.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.set.set = arg.set.set;\r\n            code.arg.set.list = arg.set.list;\r\n            break;\r\n        case O_MEMVAR:\r\n            for (e = arg.var_.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.var_.var_ = arg.var_.var_;\r\n            code.arg.var_.list = arg.var_.list;\r\n            code.arg.var_.suff = arg.var_.suff;\r\n            break;\r\n        case O_MEMCON:\r\n            for (e = arg.con.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.con.con = arg.con.con;\r\n            code.arg.con.list = arg.con.list;\r\n            code.arg.con.suff = arg.con.suff;\r\n            break;\r\n        case O_TUPLE:\r\n        case O_MAKE:\r\n            for (e = arg.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.list = arg.list;\r\n            break;\r\n        case O_SLICE:\r\n            xassert(arg.slice != null);\r\n            code.arg.slice = arg.slice;\r\n            break;\r\n        case O_IRAND224:\r\n        case O_UNIFORM01:\r\n        case O_NORMAL01:\r\n        case O_GMTIME:\r\n            code.vflag = 1;\r\n            break;\r\n        case O_CVTNUM:\r\n        case O_CVTSYM:\r\n        case O_CVTLOG:\r\n        case O_CVTTUP:\r\n        case O_CVTLFM:\r\n        case O_PLUS:\r\n        case O_MINUS:\r\n        case O_NOT:\r\n        case O_ABS:\r\n        case O_CEIL:\r\n        case O_FLOOR:\r\n        case O_EXP:\r\n        case O_LOG:\r\n        case O_LOG10:\r\n        case O_SQRT:\r\n        case O_SIN:\r\n        case O_COS:\r\n        case O_ATAN:\r\n        case O_ROUND:\r\n        case O_TRUNC:\r\n        case O_CARD:\r\n        case O_LENGTH:\r\n            /* unary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            code.arg.arg.x = arg.arg.x;\r\n            break;\r\n        case O_ADD:\r\n        case O_SUB:\r\n        case O_LESS:\r\n        case O_MUL:\r\n        case O_DIV:\r\n        case O_IDIV:\r\n        case O_MOD:\r\n        case O_POWER:\r\n        case O_ATAN2:\r\n        case O_ROUND2:\r\n        case O_TRUNC2:\r\n        case O_UNIFORM:\r\n            if (op == O_UNIFORM) code.vflag = 1;\r\n        case O_NORMAL:\r\n            if (op == O_NORMAL) code.vflag = 1;\r\n        case O_CONCAT:\r\n        case O_LT:\r\n        case O_LE:\r\n        case O_EQ:\r\n        case O_GE:\r\n        case O_GT:\r\n        case O_NE:\r\n        case O_AND:\r\n        case O_OR:\r\n        case O_UNION:\r\n        case O_DIFF:\r\n        case O_SYMDIFF:\r\n        case O_INTER:\r\n        case O_CROSS:\r\n        case O_IN:\r\n        case O_NOTIN:\r\n        case O_WITHIN:\r\n        case O_NOTWITHIN:\r\n        case O_SUBSTR:\r\n        case O_STR2TIME:\r\n        case O_TIME2STR:\r\n            /* binary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            xassert(arg.arg.y != null);\r\n            xassert(arg.arg.y.up == null);\r\n            arg.arg.y.up = code;\r\n            code.vflag |= arg.arg.y.vflag;\r\n            code.arg.arg.x = arg.arg.x;\r\n            code.arg.arg.y = arg.arg.y;\r\n            break;\r\n        case O_DOTS:\r\n        case O_FORK:\r\n        case O_SUBSTR3:\r\n            /* ternary operation */\r\n            xassert(arg.arg.x != null);\r\n            xassert(arg.arg.x.up == null);\r\n            arg.arg.x.up = code;\r\n            code.vflag |= arg.arg.x.vflag;\r\n            xassert(arg.arg.y != null);\r\n            xassert(arg.arg.y.up == null);\r\n            arg.arg.y.up = code;\r\n            code.vflag |= arg.arg.y.vflag;\r\n            if (arg.arg.z != null)\r\n            {  xassert(arg.arg.z.up == null);\r\n                arg.arg.z.up = code;\r\n                code.vflag |= arg.arg.z.vflag;\r\n            }\r\n            code.arg.arg.x = arg.arg.x;\r\n            code.arg.arg.y = arg.arg.y;\r\n            code.arg.arg.z = arg.arg.z;\r\n            break;\r\n        case O_MIN:\r\n        case O_MAX:\r\n            /* n-ary operation */\r\n            for (e = arg.list; e != null; e = e.next)\r\n            {  xassert(e.x != null);\r\n                xassert(e.x.up == null);\r\n                e.x.up = code;\r\n                code.vflag |= e.x.vflag;\r\n            }\r\n            code.arg.list = arg.list;\r\n            break;\r\n        case O_SUM:\r\n        case O_PROD:\r\n        case O_MINIMUM:\r\n        case O_MAXIMUM:\r\n        case O_FORALL:\r\n        case O_EXISTS:\r\n        case O_SETOF:\r\n        case O_BUILD:\r\n            /* iterated operation */\r\n            domain = arg.loop.domain;\r\n            xassert(domain != null);\r\n            if (domain.code != null)\r\n            {  xassert(domain.code.up == null);\r\n                domain.code.up = code;\r\n                code.vflag |= domain.code.vflag;\r\n            }\r\n            for (block = domain.list; block != null; block =\r\n                block.next)\r\n            {  xassert(block.code != null);\r\n                xassert(block.code.up == null);\r\n                block.code.up = code;\r\n                code.vflag |= block.code.vflag;\r\n            }\r\n            if (arg.loop.x != null)\r\n            {  xassert(arg.loop.x.up == null);\r\n                arg.loop.x.up = code;\r\n                code.vflag |= arg.loop.x.vflag;\r\n            }\r\n            code.arg.loop.domain = arg.loop.domain;\r\n            code.arg.loop.x = arg.loop.x;\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    /* set other attributes of the pseudo-code */\r\n    code.type = type;\r\n    code.dim = dim;\r\n    code.up = null;\r\n    code.valid = 0;\r\n    code.value = {};\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_unary(mpl, op, x, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    arg.arg.x = x;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_binary(mpl, op, x, y, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    xassert(y != null);\r\n    arg.arg.x = x;\r\n    arg.arg.y = y;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_make_ternary(mpl, op, x, y, z, type, dim){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(x != null);\r\n    xassert(y != null);\r\n    /* third operand can be null */\r\n    arg.arg.x = x;\r\n    arg.arg.y = y;\r\n    arg.arg.z = z;\r\n    code = mpl_internal_make_code(mpl, op, arg, type, dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_numeric_literal(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_NUMBER);\r\n    arg.num = mpl.value;\r\n    code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);\r\n    mpl_internal_get_token(mpl /* <numeric literal> */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_string_literal(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_STRING);\r\n    arg.str = mpl.image;\r\n    code = mpl_internal_make_code(mpl, O_STRING, arg, A_SYMBOLIC, 0);\r\n    mpl_internal_get_token(mpl /* <string literal> */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_expand_arg_list(mpl, list, x){\r\n    var tail = {}, temp;\r\n    xassert(x != null);\r\n    /* create new operands list entry */\r\n    tail.x = x;\r\n    tail.next = null;\r\n    /* and append it to the operands list */\r\n    if (list == null)\r\n        list = tail;\r\n    else\r\n    {   for (temp = list; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return list;\r\n}\r\n\r\nfunction mpl_internal_arg_list_len(mpl, list){\r\n    var temp;\r\n    var len;\r\n\r\n    len = 0;\r\n    for (temp = list; temp != null; temp = temp.next) len++;\r\n    return len;\r\n}\r\n\r\nfunction mpl_internal_subscript_list(mpl){\r\n    var x;\r\n    var list = null;\r\n    for (;;)\r\n    {   /* parse subscript expression */\r\n        x = mpl_internal_expression_5(mpl);\r\n        /* convert it to symbolic type, if necessary */\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n        /* check that now the expression is of symbolic type */\r\n        if (x.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"subscript expression has invalid type\");\r\n        xassert(x.dim == 0);\r\n        /* and append it to the subscript list */\r\n        list = mpl_internal_expand_arg_list(mpl, list, x);\r\n        /* check a token that follows the subscript expression */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RBRACKET)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in subscript list\");\r\n    }\r\n    return list;\r\n}\r\n\r\nfunction mpl_internal_object_reference(mpl){\r\n    var slot, set, par, var_, con, list, code, name, dim, suff;\r\n    var arg = mpl_internal_create_operands();\r\n    /* find the object in the symbolic name table */\r\n    xassert(mpl.token == T_NAME);\r\n    var node = mpl.tree[mpl.image];\r\n    if (node == null)\r\n        mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n    /* check the object type and obtain its dimension */\r\n    switch (node.type)\r\n    {  case A_INDEX:\r\n        /* dummy index */\r\n        slot = node.link;\r\n        name = slot.name;\r\n        dim = 0;\r\n        break;\r\n        case A_SET:\r\n            /* model set */\r\n            set = node.link;\r\n            name = set.name;\r\n            dim = set.dim;\r\n            /* if a set object is referenced in its own declaration and\r\n             the dimen attribute is not specified yet, use dimen 1 by\r\n             default */\r\n            if (set.dimen == 0) set.dimen = 1;\r\n            break;\r\n        case A_PARAMETER:\r\n            /* model parameter */\r\n            par = node.link;\r\n            name = par.name;\r\n            dim = par.dim;\r\n            break;\r\n        case A_VARIABLE:\r\n            /* model variable */\r\n            var_ = node.link;\r\n            name = var_.name;\r\n            dim = var_.dim;\r\n            break;\r\n        case A_CONSTRAINT:\r\n            /* model constraint or objective */\r\n            con = node.link;\r\n            name = con.name;\r\n            dim = con.dim;\r\n            break;\r\n        default:\r\n            xassert(node != node);\r\n    }\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional subscript list */\r\n    if (mpl.token == T_LBRACKET)\r\n    {  /* subscript list is specified */\r\n        if (dim == 0)\r\n            mpl_internal_error(mpl, name + \" cannot be subscripted\");\r\n        mpl_internal_get_token(mpl /* [ */);\r\n        list = mpl_internal_subscript_list(mpl);\r\n        if (dim != mpl_internal_arg_list_len(mpl, list))\r\n            mpl_internal_error(mpl, name + \" must have \" + dim + \" subscript\" + (dim == 1 ? \"\" : \"s\") + \" rather than \" + mpl_internal_arg_list_len(mpl, list));\r\n        xassert(mpl.token == T_RBRACKET);\r\n        mpl_internal_get_token(mpl /* ] */);\r\n    }\r\n    else\r\n    {  /* subscript list is not specified */\r\n        if (dim != 0)\r\n            mpl_internal_error(mpl, name + \" must be subscripted\");\r\n        list = null;\r\n    }\r\n    /* parse optional suffix */\r\n    if (!mpl.flag_s && node.type == A_VARIABLE)\r\n        suff = DOT_NONE;\r\n    else\r\n        suff = DOT_VAL;\r\n    if (mpl.token == T_POINT)\r\n    {  mpl_internal_get_token(mpl /* . */);\r\n        if (mpl.token != T_NAME)\r\n            mpl_internal_error(mpl, \"invalid use of period\");\r\n        if (!(node.type == A_VARIABLE ||\r\n            node.type == A_CONSTRAINT))\r\n            mpl_internal_error(mpl, name + \" cannot have a suffix\");\r\n        if (mpl.image == \"lb\")\r\n            suff = DOT_LB;\r\n        else if (mpl.image == \"ub\")\r\n            suff = DOT_UB;\r\n        else if (mpl.image == \"status\")\r\n            suff = DOT_STATUS;\r\n        else if (mpl.image == \"val\")\r\n            suff = DOT_VAL;\r\n        else if (mpl.image == \"dual\")\r\n            suff = DOT_DUAL;\r\n        else\r\n            mpl_internal_error(mpl, \"suffix .\" + mpl.image + \" invalid\");\r\n        mpl_internal_get_token(mpl /* suffix */);\r\n    }\r\n    /* generate pseudo-code to take value of the object */\r\n    switch (node.type)\r\n    {  case A_INDEX:\r\n        arg.index.slot = slot;\r\n        arg.index.next = slot.list;\r\n        code = mpl_internal_make_code(mpl, O_INDEX, arg, A_SYMBOLIC, 0);\r\n        slot.list = code;\r\n        break;\r\n        case A_SET:\r\n            arg.set.set = set;\r\n            arg.set.list = list;\r\n            code = mpl_internal_make_code(mpl, O_MEMSET, arg, A_ELEMSET, set.dimen);\r\n            break;\r\n        case A_PARAMETER:\r\n            arg.par.par = par;\r\n            arg.par.list = list;\r\n            if (par.type == A_SYMBOLIC)\r\n                code = mpl_internal_make_code(mpl, O_MEMSYM, arg, A_SYMBOLIC, 0);\r\n            else\r\n                code = mpl_internal_make_code(mpl, O_MEMNUM, arg, A_NUMERIC, 0);\r\n            break;\r\n        case A_VARIABLE:\r\n            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL\r\n                || suff == DOT_DUAL))\r\n                mpl_internal_error(mpl, \"invalid reference to status, primal value, or dual value of variable \" + var_.name + \" above solve statement\");\r\n            arg.var_.var_ = var_;\r\n            arg.var_.list = list;\r\n            arg.var_.suff = suff;\r\n            code = mpl_internal_make_code(mpl, O_MEMVAR, arg, suff == DOT_NONE ?\r\n                A_FORMULA : A_NUMERIC, 0);\r\n            break;\r\n        case A_CONSTRAINT:\r\n            if (!mpl.flag_s && (suff == DOT_STATUS || suff == DOT_VAL\r\n                || suff == DOT_DUAL))\r\n                mpl_internal_error(mpl, \"invalid reference to status, primal value, o\"+\r\n                    \"r dual value of \" + (con.type == A_CONSTRAINT ? \"constraint\" : \"objective\") +\r\n                    \" \" + con.name + \" above solve statement\");\r\n            arg.con.con = con;\r\n            arg.con.list = list;\r\n            arg.con.suff = suff;\r\n            code = mpl_internal_make_code(mpl, O_MEMCON, arg, A_NUMERIC, 0);\r\n            break;\r\n        default:\r\n            xassert(node != node);\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_numeric_argument(mpl, func){\r\n    var x = mpl_internal_expression_5(mpl);\r\n    /* convert the argument to numeric type, if necessary */\r\n    if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n    /* check that now the argument is of numeric type */\r\n    if (x.type != A_NUMERIC)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim == 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_symbolic_argument(mpl, func){\r\n    var x = mpl_internal_expression_5(mpl);\r\n    /* convert the argument to symbolic type, if necessary */\r\n    if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n    /* check that now the argument is of symbolic type */\r\n    if (x.type != A_SYMBOLIC)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim == 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_elemset_argument(mpl, func){\r\n    var x = mpl_internal_expression_9(mpl);\r\n    if (x.type != A_ELEMSET)\r\n        mpl_internal_error(mpl, \"argument for \" + func + \" has invalid type\");\r\n    xassert(x.dim > 0);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_function_reference(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var op;\r\n    var func;\r\n    /* determine operation code */\r\n    xassert(mpl.token == T_NAME);\r\n    if (mpl.image == \"abs\")\r\n        op = O_ABS;\r\n    else if (mpl.image == \"ceil\")\r\n        op = O_CEIL;\r\n    else if (mpl.image == \"floor\")\r\n        op = O_FLOOR;\r\n    else if (mpl.image == \"exp\")\r\n        op = O_EXP;\r\n    else if (mpl.image == \"log\")\r\n        op = O_LOG;\r\n    else if (mpl.image == \"log10\")\r\n        op = O_LOG10;\r\n    else if (mpl.image == \"sqrt\")\r\n        op = O_SQRT;\r\n    else if (mpl.image == \"sin\")\r\n        op = O_SIN;\r\n    else if (mpl.image == \"cos\")\r\n        op = O_COS;\r\n    else if (mpl.image == \"atan\")\r\n        op = O_ATAN;\r\n    else if (mpl.image == \"min\")\r\n        op = O_MIN;\r\n    else if (mpl.image == \"max\")\r\n        op = O_MAX;\r\n    else if (mpl.image == \"round\")\r\n        op = O_ROUND;\r\n    else if (mpl.image == \"trunc\")\r\n        op = O_TRUNC;\r\n    else if (mpl.image == \"Irand224\")\r\n        op = O_IRAND224;\r\n    else if (mpl.image == \"Uniform01\")\r\n        op = O_UNIFORM01;\r\n    else if (mpl.image == \"Uniform\")\r\n        op = O_UNIFORM;\r\n    else if (mpl.image == \"Normal01\")\r\n        op = O_NORMAL01;\r\n    else if (mpl.image == \"Normal\")\r\n        op = O_NORMAL;\r\n    else if (mpl.image == \"card\")\r\n        op = O_CARD;\r\n    else if (mpl.image == \"length\")\r\n        op = O_LENGTH;\r\n    else if (mpl.image == \"substr\")\r\n        op = O_SUBSTR;\r\n    else if (mpl.image == \"str2time\")\r\n        op = O_STR2TIME;\r\n    else if (mpl.image == \"time2str\")\r\n        op = O_TIME2STR;\r\n    else if (mpl.image == \"gmtime\")\r\n        op = O_GMTIME;\r\n    else\r\n        mpl_internal_error(mpl, \"function \" + mpl.image + \" unknown\");\r\n    /* save symbolic name of the function */\r\n    func = mpl.image;\r\n    xassert(func.length < 16);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* check the left parenthesis that follows the function name */\r\n    xassert(mpl.token == T_LEFT);\r\n    mpl_internal_get_token(mpl /* ( */);\r\n    /* parse argument list */\r\n    if (op == O_MIN || op == O_MAX)\r\n    {  /* min and max allow arbitrary number of arguments */\r\n        arg.list = null;\r\n        /* parse argument list */\r\n        for (;;)\r\n        {  /* parse argument and append it to the operands list */\r\n            arg.list = mpl_internal_expand_arg_list(mpl, arg.list,\r\n                mpl_internal_numeric_argument(mpl, func));\r\n            /* check a token that follows the argument */\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RIGHT)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in argument list for \" + func);\r\n        }\r\n    }\r\n    else if (op == O_IRAND224 || op == O_UNIFORM01 || op ==\r\n        O_NORMAL01 || op == O_GMTIME)\r\n    {  /* Irand224, Uniform01, Normal01, gmtime need no arguments */\r\n        if (mpl.token != T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs no arguments\");\r\n    }\r\n    else if (op == O_UNIFORM || op == O_NORMAL)\r\n    {  /* Uniform and Normal need two arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_ATAN || op == O_ROUND || op == O_TRUNC)\r\n    {  /* atan, round, and trunc need one or two arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* parse the second argument, if specified */\r\n        if (mpl.token == T_COMMA)\r\n        {  switch (op)\r\n        {  case O_ATAN:  op = O_ATAN2;  break;\r\n            case O_ROUND: op = O_ROUND2; break;\r\n            case O_TRUNC: op = O_TRUNC2; break;\r\n            default: xassert(op != op);\r\n        }\r\n            mpl_internal_get_token(mpl /* , */);\r\n            arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        }\r\n        /* check a token that follows the last argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs one or two arguments\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_SUBSTR)\r\n    {  /* substr needs two or three arguments */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two or three arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_numeric_argument(mpl, func);\r\n        /* parse the third argument, if specified */\r\n        if (mpl.token == T_COMMA)\r\n        {  op = O_SUBSTR3;\r\n            mpl_internal_get_token(mpl /* , */);\r\n            arg.arg.z = mpl_internal_numeric_argument(mpl, func);\r\n        }\r\n        /* check a token that follows the last argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two or three arguments\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_STR2TIME)\r\n    {  /* str2time needs two arguments, both symbolic */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else if (op == O_TIME2STR)\r\n    {  /* time2str needs two arguments, numeric and symbolic */\r\n        /* parse the first argument */\r\n        arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the first argument */\r\n        if (mpl.token == T_COMMA){\r\n\r\n        }\r\n        else if (mpl.token == T_RIGHT)\r\n            mpl_internal_error(mpl, func + \" needs two arguments\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n        mpl_internal_get_token(mpl /* , */);\r\n        /* parse the second argument */\r\n        arg.arg.y = mpl_internal_symbolic_argument(mpl, func);\r\n        /* check a token that follows the second argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs two argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    else\r\n    {  /* other functions need one argument */\r\n        if (op == O_CARD)\r\n            arg.arg.x = mpl_internal_elemset_argument(mpl, func);\r\n        else if (op == O_LENGTH)\r\n            arg.arg.x = mpl_internal_symbolic_argument(mpl, func);\r\n        else\r\n            arg.arg.x = mpl_internal_numeric_argument(mpl, func);\r\n        /* check a token that follows the argument */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_error(mpl, func + \" needs one argument\");\r\n        else if (mpl.token == T_RIGHT){\r\n\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in argument for \" + func);\r\n    }\r\n    /* make pseudo-code to call the built-in function */\r\n    if (op == O_SUBSTR || op == O_SUBSTR3 || op == O_TIME2STR)\r\n        code = mpl_internal_make_code(mpl, op, arg, A_SYMBOLIC, 0);\r\n    else\r\n        code = mpl_internal_make_code(mpl, op, arg, A_NUMERIC, 0);\r\n    /* the reference ends with the right parenthesis */\r\n    xassert(mpl.token == T_RIGHT);\r\n    mpl_internal_get_token(mpl /* ) */);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_append_block(mpl, domain, block){\r\n    var temp;\r\n\r\n    xassert(domain != null);\r\n    xassert(block != null);\r\n    xassert(block.next == null);\r\n    if (domain.list == null)\r\n        domain.list = block;\r\n    else\r\n    {   for (temp = domain.list; temp.next != null; temp = temp.next){}\r\n        temp.next = block;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_append_slot(mpl, block, name, code){\r\n    var slot = {}, temp;\r\n    xassert(block != null);\r\n    slot.name = name;\r\n    slot.code = code;\r\n    slot.value = null;\r\n    slot.list = null;\r\n    slot.next = null;\r\n    if (block.list == null)\r\n        block.list = slot;\r\n    else\r\n    {  for (temp = block.list; temp.next != null; temp = temp.next){}\r\n        temp.next = slot;\r\n    }\r\n    return slot;\r\n}\r\n\r\nfunction mpl_internal_expression_list(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var max_dim = 20;\r\n    /* maximal number of components allowed within parentheses */\r\n    var list = new Array(max_dim + 1);\r\n    xfillObjArr(list, 0, max_dim + 1);\r\n    var flag_x, next_token, dim, j, slice = 0;\r\n    xassert(mpl.token == T_LEFT);\r\n    /* the flag, which allows recognizing undeclared symbolic names\r\n     as dummy indices, will be automatically reset by get_token(),\r\n     so save it before scanning the next token */\r\n    flag_x = mpl.flag_x;\r\n    mpl_internal_get_token(mpl /* ( */);\r\n    /* parse <expression list> */\r\n    for (dim = 1; ; dim++)\r\n    {   if (dim > max_dim)\r\n        mpl_internal_error(mpl, \"too many components within parentheses\");\r\n\r\n        function expr(){\r\n            /* current component of <expression list> is expression */\r\n            code = mpl_internal_expression_13(mpl);\r\n            /* if the current expression is followed by comma or it is\r\n             not the very first expression, entire <expression list>\r\n             is n-tuple or slice, in which case the current expression\r\n             should be converted to symbolic type, if necessary */\r\n            if (mpl.token == T_COMMA || dim > 1)\r\n            {  if (code.type == A_NUMERIC)\r\n                code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\r\n                /* now the expression must be of symbolic type */\r\n                if (code.type != A_SYMBOLIC)\r\n                    mpl_internal_error(mpl, \"component expression has invalid type\");\r\n                xassert(code.dim == 0);\r\n            }\r\n            list[dim].name = null;\r\n            list[dim].code = code;\r\n        }\r\n\r\n        /* current component of <expression list> can be either dummy\r\n         index or expression */\r\n        if (mpl.token == T_NAME)\r\n        {  /* symbolic name is recognized as dummy index only if:\r\n         the flag, which allows that, is set, and\r\n         the name is followed by comma or right parenthesis, and\r\n         the name is undeclared */\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (!(flag_x &&\r\n                (next_token == T_COMMA || next_token == T_RIGHT) &&\r\n                mpl.tree[mpl.image] == null))\r\n            {  /* this is not dummy index */\r\n                expr();\r\n            } else {\r\n                /* all dummy indices within the same slice must have unique\r\n                 symbolic names */\r\n                for (j = 1; j < dim; j++)\r\n                {  if (list[j].name != null && list[j].name == mpl.image)\r\n                    mpl_internal_error(mpl, \"duplicate dummy index \" + mpl.image + \" not allowed\");\r\n                }\r\n                /* current component of <expression list> is dummy index */\r\n                list[dim].name = mpl.image;\r\n                list[dim].code = null;\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                /* <expression list> is a slice, because at least one dummy\r\n                 index has appeared */\r\n                slice = 1;\r\n                /* note that the context ( <dummy index> ) is not allowed,\r\n                 i.e. in this case <primary expression> is considered as\r\n                 a parenthesized expression */\r\n                if (dim == 1 && mpl.token == T_RIGHT)\r\n                    mpl_internal_error(mpl, list[dim].name + \" not defined\");\r\n            }\r\n        }\r\n        else\r\n            expr();\r\n\r\n        /* check a token that follows the current component */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RIGHT)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"right parenthesis missing where expected\");\r\n    }\r\n    /* generate pseudo-code for <primary expression> */\r\n    if (dim == 1 && !slice)\r\n    {  /* <primary expression> is a parenthesized expression */\r\n        code = list[1].code;\r\n    }\r\n    else if (!slice)\r\n    {  /* <primary expression> is a n-tuple */\r\n        arg.list = null;\r\n        for (j = 1; j <= dim; j++)\r\n            arg.list = mpl_internal_expand_arg_list(mpl, arg.list, list[j].code);\r\n        code = mpl_internal_make_code(mpl, O_TUPLE, arg, A_TUPLE, dim);\r\n    }\r\n    else\r\n    {  /* <primary expression> is a slice */\r\n        arg.slice = {};\r\n        for (j = 1; j <= dim; j++)\r\n            mpl_internal_append_slot(mpl, arg.slice, list[j].name, list[j].code);\r\n        /* note that actually pseudo-codes with op = O_SLICE are never\r\n         evaluated */\r\n        code = mpl_internal_make_code(mpl, O_SLICE, arg, A_TUPLE, dim);\r\n    }\r\n    mpl_internal_get_token(mpl /* ) */);\r\n    /* if <primary expression> is a slice, there must be the keyword\r\n     'in', which follows the right parenthesis */\r\n    if (slice && mpl.token != T_IN)\r\n        mpl_internal_error(mpl, \"keyword in missing where expected\");\r\n    /* if the slice flag is set and there is the keyword 'in', which\r\n     follows <primary expression>, the latter must be a slice */\r\n    if (flag_x && mpl.token == T_IN && !slice)\r\n    {  if (dim == 1)\r\n        mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    else\r\n        mpl_internal_error(mpl, \"0-ary slice not allowed\");\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_literal_set(mpl, code){\r\n    var arg = mpl_internal_create_operands();\r\n    var j;\r\n    xassert(code != null);\r\n    arg.list = null;\r\n    /* parse <member list> */\r\n    for (j = 1; ; j++)\r\n    {  /* all member expressions must be n-tuples; so, if the current\r\n     expression is not n-tuple, convert it to 1-tuple */\r\n        if (code.type == A_NUMERIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTSYM, code, A_SYMBOLIC, 0);\r\n        if (code.type == A_SYMBOLIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTTUP, code, A_TUPLE, 1);\r\n        /* now the expression must be n-tuple */\r\n        if (code.type != A_TUPLE)\r\n            mpl_internal_error(mpl, \"member expression has invalid type\");\r\n        /* all member expressions must have identical dimension */\r\n        if (arg.list != null && arg.list.x.dim != code.dim)\r\n            mpl_internal_error(mpl, \"member \" + (j-1) + \" has \" + arg.list.x.dim + \" component\"\r\n                + (arg.list.x.dim == 1 ? \"\" : \"s\") + \" while member \" + j + \" has \"\r\n                + code.dim + \" component\" + (code.dim == 1 ? \"\" : \"s\"));\r\n        /* append the current expression to the member list */\r\n        arg.list = mpl_internal_expand_arg_list(mpl, arg.list, code);\r\n        /* check a token that follows the current expression */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_RBRACE)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in literal set\");\r\n        /* parse the next expression that follows the comma */\r\n        code = mpl_internal_expression_5(mpl);\r\n    }\r\n    /* generate pseudo-code for <literal set> */\r\n    code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, arg.list.x.dim);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_indexing_expression(mpl){\r\n    var domain;\r\n    var block;\r\n    var slot;\r\n    var code;\r\n    xassert(mpl.token == T_LBRACE);\r\n    mpl_internal_get_token(mpl /* { */);\r\n    if (mpl.token == T_RBRACE)\r\n        mpl_internal_error(mpl, \"empty indexing expression not allowed\");\r\n    /* create domain to be constructed */\r\n    domain = {};\r\n    /* parse either <member list> or <indexing list> that follows the\r\n     left brace */\r\n    for (;;)\r\n    {  /* domain block for <indexing element> is not created yet */\r\n        block = null;\r\n        /* pseudo-code for <basic expression> is not generated yet */\r\n        code = null;\r\n        /* check a token, which <indexing element> begins with */\r\n        if (mpl.token == T_NAME)\r\n        {  /* it is a symbolic name */\r\n            var next_token;\r\n            var name;\r\n            /* symbolic name is recognized as dummy index only if it is\r\n             followed by the keyword 'in' and not declared */\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (next_token == T_IN &&\r\n                mpl.tree[mpl.image] == null)\r\n            {\r\n                /* create domain block with one slot, which is assigned the\r\n                 dummy index */\r\n                block = {};\r\n                name = mpl.image;\r\n                mpl_internal_append_slot(mpl, block, name, null);\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                /* the keyword 'in' is already checked above */\r\n                xassert(mpl.token == T_IN);\r\n                mpl_internal_get_token(mpl /* in */);\r\n                /* <basic expression> that follows the keyword 'in' will be\r\n                 parsed below */\r\n            }\r\n\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* it is the left parenthesis; parse expression that begins\r\n         with this parenthesis (the flag is set in order to allow\r\n         recognizing slices; see the routine expression_list) */\r\n            mpl.flag_x = 1;\r\n            code = mpl_internal_expression_9(mpl);\r\n            if (code.op == O_SLICE)\r\n            {\r\n                /* this is a slice; besides the corresponding domain block\r\n                 is already created by expression_list() */\r\n                block = code.arg.slice;\r\n                code = null; /* <basic expression> is not parsed yet */\r\n                /* the keyword 'in' following the slice is already checked\r\n                 by expression_list() */\r\n                xassert(mpl.token == T_IN);\r\n                mpl_internal_get_token(mpl /* in */);\r\n                /* <basic expression> that follows the keyword 'in' will be\r\n                 parsed below */\r\n            }\r\n        }\r\n\r\n        /* parse expression that follows either the keyword 'in' (in\r\n         which case it can be <basic expression) or the left brace\r\n         (in which case it can be <basic expression> as well as the\r\n         very first <member expression> in <literal set>); note that\r\n         this expression can be already parsed above */\r\n        if (code == null) code = mpl_internal_expression_9(mpl);\r\n        /* check the type of the expression just parsed */\r\n        if (code.type != A_ELEMSET)\r\n        {  /* it is not <basic expression> and therefore it can only\r\n         be the very first <member expression> in <literal set>;\r\n         however, then there must be no dummy index neither slice\r\n         between the left brace and this expression */\r\n            if (block != null)\r\n                mpl_internal_error(mpl, \"domain expression has invalid type\");\r\n            /* parse the rest part of <literal set> and make this set\r\n             be <basic expression>, i.e. the construction {a, b, c}\r\n             is parsed as it were written as {A}, where A = {a, b, c}\r\n             is a temporary elemental set */\r\n            code = mpl_internal_literal_set(mpl, code);\r\n        }\r\n        /* now pseudo-code for <basic set> has been built */\r\n        xassert(code != null);\r\n        xassert(code.type == A_ELEMSET);\r\n        xassert(code.dim > 0);\r\n        /* if domain block for the current <indexing element> is still\r\n         not created, create it for fake slice of the same dimension\r\n         as <basic set> */\r\n        if (block == null)\r\n        {  var j;\r\n            block = {};\r\n            for (j = 1; j <= code.dim; j++)\r\n                mpl_internal_append_slot(mpl, block, null, null);\r\n        }\r\n        /* number of indexing positions in <indexing element> must be\r\n         the same as dimension of n-tuples in basic set */\r\n        {  var dim = 0;\r\n            for (slot = block.list; slot != null; slot = slot.next)\r\n                dim++;\r\n            if (dim != code.dim)\r\n                mpl_internal_error(mpl, dim + \" \" + (dim == 1 ? \"index\" : \"indices\") + \" specified for set of dimension \" + code.dim);\r\n        }\r\n        /* store pseudo-code for <basic set> in the domain block */\r\n        xassert(block.code == null);\r\n        block.code = code;\r\n        /* and append the domain block to the domain */\r\n        mpl_internal_append_block(mpl, domain, block);\r\n        /* the current <indexing element> has been completely parsed;\r\n         include all its dummy indices into the symbolic name table\r\n         to make them available for referencing from expressions;\r\n         implicit declarations of dummy indices remain valid while\r\n         the corresponding domain scope is valid */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n            if (slot.name != null)\r\n            {  var node;\r\n                xassert(mpl.tree[slot.name] == null);\r\n                mpl.tree[slot.name] = node = {type: A_INDEX, link: slot};\r\n            }\r\n        /* check a token that follows <indexing element> */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_COLON || mpl.token == T_RBRACE)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    }\r\n    /* parse <logical expression> that follows the colon */\r\n    if (mpl.token == T_COLON)\r\n    {  mpl_internal_get_token(mpl /* : */);\r\n        code = mpl_internal_expression_13(mpl);\r\n        /* convert the expression to logical type, if necessary */\r\n        if (code.type == A_SYMBOLIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTNUM, code, A_NUMERIC, 0);\r\n        if (code.type == A_NUMERIC)\r\n            code = mpl_internal_make_unary(mpl, O_CVTLOG, code, A_LOGICAL, 0);\r\n        /* now the expression must be of logical type */\r\n        if (code.type != A_LOGICAL)\r\n            mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n        xassert(code.dim == 0);\r\n        domain.code = code;\r\n        /* the right brace must follow the logical expression */\r\n        if (mpl.token != T_RBRACE)\r\n            mpl_internal_error(mpl, \"syntax error in indexing expression\");\r\n    }\r\n    mpl_internal_get_token(mpl /* } */);\r\n    return domain;\r\n}\r\n\r\nfunction mpl_internal_close_scope(mpl, domain){\r\n    var block;\r\n    var slot;\r\n    var node;\r\n    xassert(domain != null);\r\n    /* remove all dummy indices from the symbolic names table */\r\n    for (block = domain.list; block != null; block = block.next)\r\n    {  for (slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.name != null)\r\n    {   node = mpl.tree[slot.name];\r\n        xassert(node != null);\r\n        xassert(node.type == A_INDEX);\r\n        delete mpl.tree[slot.name];\r\n    }\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_link_up(code)\r\n{     /* if we have something like sum{(i+1,j,k-1) in E} x[i,j,k],\r\n where i and k are dummy indices defined out of the iterated\r\n expression, we should link up pseudo-code for computing i+1\r\n and k-1 to pseudo-code for computing the iterated expression;\r\n this is needed to invalidate current value of the iterated\r\n expression once i or k have been changed */\r\n    var block;\r\n    var slot;\r\n    for (block = code.arg.loop.domain.list; block != null;\r\n         block = block.next)\r\n    {  for (slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.code != null)\r\n    {  xassert(slot.code.up == null);\r\n        slot.code.up = code;\r\n    }\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_iterated_expression(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    var op;\r\n    var opstr; // 8\r\n    /* determine operation code */\r\n    xassert(mpl.token == T_NAME);\r\n    if (mpl.image == \"sum\")\r\n        op = O_SUM;\r\n    else if (mpl.image == \"prod\")\r\n        op = O_PROD;\r\n    else if (mpl.image == \"min\")\r\n        op = O_MINIMUM;\r\n    else if (mpl.image == \"max\")\r\n        op = O_MAXIMUM;\r\n    else if (mpl.image == \"forall\")\r\n        op = O_FORALL;\r\n    else if (mpl.image == \"exists\")\r\n        op = O_EXISTS;\r\n    else if (mpl.image == \"setof\")\r\n        op = O_SETOF;\r\n    else\r\n        mpl_internal_error(mpl, \"operator \" + mpl.image + \" unknown\");\r\n    opstr = mpl.image;\r\n    xassert(opstr.length < 8);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* check the left brace that follows the operator name */\r\n    xassert(mpl.token == T_LBRACE);\r\n    /* parse indexing expression that controls iterating */\r\n    arg.loop.domain = mpl_internal_indexing_expression(mpl);\r\n\r\n    function err(){\r\n        mpl_internal_error(mpl, \"integrand following \" + opstr + \"{...} has invalid type\");\r\n    }\r\n\r\n    /* parse \"integrand\" expression and generate pseudo-code */\r\n    switch (op)\r\n    {  case O_SUM:\r\n        case O_PROD:\r\n        case O_MINIMUM:\r\n        case O_MAXIMUM:\r\n            arg.loop.x = mpl_internal_expression_3(mpl);\r\n            /* convert the integrand to numeric type, if necessary */\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x,\r\n                    A_NUMERIC, 0);\r\n            /* now the integrand must be of numeric type or linear form\r\n             (the latter is only allowed for the sum operator) */\r\n            if (!(arg.loop.x.type == A_NUMERIC ||\r\n                op == O_SUM && arg.loop.x.type == A_FORMULA))\r\n                err();\r\n            xassert(arg.loop.x.dim == 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, arg.loop.x.type, 0);\r\n            break;\r\n        case O_FORALL:\r\n        case O_EXISTS:\r\n            arg.loop.x = mpl_internal_expression_12(mpl);\r\n            /* convert the integrand to logical type, if necessary */\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTNUM, arg.loop.x,\r\n                    A_NUMERIC, 0);\r\n            if (arg.loop.x.type == A_NUMERIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTLOG, arg.loop.x,\r\n                    A_LOGICAL, 0);\r\n            /* now the integrand must be of logical type */\r\n            if (arg.loop.x.type != A_LOGICAL) err();\r\n            xassert(arg.loop.x.dim == 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, A_LOGICAL, 0);\r\n            break;\r\n        case O_SETOF:\r\n            arg.loop.x = mpl_internal_expression_5(mpl);\r\n            /* convert the integrand to 1-tuple, if necessary */\r\n            if (arg.loop.x.type == A_NUMERIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTSYM, arg.loop.x,\r\n                    A_SYMBOLIC, 0);\r\n            if (arg.loop.x.type == A_SYMBOLIC)\r\n                arg.loop.x = mpl_internal_make_unary(mpl, O_CVTTUP, arg.loop.x,\r\n                    A_TUPLE, 1);\r\n            /* now the integrand must be n-tuple */\r\n            if (arg.loop.x.type != A_TUPLE) err();\r\n            xassert(arg.loop.x.dim > 0);\r\n            /* generate pseudo-code */\r\n            code = mpl_internal_make_code(mpl, op, arg, A_ELEMSET, arg.loop.x.dim);\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    /* close the scope of the indexing expression */\r\n    mpl_internal_close_scope(mpl, arg.loop.domain);\r\n    mpl_internal_link_up(code);\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_domain_arity(mpl, domain){\r\n    var arity = 0;\r\n\r\n    for (var block = domain.list; block != null; block = block.next)\r\n        for (var slot = block.list; slot != null; slot = slot.next)\r\n            if (slot.code == null) arity++;\r\n    return arity;\r\n}\r\n\r\nfunction mpl_internal_set_expression(mpl){\r\n    var code;\r\n    var arg = mpl_internal_create_operands();\r\n    xassert(mpl.token == T_LBRACE);\r\n    mpl_internal_get_token(mpl /* { */);\r\n    /* check a token that follows the left brace */\r\n    if (mpl.token == T_RBRACE)\r\n    {  /* it is the right brace, so the resultant is an empty set of\r\n     dimension 1 */\r\n        arg.list = null;\r\n        /* generate pseudo-code to build the resultant set */\r\n        code = mpl_internal_make_code(mpl, O_MAKE, arg, A_ELEMSET, 1);\r\n        mpl_internal_get_token(mpl /* } */);\r\n    }\r\n    else\r\n    {  /* the next token begins an indexing expression */\r\n        mpl_internal_unget_token(mpl);\r\n        arg.loop.domain = mpl_internal_indexing_expression(mpl);\r\n        arg.loop.x = null; /* integrand is not used */\r\n        /* close the scope of the indexing expression */\r\n        mpl_internal_close_scope(mpl, arg.loop.domain);\r\n        /* generate pseudo-code to build the resultant set */\r\n        code = mpl_internal_make_code(mpl, O_BUILD, arg, A_ELEMSET,\r\n            mpl_internal_domain_arity(mpl, arg.loop.domain));\r\n        mpl_internal_link_up(code);\r\n    }\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_branched_expression(mpl){\r\n    var x, y, z;\r\n    xassert(mpl.token == T_IF);\r\n    mpl_internal_get_token(mpl /* if */);\r\n    /* parse <logical expression> that follows 'if' */\r\n    x = mpl_internal_expression_13(mpl);\r\n    /* convert the expression to logical type, if necessary */\r\n    if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n    if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n    /* now the expression must be of logical type */\r\n    if (x.type != A_LOGICAL)\r\n        mpl_internal_error(mpl, \"expression following if has invalid type\");\r\n    xassert(x.dim == 0);\r\n    /* the keyword 'then' must follow the logical expression */\r\n    if (mpl.token != T_THEN)\r\n        mpl_internal_error(mpl, \"keyword then missing where expected\");\r\n    mpl_internal_get_token(mpl /* then */);\r\n    /* parse <expression> that follows 'then' and check its type */\r\n    y = mpl_internal_expression_9(mpl);\r\n    if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC ||\r\n        y.type == A_ELEMSET || y.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following then has invalid type\");\r\n    /* if the expression that follows the keyword 'then' is elemental\r\n     set, the keyword 'else' cannot be omitted; otherwise else-part\r\n     is optional */\r\n    if (mpl.token != T_ELSE)\r\n    {  if (y.type == A_ELEMSET)\r\n        mpl_internal_error(mpl, \"keyword else missing where expected\");\r\n        z = null;\r\n    } else {\r\n        mpl_internal_get_token(mpl /* else */);\r\n        /* parse <expression> that follow 'else' and check its type */\r\n        z = mpl_internal_expression_9(mpl);\r\n        if (!(z.type == A_NUMERIC || z.type == A_SYMBOLIC ||\r\n            z.type == A_ELEMSET || z.type == A_FORMULA))\r\n            mpl_internal_error(mpl, \"expression following else has invalid type\");\r\n        /* convert to identical types, if necessary */\r\n        if (y.type == A_FORMULA || z.type == A_FORMULA)\r\n        {  if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n            if (y.type == A_NUMERIC)\r\n                y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n            if (z.type == A_SYMBOLIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\r\n            if (z.type == A_NUMERIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTLFM, z, A_FORMULA, 0);\r\n        }\r\n        if (y.type == A_SYMBOLIC || z.type == A_SYMBOLIC)\r\n        {  if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n            if (z.type == A_NUMERIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTSYM, z, A_SYMBOLIC, 0);\r\n        }\r\n        /* now both expressions must have identical types */\r\n        if (y.type != z.type)\r\n            mpl_internal_error(mpl, \"expressions following then and else have incompatible types\");\r\n        /* and identical dimensions */\r\n        if (y.dim != z.dim)\r\n            mpl_internal_error(mpl, \"expressions following then and else have different\" +\r\n                \" dimensions \" + y.dim + \" and \" + z.dim + \", respectively\");\r\n    }\r\n\r\n    /* generate pseudo-code to perform branching */\r\n    return mpl_internal_make_ternary(mpl, O_FORK, x, y, z, y.type, y.dim);\r\n}\r\n\r\nfunction mpl_internal_primary_expression(mpl){\r\n    var code;\r\n    if (mpl.token == T_NUMBER)\r\n    {  /* parse numeric literal */\r\n        code = mpl_internal_numeric_literal(mpl);\r\n    }\r\n    else if (mpl.token == T_INFINITY)\r\n    {  /* parse \"infinity\" */\r\n        var arg = mpl_internal_create_operands();\r\n        arg.num = DBL_MAX;\r\n        code = mpl_internal_make_code(mpl, O_NUMBER, arg, A_NUMERIC, 0);\r\n        mpl_internal_get_token(mpl /* Infinity */);\r\n    }\r\n    else if (mpl.token == T_STRING)\r\n    {  /* parse string literal */\r\n        code = mpl_internal_string_literal(mpl);\r\n    }\r\n    else if (mpl.token == T_NAME)\r\n    {   var next_token;\r\n        mpl_internal_get_token(mpl /* <symbolic name> */);\r\n        next_token = mpl.token;\r\n        mpl_internal_unget_token(mpl);\r\n        /* check a token that follows <symbolic name> */\r\n        switch (next_token)\r\n        {  case T_LBRACKET:\r\n            /* parse reference to subscripted object */\r\n            code = mpl_internal_object_reference(mpl);\r\n            break;\r\n            case T_LEFT:\r\n                /* parse reference to built-in function */\r\n                code = mpl_internal_function_reference(mpl);\r\n                break;\r\n            case T_LBRACE:\r\n                /* parse iterated expression */\r\n                code = mpl_internal_iterated_expression(mpl);\r\n                break;\r\n            default:\r\n                /* parse reference to unsubscripted object */\r\n                code = mpl_internal_object_reference(mpl);\r\n                break;\r\n        }\r\n    }\r\n    else if (mpl.token == T_LEFT)\r\n    {  /* parse parenthesized expression */\r\n        code = mpl_internal_expression_list(mpl);\r\n    }\r\n    else if (mpl.token == T_LBRACE)\r\n    {  /* parse set expression */\r\n        code = mpl_internal_set_expression(mpl);\r\n    }\r\n    else if (mpl.token == T_IF)\r\n    {  /* parse conditional expression */\r\n        code = mpl_internal_branched_expression(mpl);\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n    {  /* other reserved keywords cannot be used here */\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    }\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in expression\");\r\n    return code;\r\n}\r\n\r\nfunction mpl_internal_error_preceding(mpl, opstr){\r\n    mpl_internal_error(mpl, \"operand preceding \" + opstr + \" has invalid type\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_error_following(mpl, opstr)\r\n{     mpl_internal_error(mpl, \"operand following \" + opstr + \" has invalid type\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_error_dimension(mpl, opstr, dim1, dim2)\r\n{     mpl_internal_error(mpl, \"operands preceding and following \" + opstr + \" have different di\"+\r\n    \"mensions \" + dim1 + \" and \" + dim2 + \", respectively\");\r\n    /* no return */\r\n}\r\n\r\nfunction mpl_internal_expression_0(mpl){\r\n    return mpl_internal_primary_expression(mpl);\r\n}\r\n\r\nfunction mpl_internal_expression_1(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_0(mpl);\r\n    if (mpl.token == T_POWER)\r\n    {   var opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* ^ | ** */);\r\n        if (mpl.token == T_PLUS || mpl.token == T_MINUS)\r\n            y = mpl_internal_expression_2(mpl);\r\n        else\r\n            y = mpl_internal_expression_1(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_POWER, x, y, A_NUMERIC, 0);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_2(mpl){\r\n    var x;\r\n    if (mpl.token == T_PLUS)\r\n    {  mpl_internal_get_token(mpl /* + */);\r\n        x = mpl_internal_expression_1(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"+\");\r\n        x = mpl_internal_make_unary(mpl, O_PLUS, x, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_MINUS)\r\n    {  mpl_internal_get_token(mpl /* - */);\r\n        x = mpl_internal_expression_1(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"-\");\r\n        x = mpl_internal_make_unary(mpl, O_MINUS, x, x.type, 0);\r\n    }\r\n    else\r\n        x = mpl_internal_expression_1(mpl);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_3(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_2(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_ASTERISK)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"*\");\r\n        mpl_internal_get_token(mpl /* * */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"*\");\r\n        if (x.type == A_FORMULA && y.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"multiplication of linear forms not allowed\");\r\n        if (x.type == A_NUMERIC && y.type == A_NUMERIC)\r\n            x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_NUMERIC, 0);\r\n        else\r\n            x = mpl_internal_make_binary(mpl, O_MUL, x, y, A_FORMULA, 0);\r\n    }\r\n    else if (mpl.token == T_SLASH)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"/\");\r\n        mpl_internal_get_token(mpl /* / */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"/\");\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_NUMERIC, 0);\r\n        else\r\n            x = mpl_internal_make_binary(mpl, O_DIV, x, y, A_FORMULA, 0);\r\n    }\r\n    else if (mpl.token == T_DIV)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"div\");\r\n        mpl_internal_get_token(mpl /* div */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"div\");\r\n        x = mpl_internal_make_binary(mpl, O_IDIV, x, y, A_NUMERIC, 0);\r\n    }\r\n    else if (mpl.token == T_MOD)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"mod\");\r\n        mpl_internal_get_token(mpl /* mod */);\r\n        y = mpl_internal_expression_2(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"mod\");\r\n        x = mpl_internal_make_binary(mpl, O_MOD, x, y, A_NUMERIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_4(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_3(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_PLUS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"+\");\r\n        mpl_internal_get_token(mpl /* + */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"+\");\r\n        if (x.type == A_NUMERIC && y.type == A_FORMULA)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\r\n        if (x.type == A_FORMULA && y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n        x = mpl_internal_make_binary(mpl, O_ADD, x, y, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_MINUS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (!(x.type == A_NUMERIC || x.type == A_FORMULA))\r\n            mpl_internal_error_preceding(mpl, \"-\");\r\n        mpl_internal_get_token(mpl /* - */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (!(y.type == A_NUMERIC || y.type == A_FORMULA))\r\n            mpl_internal_error_following(mpl, \"-\");\r\n        if (x.type == A_NUMERIC && y.type == A_FORMULA)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLFM, x, A_FORMULA, 0);\r\n        if (x.type == A_FORMULA && y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLFM, y, A_FORMULA, 0);\r\n        x = mpl_internal_make_binary(mpl, O_SUB, x, y, x.type, 0);\r\n    }\r\n    else if (mpl.token == T_LESS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"less\");\r\n        mpl_internal_get_token(mpl /* less */);\r\n        y = mpl_internal_expression_3(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"less\");\r\n        x = mpl_internal_make_binary(mpl, O_LESS, x, y, A_NUMERIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_5(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_4(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_CONCAT)\r\n    {  if (x.type == A_NUMERIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n        if (x.type != A_SYMBOLIC)\r\n            mpl_internal_error_preceding(mpl, \"&\");\r\n        mpl_internal_get_token(mpl /* & */);\r\n        y = mpl_internal_expression_4(mpl);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n        if (y.type != A_SYMBOLIC)\r\n            mpl_internal_error_following(mpl, \"&\");\r\n        x = mpl_internal_make_binary(mpl, O_CONCAT, x, y, A_SYMBOLIC, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_6(mpl){\r\n    var y, z;\r\n    var x = mpl_internal_expression_5(mpl);\r\n    if (mpl.token == T_DOTS)\r\n    {  if (x.type == A_SYMBOLIC)\r\n        x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type != A_NUMERIC)\r\n            mpl_internal_error_preceding(mpl, \"..\");\r\n        mpl_internal_get_token(mpl /* .. */);\r\n        y = mpl_internal_expression_5(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type != A_NUMERIC)\r\n            mpl_internal_error_following(mpl, \"..\");\r\n        if (mpl.token == T_BY)\r\n        {  mpl_internal_get_token(mpl /* by */);\r\n            z = mpl_internal_expression_5(mpl);\r\n            if (z.type == A_SYMBOLIC)\r\n                z = mpl_internal_make_unary(mpl, O_CVTNUM, z, A_NUMERIC, 0);\r\n            if (z.type != A_NUMERIC)\r\n                mpl_internal_error_following(mpl, \"by\");\r\n        }\r\n        else\r\n            z = null;\r\n        x = mpl_internal_make_ternary(mpl, O_DOTS, x, y, z, A_ELEMSET, 1);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_7(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_6(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_CROSS)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"cross\");\r\n        mpl_internal_get_token(mpl /* cross */);\r\n        y = mpl_internal_expression_6(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"cross\");\r\n        x = mpl_internal_make_binary(mpl, O_CROSS, x, y, A_ELEMSET,\r\n            x.dim + y.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_8(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_7(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_INTER)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"inter\");\r\n        mpl_internal_get_token(mpl /* inter */);\r\n        y = mpl_internal_expression_7(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"inter\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"inter\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_INTER, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_9(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_8(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_UNION)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"union\");\r\n        mpl_internal_get_token(mpl /* union */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"union\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"union\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_UNION, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else if (mpl.token == T_DIFF)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"diff\");\r\n        mpl_internal_get_token(mpl /* diff */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"diff\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"diff\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_DIFF, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else if (mpl.token == T_SYMDIFF)\r\n    {  if (x.type != A_ELEMSET)\r\n        mpl_internal_error_preceding(mpl, \"symdiff\");\r\n        mpl_internal_get_token(mpl /* symdiff */);\r\n        y = mpl_internal_expression_8(mpl);\r\n        if (y.type != A_ELEMSET)\r\n            mpl_internal_error_following(mpl, \"symdiff\");\r\n        if (x.dim != y.dim)\r\n            mpl_internal_error_dimension(mpl, \"symdiff\", x.dim, y.dim);\r\n        x = mpl_internal_make_binary(mpl, O_SYMDIFF, x, y, A_ELEMSET, x.dim);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_10(mpl){\r\n    var y;\r\n    var op = -1;\r\n    var opstr = \"\"; // [16];\r\n    var x = mpl_internal_expression_9(mpl);\r\n    switch (mpl.token)\r\n    {  case T_LT:\r\n        op = O_LT; break;\r\n        case T_LE:\r\n            op = O_LE; break;\r\n        case T_EQ:\r\n            op = O_EQ; break;\r\n        case T_GE:\r\n            op = O_GE; break;\r\n        case T_GT:\r\n            op = O_GT; break;\r\n        case T_NE:\r\n            op = O_NE; break;\r\n        case T_IN:\r\n            op = O_IN; break;\r\n        case T_WITHIN:\r\n            op = O_WITHIN; break;\r\n        case T_NOT:\r\n            opstr = mpl.image;\r\n            mpl_internal_get_token(mpl /* not | ! */);\r\n            if (mpl.token == T_IN)\r\n                op = O_NOTIN;\r\n            else if (mpl.token == T_WITHIN)\r\n                op = O_NOTWITHIN;\r\n            else\r\n                mpl_internal_error(mpl, \"invalid use of \" + opstr);\r\n            opstr += \" \";\r\n            break;\r\n        default:\r\n            return x;\r\n    }\r\n    opstr += mpl.image;\r\n    xassert(opstr.length < 16);\r\n    switch (op)\r\n    {  case O_EQ:\r\n        case O_NE:\r\n        case O_LT:\r\n        case O_LE:\r\n        case O_GT:\r\n        case O_GE:\r\n            if (!(x.type == A_NUMERIC || x.type == A_SYMBOLIC))\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (!(y.type == A_NUMERIC || y.type == A_SYMBOLIC))\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.type == A_NUMERIC && y.type == A_SYMBOLIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n            if (x.type == A_SYMBOLIC && y.type == A_NUMERIC)\r\n                y = mpl_internal_make_unary(mpl, O_CVTSYM, y, A_SYMBOLIC, 0);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        case O_IN:\r\n        case O_NOTIN:\r\n            if (x.type == A_NUMERIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTSYM, x, A_SYMBOLIC, 0);\r\n            if (x.type == A_SYMBOLIC)\r\n                x = mpl_internal_make_unary(mpl, O_CVTTUP, x, A_TUPLE, 1);\r\n            if (x.type != A_TUPLE)\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (y.type != A_ELEMSET)\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.dim != y.dim)\r\n                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        case O_WITHIN:\r\n        case O_NOTWITHIN:\r\n            if (x.type != A_ELEMSET)\r\n                mpl_internal_error_preceding(mpl, opstr);\r\n            mpl_internal_get_token(mpl /* <rho> */);\r\n            y = mpl_internal_expression_9(mpl);\r\n            if (y.type != A_ELEMSET)\r\n                mpl_internal_error_following(mpl, opstr);\r\n            if (x.dim != y.dim)\r\n                mpl_internal_error_dimension(mpl, opstr, x.dim, y.dim);\r\n            x = mpl_internal_make_binary(mpl, op, x, y, A_LOGICAL, 0);\r\n            break;\r\n        default:\r\n            xassert(op != op);\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_11(mpl){\r\n    var x;\r\n    var opstr; //[8];\r\n    if (mpl.token == T_NOT)\r\n    {   opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        mpl_internal_get_token(mpl /* not | ! */);\r\n        x = mpl_internal_expression_10(mpl);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_unary(mpl, O_NOT, x, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        x = mpl_internal_expression_10(mpl);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_12(mpl){\r\n    var y;\r\n    var opstr = \"\"; //[8];\r\n    var x = mpl_internal_expression_11(mpl);\r\n    for (;;)\r\n    {  if (mpl.token == T_AND)\r\n    {   opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* and | && */);\r\n        y = mpl_internal_expression_11(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\r\n        if (y.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_AND, x, y, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_expression_13(mpl){\r\n    var y;\r\n    var x = mpl_internal_expression_12(mpl);\r\n    for (;;)\r\n    {   if (mpl.token == T_OR)\r\n    {   var opstr = mpl.image;\r\n        xassert(opstr.length < 8);\r\n        if (x.type == A_SYMBOLIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTNUM, x, A_NUMERIC, 0);\r\n        if (x.type == A_NUMERIC)\r\n            x = mpl_internal_make_unary(mpl, O_CVTLOG, x, A_LOGICAL, 0);\r\n        if (x.type != A_LOGICAL)\r\n            mpl_internal_error_preceding(mpl, opstr);\r\n        mpl_internal_get_token(mpl /* or | || */);\r\n        y = mpl_internal_expression_12(mpl);\r\n        if (y.type == A_SYMBOLIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTNUM, y, A_NUMERIC, 0);\r\n        if (y.type == A_NUMERIC)\r\n            y = mpl_internal_make_unary(mpl, O_CVTLOG, y, A_LOGICAL, 0);\r\n        if (y.type != A_LOGICAL)\r\n            mpl_internal_error_following(mpl, opstr);\r\n        x = mpl_internal_make_binary(mpl, O_OR, x, y, A_LOGICAL, 0);\r\n    }\r\n    else\r\n        break;\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_set_statement(mpl){\r\n    var set, node;\r\n    var dimen_used = 0;\r\n    var gadget;\r\n\r\n    function err(){mpl_internal_error(mpl, \"at most one := or default/data allowed\")}\r\n    function err1(){mpl_internal_error(mpl, mpl.image + \" not a plain set\")}\r\n    function err2(){mpl_internal_error(mpl, \"dimension of \" + mpl.image + \" too small\")}\r\n    function err3(){mpl_internal_error(mpl, \"component number must be integer between 1 and \" + gadget.set.dimen)};\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"set\"));\r\n    mpl_internal_get_token(mpl /* set */);\r\n    /* symbolic name must follow the keyword 'set' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model set */\r\n    set = {};\r\n    set.name = mpl.image;\r\n    set.alias = null;\r\n    set.dim = 0;\r\n    set.domain = null;\r\n    set.dimen = 0;\r\n    set.within = null;\r\n    set.assign = null;\r\n    set.option = null;\r\n    set.gadget = null;\r\n    set.data = 0;\r\n    set.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {   set.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  set.domain = mpl_internal_indexing_expression(mpl);\r\n        set.dim = mpl_internal_domain_arity(mpl, set.domain);\r\n    }\r\n    /* include the set name in the symbolic names table */\r\n    {\r\n        node = mpl.tree[set.name] = {};\r\n        node.type = A_SET;\r\n        node.link = set;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"dimen\"))\r\n        {  /* dimension of set members */\r\n            var dimen;\r\n            mpl_internal_get_token(mpl /* dimen */);\r\n            if (!(mpl.token == T_NUMBER &&\r\n                1.0 <= mpl.value && mpl.value <= 20.0 &&\r\n                Math.floor(mpl.value) == mpl.value))\r\n                mpl_internal_error(mpl, \"dimension must be integer between 1 and 20\");\r\n            dimen = (mpl.value + 0.5)|0;\r\n            if (dimen_used)\r\n                mpl_internal_error(mpl, \"at most one dimension attribute allowed\");\r\n            if (set.dimen > 0)\r\n                mpl_internal_error(mpl, \"dimension \" + dimen + \" conflicts with dimension \" + set.dimen + \" already determined\");\r\n            set.dimen = dimen;\r\n            dimen_used = 1;\r\n            mpl_internal_get_token(mpl /* <numeric literal> */);\r\n        }\r\n        else if (mpl.token == T_WITHIN || mpl.token == T_IN)\r\n        {  /* restricting superset */\r\n            var within, temp;\r\n            if (mpl.token == T_IN && !mpl.as_within)\r\n            {   mpl_internal_warning(mpl, \"keyword in understood as within\");\r\n                mpl.as_within = 1;\r\n            }\r\n            mpl_internal_get_token(mpl /* within */);\r\n            /* create new restricting superset list entry and append it\r\n             to the within-list */\r\n            within = {};\r\n            within.code = null;\r\n            within.next = null;\r\n            if (set.within == null)\r\n                set.within = within;\r\n            else\r\n            {   for (temp = set.within; temp.next != null; temp = temp.next){}\r\n                temp.next = within;\r\n            }\r\n            /* parse an expression that follows 'within' */\r\n            within.code = mpl_internal_expression_9(mpl);\r\n            if (within.code.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following within has invalid type\");\r\n            xassert(within.code.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = within.code.dim;\r\n            if (set.dimen != within.code.dim)\r\n                mpl_internal_error(mpl, \"set expression following within must have di\"+\r\n                    \"mension \" + set.dimen + \" rather than \" + within.code.dim);\r\n        }\r\n        else if (mpl.token == T_ASSIGN)\r\n        {  /* assignment expression */\r\n            if (!(set.assign == null && set.option == null &&\r\n                set.gadget == null))\r\n                err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows ':=' */\r\n            set.assign = mpl_internal_expression_9(mpl);\r\n            if (set.assign.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following := has invalid type\");\r\n            xassert(set.assign.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = set.assign.dim;\r\n            if (set.dimen != set.assign.dim)\r\n                mpl_internal_error(mpl, \"set expression following := must have dimens\" +\r\n                    \"ion \" + set.dimen + \" rather than \" + set.assign.dim);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"default\"))\r\n        {  /* expression for default value */\r\n            if (!(set.assign == null && set.option == null)) err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows 'default' */\r\n            set.option = mpl_internal_expression_9(mpl);\r\n            if (set.option.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following default has invalid type\");\r\n            xassert(set.option.dim > 0);\r\n            /* check/set dimension of set members */\r\n            if (set.dimen == 0) set.dimen = set.option.dim;\r\n            if (set.dimen != set.option.dim)\r\n                mpl_internal_error(mpl, \"set expression following default must have d\" +\r\n                    \"imension \" + set.dimen + \" rather than \" + set.option.dim);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"data\"))\r\n        {  /* gadget to initialize the set by data from plain set */\r\n            var i = 0, k, fff = new Array(20); //[20];\r\n            if (!(set.assign == null && set.gadget == null)) err();\r\n            mpl_internal_get_token(mpl /* data */);\r\n            set.gadget = gadget = {};\r\n            /* set name must follow the keyword 'data' */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"set name missing where expected\");\r\n            /* find the set in the symbolic name table */\r\n            node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_SET)\r\n                err1();\r\n            gadget.set = node.link;\r\n            if (gadget.set.dim != 0) err1();\r\n            if (gadget.set == set)\r\n                mpl_internal_error(mpl, \"set cannot be initialized by itself\");\r\n            /* check and set dimensions */\r\n            if (set.dim >= gadget.set.dimen)\r\n                err2();\r\n            if (set.dimen == 0)\r\n                set.dimen = gadget.set.dimen - set.dim;\r\n            if (set.dim + set.dimen > gadget.set.dimen)\r\n                err2();\r\n            else if (set.dim + set.dimen < gadget.set.dimen)\r\n                mpl_internal_error(mpl, \"dimension of \" + mpl.image + \" too big\");\r\n            mpl_internal_get_token(mpl /* set name */);\r\n            /* left parenthesis must follow the set name */\r\n            if (mpl.token == T_LEFT)\r\n                mpl_internal_get_token(mpl /* ( */);\r\n            else\r\n                mpl_internal_error(mpl, \"left parenthesis missing where expected\");\r\n            /* parse permutation of component numbers */\r\n            for (k = 0; k < gadget.set.dimen; k++) fff[k] = 0;\r\n            k = 0;\r\n            for (;;)\r\n            {  if (mpl.token != T_NUMBER)\r\n                mpl_internal_error(mpl, \"component number missing where expected\");\r\n                if (str2int(mpl.image, function(v){i = v}) != 0)\r\n                    err3();\r\n                if (!(1 <= i && i <= gadget.set.dimen)) err3();\r\n                if (fff[i-1] != 0)\r\n                    mpl_internal_error(mpl, \"component \" + i + \" multiply specified\");\r\n                gadget.ind[k++] = i; fff[i-1] = 1;\r\n                xassert(k <= gadget.set.dimen);\r\n                mpl_internal_get_token(mpl /* number */);\r\n                if (mpl.token == T_COMMA)\r\n                    mpl_internal_get_token(mpl /* , */);\r\n                else if (mpl.token == T_RIGHT)\r\n                    break;\r\n                else\r\n                    mpl_internal_error(mpl, \"syntax error in data attribute\");\r\n            }\r\n            if (k < gadget.set.dimen)\r\n                mpl_internal_error(mpl, \"there are must be \" + gadget.set.dimen + \" components rather than \" + k);\r\n            mpl_internal_get_token(mpl /* ) */);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in set statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (set.domain != null) mpl_internal_close_scope(mpl, set.domain);\r\n    /* if dimension of set members is still unknown, set it to 1 */\r\n    if (set.dimen == 0) set.dimen = 1;\r\n    /* the set statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_parameter_statement(mpl){\r\n    var par, temp;\r\n    var integer_used = 0, binary_used = 0, symbolic_used = 0;\r\n\r\n    function process_binary(){\r\n        if (binary_used)\r\n            mpl_internal_error(mpl, \"at most one binary allowed\");\r\n        if (par.type == A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"symbolic parameter cannot be binary\");\r\n        par.type = A_BINARY;\r\n        binary_used = 1;\r\n        mpl_internal_get_token(mpl /* binary */);\r\n    }\r\n\r\n    function err(){mpl_internal_error(mpl, \"at most one := or default allowed\")}\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"param\"));\r\n    mpl_internal_get_token(mpl /* param */);\r\n    /* symbolic name must follow the keyword 'param' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model parameter */\r\n    par = {};\r\n    par.name = mpl.image;\r\n    par.alias = null;\r\n    par.dim = 0;\r\n    par.domain = null;\r\n    par.type = A_NUMERIC;\r\n    par.cond = null;\r\n    par.in_ = null;\r\n    par.assign = null;\r\n    par.option = null;\r\n    par.data = 0;\r\n    par.defval = null;\r\n    par.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        par.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  par.domain = mpl_internal_indexing_expression(mpl);\r\n        par.dim = mpl_internal_domain_arity(mpl, par.domain);\r\n    }\r\n    /* include the parameter name in the symbolic names table */\r\n    {   var node = mpl.tree[par.name] = {};\r\n        node.type = A_PARAMETER;\r\n        node.link = par;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"integer\"))\r\n        {  if (integer_used)\r\n            mpl_internal_error(mpl, \"at most one integer allowed\");\r\n            if (par.type == A_SYMBOLIC)\r\n                mpl_internal_error(mpl, \"symbolic parameter cannot be integer\");\r\n            if (par.type != A_BINARY) par.type = A_INTEGER;\r\n            integer_used = 1;\r\n            mpl_internal_get_token(mpl /* integer */);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"binary\"))\r\n            process_binary();\r\n        else if (mpl_internal_is_keyword(mpl, \"logical\"))\r\n        {  if (!mpl.as_binary)\r\n        {   mpl_internal_warning(mpl, \"keyword logical understood as binary\");\r\n            mpl.as_binary = 1;\r\n        }\r\n            process_binary();\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"symbolic\"))\r\n        {  if (symbolic_used)\r\n            mpl_internal_error(mpl, \"at most one symbolic allowed\");\r\n            if (par.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"integer or binary parameter cannot be symbolic\");\r\n            /* the parameter may be referenced from expressions given\r\n             in the same parameter declaration, so its type must be\r\n             completed before parsing that expressions */\r\n            if (!(par.cond == null && par.in_ == null &&\r\n                par.assign == null && par.option == null))\r\n                mpl_internal_error(mpl, \"keyword symbolic must precede any other parameter attributes\");\r\n            par.type = A_SYMBOLIC;\r\n            symbolic_used = 1;\r\n            mpl_internal_get_token(mpl /* symbolic */);\r\n        }\r\n        else if (mpl.token == T_LT || mpl.token == T_LE ||\r\n            mpl.token == T_EQ || mpl.token == T_GE ||\r\n            mpl.token == T_GT || mpl.token == T_NE)\r\n        {  /* restricting condition */\r\n            var opstr; // [8];\r\n            /* create new restricting condition list entry and append\r\n             it to the conditions list */\r\n            var cond = {};\r\n            switch (mpl.token)\r\n            {  case T_LT:\r\n                cond.rho = O_LT; opstr = mpl.image; break;\r\n                case T_LE:\r\n                    cond.rho = O_LE; opstr = mpl.image; break;\r\n                case T_EQ:\r\n                    cond.rho = O_EQ; opstr = mpl.image; break;\r\n                case T_GE:\r\n                    cond.rho = O_GE; opstr = mpl.image; break;\r\n                case T_GT:\r\n                    cond.rho = O_GT; opstr = mpl.image; break;\r\n                case T_NE:\r\n                    cond.rho = O_NE; opstr = mpl.image; break;\r\n                default:\r\n                    xassert(mpl.token != mpl.token);\r\n            }\r\n            xassert(opstr.length < 8);\r\n            cond.code = null;\r\n            cond.next = null;\r\n            if (par.cond == null)\r\n                par.cond = cond;\r\n            else\r\n            {  for (temp = par.cond; temp.next != null; temp = temp.next){}\r\n                temp.next = cond;\r\n            }\r\n            mpl_internal_get_token(mpl /* rho */);\r\n            /* parse an expression that follows relational operator */\r\n            cond.code = mpl_internal_expression_5(mpl);\r\n            if (!(cond.code.type == A_NUMERIC ||\r\n                cond.code.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n            xassert(cond.code.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && cond.code.type ==\r\n                A_SYMBOLIC)\r\n                cond.code = mpl_internal_make_unary(mpl, O_CVTNUM, cond.code,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && cond.code.type !=\r\n                A_SYMBOLIC)\r\n                cond.code = mpl_internal_make_unary(mpl, O_CVTSYM, cond.code,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else if (mpl.token == T_IN || mpl.token == T_WITHIN)\r\n        {  /* restricting superset */\r\n            var in_;\r\n            if (mpl.token == T_WITHIN && !mpl.as_in)\r\n            {   mpl_internal_warning(mpl, \"keyword within understood as in\");\r\n                mpl.as_in = 1;\r\n            }\r\n            mpl_internal_get_token(mpl /* in */);\r\n            /* create new restricting superset list entry and append it\r\n             to the in-list */\r\n            in_ = {};\r\n            in_.code = null;\r\n            in_.next = null;\r\n            if (par.in_ == null)\r\n                par.in_ = in_;\r\n            else\r\n            {  for (temp = par.in_; temp.next != null; temp = temp.next){}\r\n                temp.next = in_;\r\n            }\r\n            /* parse an expression that follows 'in' */\r\n            in_.code = mpl_internal_expression_9(mpl);\r\n            if (in_.code.type != A_ELEMSET)\r\n                mpl_internal_error(mpl, \"expression following in has invalid type\");\r\n            xassert(in_.code.dim > 0);\r\n            if (in_.code.dim != 1)\r\n                mpl_internal_error(mpl, \"set expression following in must have dimens\"+\r\n                    \"ion 1 rather than \" + in_.code.dim);\r\n        }\r\n        else if (mpl.token == T_ASSIGN)\r\n        {   /* assignment expression */\r\n            if (!(par.assign == null && par.option == null))\r\n                err();\r\n            mpl_internal_get_token(mpl /* := */);\r\n            /* parse an expression that follows ':=' */\r\n            par.assign = mpl_internal_expression_5(mpl);\r\n            /* the expression must be of numeric/symbolic type */\r\n            if (!(par.assign.type == A_NUMERIC ||\r\n                par.assign.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following := has invalid type\");\r\n            xassert(par.assign.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && par.assign.type ==\r\n                A_SYMBOLIC)\r\n                par.assign = mpl_internal_make_unary(mpl, O_CVTNUM, par.assign,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && par.assign.type !=\r\n                A_SYMBOLIC)\r\n                par.assign = mpl_internal_make_unary(mpl, O_CVTSYM, par.assign,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"default\"))\r\n        {  /* expression for default value */\r\n            if (!(par.assign == null && par.option == null)) err();\r\n            mpl_internal_get_token(mpl /* default */);\r\n            /* parse an expression that follows 'default' */\r\n            par.option = mpl_internal_expression_5(mpl);\r\n            if (!(par.option.type == A_NUMERIC ||\r\n                par.option.type == A_SYMBOLIC))\r\n                mpl_internal_error(mpl, \"expression following default has invalid type\");\r\n            xassert(par.option.dim == 0);\r\n            /* convert to the parameter type, if necessary */\r\n            if (par.type != A_SYMBOLIC && par.option.type ==\r\n                A_SYMBOLIC)\r\n                par.option = mpl_internal_make_unary(mpl, O_CVTNUM, par.option,\r\n                    A_NUMERIC, 0);\r\n            if (par.type == A_SYMBOLIC && par.option.type !=\r\n                A_SYMBOLIC)\r\n                par.option = mpl_internal_make_unary(mpl, O_CVTSYM, par.option,\r\n                    A_SYMBOLIC, 0);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in parameter statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (par.domain != null) mpl_internal_close_scope(mpl, par.domain);\r\n    /* the parameter statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return par;\r\n}\r\n\r\nfunction mpl_internal_variable_statement(mpl){\r\n    var integer_used = 0, binary_used = 0;\r\n\r\n    function process_binary(){\r\n        if (binary_used)\r\n            mpl_internal_error(mpl, \"at most one binary allowed\");\r\n        var_.type = A_BINARY;\r\n        binary_used = 1;\r\n        mpl_internal_get_token(mpl /* binary */);\r\n    }\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"var\"));\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"variable statement must precede solve statement\");\r\n    mpl_internal_get_token(mpl /* var */);\r\n    /* symbolic name must follow the keyword 'var' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model variable */\r\n    var var_ = {};\r\n    var_.name = mpl.image;\r\n    var_.alias = null;\r\n    var_.dim = 0;\r\n    var_.domain = null;\r\n    var_.type = A_NUMERIC;\r\n    var_.lbnd = null;\r\n    var_.ubnd = null;\r\n    var_.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        var_.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  var_.domain = mpl_internal_indexing_expression(mpl);\r\n        var_.dim = mpl_internal_domain_arity(mpl, var_.domain);\r\n    }\r\n    /* include the variable name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[var_.name] = {};\r\n        node.type = A_VARIABLE;\r\n        node.link = var_;\r\n    }\r\n    /* parse the list of optional attributes */\r\n    for (;;)\r\n    {  if (mpl.token == T_COMMA)\r\n        mpl_internal_get_token(mpl /* , */);\r\n    else if (mpl.token == T_SEMICOLON)\r\n        break;\r\n        if (mpl_internal_is_keyword(mpl, \"integer\"))\r\n        {  if (integer_used)\r\n            mpl_internal_error(mpl, \"at most one integer allowed\");\r\n            if (var_.type != A_BINARY) var_.type = A_INTEGER;\r\n            integer_used = 1;\r\n            mpl_internal_get_token(mpl /* integer */);\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"binary\"))\r\n            process_binary();\r\n        else if (mpl_internal_is_keyword(mpl, \"logical\"))\r\n        {  if (!mpl.as_binary)\r\n        {  mpl_internal_warning(mpl, \"keyword logical understood as binary\");\r\n            mpl.as_binary = 1;\r\n        }\r\n            process_binary();\r\n        }\r\n        else if (mpl_internal_is_keyword(mpl, \"symbolic\"))\r\n            mpl_internal_error(mpl, \"variable cannot be symbolic\");\r\n        else if (mpl.token == T_GE)\r\n        {  /* lower bound */\r\n            if (var_.lbnd != null)\r\n            {  if (var_.lbnd == var_.ubnd)\r\n                mpl_internal_error(mpl, \"both fixed value and lower bound not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"at most one lower bound allowed\");\r\n            }\r\n            mpl_internal_get_token(mpl /* >= */);\r\n            /* parse an expression that specifies the lower bound */\r\n            var_.lbnd = mpl_internal_expression_5(mpl);\r\n            if (var_.lbnd.type == A_SYMBOLIC)\r\n                var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.lbnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following >= has invalid type\");\r\n            xassert(var_.lbnd.dim == 0);\r\n        }\r\n        else if (mpl.token == T_LE)\r\n        {  /* upper bound */\r\n            if (var_.ubnd != null)\r\n            {  if (var_.ubnd == var_.lbnd)\r\n                mpl_internal_error(mpl, \"both fixed value and upper bound not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"at most one upper bound allowed\");\r\n            }\r\n            mpl_internal_get_token(mpl /* <= */);\r\n            /* parse an expression that specifies the upper bound */\r\n            var_.ubnd = mpl_internal_expression_5(mpl);\r\n            if (var_.ubnd.type == A_SYMBOLIC)\r\n                var_.ubnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.ubnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.ubnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following <= has invalid type\");\r\n            xassert(var_.ubnd.dim == 0);\r\n        }\r\n        else if (mpl.token == T_EQ)\r\n        {  /* fixed value */\r\n            var opstr; //[8]\r\n            if (!(var_.lbnd == null && var_.ubnd == null))\r\n            {  if (var_.lbnd == var_.ubnd)\r\n                mpl_internal_error(mpl, \"at most one fixed value allowed\");\r\n            else if (var_.lbnd != null)\r\n                mpl_internal_error(mpl, \"both lower bound and fixed value not allowed\");\r\n            else\r\n                mpl_internal_error(mpl, \"both upper bound and fixed value not allowed\");\r\n            }\r\n            opstr = mpl.image;\r\n            xassert(opstr.length < 8);\r\n            mpl_internal_get_token(mpl /* = | == */);\r\n            /* parse an expression that specifies the fixed value */\r\n            var_.lbnd = mpl_internal_expression_5(mpl);\r\n            if (var_.lbnd.type == A_SYMBOLIC)\r\n                var_.lbnd = mpl_internal_make_unary(mpl, O_CVTNUM, var_.lbnd,\r\n                    A_NUMERIC, 0);\r\n            if (var_.lbnd.type != A_NUMERIC)\r\n                mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n            xassert(var_.lbnd.dim == 0);\r\n            /* indicate that the variable is fixed, not bounded */\r\n            var_.ubnd = var_.lbnd;\r\n        }\r\n        else if (mpl.token == T_LT || mpl.token == T_GT ||\r\n            mpl.token == T_NE)\r\n            mpl_internal_error(mpl, \"strict bound not allowed\");\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in variable statement\");\r\n    }\r\n    /* close the domain scope */\r\n    if (var_.domain != null) mpl_internal_close_scope(mpl, var_.domain);\r\n    /* the variable statement has been completely parsed */\r\n    xassert(mpl.token == T_SEMICOLON);\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return var_;\r\n}\r\n\r\nfunction mpl_internal_constraint_statement(mpl){\r\n    var first, second, third;\r\n    var rho;\r\n    var opstr; //[8];\r\n\r\n    function err(){mpl_internal_error(mpl, \"syntax error in constraint statement\")}\r\n\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"constraint statement must precede solve statement\");\r\n    if (mpl_internal_is_keyword(mpl, \"subject\"))\r\n    {  mpl_internal_get_token(mpl /* subject */);\r\n        if (!mpl_internal_is_keyword(mpl, \"to\"))\r\n            mpl_internal_error(mpl, \"keyword subject to incomplete\");\r\n        mpl_internal_get_token(mpl /* to */);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"subj\"))\r\n    {  mpl_internal_get_token(mpl /* subj */);\r\n        if (!mpl_internal_is_keyword(mpl, \"to\"))\r\n            mpl_internal_error(mpl, \"keyword subj to incomplete\");\r\n        mpl_internal_get_token(mpl /* to */);\r\n    }\r\n    else if (mpl.token == T_SPTP)\r\n        mpl_internal_get_token(mpl /* s.t. */);\r\n    /* the current token must be symbolic name of constraint */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model constraint */\r\n    var con = {};\r\n    con.name = mpl.image;\r\n    con.alias = null;\r\n    con.dim = 0;\r\n    con.domain = null;\r\n    con.type = A_CONSTRAINT;\r\n    con.code = null;\r\n    con.lbnd = null;\r\n    con.ubnd = null;\r\n    con.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        con.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  con.domain = mpl_internal_indexing_expression(mpl);\r\n        con.dim = mpl_internal_domain_arity(mpl, con.domain);\r\n    }\r\n    /* include the constraint name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[con.name] = {};\r\n        node.type = A_CONSTRAINT;\r\n        node.link = con;\r\n    }\r\n    /* the colon must precede the first expression */\r\n    if (mpl.token != T_COLON)\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    mpl_internal_get_token(mpl /* : */);\r\n    /* parse the first expression */\r\n    first = mpl_internal_expression_5(mpl);\r\n    if (first.type == A_SYMBOLIC)\r\n        first = mpl_internal_make_unary(mpl, O_CVTNUM, first, A_NUMERIC, 0);\r\n    if (!(first.type == A_NUMERIC || first.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n    xassert(first.dim == 0);\r\n    /* relational operator must follow the first expression */\r\n    if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    switch (mpl.token)\r\n    {  case T_LE:\r\n        case T_GE:\r\n        case T_EQ:\r\n            break;\r\n        case T_LT:\r\n        case T_GT:\r\n        case T_NE:\r\n            mpl_internal_error(mpl, \"strict inequality not allowed\");\r\n            break;\r\n        case T_SEMICOLON:\r\n            mpl_internal_error(mpl, \"constraint must be equality or inequality\");\r\n            break;\r\n        default:\r\n            err();\r\n    }\r\n    rho = mpl.token;\r\n    opstr = mpl.image;\r\n    xassert(opstr.length < 8);\r\n    mpl_internal_get_token(mpl /* rho */);\r\n    /* parse the second expression */\r\n    second = mpl_internal_expression_5(mpl);\r\n    if (second.type == A_SYMBOLIC)\r\n        second = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\r\n    if (!(second.type == A_NUMERIC || second.type == A_FORMULA))\r\n        mpl_internal_error(mpl, \"expression following \" + opstr + \" has invalid type\");\r\n    xassert(second.dim == 0);\r\n    /* check a token that follow the second expression */\r\n    if (mpl.token == T_COMMA)\r\n    {  mpl_internal_get_token(mpl /* , */);\r\n        if (mpl.token == T_SEMICOLON) err();\r\n    }\r\n    if (mpl.token == T_LT || mpl.token == T_LE ||\r\n        mpl.token == T_EQ || mpl.token == T_GE ||\r\n        mpl.token == T_GT || mpl.token == T_NE)\r\n    {  /* it is another relational operator, therefore the constraint\r\n     is double inequality */\r\n        if (rho == T_EQ || mpl.token != rho)\r\n            mpl_internal_error(mpl, \"double inequality must be ... <= ... <= ... or \" +\r\n                \"... >= ... >= ...\");\r\n        /* the first expression cannot be linear form */\r\n        if (first.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"leftmost expression in double inequality cannot\" +\r\n                \" be linear form\");\r\n        mpl_internal_get_token(mpl /* rho */);\r\n        /* parse the third expression */\r\n        third = mpl_internal_expression_5(mpl);\r\n        if (third.type == A_SYMBOLIC)\r\n            third = mpl_internal_make_unary(mpl, O_CVTNUM, second, A_NUMERIC, 0);\r\n        if (!(third.type == A_NUMERIC || third.type == A_FORMULA))\r\n            mpl_internal_error(mpl, \"rightmost expression in double inequality const\" +\r\n                \"raint has invalid type\");\r\n        xassert(third.dim == 0);\r\n        /* the third expression also cannot be linear form */\r\n        if (third.type == A_FORMULA)\r\n            mpl_internal_error(mpl, \"rightmost expression in double inequality canno\" +\r\n                \"t be linear form\");\r\n    }\r\n    else\r\n    {  /* the constraint is equality or single inequality */\r\n        third = null;\r\n    }\r\n    /* close the domain scope */\r\n    if (con.domain != null) mpl_internal_close_scope(mpl, con.domain);\r\n    /* convert all expressions to linear form, if necessary */\r\n    if (first.type != A_FORMULA)\r\n        first = mpl_internal_make_unary(mpl, O_CVTLFM, first, A_FORMULA, 0);\r\n    if (second.type != A_FORMULA)\r\n        second = mpl_internal_make_unary(mpl, O_CVTLFM, second, A_FORMULA, 0);\r\n    if (third != null)\r\n        third = mpl_internal_make_unary(mpl, O_CVTLFM, third, A_FORMULA, 0);\r\n    /* arrange expressions in the constraint */\r\n    if (third == null)\r\n    {  /* the constraint is equality or single inequality */\r\n        switch (rho)\r\n        {  case T_LE:\r\n            /* first <= second */\r\n            con.code = first;\r\n            con.lbnd = null;\r\n            con.ubnd = second;\r\n            break;\r\n            case T_GE:\r\n                /* first >= second */\r\n                con.code = first;\r\n                con.lbnd = second;\r\n                con.ubnd = null;\r\n                break;\r\n            case T_EQ:\r\n                /* first = second */\r\n                con.code = first;\r\n                con.lbnd = second;\r\n                con.ubnd = second;\r\n                break;\r\n            default:\r\n                xassert(rho != rho);\r\n        }\r\n    }\r\n    else\r\n    {  /* the constraint is double inequality */\r\n        switch (rho)\r\n        {  case T_LE:\r\n            /* first <= second <= third */\r\n            con.code = second;\r\n            con.lbnd = first;\r\n            con.ubnd = third;\r\n            break;\r\n            case T_GE:\r\n                /* first >= second >= third */\r\n                con.code = second;\r\n                con.lbnd = third;\r\n                con.ubnd = first;\r\n                break;\r\n            default:\r\n                xassert(rho != rho);\r\n        }\r\n    }\r\n    /* the constraint statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        err();\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return con;\r\n}\r\n\r\nfunction mpl_internal_objective_statement(mpl){\r\n    var obj;\r\n    var type;\r\n    if (mpl_internal_is_keyword(mpl, \"minimize\"))\r\n        type = A_MINIMIZE;\r\n    else if (mpl_internal_is_keyword(mpl, \"maximize\"))\r\n        type = A_MAXIMIZE;\r\n    else\r\n        xassert(mpl != mpl);\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"objective statement must precede solve statement\");\r\n    mpl_internal_get_token(mpl /* minimize | maximize */);\r\n    /* symbolic name must follow the verb 'minimize' or 'maximize' */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create model objective */\r\n    obj = {};\r\n    obj.name = mpl.image;\r\n    obj.alias = null;\r\n    obj.dim = 0;\r\n    obj.domain = null;\r\n    obj.type = type;\r\n    obj.code = null;\r\n    obj.lbnd = null;\r\n    obj.ubnd = null;\r\n    obj.array = null;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        obj.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {   obj.domain = mpl_internal_indexing_expression(mpl);\r\n        obj.dim = mpl_internal_domain_arity(mpl, obj.domain);\r\n    }\r\n    /* include the constraint name in the symbolic names table */\r\n    {\r\n        var node = mpl.tree[obj.name] = {};\r\n        node.type = A_CONSTRAINT;\r\n        node.link = obj;\r\n    }\r\n    /* the colon must precede the objective expression */\r\n    if (mpl.token != T_COLON)\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    mpl_internal_get_token(mpl /* : */);\r\n    /* parse the objective expression */\r\n    obj.code = mpl_internal_expression_5(mpl);\r\n    if (obj.code.type == A_SYMBOLIC)\r\n        obj.code = mpl_internal_make_unary(mpl, O_CVTNUM, obj.code, A_NUMERIC, 0);\r\n    if (obj.code.type == A_NUMERIC)\r\n        obj.code = mpl_internal_make_unary(mpl, O_CVTLFM, obj.code, A_FORMULA, 0);\r\n    if (obj.code.type != A_FORMULA)\r\n        mpl_internal_error(mpl, \"expression following colon has invalid type\");\r\n    xassert(obj.code.dim == 0);\r\n    /* close the domain scope */\r\n    if (obj.domain != null) mpl_internal_close_scope(mpl, obj.domain);\r\n    /* the objective statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in objective statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return obj;\r\n}\r\n\r\nfunction mpl_internal_table_statement(mpl){\r\n    var last_arg, arg;\r\n    var last_fld, fld;\r\n    var last_in, in_;\r\n    var last_out, out;\r\n    var node;\r\n    var nflds;\r\n    var name; // [MAX_LENGTH+1];\r\n    xassert(mpl_internal_is_keyword(mpl, \"table\"));\r\n    mpl_internal_get_token(mpl /* solve */);\r\n    /* symbolic name must follow the keyword table */\r\n    if (mpl.token == T_NAME){\r\n\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"symbolic name missing where expected\");\r\n    /* there must be no other object with the same name */\r\n    if (mpl.tree[mpl.image] != null)\r\n        mpl_internal_error(mpl, mpl.image + \" multiply declared\");\r\n    /* create data table */\r\n    var tab = {u: {in_: {}, out: {}}};\r\n    tab.name = mpl.image;\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* parse optional alias */\r\n    if (mpl.token == T_STRING)\r\n    {\r\n        tab.alias = mpl.image;\r\n        mpl_internal_get_token(mpl /* <string literal> */);\r\n    }\r\n    else\r\n        tab.alias = null;\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  /* this is output table */\r\n        tab.type = A_OUTPUT;\r\n        tab.u.out.domain = mpl_internal_indexing_expression(mpl);\r\n        if (!mpl_internal_is_keyword(mpl, \"OUT\"))\r\n            mpl_internal_error(mpl, \"keyword OUT missing where expected\");\r\n        mpl_internal_get_token(mpl /* OUT */);\r\n    }\r\n    else\r\n    {  /* this is input table */\r\n        tab.type = A_INPUT;\r\n        if (!mpl_internal_is_keyword(mpl, \"IN\"))\r\n            mpl_internal_error(mpl, \"keyword IN missing where expected\");\r\n        mpl_internal_get_token(mpl /* IN */);\r\n    }\r\n    /* parse argument list */\r\n    tab.arg = last_arg = null;\r\n    for (;;)\r\n    {  /* create argument list entry */\r\n        arg = {};\r\n        /* parse argument expression */\r\n        if (mpl.token == T_COMMA || mpl.token == T_COLON ||\r\n            mpl.token == T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"argument expression missing where expected\");\r\n        arg.code = mpl_internal_expression_5(mpl);\r\n        /* convert the result to symbolic type, if necessary */\r\n        if (arg.code.type == A_NUMERIC)\r\n            arg.code =\r\n                mpl_internal_make_unary(mpl, O_CVTSYM, arg.code, A_SYMBOLIC, 0);\r\n        /* check that now the result is of symbolic type */\r\n        if (arg.code.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"argument expression has invalid type\");\r\n        /* add the entry to the end of the list */\r\n        arg.next = null;\r\n        if (last_arg == null)\r\n            tab.arg = arg;\r\n        else\r\n            last_arg.next = arg;\r\n        last_arg = arg;\r\n        /* argument expression has been parsed */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == T_COLON || mpl.token == T_SEMICOLON)\r\n            break;\r\n    }\r\n    xassert(tab.arg != null);\r\n    /* argument list must end with colon */\r\n    if (mpl.token == T_COLON)\r\n        mpl_internal_get_token(mpl /* : */);\r\n    else\r\n        mpl_internal_error(mpl, \"colon missing where expected\");\r\n    /* parse specific part of the table statement */\r\n    switch (tab.type)\r\n    {   case A_INPUT:\r\n        /* parse optional set name */\r\n        if (mpl.token == T_NAME)\r\n        {   node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_SET)\r\n                mpl_internal_error(mpl, mpl.image + \" not a set\");\r\n            tab.u.in_.set = node.link;\r\n            if (tab.u.in_.set.assign != null)\r\n                mpl_internal_error(mpl, mpl.image + \" needs no data\");\r\n            if (tab.u.in_.set.dim != 0)\r\n                mpl_internal_error(mpl, mpl.image + \" must be a simple set\");\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            if (mpl.token == T_INPUT)\r\n                mpl_internal_get_token(mpl /* <- */);\r\n            else\r\n                mpl_internal_error(mpl, \"delimiter <- missing where expected\");\r\n        }\r\n        else if (mpl_internal_is_reserved(mpl))\r\n            mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n        else\r\n            tab.u.in_.set = null;\r\n        /* parse field list */\r\n        tab.u.in_.fld = last_fld = null;\r\n        nflds = 0;\r\n        if (mpl.token == T_LBRACKET)\r\n            mpl_internal_get_token(mpl /* [ */);\r\n        else\r\n            mpl_internal_error(mpl, \"field list missing where expected\");\r\n        for (;;)\r\n        {  /* create field list entry */\r\n            fld = {};\r\n            /* parse field name */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl,\r\n                    \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"field name missing where expected\");\r\n            fld.name = mpl.image;\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            /* add the entry to the end of the list */\r\n            fld.next = null;\r\n            if (last_fld == null)\r\n                tab.u.in_.fld = fld;\r\n            else\r\n                last_fld.next = fld;\r\n            last_fld = fld;\r\n            nflds++;\r\n            /* field name has been parsed */\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RBRACKET)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in field list\");\r\n        }\r\n        /* check that the set dimen is equal to the number of fields */\r\n        if (tab.u.in_.set != null && tab.u.in_.set.dimen != nflds)\r\n            mpl_internal_error(mpl, \"there must be \" + tab.u.in_.set.dimen + \" field\" +\r\n                (tab.u.in_.set.dimen == 1 ? \"\" : \"s\") + \" rather than \" + nflds);\r\n        mpl_internal_get_token(mpl /* ] */);\r\n        /* parse optional input list */\r\n        tab.u.in_.list = last_in = null;\r\n        while (mpl.token == T_COMMA)\r\n        {  mpl_internal_get_token(mpl /* , */);\r\n            /* create input list entry */\r\n            in_ = {};\r\n            /* parse parameter name */\r\n            if (mpl.token == T_NAME){\r\n\r\n            }\r\n            else if (mpl_internal_is_reserved(mpl))\r\n                mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n            else\r\n                mpl_internal_error(mpl, \"parameter name missing where expected\");\r\n            node = mpl.tree[mpl.image];\r\n            if (node == null)\r\n                mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n            if (node.type != A_PARAMETER)\r\n                mpl_internal_error(mpl, mpl.image + \" not a parameter\");\r\n            in_.par = node.link;\r\n            if (in_.par.dim != nflds)\r\n                mpl_internal_error(mpl, mpl.image + \" must have \" + nflds + \" subscript\" + (nflds == 1 ? \"\" : \"s\") + \" rather than \" + in_.par.dim);\r\n            if (in_.par.assign != null)\r\n                mpl_internal_error(mpl, mpl.image + \" needs no data\");\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            /* parse optional field name */\r\n            if (mpl.token == T_TILDE)\r\n            {  mpl_internal_get_token(mpl /* ~ */);\r\n                /* parse field name */\r\n                if (mpl.token == T_NAME){\r\n\r\n                }\r\n                else if (mpl_internal_is_reserved(mpl))\r\n                    mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n                else\r\n                    mpl_internal_error(mpl, \"field name missing where expected\");\r\n                //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                name = mpl.image;\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            }\r\n            else\r\n            {  /* field name is the same as the parameter name */\r\n                //xassert(in_.par.name.length < MAX_LENGTH+1);\r\n                name = in_.par.name;\r\n            }\r\n            /* assign field name */\r\n            in_.name = name;\r\n            /* add the entry to the end of the list */\r\n            in_.next = null;\r\n            if (last_in == null)\r\n                tab.u.in_.list = in_;\r\n            else\r\n                last_in.next = in_;\r\n            last_in = in_;\r\n        }\r\n        break;\r\n        case A_OUTPUT:\r\n            /* parse output list */\r\n            tab.u.out.list = last_out = null;\r\n            for (;;)\r\n            {  /* create output list entry */\r\n                out = {};\r\n                /* parse expression */\r\n                if (mpl.token == T_COMMA || mpl.token == T_SEMICOLON)\r\n                    mpl_internal_error(mpl, \"expression missing where expected\");\r\n                if (mpl.token == T_NAME)\r\n                {  //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                    name = mpl.image;\r\n                }\r\n                else\r\n                    name = '';\r\n                out.code = mpl_internal_expression_5(mpl);\r\n                /* parse optional field name */\r\n                if (mpl.token == T_TILDE)\r\n                {  mpl_internal_get_token(mpl /* ~ */);\r\n                    /* parse field name */\r\n                    if (mpl.token == T_NAME){\r\n\r\n                    }\r\n                    else if (mpl_internal_is_reserved(mpl))\r\n                        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n                    else\r\n                        mpl_internal_error(mpl, \"field name missing where expected\");\r\n                    //xassert(mpl.image.length < MAX_LENGTH+1);\r\n                    name = mpl.image;\r\n                    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n                }\r\n                /* assign field name */\r\n                if (name == '')\r\n                    mpl_internal_error(mpl, \"field name required\");\r\n                out.name = name;\r\n                /* add the entry to the end of the list */\r\n                out.next = null;\r\n                if (last_out == null)\r\n                    tab.u.out.list = out;\r\n                else\r\n                    last_out.next = out;\r\n                last_out = out;\r\n                /* output item has been parsed */\r\n                if (mpl.token == T_COMMA)\r\n                    mpl_internal_get_token(mpl /* , */);\r\n                else if (mpl.token == T_SEMICOLON)\r\n                    break;\r\n                else\r\n                    mpl_internal_error(mpl, \"syntax error in output list\");\r\n            }\r\n            /* close the domain scope */\r\n            mpl_internal_close_scope(mpl,tab.u.out.domain);\r\n            break;\r\n        default:\r\n            xassert(tab != tab);\r\n    }\r\n\r\n    /* the table statement must end with semicolon */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in table statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return tab;\r\n}\r\n\r\nfunction mpl_internal_solve_statement(mpl){\r\n    xassert(mpl_internal_is_keyword(mpl, \"solve\"));\r\n    if (mpl.flag_s)\r\n        mpl_internal_error(mpl, \"at most one solve statement allowed\");\r\n    mpl.flag_s = 1;\r\n    mpl_internal_get_token(mpl /* solve */);\r\n    /* semicolon must follow solve statement */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in solve statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return null;\r\n}\r\n\r\nfunction mpl_internal_check_statement(mpl){\r\n    xassert(mpl_internal_is_keyword(mpl, \"check\"));\r\n    /* create check descriptor */\r\n    var chk = {};\r\n    chk.domain = null;\r\n    chk.code = null;\r\n    mpl_internal_get_token(mpl /* check */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  chk.domain = mpl_internal_indexing_expression(mpl);\r\n    }\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse logical expression */\r\n    chk.code = mpl_internal_expression_13(mpl);\r\n    if (chk.code.type != A_LOGICAL)\r\n        mpl_internal_error(mpl, \"expression has invalid type\");\r\n    xassert(chk.code.dim == 0);\r\n    /* close the domain scope */\r\n    if (chk.domain != null) mpl_internal_close_scope(mpl, chk.domain);\r\n    /* the check statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in check statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return chk;\r\n}\r\n\r\nfunction mpl_internal_display_statement(mpl){\r\n    var last_entry;\r\n\r\n    xassert(mpl_internal_is_keyword(mpl, \"display\"));\r\n    /* create display descriptor */\r\n    var dpy = {};\r\n    dpy.domain = null;\r\n    dpy.list = last_entry = null;\r\n    mpl_internal_get_token(mpl /* display */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n        dpy.domain = mpl_internal_indexing_expression(mpl);\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse display list */\r\n    for (;;)\r\n    {  /* create new display entry */\r\n        var entry = {u: {}};\r\n\r\n        function expr(){\r\n            /* display entry is expression */\r\n            entry.type = A_EXPRESSION;\r\n            entry.u.code = mpl_internal_expression_13(mpl);\r\n        }\r\n\r\n        entry.type = 0;\r\n        entry.next = null;\r\n        /* and append it to the display list */\r\n        if (dpy.list == null)\r\n            dpy.list = entry;\r\n        else\r\n            last_entry.next = entry;\r\n        last_entry = entry;\r\n        /* parse display entry */\r\n        if (mpl.token == T_NAME)\r\n        {   var node;\r\n            var next_token;\r\n            mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            next_token = mpl.token;\r\n            mpl_internal_unget_token(mpl);\r\n            if (!(next_token == T_COMMA || next_token == T_SEMICOLON))\r\n            {  /* symbolic name begins expression */\r\n                expr();\r\n            } else {\r\n                /* display entry is dummy index or model object */\r\n                node = mpl.tree[mpl.image];\r\n                if (node == null)\r\n                    mpl_internal_error(mpl, mpl.image + \" not defined\");\r\n                entry.type = node.type;\r\n                switch (node.type)\r\n                {  case A_INDEX:\r\n                    entry.u.slot = node.link;\r\n                    break;\r\n                    case A_SET:\r\n                        entry.u.set = node.link;\r\n                        break;\r\n                    case A_PARAMETER:\r\n                        entry.u.par = node.link;\r\n                        break;\r\n                    case A_VARIABLE:\r\n                        entry.u.var_ = node.link;\r\n                        if (!mpl.flag_s)\r\n                            mpl_internal_error(mpl, \"invalid reference to variable \" + entry.u.var_.name +  \" above solve statement\");\r\n                        break;\r\n                    case A_CONSTRAINT:\r\n                        entry.u.con = node.link;\r\n                        if (!mpl.flag_s)\r\n                            mpl_internal_error(mpl, \"invalid reference to \" + (entry.u.con.type == A_CONSTRAINT ?\"constraint\" : \"objective\") +\r\n                                \" \" + entry.u.con.name + \" above solve statement\");\r\n                        break;\r\n                    default:\r\n                        xassert(node != node);\r\n                }\r\n                mpl_internal_get_token(mpl /* <symbolic name> */);\r\n            }\r\n        }\r\n        else\r\n            expr();\r\n        /* check a token that follows the entry parsed */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else\r\n            break;\r\n    }\r\n    /* close the domain scope */\r\n    if (dpy.domain != null) mpl_internal_close_scope(mpl, dpy.domain);\r\n    /* the display statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in display statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return dpy;\r\n}\r\n\r\nfunction mpl_internal_printf_statement(mpl){\r\n    var entry, last_entry;\r\n    xassert(mpl_internal_is_keyword(mpl, \"printf\"));\r\n    /* create printf descriptor */\r\n    var prt = {};\r\n    prt.domain = null;\r\n    prt.fmt = null;\r\n    prt.list = last_entry = null;\r\n    mpl_internal_get_token(mpl /* printf */);\r\n    /* parse optional indexing expression */\r\n    if (mpl.token == T_LBRACE)\r\n    {  prt.domain = mpl_internal_indexing_expression(mpl);\r\n    }\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse expression for format string */\r\n    prt.fmt = mpl_internal_expression_5(mpl);\r\n    /* convert it to symbolic type, if necessary */\r\n    if (prt.fmt.type == A_NUMERIC)\r\n        prt.fmt = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fmt, A_SYMBOLIC, 0);\r\n    /* check that now the expression is of symbolic type */\r\n    if (prt.fmt.type != A_SYMBOLIC)\r\n        mpl_internal_error(mpl, \"format expression has invalid type\");\r\n    /* parse printf list */\r\n    while (mpl.token == T_COMMA)\r\n    {  mpl_internal_get_token(mpl /* , */);\r\n        /* create new printf entry */\r\n        entry = {};\r\n        entry.code = null;\r\n        entry.next = null;\r\n        /* and append it to the printf list */\r\n        if (prt.list == null)\r\n            prt.list = entry;\r\n        else\r\n            last_entry.next = entry;\r\n        last_entry = entry;\r\n        /* parse printf entry */\r\n        entry.code = mpl_internal_expression_9(mpl);\r\n        if (!(entry.code.type == A_NUMERIC ||\r\n            entry.code.type == A_SYMBOLIC ||\r\n            entry.code.type == A_LOGICAL))\r\n            mpl_internal_error(mpl, \"only numeric, symbolic, or logical expression allowed\");\r\n    }\r\n    /* close the domain scope */\r\n    if (prt.domain != null) mpl_internal_close_scope(mpl, prt.domain);\r\n    /* parse optional redirection */\r\n    prt.fname = null; prt.app = 0;\r\n    if (mpl.token == T_GT || mpl.token == T_APPEND)\r\n    {  prt.app = (mpl.token == T_APPEND);\r\n        mpl_internal_get_token(mpl /* > or >> */);\r\n        /* parse expression for file name string */\r\n        prt.fname = mpl_internal_expression_5(mpl);\r\n        /* convert it to symbolic type, if necessary */\r\n        if (prt.fname.type == A_NUMERIC)\r\n            prt.fname = mpl_internal_make_unary(mpl, O_CVTSYM, prt.fname,\r\n                A_SYMBOLIC, 0);\r\n        /* check that now the expression is of symbolic type */\r\n        if (prt.fname.type != A_SYMBOLIC)\r\n            mpl_internal_error(mpl, \"file name expression has invalid type\");\r\n    }\r\n    /* the printf statement has been completely parsed */\r\n    if (mpl.token != T_SEMICOLON)\r\n        mpl_internal_error(mpl, \"syntax error in printf statement\");\r\n    mpl_internal_get_token(mpl /* ; */);\r\n    return prt;\r\n}\r\n\r\nfunction mpl_internal_for_statement(mpl){\r\n    var stmt, last_stmt;\r\n    xassert(mpl_internal_is_keyword(mpl, \"for\"));\r\n    /* create for descriptor */\r\n    var fur = {};\r\n    fur.domain = null;\r\n    fur.list = last_stmt = null;\r\n    mpl_internal_get_token(mpl /* for */);\r\n    /* parse indexing expression */\r\n    if (mpl.token != T_LBRACE)\r\n        mpl_internal_error(mpl, \"indexing expression missing where expected\");\r\n    fur.domain = mpl_internal_indexing_expression(mpl);\r\n    /* skip optional colon */\r\n    if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n    /* parse for statement body */\r\n    if (mpl.token != T_LBRACE)\r\n    {  /* parse simple statement */\r\n        fur.list = mpl_internal_simple_statement(mpl, 1);\r\n    }\r\n    else\r\n    {  /* parse compound statement */\r\n        mpl_internal_get_token(mpl /* { */);\r\n        while (mpl.token != T_RBRACE)\r\n        {  /* parse statement */\r\n            stmt = mpl_internal_simple_statement(mpl, 1);\r\n            /* and append it to the end of the statement list */\r\n            if (last_stmt == null)\r\n                fur.list = stmt;\r\n            else\r\n                last_stmt.next = stmt;\r\n            last_stmt = stmt;\r\n        }\r\n        mpl_internal_get_token(mpl /* } */);\r\n    }\r\n    /* close the domain scope */\r\n    xassert(fur.domain != null);\r\n    mpl_internal_close_scope(mpl, fur.domain);\r\n    /* the for statement has been completely parsed */\r\n    return fur;\r\n}\r\n\r\nfunction mpl_internal_end_statement(mpl){\r\n    if (!mpl.flag_d && mpl_internal_is_keyword(mpl, \"end\") ||\r\n        mpl.flag_d && mpl_internal_is_literal(mpl, \"end\"))\r\n    {\r\n        mpl_internal_get_token(mpl /* end */);\r\n        if (mpl.token == T_SEMICOLON)\r\n            mpl_internal_get_token(mpl /* ; */);\r\n        else\r\n            mpl_internal_warning(mpl, \"no semicolon following end statement; missing\" +\r\n                \" semicolon inserted\");\r\n    }\r\n    else\r\n        mpl_internal_warning(mpl, \"unexpected end of file; missing end statement inserted\");\r\n    if (mpl.token != T_EOF)\r\n        mpl_internal_warning(mpl, \"some text detected beyond end statement; text ignored\");\r\n}\r\n\r\nfunction mpl_internal_simple_statement(mpl, spec){\r\n    var stmt = {u: {}};\r\n    stmt.line = mpl.line;\r\n    stmt.column = mpl.column;\r\n    stmt.next = null;\r\n    if (mpl_internal_is_keyword(mpl, \"set\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"set statement not allowed here\");\r\n        stmt.type = A_SET;\r\n        stmt.u.set = mpl_internal_set_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"param\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"parameter statement not allowed here\");\r\n        stmt.type = A_PARAMETER;\r\n        stmt.u.par = mpl_internal_parameter_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"var\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"variable statement not allowed here\");\r\n        stmt.type = A_VARIABLE;\r\n        stmt.u.var_ = mpl_internal_variable_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"subject\") ||\r\n        mpl_internal_is_keyword(mpl, \"subj\") ||\r\n        mpl.token == T_SPTP)\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"constraint statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_constraint_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"minimize\") ||\r\n        mpl_internal_is_keyword(mpl, \"maximize\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"objective statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_objective_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"table\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"table statement not allowed here\");\r\n        stmt.type = A_TABLE;\r\n        stmt.u.tab = mpl_internal_table_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"solve\"))\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"solve statement not allowed here\");\r\n        stmt.type = A_SOLVE;\r\n        stmt.u.slv = mpl_internal_solve_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"check\"))\r\n    {  stmt.type = A_CHECK;\r\n        stmt.u.chk = mpl_internal_check_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"display\"))\r\n    {  stmt.type = A_DISPLAY;\r\n        stmt.u.dpy = mpl_internal_display_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"printf\"))\r\n    {  stmt.type = A_PRINTF;\r\n        stmt.u.prt = mpl_internal_printf_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_keyword(mpl, \"for\"))\r\n    {  stmt.type = A_FOR;\r\n        stmt.u.fur = mpl_internal_for_statement(mpl);\r\n    }\r\n    else if (mpl.token == T_NAME)\r\n    {  if (spec)\r\n        mpl_internal_error(mpl, \"constraint statement not allowed here\");\r\n        stmt.type = A_CONSTRAINT;\r\n        stmt.u.con = mpl_internal_constraint_statement(mpl);\r\n    }\r\n    else if (mpl_internal_is_reserved(mpl))\r\n        mpl_internal_error(mpl, \"invalid use of reserved keyword \" + mpl.image);\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in model section\");\r\n    return stmt;\r\n}\r\n\r\nfunction mpl_internal_model_section(mpl){\r\n    var stmt, last_stmt;\r\n    xassert(mpl.model == null);\r\n    last_stmt = null;\r\n    while (!(mpl.token == T_EOF || mpl_internal_is_keyword(mpl, \"data\") ||\r\n        mpl_internal_is_keyword(mpl, \"end\")))\r\n    {  /* parse statement */\r\n        stmt = mpl_internal_simple_statement(mpl, 0);\r\n        /* and append it to the end of the statement list */\r\n        if (last_stmt == null)\r\n            mpl.model = stmt;\r\n        else\r\n            last_stmt.next = stmt;\r\n        last_stmt = stmt;\r\n    }\r\n}\r\n\r\n/* glpmpl02.c */\r\n\r\n/**********************************************************************/\r\n/* * *                  PROCESSING DATA SECTION                   * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_expand_slice\r\n    (   mpl,\r\n        slice,           /* destroyed */\r\n        sym             /* destroyed */\r\n        ){\r\n    var temp;\r\n    /* create a new component */\r\n    var tail = {};\r\n    tail.sym = sym;\r\n    tail.next = null;\r\n    /* and append it to the component list */\r\n    if (slice == null)\r\n        slice = tail;\r\n    else\r\n    {  for (temp = slice; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_slice_dimen\r\n    (   mpl,\r\n        slice            /* not changed */\r\n        ){\r\n    var temp;\r\n\r\n    var dim = 0;\r\n    for (temp = slice; temp != null; temp = temp.next) dim++;\r\n    return dim;\r\n}\r\n\r\nfunction mpl_internal_slice_arity\r\n    (   mpl,\r\n        slice            /* not changed */\r\n        ){\r\n    var temp;\r\n\r\n    var arity = 0;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n        if (temp.sym == null) arity++;\r\n    return arity;\r\n}\r\n\r\nfunction mpl_internal_fake_slice(mpl, dim){\r\n    var slice = null;\r\n    while (dim-- > 0) slice = mpl_internal_expand_slice(mpl, slice, null);\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_delete_slice\r\n    (   mpl,\r\n        slice            /* destroyed */\r\n        ){\r\n    var temp;\r\n    while (slice != null)\r\n    {  temp = slice;\r\n        slice = temp.next;\r\n    }\r\n}\r\n\r\nfunction mpl_internal_is_number(mpl){\r\n    return mpl.token == T_NUMBER;\r\n}\r\n\r\nfunction mpl_internal_is_symbol(mpl){\r\n    return mpl.token == T_NUMBER ||\r\n        mpl.token == T_SYMBOL ||\r\n        mpl.token == T_STRING;\r\n}\r\n\r\nfunction mpl_internal_is_literal(mpl, literal){\r\n    return mpl_internal_is_symbol(mpl) && mpl.image == literal;\r\n}\r\n\r\nfunction mpl_internal_read_number(mpl){\r\n    xassert(mpl_internal_is_number(mpl));\r\n    var num = mpl.value;\r\n    mpl_internal_get_token(mpl /* <number> */);\r\n    return num;\r\n}\r\n\r\nfunction mpl_internal_read_symbol(mpl){\r\n    var sym;\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    if (mpl_internal_is_number(mpl))\r\n        sym = mpl_internal_create_symbol_num(mpl, mpl.value);\r\n    else\r\n        sym = mpl_internal_create_symbol_str(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbol> */);\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_read_slice(mpl, name, dim){\r\n    var slice;\r\n    var close;\r\n    xassert(name != null);\r\n    switch (mpl.token)\r\n    {  case T_LBRACKET:\r\n        close = T_RBRACKET;\r\n        break;\r\n        case T_LEFT:\r\n            xassert(dim > 0);\r\n            close = T_RIGHT;\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    if (dim == 0)\r\n        mpl_internal_error(mpl, name + \" cannot be subscripted\");\r\n    mpl_internal_get_token(mpl /* ( | [ */);\r\n    /* read slice components */\r\n    slice = null;\r\n    for (;;)\r\n    {  /* the current token must be a symbol or asterisk */\r\n        if (mpl_internal_is_symbol(mpl))\r\n            slice = mpl_internal_expand_slice(mpl, slice, mpl_internal_read_symbol(mpl));\r\n        else if (mpl.token == T_ASTERISK)\r\n        {  slice = mpl_internal_expand_slice(mpl, slice, null);\r\n            mpl_internal_get_token(mpl /* * */);\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"number, symbol, or asterisk missing where expected\");\r\n        /* check a token that follows the symbol */\r\n        if (mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n        else if (mpl.token == close)\r\n            break;\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in slice\");\r\n    }\r\n    /* number of slice components must be the same as the appropriate\r\n     dimension */\r\n    if (mpl_internal_slice_dimen(mpl, slice) != dim)\r\n    {  switch (close)\r\n    {  case T_RBRACKET:\r\n            mpl_internal_error(mpl, name + \" must have \" + dim +\r\n                \" subscript\" + (dim == 1 ? \"\" : \"s\") + \", not \" + mpl_internal_slice_dimen(mpl, slice));\r\n            break;\r\n        case T_RIGHT:\r\n            mpl_internal_error(mpl, name + \" has dimension \" + dim + \", not \" + mpl_internal_slice_dimen(mpl, slice));\r\n            break;\r\n        default:\r\n            xassert(close != close);\r\n    }\r\n    }\r\n    mpl_internal_get_token(mpl /* ) | ] */);\r\n    return slice;\r\n}\r\n\r\nfunction mpl_internal_select_set\r\n    (   mpl,\r\n        name              /* not changed */\r\n        ){\r\n    var set;\r\n    var node;\r\n    xassert(name != null);\r\n    node = mpl.tree[name];\r\n    if (node == null || node.type != A_SET)\r\n        mpl_internal_error(mpl, name + \" not a set\");\r\n    set = node.link;\r\n    if (set.assign != null || set.gadget != null)\r\n        mpl_internal_error(mpl, name + \" needs no data\");\r\n    set.data = 1;\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_simple_format\r\n    (   mpl,\r\n        set,               /* not changed */\r\n        memb,           /* modified */\r\n        slice            /* not changed */\r\n        ){\r\n    var tuple;\r\n    var temp;\r\n    var sym, with_ = null;\r\n    xassert(set != null);\r\n    xassert(memb != null);\r\n    xassert(slice != null);\r\n    xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(memb.value.set.dim == set.dimen);\r\n    if (mpl_internal_slice_arity(mpl, slice) > 0) xassert(mpl_internal_is_symbol(mpl));\r\n    /* read symbols and construct complete n-tuple */\r\n    tuple = null;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n    {  if (temp.sym == null)\r\n    {  /* substitution is needed; read symbol */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n        {  var lack = mpl_internal_slice_arity(mpl, temp);\r\n            /* with cannot be null due to assertion above */\r\n            xassert(with_ != null);\r\n            if (lack == 1)\r\n                mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n            else\r\n                mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n        }\r\n        sym = mpl_internal_read_symbol(mpl);\r\n        if (with_ == null) with_ = sym;\r\n    }\r\n    else\r\n    {  /* copy symbol from the slice */\r\n        sym = mpl_internal_copy_symbol(mpl, temp.sym);\r\n    }\r\n        /* append the symbol to the n-tuple */\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, sym);\r\n        /* skip optional comma *between* <symbols> */\r\n        if (temp.next != null && mpl.token == T_COMMA)\r\n            mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    /* add constructed n-tuple to elemental set */\r\n    mpl_internal_check_then_add(mpl, memb.value.set, tuple);\r\n}\r\n\r\nfunction mpl_internal_matrix_format\r\n    (   mpl,\r\n        set,               /* not changed */\r\n        memb,           /* modified */\r\n        slice,           /* not changed */\r\n        tr\r\n        ){\r\n    var list, col, temp;\r\n    var tuple;\r\n    var row;\r\n    xassert(set != null);\r\n    xassert(memb != null);\r\n    xassert(slice != null);\r\n    xassert(set.dimen == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(memb.value.set.dim == set.dimen);\r\n    xassert(mpl_internal_slice_arity(mpl, slice) == 2);\r\n    /* read the matrix heading that contains column symbols (there\r\n     may be no columns at all) */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* read column symbol and append it to the column list */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number, symbol, or := missing where expected\");\r\n        list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));\r\n    }\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* read zero or more rows that contain matrix data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read row symbol (if the matrix has no columns, row symbols\r\n     are just ignored) */\r\n        row = mpl_internal_read_symbol(mpl);\r\n        /* read the matrix row accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  var which = 0;\r\n            /* check indicator */\r\n            if (mpl_internal_is_literal(mpl, \"+\")){\r\n\r\n            }\r\n            else if (mpl_internal_is_literal(mpl, \"-\"))\r\n            {  mpl_internal_get_token(mpl /* - */);\r\n                continue;\r\n            }\r\n            else\r\n            {  var lack = mpl_internal_slice_dimen(mpl, col);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n            }\r\n            /* construct complete n-tuple */\r\n            tuple = null;\r\n            for (temp = slice; temp != null; temp = temp.next)\r\n            {  if (temp.sym == null)\r\n            {  /* substitution is needed */\r\n                switch (++which)\r\n                {  case 1:\r\n                    /* substitute in the first null position */\r\n                    tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                        mpl_internal_copy_symbol(mpl, tr ? col.sym : row));\r\n                    break;\r\n                    case 2:\r\n                        /* substitute in the second null position */\r\n                        tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                            mpl_internal_copy_symbol(mpl, tr ? row : col.sym));\r\n                        break;\r\n                    default:\r\n                        xassert(which != which);\r\n                }\r\n            }\r\n            else\r\n            {  /* copy symbol from the slice */\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                    temp.sym));\r\n            }\r\n            }\r\n            xassert(which == 2);\r\n            /* add constructed n-tuple to elemental set */\r\n            mpl_internal_check_then_add(mpl, memb.value.set, tuple);\r\n            mpl_internal_get_token(mpl /* + */);\r\n        }\r\n    }\r\n    /* delete the column list */\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_set_data(mpl){\r\n    var set;\r\n    var tuple;\r\n    var memb;\r\n    var slice;\r\n    var tr = 0;\r\n\r\n    function err1(){mpl_internal_error(mpl, \"slice currently used must specify 2 asterisks, not \" + mpl_internal_slice_arity(mpl, slice))}\r\n    function err2(){mpl_internal_error(mpl, \"transpose indicator (tr) incomplete\")}\r\n    function left(){\r\n        /* left parenthesis begins the \"transpose\" indicator, which\r\n         is followed by data in the matrix format */\r\n        mpl_internal_get_token(mpl /* ( */);\r\n        if (!mpl_internal_is_literal(mpl, \"tr\"))\r\n            err2();\r\n        if (mpl_internal_slice_arity(mpl, slice) != 2) err1();\r\n        mpl_internal_get_token(mpl /* tr */);\r\n        if (mpl.token != T_RIGHT) err2();\r\n        mpl_internal_get_token(mpl /* ) */);\r\n        /* in this case the colon is optional */\r\n        if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n        /* set the \"transpose\" indicator */\r\n        tr = 1;\r\n        /* read elemental set data in the matrix format */\r\n        mpl_internal_matrix_format(mpl, set, memb, slice, tr);\r\n    }\r\n\r\n    xassert(mpl_internal_is_literal(mpl, \"set\"));\r\n    mpl_internal_get_token(mpl /* set */);\r\n    /* symbolic name of set must follows the keyword 'set' */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n        mpl_internal_error(mpl, \"set name missing where expected\");\r\n    /* select the set to saturate it with data */\r\n    set = mpl_internal_select_set(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbolic name> */);\r\n    /* read optional subscript list, which identifies member of the\r\n     set to be read */\r\n    tuple = null;\r\n    if (mpl.token == T_LBRACKET)\r\n    {  /* subscript list is specified */\r\n        if (set.dim == 0)\r\n            mpl_internal_error(mpl, set.name + \" cannot be subscripted\");\r\n        mpl_internal_get_token(mpl /* [ */);\r\n        /* read symbols and construct subscript list */\r\n        for (;;)\r\n        {  if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number or symbol missing where expected\");\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));\r\n            if (mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n            else if (mpl.token == T_RBRACKET)\r\n                break;\r\n            else\r\n                mpl_internal_error(mpl, \"syntax error in subscript list\");\r\n        }\r\n        if (set.dim != mpl_internal_tuple_dimen(mpl, tuple))\r\n            mpl_internal_error(mpl, set.name + \" must have \" + set.dim + \" subscript\" + (set.dim == 1 ? \"\" : \"s\")\r\n                + \" rather than \" + mpl_internal_tuple_dimen(mpl, tuple));\r\n        mpl_internal_get_token(mpl /* ] */);\r\n    }\r\n    else\r\n    {  /* subscript list is not specified */\r\n        if (set.dim != 0)\r\n            mpl_internal_error(mpl, set.name + \" must be subscripted\");\r\n    }\r\n    /* there must be no member with the same subscript list */\r\n    if (mpl_internal_find_member(mpl, set.array, tuple) != null)\r\n        mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" already defined\");\r\n    /* add new member to the set and assign it empty elemental set */\r\n    memb = mpl_internal_add_member(mpl, set.array, tuple);\r\n    memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);\r\n    /* create an initial fake slice of all asterisks */\r\n    slice = mpl_internal_fake_slice(mpl, set.dimen);\r\n    /* read zero or more data assignments */\r\n    for (;;)\r\n    {  /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* process assignment element */\r\n        if (mpl.token == T_ASSIGN)\r\n        {  /* assignment ligature is non-significant element */\r\n            mpl_internal_get_token(mpl /* := */);\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* left parenthesis begins either new slice or \"transpose\"\r\n         indicator */\r\n            var is_tr;\r\n            mpl_internal_get_token(mpl /* ( */);\r\n            is_tr = mpl_internal_is_literal(mpl, \"tr\");\r\n            mpl_internal_unget_token(mpl /* ( */);\r\n            if (is_tr) {\r\n                left();\r\n            } else {\r\n                /* delete the current slice and read new one */\r\n                mpl_internal_delete_slice(mpl, slice);\r\n                slice = mpl_internal_read_slice(mpl, set.name, set.dimen);\r\n                /* each new slice resets the \"transpose\" indicator */\r\n                tr = 0;\r\n                /* if the new slice is 0-ary, formally there is one 0-tuple\r\n                 (in the simple format) that follows it */\r\n                if (mpl_internal_slice_arity(mpl, slice) == 0)\r\n                    mpl_internal_simple_format(mpl, set, memb, slice);\r\n            }\r\n        }\r\n        else if (mpl_internal_is_symbol(mpl))\r\n        {  /* number or symbol begins data in the simple format */\r\n            mpl_internal_simple_format(mpl, set, memb, slice);\r\n        }\r\n        else if (mpl.token == T_COLON)\r\n        {  /* colon begins data in the matrix format */\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2)\r\n                err1();\r\n            mpl_internal_get_token(mpl /* : */);\r\n            /* read elemental set data in the matrix format */\r\n            mpl_internal_matrix_format(mpl, set, memb, slice, tr);\r\n        }\r\n        else if (mpl.token == T_LEFT){\r\n            left();\r\n        }\r\n        else if (mpl.token == T_SEMICOLON)\r\n        {  /* semicolon terminates the data block */\r\n            mpl_internal_get_token(mpl /* ; */);\r\n            break;\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in set data block\");\r\n    }\r\n    /* delete the current slice */\r\n    mpl_internal_delete_slice(mpl, slice);\r\n}\r\n\r\nfunction mpl_internal_select_parameter(\r\n    mpl,\r\n    name              /* not changed */\r\n    ){\r\n    var par;\r\n    var node;\r\n    xassert(name != null);\r\n    node = mpl.tree[name];\r\n    if (node == null || node.type != A_PARAMETER)\r\n        mpl_internal_error(mpl, name + \" not a parameter\");\r\n    par = node.link;\r\n    if (par.assign != null)\r\n        mpl_internal_error(mpl, name + \" needs no data\");\r\n    if (par.data)\r\n        mpl_internal_error(mpl, name + \" already provided with data\");\r\n    par.data = 1;\r\n    return par;\r\n}\r\n\r\nfunction mpl_internal_set_default(\r\n    mpl,\r\n    par,         /* not changed */\r\n    altval          /* destroyed */\r\n    ){\r\n    xassert(par != null);\r\n    xassert(altval != null);\r\n    if (par.option != null)\r\n        mpl_internal_error(mpl, \"default value for \" + par.name + \" already specified in model section\");\r\n    xassert(par.defval == null);\r\n    par.defval = altval;\r\n}\r\n\r\nfunction mpl_internal_read_value\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        tuple            /* destroyed */\r\n        ){\r\n    var memb;\r\n    xassert(par != null);\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    /* there must be no member with the same n-tuple */\r\n    if (mpl_internal_find_member(mpl, par.array, tuple) != null)\r\n        mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" already defined\");\r\n    /* create new parameter member with given n-tuple */\r\n    memb = mpl_internal_add_member(mpl, par.array, tuple);\r\n    /* read value and assigns it to the new parameter member */\r\n    switch (par.type)\r\n    {  case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            if (!mpl_internal_is_number(mpl))\r\n                mpl_internal_error(mpl, par.name + \" requires numeric data\");\r\n            memb.value.num = mpl_internal_read_number(mpl);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            memb.value.sym = mpl_internal_read_symbol(mpl);\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_plain_format\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        slice            /* not changed */\r\n        )\r\n{\r\n    var tuple;\r\n    var temp;\r\n    var sym, with_ = null;\r\n    xassert(par != null);\r\n    xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(mpl_internal_is_symbol(mpl));\r\n    /* read symbols and construct complete subscript list */\r\n    tuple = null;\r\n    for (temp = slice; temp != null; temp = temp.next)\r\n    {  if (temp.sym == null)\r\n    {  /* substitution is needed; read symbol */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n        {   var lack = mpl_internal_slice_arity(mpl, temp) + 1;\r\n            xassert(with_ != null);\r\n            xassert(lack > 1);\r\n            mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n        }\r\n        sym = mpl_internal_read_symbol(mpl);\r\n        if (with_ == null) with_ = sym;\r\n    }\r\n    else\r\n    {  /* copy symbol from the slice */\r\n        sym = mpl_internal_copy_symbol(mpl, temp.sym);\r\n    }\r\n        /* append the symbol to the subscript list */\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, sym);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    /* read value and assign it to new parameter member */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n    {  xassert(with_ != null);\r\n        mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, with_));\r\n    }\r\n    mpl_internal_read_value(mpl, par, tuple);\r\n}\r\n\r\nfunction mpl_internal_tabular_format\r\n    (   mpl,\r\n        par,         /* not changed */\r\n        slice,           /* not changed */\r\n        tr\r\n        ){\r\n    var list, col, temp;\r\n    var tuple;\r\n    var row;\r\n    xassert(par != null);\r\n    xassert(par.dim == mpl_internal_slice_dimen(mpl, slice));\r\n    xassert(mpl_internal_slice_arity(mpl, slice) == 2);\r\n    /* read the table heading that contains column symbols (the table\r\n     may have no columns) */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* read column symbol and append it to the column list */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"number, symbol, or := missing where expected\");\r\n        list = mpl_internal_expand_slice(mpl, list, mpl_internal_read_symbol(mpl));\r\n    }\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* read zero or more rows that contain tabular data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read row symbol (if the table has no columns, these symbols\r\n     are just ignored) */\r\n        row = mpl_internal_read_symbol(mpl);\r\n        /* read values accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  var which = 0;\r\n            /* if the token is single point, no value is provided */\r\n            if (mpl_internal_is_literal(mpl, \".\"))\r\n            {  mpl_internal_get_token(mpl /* . */);\r\n                continue;\r\n            }\r\n            /* construct complete subscript list */\r\n            tuple = null;\r\n            for (temp = slice; temp != null; temp = temp.next)\r\n            {  if (temp.sym == null)\r\n            {  /* substitution is needed */\r\n                switch (++which)\r\n                {  case 1:\r\n                    /* substitute in the first null position */\r\n                    tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                        mpl_internal_copy_symbol(mpl, tr ? col.sym : row));\r\n                    break;\r\n                    case 2:\r\n                        /* substitute in the second null position */\r\n                        tuple = mpl_internal_expand_tuple(mpl, tuple,\r\n                            mpl_internal_copy_symbol(mpl, tr ? row : col.sym));\r\n                        break;\r\n                    default:\r\n                        xassert(which != which);\r\n                }\r\n            }\r\n            else\r\n            {  /* copy symbol from the slice */\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                    temp.sym));\r\n            }\r\n            }\r\n            xassert(which == 2);\r\n            /* read value and assign it to new parameter member */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {  var lack = mpl_internal_slice_dimen(mpl, col);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, row));\r\n            }\r\n            mpl_internal_read_value(mpl, par, tuple);\r\n        }\r\n    }\r\n    /* delete the column list */\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_tabbing_format\r\n    (   mpl,\r\n        altval          /* not changed */\r\n        ){\r\n    var set = null;\r\n    var par;\r\n    var list, col;\r\n    var tuple;\r\n    var next_token, j, dim = 0;\r\n    var last_name = null;\r\n    /* read the optional <prefix> */\r\n    if (mpl_internal_is_symbol(mpl))\r\n    {  mpl_internal_get_token(mpl /* <symbol> */);\r\n        next_token = mpl.token;\r\n        mpl_internal_unget_token(mpl /* <symbol> */);\r\n        if (next_token == T_COLON)\r\n        {  /* select the set to saturate it with data */\r\n            set = mpl_internal_select_set(mpl, mpl.image);\r\n            /* the set must be simple (i.e. not set of sets) */\r\n            if (set.dim != 0)\r\n                mpl_internal_error(mpl, set.name + \" must be a simple set\");\r\n            /* and must not be defined yet */\r\n            if (set.array.head != null)\r\n                mpl_internal_error(mpl, set.name + \" already defined\");\r\n            /* add new (the only) member to the set and assign it empty\r\n             elemental set */\r\n            mpl_internal_add_member(mpl, set.array, null).value.set =\r\n                mpl_internal_create_elemset(mpl, set.dimen);\r\n            last_name = set.name; dim = set.dimen;\r\n            mpl_internal_get_token(mpl /* <symbol> */);\r\n            xassert(mpl.token == T_COLON);\r\n            mpl_internal_get_token(mpl /* : */);\r\n        }\r\n    }\r\n    /* read the table heading that contains parameter names */\r\n    list = null;\r\n    while (mpl.token != T_ASSIGN)\r\n    {  /* there must be symbolic name of parameter */\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"parameter name or := missing where expected\");\r\n        /* select the parameter to saturate it with data */\r\n        par = mpl_internal_select_parameter(mpl, mpl.image);\r\n        /* the parameter must be subscripted */\r\n        if (par.dim == 0)\r\n            mpl_internal_error(mpl, mpl.image + \" not a subscripted parameter\");\r\n        /* the set (if specified) and all the parameters in the data\r\n         block must have identical dimension */\r\n        if (dim != 0 && par.dim != dim)\r\n        {  xassert(last_name != null);\r\n            mpl_internal_error(mpl, last_name + \" has dimension \" + dim + \" while \" + par.name + \" has dimension \" + par.dim);\r\n        }\r\n        /* set default value for the parameter (if specified) */\r\n        if (altval != null)\r\n            mpl_internal_set_default(mpl, par, mpl_internal_copy_symbol(mpl, altval));\r\n        /* append the parameter to the column list */\r\n        list = mpl_internal_expand_slice(mpl, list, par);\r\n        last_name = par.name; dim = par.dim;\r\n        mpl_internal_get_token(mpl /* <symbol> */);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    }\r\n    if (mpl_internal_slice_dimen(mpl, list) == 0)\r\n        mpl_internal_error(mpl, \"at least one parameter name required\");\r\n    mpl_internal_get_token(mpl /* := */);\r\n    /* skip optional comma */\r\n    if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n    /* read rows that contain tabbing data */\r\n    while (mpl_internal_is_symbol(mpl))\r\n    {  /* read subscript list */\r\n        var lack;\r\n        tuple = null;\r\n        for (j = 1; j <= dim; j++)\r\n        {  /* read j-th subscript */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {   lack = mpl_internal_slice_dimen(mpl, list) + dim - j + 1;\r\n                xassert(tuple != null);\r\n                xassert(lack > 1);\r\n                mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n            }\r\n            /* read and append j-th subscript to the n-tuple */\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_read_symbol(mpl));\r\n            /* skip optional comma *between* <symbols> */\r\n            if (j < dim && mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n        }\r\n        /* if the set is specified, add to it new n-tuple, which is a\r\n         copy of the subscript list just read */\r\n        if (set != null)\r\n            mpl_internal_check_then_add(mpl, set.array.head.value.set, mpl_internal_copy_tuple(mpl, tuple));\r\n        /* skip optional comma between <symbol> and <value> */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* read values accordingly to the column list */\r\n        for (col = list; col != null; col = col.next)\r\n        {  /* if the token is single point, no value is provided */\r\n            if (mpl_internal_is_literal(mpl, \".\"))\r\n            {  mpl_internal_get_token(mpl /* . */);\r\n                continue;\r\n            }\r\n            /* read value and assign it to new parameter member */\r\n            if (!mpl_internal_is_symbol(mpl))\r\n            {   lack = mpl_internal_slice_dimen(mpl, col);\r\n                xassert(tuple != null);\r\n                if (lack == 1)\r\n                    mpl_internal_error(mpl, \"one item missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n                else\r\n                    mpl_internal_error(mpl, lack + \" items missing in data group beginning with \" + mpl_internal_format_symbol(mpl, tuple.sym));\r\n            }\r\n            mpl_internal_read_value(mpl, col.sym, mpl_internal_copy_tuple(mpl, tuple));\r\n            /* skip optional comma preceding the next value */\r\n            if (col.next != null && mpl.token == T_COMMA)\r\n                mpl_internal_get_token(mpl /* , */);\r\n        }\r\n        /* skip optional comma (only if there is next data group) */\r\n        if (mpl.token == T_COMMA)\r\n        {  mpl_internal_get_token(mpl /* , */);\r\n            if (!mpl_internal_is_symbol(mpl)) mpl_internal_unget_token(mpl /* , */);\r\n        }\r\n    }\r\n    /* delete the column list (it contains parameters, not symbols,\r\n     so nullify it before) */\r\n    for (col = list; col != null; col = col.next) col.sym = null;\r\n    mpl_internal_delete_slice(mpl, list);\r\n}\r\n\r\nfunction mpl_internal_parameter_data(mpl){\r\n    var par;\r\n    var altval = null;\r\n    var slice;\r\n    var tr = 0;\r\n    xassert(mpl_internal_is_literal(mpl, \"param\"));\r\n    mpl_internal_get_token(mpl /* param */);\r\n    /* read optional default value */\r\n    if (mpl_internal_is_literal(mpl, \"default\"))\r\n    {  mpl_internal_get_token(mpl /* default */);\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"default value missing where expected\");\r\n        altval = mpl_internal_read_symbol(mpl);\r\n        /* if the default value follows the keyword 'param', the next\r\n         token must be only the colon */\r\n        if (mpl.token != T_COLON)\r\n            mpl_internal_error(mpl, \"colon missing where expected\");\r\n    }\r\n    /* being used after the keyword 'param' or the optional default\r\n     value the colon begins data in the tabbing format */\r\n    if (mpl.token == T_COLON)\r\n    {  mpl_internal_get_token(mpl /* : */);\r\n        /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* read parameter data in the tabbing format */\r\n        mpl_internal_tabbing_format(mpl, altval);\r\n        /* the next token must be only semicolon */\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"symbol, number, or semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n        return;\r\n    }\r\n    /* in other cases there must be symbolic name of parameter, which\r\n     follows the keyword 'param' */\r\n    if (!mpl_internal_is_symbol(mpl))\r\n        mpl_internal_error(mpl, \"parameter name missing where expected\");\r\n    /* select the parameter to saturate it with data */\r\n    par = mpl_internal_select_parameter(mpl, mpl.image);\r\n    mpl_internal_get_token(mpl /* <symbol> */);\r\n    /* read optional default value */\r\n    if (mpl_internal_is_literal(mpl, \"default\"))\r\n    {  mpl_internal_get_token(mpl /* default */);\r\n        if (!mpl_internal_is_symbol(mpl))\r\n            mpl_internal_error(mpl, \"default value missing where expected\");\r\n        altval = mpl_internal_read_symbol(mpl);\r\n        /* set default value for the parameter */\r\n        mpl_internal_set_default(mpl, par, altval);\r\n    }\r\n    /* create initial fake slice of all asterisks */\r\n    slice = mpl_internal_fake_slice(mpl, par.dim);\r\n    /* read zero or more data assignments */\r\n\r\n    function err1(){mpl_internal_error(mpl, par.name + \" not a subscripted parameter\")}\r\n    function err2(){mpl_internal_error(mpl, \"slice currently used must specify 2 asterisks, not \" + mpl_internal_slice_arity(mpl, slice))}\r\n    function err3(){mpl_internal_error(mpl, \"transpose indicator (tr) incomplete\")}\r\n\r\n    for (;;)\r\n    {  /* skip optional comma */\r\n        if (mpl.token == T_COMMA) mpl_internal_get_token(mpl /* , */);\r\n        /* process current assignment */\r\n        if (mpl.token == T_ASSIGN)\r\n        {  /* assignment ligature is non-significant element */\r\n            mpl_internal_get_token(mpl /* := */);\r\n        }\r\n        else if (mpl.token == T_LBRACKET)\r\n        {  /* left bracket begins new slice; delete the current slice\r\n         and read new one */\r\n            mpl_internal_delete_slice(mpl, slice);\r\n            slice = mpl_internal_read_slice(mpl, par.name, par.dim);\r\n            /* each new slice resets the \"transpose\" indicator */\r\n            tr = 0;\r\n        }\r\n        else if (mpl_internal_is_symbol(mpl))\r\n        {  /* number or symbol begins data in the plain format */\r\n            mpl_internal_plain_format(mpl, par, slice);\r\n        }\r\n        else if (mpl.token == T_COLON)\r\n        {  /* colon begins data in the tabular format */\r\n            if (par.dim == 0)\r\n                err1();\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2)\r\n                err2();\r\n            mpl_internal_get_token(mpl /* : */);\r\n            /* read parameter data in the tabular format */\r\n            mpl_internal_tabular_format(mpl, par, slice, tr);\r\n        }\r\n        else if (mpl.token == T_LEFT)\r\n        {  /* left parenthesis begins the \"transpose\" indicator, which\r\n         is followed by data in the tabular format */\r\n            mpl_internal_get_token(mpl /* ( */);\r\n            if (!mpl_internal_is_literal(mpl, \"tr\"))\r\n                err3();\r\n            if (par.dim == 0) err1();\r\n            if (mpl_internal_slice_arity(mpl, slice) != 2) err2();\r\n            mpl_internal_get_token(mpl /* tr */);\r\n            if (mpl.token != T_RIGHT) err3();\r\n            mpl_internal_get_token(mpl /* ) */);\r\n            /* in this case the colon is optional */\r\n            if (mpl.token == T_COLON) mpl_internal_get_token(mpl /* : */);\r\n            /* set the \"transpose\" indicator */\r\n            tr = 1;\r\n            /* read parameter data in the tabular format */\r\n            mpl_internal_tabular_format(mpl, par, slice, tr);\r\n        }\r\n        else if (mpl.token == T_SEMICOLON)\r\n        {  /* semicolon terminates the data block */\r\n            mpl_internal_get_token(mpl /* ; */);\r\n            break;\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"syntax error in parameter data block\");\r\n    }\r\n    /* delete the current slice */\r\n    mpl_internal_delete_slice(mpl, slice);\r\n}\r\n\r\nfunction mpl_internal_data_section(mpl){\r\n    while (!(mpl.token == T_EOF || mpl_internal_is_literal(mpl, \"end\")))\r\n    {   if (mpl_internal_is_literal(mpl, \"set\"))\r\n        mpl_internal_set_data(mpl);\r\n    else if (mpl_internal_is_literal(mpl, \"param\"))\r\n        mpl_internal_parameter_data(mpl);\r\n    else\r\n        mpl_internal_error(mpl, \"syntax error in data section\");\r\n    }\r\n}\r\n\r\n/* glpmpl03.c */\r\n\r\n/**********************************************************************/\r\n/* * *                   FLOATING-POINT NUMBERS                   * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_fp_add(mpl, x, y){\r\n    if (x > 0.0 && y > 0.0 && x > + 0.999 * DBL_MAX - y ||\r\n        x < 0.0 && y < 0.0 && x < - 0.999 * DBL_MAX - y)\r\n        mpl_internal_error(mpl, x + \" + \" + y + \"; floating-point overflow\");\r\n    return x + y;\r\n}\r\n\r\nfunction mpl_internal_fp_sub(mpl, x, y){\r\n    if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y ||\r\n        x < 0.0 && y > 0.0 && x < - 0.999 * DBL_MAX + y)\r\n        mpl_internal_error(mpl, x + \" - \" + y + \"; floating-point overflow\");\r\n    return x - y;\r\n}\r\n\r\nfunction mpl_internal_fp_less(mpl, x, y){\r\n    if (x < y) return 0.0;\r\n    if (x > 0.0 && y < 0.0 && x > + 0.999 * DBL_MAX + y)\r\n        mpl_internal_error(mpl, x+ \" less \" + y + \"; floating-point overflow\");\r\n    return x - y;\r\n}\r\n\r\nfunction mpl_internal_fp_mul(mpl, x, y){\r\n    if (Math.abs(y) > 1.0 && Math.abs(x) > (0.999 * DBL_MAX) / Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" * \" + y + \"; floating-point overflow\");\r\n    return x * y;\r\n}\r\n\r\nfunction mpl_internal_fp_div(mpl, x, y){\r\n    if (Math.abs(y) < DBL_MIN)\r\n        mpl_internal_error(mpl, x + \" / \" + y + \"; floating-point zero divide\");\r\n    if (Math.abs(y) < 1.0 && Math.abs(x) > (0.999 * DBL_MAX) * Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" / \" + y + \"; floating-point overflow\");\r\n    return x / y;\r\n}\r\n\r\nfunction mpl_internal_fp_idiv(mpl, x, y){\r\n    if (Math.abs(y) < DBL_MIN)\r\n        mpl_internal_error(mpl, x + \" div \" + y + \"; floating-point zero divide\");\r\n    if (Math.abs(y) < 1.0 && Math.abs(x) > (0.999 * DBL_MAX) * Math.abs(y))\r\n        mpl_internal_error(mpl, x + \" div \" + y + \"; floating-point overflow\");\r\n    x /= y;\r\n    return x > 0.0 ? Math.floor(x) : x < 0.0 ? Math.ceil(x) : 0.0;\r\n}\r\n\r\nfunction mpl_internal_fp_mod(mpl, x, y)\r\n{\r\n    var r;\r\n\r\n    if (x == 0.0)\r\n        r = 0.0;\r\n    else if (y == 0.0)\r\n        r = x;\r\n    else\r\n    {  r = Math.abs(x) % Math.abs(y);\r\n        if (r != 0.0)\r\n        {  if (x < 0.0) r = - r;\r\n            if (x > 0.0 && y < 0.0 || x < 0.0 && y > 0.0) r += y;\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction mpl_internal_fp_power(mpl, x, y)\r\n{\r\n    var r;\r\n    if (x == 0.0 && y <= 0.0 || x < 0.0 && y != Math.floor(y))\r\n        mpl_internal_error(mpl, x + \" ** \" + y + \"; result undefined\");\r\n    if (x == 0.0) {\r\n        r = Math.pow(x, y);\r\n    } else {\r\n        if (Math.abs(x) > 1.0 && y > +1.0 &&\r\n            +Math.log(Math.abs(x)) > (0.999 * Math.log(DBL_MAX)) / y ||\r\n            Math.abs(x) < 1.0 && y < -1.0 &&\r\n                +Math.log(Math.abs(x)) < (0.999 * Math.log(DBL_MAX)) / y)\r\n            mpl_internal_error(mpl, x + \" ** \" + y + \"; floating-point overflow\");\r\n        if (Math.abs(x) > 1.0 && y < -1.0 &&\r\n            -Math.log(Math.abs(x)) < (0.999 * Math.log(DBL_MAX)) / y ||\r\n            Math.abs(x) < 1.0 && y > +1.0 &&\r\n                -Math.log(Math.abs(x)) > (0.999 * Math.log(DBL_MAX)) / y)\r\n            r = 0.0;\r\n        else\r\n            r = Math.pow(x, y);\r\n    }\r\n    return r;\r\n}\r\n\r\nfunction mpl_internal_fp_exp(mpl, x)\r\n{\r\n    if (x > 0.999 * Math.log(DBL_MAX))\r\n        mpl_internal_error(mpl, \"exp(\" + x + \"); floating-point overflow\");\r\n    return Math.exp(x);\r\n}\r\n\r\nfunction mpl_internal_fp_log(mpl, x)\r\n{     if (x <= 0.0)\r\n    mpl_internal_error(mpl, \"log(\" + x + \"); non-positive argument\");\r\n    return Math.log(x);\r\n}\r\n\r\nfunction mpl_internal_fp_log10(mpl, x)\r\n{\r\n    if (x <= 0.0)\r\n        mpl_internal_error(mpl, \"log10(\" + x + \"); non-positive argument\");\r\n    return Math.log(x) / Math.LN10;\r\n}\r\n\r\nfunction mpl_internal_fp_sqrt(mpl, x)\r\n{\r\n    if (x < 0.0)\r\n        mpl_internal_error(mpl, \"sqrt(\" + x + \"); negative argument\");\r\n    return Math.sqrt(x);\r\n}\r\n\r\nfunction mpl_internal_fp_sin(mpl, x)\r\n{\r\n    if (!(-1e6 <= x && x <= +1e6))\r\n        mpl_internal_error(mpl, \"sin(\" + x + \"); argument too large\");\r\n    return Math.sin(x);\r\n}\r\n\r\nfunction mpl_internal_fp_cos(mpl, x)\r\n{\r\n    if (!(-1e6 <= x && x <= +1e6))\r\n        mpl_internal_error(mpl, \"cos(\" + x + \"); argument too large\");\r\n    return Math.cos(x);\r\n}\r\n\r\nfunction mpl_internal_fp_atan(mpl, x)\r\n{\r\n\r\n    return Math.atan(x);\r\n}\r\n\r\nfunction mpl_internal_fp_atan2(mpl, y, x)\r\n{\r\n\r\n    return Math.atan2(y, x);\r\n}\r\n\r\nfunction mpl_internal_fp_round(mpl, x, n)\r\n{     var ten_to_n;\r\n    if (n != Math.floor(n))\r\n        mpl_internal_error(mpl, \"round(\" + x + \", \" + n + \"); non-integer second argument\");\r\n    if (n <= DBL_DIG + 2)\r\n    {  ten_to_n = Math.pow(10.0, n);\r\n        if (Math.abs(x) < (0.999 * DBL_MAX) / ten_to_n)\r\n        {  x = Math.floor(x * ten_to_n + 0.5);\r\n            if (x != 0.0) x /= ten_to_n;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_fp_trunc(mpl, x, n)\r\n{     var ten_to_n;\r\n    if (n != Math.floor(n))\r\n        mpl_internal_error(mpl, \"trunc(\" + x + \", \" + n + \"); non-integer second argument\");\r\n    if (n <= DBL_DIG + 2)\r\n    {  ten_to_n = Math.pow(10.0, n);\r\n        if (Math.abs(x) < (0.999 * DBL_MAX) / ten_to_n)\r\n        {  x = (x >= 0.0 ? Math.floor(x * ten_to_n) : Math.ceil(x * ten_to_n));\r\n            if (x != 0.0) x /= ten_to_n;\r\n        }\r\n    }\r\n    return x;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *              PSEUDO-RANDOM NUMBER GENERATORS               * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_fp_irand224(mpl)\r\n{\r\n    var two_to_the_24 = 0x1000000;\r\n    return rng_unif_rand(mpl.rand, two_to_the_24);\r\n}\r\n\r\nfunction mpl_internal_fp_uniform01(mpl)\r\n{\r\n    var two_to_the_31 = 0x80000000;\r\n    return rng_next_rand(mpl.rand) / two_to_the_31;\r\n}\r\n\r\nfunction mpl_internal_fp_uniform(mpl, a, b){\r\n    var x;\r\n    if (a >= b)\r\n        mpl_internal_error(mpl, \"Uniform(\" + a + \", \" + b + \"); invalid range\");\r\n    x = mpl_internal_fp_uniform01(mpl);\r\n    x = mpl_internal_fp_add(mpl, a * (1.0 - x), b * x);\r\n    return x;\r\n}\r\n\r\nfunction mpl_internal_fp_normal01(mpl){\r\n    var x, y, r2;\r\n    do\r\n    {  /* choose x, y in uniform square (-1,-1) to (+1,+1) */\r\n        x = -1.0 + 2.0 * mpl_internal_fp_uniform01(mpl);\r\n        y = -1.0 + 2.0 * mpl_internal_fp_uniform01(mpl);\r\n        /* see if it is in the unit circle */\r\n        r2 = x * x + y * y;\r\n    } while (r2 > 1.0 || r2 == 0.0);\r\n    /* Box-Muller transform */\r\n    return y * Math.sqrt(-2.0 * Math.log(r2) / r2);\r\n}\r\n\r\nfunction mpl_internal_fp_normal(mpl, mu, sigma){\r\n    return mpl_internal_fp_add(mpl, mu, mpl_internal_fp_mul(mpl, sigma, mpl_internal_fp_normal01(mpl)));\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                SEGMENTED CHARACTER STRINGS                 * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_compare_strings(mpl, str1, str2)\r\n{\r\n    if (str1 == str2)\r\n        return 0;\r\n    else if (str1 > str2)\r\n        return 1;\r\n    else\r\n        return -1;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                          SYMBOLS                           * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_symbol_num(mpl, num){\r\n    var sym = {};\r\n    sym.num = num;\r\n    sym.str = null;\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_create_symbol_str(mpl, str){\r\n    xassert(str != null);\r\n    var sym = {};\r\n    sym.num = 0.0;\r\n    sym.str = str;\r\n    return sym;\r\n}\r\n\r\nfunction mpl_internal_copy_symbol(mpl, sym){\r\n    xassert(sym != null);\r\n    var copy = {};\r\n    if (sym.str == null)\r\n    {  copy.num = sym.num;\r\n        copy.str = null;\r\n    }\r\n    else\r\n    {  copy.num = 0.0;\r\n        copy.str = sym.str;\r\n    }\r\n    return copy;\r\n}\r\n\r\nfunction mpl_internal_compare_symbols(mpl, sym1, sym2){\r\n    xassert(sym1 != null);\r\n    xassert(sym2 != null);\r\n    /* let all numeric quantities precede all symbolic quantities */\r\n    if (sym1.str == null && sym2.str == null)\r\n    {  if (sym1.num < sym2.num) return -1;\r\n        if (sym1.num > sym2.num) return +1;\r\n        return 0;\r\n    }\r\n    if (sym1.str == null) return -1;\r\n    if (sym2.str == null) return +1;\r\n    return mpl_internal_compare_strings(mpl, sym1.str, sym2.str);\r\n}\r\n\r\nfunction mpl_internal_format_symbol(mpl, sym){\r\n    xassert(sym != null);\r\n    var buf;\r\n    if (sym.str == null)\r\n        buf = String(sym.num);\r\n    else\r\n    {\r\n        var quoted, j, len;\r\n        var str = sym.str;\r\n        if (!(isalpha(str[0]) || str[0] == '_'))\r\n            quoted = true;\r\n        else\r\n        {   quoted = false;\r\n            for (j = 1; j < str.length; j++)\r\n            {   if (!(isalnum(str[j]) || strchr(\"+-._\", str[j]) >= 0))\r\n            {   quoted = true;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n\r\n        buf = ''; len = 0;\r\n        function safe_append(c){if (len < 255) {buf += c; len++}}\r\n\r\n        if (quoted) safe_append('\\'');\r\n        for (j = 0; j < str.length; j++)\r\n        {  if (quoted && str[j] == '\\'') safe_append('\\'');\r\n            safe_append(str[j]);\r\n        }\r\n        if (quoted) safe_append('\\'');\r\n        if (len == 255) buf = buf.slice(0, 252) + \"...\";\r\n    }\r\n    xassert(buf.length <= 255);\r\n    return buf;\r\n}\r\n\r\nfunction mpl_internal_concat_symbols\r\n    (   mpl,\r\n        sym1,           /* destroyed */\r\n        sym2            /* destroyed */\r\n        ){\r\n    var str1, str2;\r\n    //xassert(MAX_LENGTH >= DBL_DIG + DBL_DIG);\r\n\r\n    if (sym1.str == null)\r\n        str1 = String(sym1.num);\r\n    else\r\n        str1 = sym1.str;\r\n\r\n    if (sym2.str == null)\r\n        str2 = String(sym2.num);\r\n    else\r\n        str2 = sym2.str;\r\n/*\r\n    if (str1.length + str2.length > MAX_LENGTH)\r\n    {   var buf = mpl_internal_format_symbol(mpl, sym1);\r\n        xassert(buf.length < MAX_LENGTH);\r\n        mpl_internal_error(mpl, buf + \" & \" + mpl_internal_format_symbol(mpl, sym2) + \"; resultant symbol exceeds \" + MAX_LENGTH + \" characters\");\r\n    }\r\n*/\r\n    return mpl_internal_create_symbol_str(mpl, str1 + str2);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                          N-TUPLES                          * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_expand_tuple(mpl, tuple, sym){\r\n    var temp;\r\n    xassert(sym != null);\r\n    /* create a new component */\r\n    var tail = {};\r\n    tail.sym = sym;\r\n    tail.next = null;\r\n    /* and append it to the component list */\r\n    if (tuple == null)\r\n        tuple = tail;\r\n    else\r\n    {  for (temp = tuple; temp.next != null; temp = temp.next){}\r\n        temp.next = tail;\r\n    }\r\n    return tuple;\r\n}\r\n\r\nfunction mpl_internal_tuple_dimen(mpl, tuple){\r\n    var dim = 0;\r\n    for (var temp = tuple; temp != null; temp = temp.next) dim++;\r\n    return dim;\r\n}\r\n\r\nfunction mpl_internal_copy_tuple(mpl, tuple){\r\n    var head, tail;\r\n    if (tuple == null)\r\n        head = null;\r\n    else\r\n    {   head = tail = {};\r\n        for (; tuple != null; tuple = tuple.next)\r\n        {  xassert(tuple.sym != null);\r\n            tail.sym = mpl_internal_copy_symbol(mpl, tuple.sym);\r\n            if (tuple.next != null)\r\n                tail = tail.next = {};\r\n        }\r\n        tail.next = null;\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_compare_tuples(mpl, tuple1, tuple2){\r\n    var item1, item2;\r\n    var ret;\r\n    for (item1 = tuple1, item2 = tuple2; item1 != null;\r\n         item1 = item1.next, item2 = item2.next)\r\n    {  xassert(item2 != null);\r\n        xassert(item1.sym != null);\r\n        xassert(item2.sym != null);\r\n        ret = mpl_internal_compare_symbols(mpl, item1.sym, item2.sym);\r\n        if (ret != 0) return ret;\r\n    }\r\n    xassert(item2 == null);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_build_subtuple(mpl, tuple, dim){\r\n    var head = null;\r\n    for (var j = 1, temp = tuple; j <= dim; j++, temp = temp.next)\r\n    {  xassert(temp != null);\r\n        head = mpl_internal_expand_tuple(mpl, head, mpl_internal_copy_symbol(mpl, temp.sym));\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_format_tuple(mpl, c, tuple){\r\n    var temp;\r\n    var j, len = 0;\r\n    var buf = '', str = '', save;\r\n    function safe_append(c){if (len < 255) buf += c; len++}\r\n    var dim = mpl_internal_tuple_dimen(mpl, tuple);\r\n    if (c == '[' && dim > 0) safe_append('[');\r\n    if (c == '(' && dim > 1) safe_append('(');\r\n    for (temp = tuple; temp != null; temp = temp.next)\r\n    {  if (temp != tuple) safe_append(',');\r\n        xassert(temp.sym != null);\r\n        str = mpl_internal_format_symbol(mpl, temp.sym);\r\n        xassert(str.length <= 255);\r\n        for (j = 0; j < str.length; j++) safe_append(str[j]);\r\n    }\r\n    if (c == '[' && dim > 0) safe_append(']');\r\n    if (c == '(' && dim > 1) safe_append(')');\r\n    if (len == 255) buf = buf.slice(0,252) + \"...\";\r\n    xassert(buf.length <= 255);\r\n    return buf;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                       ELEMENTAL SETS                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_elemset(mpl, dim){\r\n    xassert(dim > 0);\r\n    return mpl_internal_create_array(mpl, A_NONE, dim);\r\n}\r\n\r\nfunction mpl_internal_find_tuple(mpl, set, tuple){\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    return mpl_internal_find_member(mpl, set, tuple);\r\n}\r\n\r\nfunction mpl_internal_add_tuple(mpl, set, tuple){\r\n    var memb;\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    memb = mpl_internal_add_member(mpl, set, tuple);\r\n    memb.value.none = null;\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_check_then_add(mpl, set, tuple){\r\n    if (mpl_internal_find_tuple(mpl, set, tuple) != null)\r\n        mpl_internal_error(mpl, \"duplicate tuple \" + mpl_internal_format_tuple(mpl, '(', tuple) + \" detected\");\r\n    return mpl_internal_add_tuple(mpl, set, tuple);\r\n}\r\n\r\nfunction mpl_internal_copy_elemset(mpl, set){\r\n    var copy;\r\n    var memb;\r\n    xassert(set != null);\r\n    xassert(set.type == A_NONE);\r\n    xassert(set.dim > 0);\r\n    copy = mpl_internal_create_elemset(mpl, set.dim);\r\n    for (memb = set.head; memb != null; memb = memb.next)\r\n        mpl_internal_add_tuple(mpl, copy, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    return copy;\r\n}\r\n\r\nfunction mpl_internal_arelset_size(mpl, t0, tf, dt){\r\n    var temp;\r\n    if (dt == 0.0)\r\n        mpl_internal_error(mpl, t0 + \" .. \" + tf + \" by \" + dt + \"; zero stride not allowed\");\r\n    if (tf > 0.0 && t0 < 0.0 && tf > + 0.999 * DBL_MAX + t0)\r\n        temp = +DBL_MAX;\r\n    else if (tf < 0.0 && t0 > 0.0 && tf < - 0.999 * DBL_MAX + t0)\r\n        temp = -DBL_MAX;\r\n    else\r\n        temp = tf - t0;\r\n    if (Math.abs(dt) < 1.0 && Math.abs(temp) > (0.999 * DBL_MAX) * Math.abs(dt))\r\n    {  if (temp > 0.0 && dt > 0.0 || temp < 0.0 && dt < 0.0)\r\n        temp = +DBL_MAX;\r\n    else\r\n        temp = 0.0;\r\n    }\r\n    else\r\n    {  temp = Math.floor(temp / dt) + 1.0;\r\n        if (temp < 0.0) temp = 0.0;\r\n    }\r\n    xassert(temp >= 0.0);\r\n    if (temp > (INT_MAX - 1))\r\n        mpl_internal_error(mpl, t0 + \" .. \" + tf + \" by \" + dt + \"; set too large\");\r\n    return (temp + 0.5)|0;\r\n}\r\n\r\nfunction mpl_internal_arelset_member(mpl, t0, tf, dt, j){\r\n    xassert(1 <= j && j <= mpl_internal_arelset_size(mpl, t0, tf, dt));\r\n    return t0 + (j - 1) * dt;\r\n}\r\n\r\nfunction mpl_internal_create_arelset(mpl, t0, tf, dt){\r\n    var set = mpl_internal_create_elemset(mpl, 1);\r\n    var n = mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n    for (var j = 1; j <= n; j++)\r\n    {\r\n        mpl_internal_add_tuple(mpl, set,\r\n            mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_create_symbol_num(mpl,\r\n                    mpl_internal_arelset_member(mpl, t0, tf, dt, j))));\r\n    }\r\n    return set;\r\n}\r\n\r\nfunction mpl_internal_set_union(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    for (var memb = Y.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, X, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return X;\r\n}\r\n\r\nfunction mpl_internal_set_diff(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (var memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_symdiff(mpl, X, Y){\r\n    var memb;\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    /* Z := X \\ Y */\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    /* Z := Z U (Y \\ X) */\r\n    for (memb = Y.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, X, memb.tuple) == null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_inter(mpl, X, Y){\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    xassert(X.dim == Y.dim);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim);\r\n    for (var memb = X.head; memb != null; memb = memb.next)\r\n    {  if (mpl_internal_find_tuple(mpl, Y, memb.tuple) != null)\r\n        mpl_internal_add_tuple(mpl, Z, mpl_internal_copy_tuple(mpl, memb.tuple));\r\n    }\r\n    return Z;\r\n}\r\n\r\nfunction mpl_internal_set_cross(mpl, X, Y){\r\n    var memx, memy;\r\n    var tuple, temp;\r\n    xassert(X != null);\r\n    xassert(X.type == A_NONE);\r\n    xassert(X.dim > 0);\r\n    xassert(Y != null);\r\n    xassert(Y.type == A_NONE);\r\n    xassert(Y.dim > 0);\r\n    var Z = mpl_internal_create_elemset(mpl, X.dim + Y.dim);\r\n    for (memx = X.head; memx != null; memx = memx.next)\r\n    {  for (memy = Y.head; memy != null; memy = memy.next)\r\n    {  tuple = mpl_internal_copy_tuple(mpl, memx.tuple);\r\n        for (temp = memy.tuple; temp != null; temp = temp.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n                temp.sym));\r\n        mpl_internal_add_tuple(mpl, Z, tuple);\r\n    }\r\n    }\r\n    return Z;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        LINEAR FORMS                        * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_constant_term(mpl, coef){\r\n    var form;\r\n    if (coef == 0.0)\r\n        form = null;\r\n    else\r\n    {   form = {};\r\n        form.coef = coef;\r\n        form.var_ = null;\r\n        form.next = null;\r\n    }\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_single_variable(mpl, var_){\r\n    xassert(var_ != null);\r\n    var form = {};\r\n    form.coef = 1.0;\r\n    form.var_ = var_;\r\n    form.next = null;\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_copy_formula(mpl, form){\r\n    var head, tail;\r\n    if (form == null)\r\n        head = null;\r\n    else\r\n    {  head = tail = {};\r\n        for (; form != null; form = form.next)\r\n        {  tail.coef = form.coef;\r\n            tail.var_ = form.var_;\r\n            if (form.next != null)\r\n                tail = tail.next = {};\r\n        }\r\n        tail.next = null;\r\n    }\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_linear_comb(mpl, a, fx, b, fy){\r\n    var form = null, term, temp;\r\n    var c0 = 0.0;\r\n    for (term = fx; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, a, term.coef));\r\n    else\r\n        term.var_.temp =\r\n            mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, a, term.coef));\r\n    }\r\n    for (term = fy; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, mpl_internal_fp_mul(mpl, b, term.coef));\r\n    else\r\n        term.var_.temp =\r\n            mpl_internal_fp_add(mpl, term.var_.temp, mpl_internal_fp_mul(mpl, b, term.coef));\r\n    }\r\n    for (term = fx; term != null; term = term.next)\r\n    {  if (term.var_ != null && term.var_.temp != 0.0)\r\n    {  temp = {};\r\n        temp.coef = term.var_.temp; temp.var_ = term.var_;\r\n        temp.next = form; form = temp;\r\n        term.var_.temp = 0.0;\r\n    }\r\n    }\r\n    for (term = fy; term != null; term = term.next)\r\n    {  if (term.var_ != null && term.var_.temp != 0.0)\r\n    {  temp = {};\r\n        temp.coef = term.var_.temp; temp.var_ = term.var_;\r\n        temp.next = form; form = temp;\r\n        term.var_.temp = 0.0;\r\n    }\r\n    }\r\n    if (c0 != 0.0)\r\n    {  temp = {};\r\n        temp.coef = c0; temp.var_ = null;\r\n        temp.next = form; form = temp;\r\n    }\r\n    return form;\r\n}\r\n\r\nfunction mpl_internal_remove_constant(mpl, form, callback){\r\n    var head = null, temp;\r\n    var coef = 0.0;\r\n    while (form != null)\r\n    {  temp = form;\r\n        form = form.next;\r\n        if (temp.var_ == null)\r\n        {  /* constant term */\r\n            coef = mpl_internal_fp_add(mpl, coef, temp.coef);\r\n        }\r\n        else\r\n        {  /* linear term */\r\n            temp.next = head;\r\n            head = temp;\r\n        }\r\n    }\r\n    callback(coef);\r\n    return head;\r\n}\r\n\r\nfunction mpl_internal_reduce_terms(mpl, form){\r\n    var term, next_term;\r\n    var c0 = 0.0;\r\n    for (term = form; term != null; term = term.next)\r\n    {  if (term.var_ == null)\r\n        c0 = mpl_internal_fp_add(mpl, c0, term.coef);\r\n    else\r\n        term.var_.temp = mpl_internal_fp_add(mpl, term.var_.temp, term.coef);\r\n    }\r\n    next_term = form; form = null;\r\n    for (term = next_term; term != null; term = next_term)\r\n    {  next_term = term.next;\r\n        if (term.var_ == null && c0 != 0.0)\r\n        {  term.coef = c0; c0 = 0.0;\r\n            term.next = form; form = term;\r\n        }\r\n        else if (term.var_ != null && term.var_.temp != 0.0)\r\n        {  term.coef = term.var_.temp; term.var_.temp = 0.0;\r\n            term.next = form; form = term;\r\n        }\r\n    }\r\n    return form;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                       GENERIC VALUES                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_delete_value(mpl, type, value){\r\n    xassert(value != null);\r\n    switch (type)\r\n    {   case A_NONE:\r\n        value.none = null;\r\n        break;\r\n        case A_NUMERIC:\r\n            value.num = 0.0;\r\n            break;\r\n        case A_SYMBOLIC:\r\n            value.sym = null;\r\n            break;\r\n        case A_LOGICAL:\r\n            value.bit = 0;\r\n            break;\r\n        case A_TUPLE:\r\n            value.tuple = null;\r\n            break;\r\n        case A_ELEMSET:\r\n            value.set = null;\r\n            break;\r\n        case A_ELEMVAR:\r\n            value.var_ = null;\r\n            break;\r\n        case A_FORMULA:\r\n            value.form = null;\r\n            break;\r\n        case A_ELEMCON:\r\n            value.con = null;\r\n            break;\r\n        default:\r\n            xassert(type != type);\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                SYMBOLICALLY INDEXED ARRAYS                 * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_create_array(mpl, type, dim){\r\n    xassert(type == A_NONE || type == A_NUMERIC ||\r\n        type == A_SYMBOLIC || type == A_ELEMSET ||\r\n        type == A_ELEMVAR || type == A_ELEMCON);\r\n    xassert(dim >= 0);\r\n    var array = {};\r\n    array.type = type;\r\n    array.dim = dim;\r\n    array.size = 0;\r\n    array.head = null;\r\n    array.tail = null;\r\n    array.tree = false;\r\n    array.prev = null;\r\n    array.next = mpl.a_list;\r\n    /* include the array in the global array list */\r\n    if (array.next != null) array.next.prev = array;\r\n    mpl.a_list = array;\r\n    return array;\r\n}\r\n\r\nfunction mpl_internal_compare_member_tuples(info, key1, key2){\r\n    /* this is an auxiliary routine used to compare keys, which are\r\n     n-tuples assigned to array members */\r\n    return mpl_internal_compare_tuples(info, key1, key2);\r\n}\r\n\r\nfunction mpl_internal_find_member(mpl, array, tuple){\r\n    var memb;\r\n    xassert(array != null);\r\n    /* the n-tuple must have the same dimension as the array */\r\n    xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);\r\n    /* if the array is large enough, create the search tree and index\r\n     all existing members of the array */\r\n    if (array.size > 30 && !array.tree)\r\n    {\r\n        array.tree = avl_create_tree(mpl_internal_compare_member_tuples, mpl);\r\n        for (memb = array.head; memb != null; memb = memb.next)\r\n            avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);\r\n    }\r\n    /* find a member, which has the given tuple */\r\n    memb = null;\r\n    if (!array.tree)\r\n    {  /* the search tree doesn't exist; use the linear search */\r\n        for (memb = array.head; memb != null; memb = memb.next)\r\n            if (mpl_internal_compare_tuples(mpl, memb.tuple, tuple) == 0) break;\r\n    }\r\n    else\r\n    {  /* the search tree exists; use the binary search */\r\n        var node = avl_find_node(array.tree, tuple);\r\n        memb = (node == null ? null : avl_get_node_link(node));\r\n    }\r\n    return memb;\r\n}\r\n\r\nfunction mpl_internal_add_member(mpl, array, tuple){\r\n    xassert(array != null);\r\n    /* the n-tuple must have the same dimension as the array */\r\n    xassert(mpl_internal_tuple_dimen(mpl, tuple) == array.dim);\r\n    /* create new member */\r\n    var memb = {};\r\n    memb.tuple = tuple;\r\n    memb.next = null;\r\n    memb.value = {};\r\n    /* and append it to the member list */\r\n    array.size++;\r\n    if (array.head == null)\r\n        array.head = memb;\r\n    else\r\n        array.tail.next = memb;\r\n    array.tail = memb;\r\n    /* if the search tree exists, index the new member */\r\n    if (array.tree != null)\r\n        avl_set_node_link(avl_insert_node(array.tree, memb.tuple), memb);\r\n    return memb;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                 DOMAINS AND DUMMY INDICES                  * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_assign_dummy_index(mpl, slot, value){\r\n    var leaf, code;\r\n    xassert(slot != null);\r\n    xassert(value != null);\r\n    /* delete the current value assigned to the dummy index */\r\n    if (slot.value != null)\r\n    {  /* if the current value and the new one are identical, actual\r\n     assignment is not needed */\r\n        if (mpl_internal_compare_symbols(mpl, slot.value, value) == 0) return;\r\n        /* delete a symbol, which is the current value */\r\n        slot.value = null;\r\n    }\r\n    /* now walk through all the pseudo-codes with op = O_INDEX, which\r\n     refer to the dummy index to be changed (these pseudo-codes are\r\n     leaves in the forest of *all* expressions in the database) */\r\n    for (leaf = slot.list; leaf != null; leaf = leaf.arg.index.\r\n        next)\r\n    {  xassert(leaf.op == O_INDEX);\r\n        /* invalidate all resultant values, which depend on the dummy\r\n         index, walking from the current leaf toward the root of the\r\n         corresponding expression tree */\r\n        for (code = leaf; code != null; code = code.up)\r\n        {  if (code.valid)\r\n        {  /* invalidate and delete resultant value */\r\n            code.valid = 0;\r\n            mpl_internal_delete_value(mpl, code.type, code.value);\r\n        }\r\n        }\r\n    }\r\n    /* assign new value to the dummy index */\r\n    slot.value = mpl_internal_copy_symbol(mpl, value);\r\n}\r\n\r\nfunction mpl_internal_update_dummy_indices(mpl, block){\r\n    var slot;\r\n    var temp;\r\n    if (block.backup != null)\r\n    {  for (slot = block.list, temp = block.backup; slot != null;\r\n            slot = slot.next, temp = temp.next)\r\n    {   xassert(temp != null);\r\n        xassert(temp.sym != null);\r\n        mpl_internal_assign_dummy_index(mpl, slot, temp.sym);\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_enter_domain_block(mpl, block, tuple, info, func){\r\n    var backup;\r\n    var ret = 0;\r\n    /* check if the given n-tuple is a member of the basic set */\r\n    xassert(block.code != null);\r\n    if (!mpl_internal_is_member(mpl, block.code, tuple))\r\n    {  ret = 1;\r\n        return ret;\r\n    }\r\n    /* save reference to \"backup\" n-tuple, which was used to assign\r\n     current values of the dummy indices (it is sufficient to save\r\n     reference, not value, because that n-tuple is defined in some\r\n     outer level of recursion and therefore cannot be changed on\r\n     this and deeper recursive calls) */\r\n    backup = block.backup;\r\n    /* set up new \"backup\" n-tuple, which defines new values of the\r\n     dummy indices */\r\n    block.backup = tuple;\r\n    /* assign new values to the dummy indices */\r\n    mpl_internal_update_dummy_indices(mpl, block);\r\n    /* call the formal routine that does the rest part of the job */\r\n    func(mpl, info);\r\n    /* restore reference to the former \"backup\" n-tuple */\r\n    block.backup = backup;\r\n    /* restore former values of the dummy indices; note that if the\r\n     domain block just escaped has no other active instances which\r\n     may exist due to recursion (it is indicated by a null pointer\r\n     to the former n-tuple), former values of the dummy indices are\r\n     undefined; therefore in this case the routine keeps currently\r\n     assigned values of the dummy indices that involves keeping all\r\n     dependent temporary results and thereby, if this domain block\r\n     is not used recursively, allows improving efficiency */\r\n    mpl_internal_update_dummy_indices(mpl, block);\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_eval_domain_func(mpl, my_info)\r\n{     /* this routine recursively enters into the domain scope and then\r\n calls the routine func */\r\n    if (my_info.block != null)\r\n    {  /* the current domain block to be entered exists */\r\n        var block;\r\n        var slot;\r\n        var tuple = null, temp = null;\r\n        /* save pointer to the current domain block */\r\n        block = my_info.block;\r\n        /* and get ready to enter the next block (if it exists) */\r\n        my_info.block = block.next;\r\n        /* construct temporary n-tuple, whose components correspond to\r\n         dummy indices (slots) of the current domain; components of\r\n         the temporary n-tuple that correspond to free dummy indices\r\n         are assigned references (not values!) to symbols specified\r\n         in the corresponding components of the given n-tuple, while\r\n         other components that correspond to non-free dummy indices\r\n         are assigned symbolic values computed here */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  /* create component that corresponds to the current slot */\r\n            if (tuple == null)\r\n                tuple = temp = {};\r\n            else\r\n                temp = temp.next = {};\r\n            if (slot.code == null)\r\n            {  /* dummy index is free; take reference to symbol, which\r\n             is specified in the corresponding component of given\r\n             n-tuple */\r\n                xassert(my_info.tuple != null);\r\n                temp.sym = my_info.tuple.sym;\r\n                xassert(temp.sym != null);\r\n                my_info.tuple = my_info.tuple.next;\r\n            }\r\n            else\r\n            {  /* dummy index is non-free; compute symbolic value to be\r\n             temporarily assigned to the dummy index */\r\n                temp.sym = mpl_internal_eval_symbolic(mpl, slot.code);\r\n            }\r\n        }\r\n        temp.next = null;\r\n        /* enter the current domain block */\r\n        if (mpl_internal_enter_domain_block(mpl, block, tuple, my_info,\r\n            mpl_internal_eval_domain_func)) my_info.failure = 1;\r\n        /* delete temporary n-tuple as well as symbols that correspond\r\n         to non-free dummy indices (they were computed here) */\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  xassert(tuple != null);\r\n            temp = tuple;\r\n            tuple = tuple.next;\r\n        }\r\n    }\r\n    else\r\n    {  /* there are no more domain blocks, i.e. we have reached the\r\n     domain scope */\r\n        xassert(my_info.tuple == null);\r\n        /* check optional predicate specified for the domain */\r\n        if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl,\r\n            my_info.domain.code))\r\n        {  /* the predicate is false */\r\n            my_info.failure = 2;\r\n        }\r\n        else\r\n        {  /* the predicate is true; do the job */\r\n            my_info.func(mpl, my_info.info);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_within_domain(mpl, domain, tuple, info, func){\r\n    /* this routine performs evaluation within domain scope */\r\n    var my_info = {};\r\n    if (domain == null)\r\n    {   xassert(tuple == null);\r\n        func(mpl, info);\r\n        my_info.failure = 0;\r\n    }\r\n    else\r\n    {   xassert(tuple != null);\r\n        my_info.domain = domain;\r\n        my_info.block = domain.list;\r\n        my_info.tuple = tuple;\r\n        my_info.info = info;\r\n        my_info.func = func;\r\n        my_info.failure = 0;\r\n        /* enter the very first domain block */\r\n        mpl_internal_eval_domain_func(mpl, my_info);\r\n    }\r\n    return my_info.failure;\r\n}\r\n\r\nfunction mpl_internal_loop_domain_func(mpl, my_info){\r\n    /* this routine enumerates all n-tuples in the basic set of the\r\n     current domain block, enters recursively into the domain scope\r\n     for every n-tuple, and then calls the routine func */\r\n    if (my_info.block != null)\r\n    {  /* the current domain block to be entered exists */\r\n        var block;\r\n        var slot;\r\n        var bound;\r\n        /* save pointer to the current domain block */\r\n        block = my_info.block;\r\n        /* and get ready to enter the next block (if it exists) */\r\n        my_info.block = block.next;\r\n        /* compute symbolic values, at which non-free dummy indices of\r\n         the current domain block are bound; since that values don't\r\n         depend on free dummy indices of the current block, they can\r\n         be computed once out of the enumeration loop */\r\n        bound = null;\r\n        for (slot = block.list; slot != null; slot = slot.next)\r\n        {  if (slot.code != null)\r\n            bound = mpl_internal_expand_tuple(mpl, bound, mpl_internal_eval_symbolic(mpl,\r\n                slot.code));\r\n        }\r\n        /* start enumeration */\r\n        xassert(block.code != null);\r\n        if (block.code.op == O_DOTS)\r\n        {  /* the basic set is \"arithmetic\", in which case it doesn't\r\n         need to be computed explicitly */\r\n            var tuple;\r\n            var n, j;\r\n            var t0, tf, dt;\r\n            /* compute \"parameters\" of the basic set */\r\n            t0 = mpl_internal_eval_numeric(mpl, block.code.arg.arg.x);\r\n            tf = mpl_internal_eval_numeric(mpl, block.code.arg.arg.y);\r\n            if (block.code.arg.arg.z == null)\r\n                dt = 1.0;\r\n            else\r\n                dt = mpl_internal_eval_numeric(mpl, block.code.arg.arg.z);\r\n            /* determine cardinality of the basic set */\r\n            n = mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n            /* create dummy 1-tuple for members of the basic set */\r\n            tuple = mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_create_symbol_num(mpl, 0.0));\r\n            /* in case of \"arithmetic\" set there is exactly one dummy\r\n             index, which cannot be non-free */\r\n            xassert(bound == null);\r\n            /* walk through 1-tuples of the basic set */\r\n            for (j = 1; j <= n && my_info.looping; j++)\r\n            {  /* construct dummy 1-tuple for the current member */\r\n                tuple.sym.num = mpl_internal_arelset_member(mpl, t0, tf, dt, j);\r\n                /* enter the current domain block */\r\n                mpl_internal_enter_domain_block(mpl, block, tuple, my_info,\r\n                    mpl_internal_loop_domain_func);\r\n            }\r\n        }\r\n        else\r\n        {  /* the basic set is of general kind, in which case it needs\r\n         to be explicitly computed */\r\n            var set;\r\n            var memb;\r\n            var temp1, temp2;\r\n            /* compute the basic set */\r\n            set = mpl_internal_eval_elemset(mpl, block.code);\r\n            /* walk through all n-tuples of the basic set */\r\n            for (memb = set.head; memb != null && my_info.looping;\r\n                 memb = memb.next)\r\n            {  /* all components of the current n-tuple that correspond\r\n             to non-free dummy indices must be feasible; otherwise\r\n             the n-tuple is not in the basic set */\r\n                temp1 = memb.tuple;\r\n                temp2 = bound;\r\n                var found = false;\r\n                for (slot = block.list; slot != null; slot = slot.next)\r\n                {  xassert(temp1 != null);\r\n                    if (slot.code != null)\r\n                    {  /* non-free dummy index */\r\n                        xassert(temp2 != null);\r\n                        if (mpl_internal_compare_symbols(mpl, temp1.sym, temp2.sym)\r\n                            != 0)\r\n                        {  /* the n-tuple is not in the basic set */\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                        temp2 = temp2.next;\r\n                    }\r\n                    temp1 = temp1.next;\r\n                }\r\n                if (!found){\r\n                    xassert(temp1 == null);\r\n                    xassert(temp2 == null);\r\n                    /* enter the current domain block */\r\n                    mpl_internal_enter_domain_block(mpl, block, memb.tuple, my_info,\r\n                        mpl_internal_loop_domain_func);\r\n                }\r\n            }\r\n        }\r\n        /* restore pointer to the current domain block */\r\n        my_info.block = block;\r\n    }\r\n    else\r\n    {  /* there are no more domain blocks, i.e. we have reached the\r\n     domain scope */\r\n        /* check optional predicate specified for the domain */\r\n        if (my_info.domain.code != null && !mpl_internal_eval_logical(mpl,\r\n            my_info.domain.code))\r\n        {  /* the predicate is false */\r\n            /* nop */\r\n        }\r\n        else\r\n        {  /* the predicate is true; do the job */\r\n            my_info.looping = !my_info.func(mpl, my_info.info);\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_loop_within_domain(mpl, domain, info, func){\r\n    /* this routine performs iterations within domain scope */\r\n    var my_info = {};\r\n    if (domain == null)\r\n        func(mpl, info);\r\n    else\r\n    {   my_info.domain = domain;\r\n        my_info.block = domain.list;\r\n        my_info.looping = 1;\r\n        my_info.info = info;\r\n        my_info.func = func;\r\n        /* enter the very first domain block */\r\n        mpl_internal_loop_domain_func(mpl, my_info);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_out_of_domain(mpl, name, tuple){\r\n    xassert(name != null);\r\n    xassert(tuple != null);\r\n    mpl_internal_error(mpl, name + mpl_internal_format_tuple(mpl, '[', tuple) + \" out of domain\");\r\n}\r\n\r\nfunction mpl_internal_get_domain_tuple(mpl, domain){\r\n    var tuple = null;\r\n    if (domain != null)\r\n    {  for (var block = domain.list; block != null; block = block.next)\r\n    {  for (var slot = block.list; slot != null; slot = slot.next)\r\n    {  if (slot.code == null)\r\n    {  xassert(slot.value != null);\r\n        tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_copy_symbol(mpl,\r\n            slot.value));\r\n    }\r\n    }\r\n    }\r\n    }\r\n    return tuple;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                         MODEL SETS                         * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_elem_set(mpl, set, tuple, refer){\r\n    /* elemental set must be within all specified supersets */\r\n    for (var within = set.within, eqno = 1; within != null; within =\r\n        within.next, eqno++)\r\n    {  xassert(within.code != null);\r\n        for (var memb = refer.head; memb != null; memb = memb.next)\r\n        {  if (!mpl_internal_is_member(mpl, within.code, memb.tuple))\r\n        {   var buf = mpl_internal_format_tuple(mpl, '(', memb.tuple);\r\n            xassert(buf.length < 255);\r\n            mpl_internal_error(mpl, set.name + mpl_internal_format_tuple(mpl, '[', tuple) +\r\n                \" contains \" + buf + \" which not within specified set; see (\" + eqno + \")\");\r\n        }\r\n        }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_set(mpl, set, tuple){\r\n    var refer;\r\n    /* find member in the set array */\r\n    var memb = mpl_internal_find_member(mpl, set.array, tuple);\r\n\r\n    function add(){\r\n        /* check that the elemental set satisfies to all restrictions,\r\n         assign it to new member, and add the member to the array */\r\n        mpl_internal_check_elem_set(mpl, set, tuple, refer);\r\n        memb = mpl_internal_add_member(mpl, set.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.set = refer;\r\n    }\r\n\r\n\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.set;\r\n    }\r\n    else if (set.assign != null)\r\n    {  /* compute value using assignment expression */\r\n        refer = mpl_internal_eval_elemset(mpl, set.assign);\r\n        add();\r\n    }\r\n    else if (set.option != null)\r\n    {  /* compute default elemental set */\r\n        refer = mpl_internal_eval_elemset(mpl, set.option);\r\n        add();\r\n    }\r\n    else\r\n    {  /* no value (elemental set) is provided */\r\n        mpl_internal_error(mpl, \"no value for \" + set.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_set_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check elemental set being assigned */\r\n        mpl_internal_check_elem_set(mpl, info.set, info.memb.tuple,\r\n            info.memb.value.set);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.refer = mpl_internal_take_member_set(mpl, info.set, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_saturate_set(mpl, set){\r\n    var gadget = set.gadget;\r\n    var data;\r\n    var elem, memb;\r\n    var tuple, work = new Array(20);\r\n    var i;\r\n    xprintf(\"Generating \" + set.name + \"...\");\r\n    mpl_internal_eval_whole_set(mpl, gadget.set);\r\n    /* gadget set must have exactly one member */\r\n    xassert(gadget.set.array != null);\r\n    xassert(gadget.set.array.head != null);\r\n    xassert(gadget.set.array.head == gadget.set.array.tail);\r\n    data = gadget.set.array.head.value.set;\r\n    xassert(data.type == A_NONE);\r\n    xassert(data.dim == gadget.set.dimen);\r\n    /* walk thru all elements of the plain set */\r\n    for (elem = data.head; elem != null; elem = elem.next)\r\n    {  /* create a copy of n-tuple */\r\n        tuple = mpl_internal_copy_tuple(mpl, elem.tuple);\r\n        /* rearrange component of the n-tuple */\r\n        for (i = 0; i < gadget.set.dimen; i++)\r\n            work[i] = null;\r\n        for (i = 0; tuple != null; tuple = tuple.next)\r\n            work[gadget.ind[i++]-1] = tuple;\r\n        xassert(i == gadget.set.dimen);\r\n        for (i = 0; i < gadget.set.dimen; i++)\r\n        {  xassert(work[i] != null);\r\n            work[i].next = work[i+1];\r\n        }\r\n        /* construct subscript list from first set.dim components */\r\n        if (set.dim == 0)\r\n            tuple = null;\r\n        else {\r\n            tuple = work[0]; work[set.dim-1].next = null;\r\n        }\r\n        /* find corresponding member of the set to be initialized */\r\n        memb = mpl_internal_find_member(mpl, set.array, tuple);\r\n        if (memb == null)\r\n        {  /* not found; add new member to the set and assign it empty\r\n         elemental set */\r\n            memb = mpl_internal_add_member(mpl, set.array, tuple);\r\n            memb.value.set = mpl_internal_create_elemset(mpl, set.dimen);\r\n        }\r\n        /* construct new n-tuple from rest set.dimen components */\r\n        tuple = work[set.dim];\r\n        xassert(set.dim + set.dimen == gadget.set.dimen);\r\n        work[gadget.set.dimen-1].next = null;\r\n        /* and add it to the elemental set assigned to the member\r\n         (no check for duplicates is needed) */\r\n        mpl_internal_add_tuple(mpl, memb.value.set, tuple);\r\n    }\r\n    /* the set has been saturated with data */\r\n    set.data = 1;\r\n}\r\n\r\nfunction mpl_internal_eval_member_set(mpl, set, tuple){\r\n    /* this routine evaluates set member */\r\n    var info = {};\r\n    xassert(set.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.set = set;\r\n    info.tuple = tuple;\r\n    if (set.gadget != null && set.data == 0)\r\n    {  /* initialize the set with data from a plain set */\r\n        mpl_internal_saturate_set(mpl, set);\r\n    }\r\n    if (set.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting supersets;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = set.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same set during the check */\r\n        set.data = 2;\r\n        /* check elemental sets assigned to array members in the data\r\n         section until the marked member has been reached */\r\n        for (info.memb = set.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, set.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_set_func))\r\n            mpl_internal_out_of_domain(mpl, set.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.set.domain, info.tuple, info,\r\n        mpl_internal_eval_set_func))\r\n        mpl_internal_out_of_domain(mpl, set.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_set_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, info.domain);\r\n    mpl_internal_eval_member_set(mpl, info, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_set(mpl, set){\r\n    mpl_internal_loop_within_domain(mpl, set.domain, set, mpl_internal_whole_set_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL PARAMETERS                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_value_num(mpl, par, tuple, value){\r\n    var cond;\r\n    var eqno;\r\n    /* the value must satisfy to the parameter type */\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        break;\r\n        case A_INTEGER:\r\n            if (value != Math.floor(value))\r\n                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not integer\");\r\n            break;\r\n        case A_BINARY:\r\n            if (!(value == 0.0 || value == 1.0))\r\n                mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not binary\");\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    /* the value must satisfy to all specified conditions */\r\n    for (cond = par.cond, eqno = 1; cond != null; cond = cond.next,\r\n        eqno++)\r\n    {   var bound;\r\n        //var rho;\r\n        xassert(cond.code != null);\r\n        bound = mpl_internal_eval_numeric(mpl, cond.code);\r\n\r\n        function err(rho){mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not \" + rho + \" \" + bound + \"; see (\" + eqno + \")\")}\r\n\r\n        switch (cond.rho)\r\n        {   case O_LT:\r\n            if (!(value < bound))\r\n                err(\"<\");\r\n            break;\r\n            case O_LE:\r\n                if (!(value <= bound)) err(\"<=\");\r\n                break;\r\n            case O_EQ:\r\n                if (!(value == bound)) err(\"=\");\r\n                break;\r\n            case O_GE:\r\n                if (!(value >= bound)) err(\">=\");\r\n                break;\r\n            case O_GT:\r\n                if (!(value > bound)) err(\">\");\r\n                break;\r\n            case O_NE:\r\n                if (!(value != bound)) err(\"<>\");\r\n                break;\r\n            default:\r\n                xassert(cond != cond);\r\n        }\r\n    }\r\n    /* the value must be in_ all specified supersets */\r\n    eqno = 1;\r\n    for (var in_ = par.in_; in_ != null; in_ = in_.next, eqno++)\r\n    {\r\n        xassert(in_.code != null);\r\n        xassert(in_.code.dim == 1);\r\n        var dummy = mpl_internal_expand_tuple(mpl, null,\r\n            mpl_internal_create_symbol_num(mpl, value));\r\n        if (!mpl_internal_is_member(mpl, in_.code, dummy))\r\n            mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + value + \" not in specified set; see (\" + eqno + \")\");\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_num(mpl, par, tuple){\r\n    /* find member in the parameter array */\r\n    var memb = mpl_internal_find_member(mpl, par.array, tuple);\r\n\r\n    function add(value){\r\n        /* check that the value satisfies to all restrictions, assign\r\n         it to new member, and add the member to the array */\r\n        mpl_internal_check_value_num(mpl, par, tuple, value);\r\n        memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.num = value;\r\n        return value;\r\n    }\r\n\r\n    if (memb != null)\r\n    /* member exists, so just take its value */\r\n        return memb.value.num;\r\n    else if (par.assign != null)\r\n    /* compute value using assignment expression */\r\n        return add(mpl_internal_eval_numeric(mpl, par.assign));\r\n    else if (par.option != null)\r\n    /* compute default value */\r\n        return add(mpl_internal_eval_numeric(mpl, par.option));\r\n    else if (par.defval != null)\r\n    {   /* take default value provided in the data section */\r\n        if (par.defval.str != null)\r\n            mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, par.defval) + \" to floating-point number\");\r\n        return add(par.defval.num);\r\n    }\r\n    else\r\n    /* no value is provided */\r\n        return mpl_internal_error(mpl, \"no value for \" + par.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n}\r\n\r\nfunction mpl_internal_eval_num_func(mpl, info){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check numeric value being assigned */\r\n        mpl_internal_check_value_num(mpl, info.par, info.memb.tuple,\r\n            info.memb.value.num);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.value = mpl_internal_take_member_num(mpl, info.par, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_member_num(mpl, par, tuple){\r\n    /* this routine evaluates numeric parameter member */\r\n    var info = {};\r\n    xassert(par.type == A_NUMERIC || par.type == A_INTEGER ||\r\n        par.type == A_BINARY);\r\n    xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.par = par;\r\n    info.tuple = tuple;\r\n    if (par.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting conditions;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = par.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same parameter during the check */\r\n        par.data = 2;\r\n        /* check values assigned to array members in the data section\r\n         until the marked member has been reached */\r\n        for (info.memb = par.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_num_func))\r\n            mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info,\r\n        mpl_internal_eval_num_func))\r\n        mpl_internal_out_of_domain(mpl, par.name, info.tuple);\r\n    /* bring evaluated value to the calling program */\r\n    return info.value;\r\n}\r\n\r\nfunction mpl_internal_check_value_sym(mpl, par, tuple, value){\r\n    var in_;\r\n    var eqno = 1;\r\n    /* the value must satisfy to all specified conditions */\r\n    for (var cond = par.cond; cond != null; cond = cond.next,\r\n        eqno++)\r\n    {\r\n        var buf; // 255\r\n        xassert(cond.code != null);\r\n        var bound = mpl_internal_eval_symbolic(mpl, cond.code);\r\n        switch (cond.rho)\r\n        {\r\n            case O_LT:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) < 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not < \" + buf);\r\n                }\r\n                break;\r\n            case O_LE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) <= 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not <= \" + buf);\r\n                }\r\n                break;\r\n            case O_EQ:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) == 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not = \" + buf);\r\n                }\r\n                break;\r\n            case O_GE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) >= 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not >= \" + buf);\r\n                }\r\n                break;\r\n            case O_GT:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) > 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not > \" + buf);\r\n                }\r\n                break;\r\n            case O_NE:\r\n                if (!(mpl_internal_compare_symbols(mpl, value, bound) != 0))\r\n                {   buf = mpl_internal_format_symbol(mpl, bound);\r\n                    xassert(buf.length <= 255);\r\n                    mpl_internal_error(mpl, par.name + mpl_internal_format_tuple(mpl, '[', tuple) + \" <> \" +\r\n                        mpl_internal_format_symbol(mpl, value) + \" not > \" + buf);\r\n                }\r\n                break;\r\n            default:\r\n                xassert(cond != cond);\r\n        }\r\n    }\r\n    /* the value must be in all specified supersets */\r\n    eqno = 1;\r\n    for (in_ = par.in_; in_ != null; in_ = in_.next, eqno++)\r\n    {\r\n        xassert(in_.code != null);\r\n        xassert(in_.code.dim == 1);\r\n        var dummy = mpl_internal_expand_tuple(mpl, null, mpl_internal_copy_symbol(mpl,\r\n            value));\r\n        if (!mpl_internal_is_member(mpl, in_.code, dummy))\r\n            mpl_internal_error(mpl, par.name, mpl_internal_format_tuple(mpl, '[', tuple) + \" = \" + mpl_internal_format_symbol(mpl, value) + \" not in specified set; see (\" + eqno + \")\");\r\n    }\r\n}\r\n\r\nfunction mpl_internal_take_member_sym(mpl, par, tuple){\r\n    /* find member in the parameter array */\r\n    var memb = mpl_internal_find_member(mpl, par.array, tuple);\r\n\r\n    function add(value){\r\n        /* check that the value satisfies to all restrictions, assign\r\n         it to new member, and add the member to the array */\r\n        mpl_internal_check_value_sym(mpl, par, tuple, value);\r\n        memb = mpl_internal_add_member(mpl, par.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        memb.value.sym = mpl_internal_copy_symbol(mpl, value);\r\n        return value;\r\n    }\r\n\r\n    if (memb != null)\r\n    {  /* member exists, so just take its value */\r\n        return mpl_internal_copy_symbol(mpl, memb.value.sym);\r\n    }\r\n    else if (par.assign != null)\r\n    /* compute value using assignment expression */\r\n        return add(mpl_internal_eval_symbolic(mpl, par.assign));\r\n    else if (par.option != null)\r\n    /* compute default value */\r\n        return add(mpl_internal_eval_symbolic(mpl, par.option));\r\n    else if (par.defval != null)\r\n    /* take default value provided in the data section */\r\n        return(mpl_internal_copy_symbol(mpl, par.defval));\r\n    else\r\n    /* no value is provided */\r\n        return mpl_internal_error(mpl, \"no value for \" + par.name + mpl_internal_format_tuple(mpl, '[', tuple));\r\n}\r\n\r\nfunction mpl_internal_eval_sym_func(mpl, info)\r\n{     /* this is auxiliary routine to work within domain scope */\r\n    if (info.memb != null)\r\n    {  /* checking call; check symbolic value being assigned */\r\n        mpl_internal_check_value_sym(mpl, info.par, info.memb.tuple,\r\n            info.memb.value.sym);\r\n    }\r\n    else\r\n    {  /* normal call; evaluate member, which has given n-tuple */\r\n        info.value = mpl_internal_take_member_sym(mpl, info.par, info.tuple);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_eval_member_sym(mpl, par, tuple){\r\n    /* this routine evaluates symbolic parameter member */\r\n    var info = {};\r\n    xassert(par.type == A_SYMBOLIC);\r\n    xassert(par.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.par = par;\r\n    info.tuple = tuple;\r\n    if (par.data == 1)\r\n    {  /* check data, which are provided in the data section, but not\r\n     checked yet */\r\n        /* save pointer to the last array member; note that during the\r\n         check new members may be added beyond the last member due to\r\n         references to the same parameter from default expression as\r\n         well as from expressions that define restricting conditions;\r\n         however, values assigned to the new members will be checked\r\n         by other routine, so we don't need to check them here */\r\n        var tail = par.array.tail;\r\n        /* change the data status to prevent infinite recursive loop\r\n         due to references to the same parameter during the check */\r\n        par.data = 2;\r\n        /* check values assigned to array members in the data section\r\n         until the marked member has been reached */\r\n        for (info.memb = par.array.head; info.memb != null;\r\n             info.memb = info.memb.next)\r\n        {  if (mpl_internal_eval_within_domain(mpl, par.domain, info.memb.tuple,\r\n            info, mpl_internal_eval_sym_func))\r\n            mpl_internal_out_of_domain(mpl, par.name, info.memb.tuple);\r\n            if (info.memb == tail) break;\r\n        }\r\n        /* the check has been finished */\r\n    }\r\n    /* evaluate member, which has given n-tuple */\r\n    info.memb = null;\r\n    if (mpl_internal_eval_within_domain(mpl, info.par.domain, info.tuple, info,\r\n        mpl_internal_eval_sym_func))\r\n        mpl_internal_out_of_domain(mpl, par.name, info.tuple);\r\n    /* bring evaluated value to the calling program */\r\n    return info.value;\r\n}\r\n\r\nfunction mpl_internal_whole_par_func(mpl, par){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, par.domain);\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            mpl_internal_eval_member_num(mpl, par, tuple);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            mpl_internal_eval_member_sym(mpl, par, tuple);\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_par(mpl, par){\r\n    mpl_internal_loop_within_domain(mpl, par.domain, par, mpl_internal_whole_par_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL VARIABLES                       * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_take_member_var(mpl, var_, tuple){\r\n    var refer;\r\n    /* find member in the variable array */\r\n    var memb = mpl_internal_find_member(mpl, var_.array, tuple);\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.var_;\r\n    }\r\n    else\r\n    {  /* member is referenced for the first time and therefore does\r\n     not exist; create new elemental variable, assign it to new\r\n     member, and add the member to the variable array */\r\n        memb = mpl_internal_add_member(mpl, var_.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        refer = memb.value.var_ = {};\r\n        refer.j = 0;\r\n        refer.var_ = var_;\r\n        refer.memb = memb;\r\n        /* compute lower bound */\r\n        if (var_.lbnd == null)\r\n            refer.lbnd = 0.0;\r\n        else\r\n            refer.lbnd = mpl_internal_eval_numeric(mpl, var_.lbnd);\r\n        /* compute upper bound */\r\n        if (var_.ubnd == null)\r\n            refer.ubnd = 0.0;\r\n        else if (var_.ubnd == var_.lbnd)\r\n            refer.ubnd = refer.lbnd;\r\n        else\r\n            refer.ubnd = mpl_internal_eval_numeric(mpl, var_.ubnd);\r\n        /* nullify working quantity */\r\n        refer.temp = 0.0;\r\n        /* solution has not been obtained by the solver yet */\r\n        refer.stat = 0;\r\n        refer.prim = refer.dual = 0.0;\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_var_func(mpl, info)\r\n{\r\n    /* this is auxiliary routine to work within domain scope */\r\n    info.refer = mpl_internal_take_member_var(mpl, info.var_, info.tuple);\r\n}\r\n\r\nfunction mpl_internal_eval_member_var(mpl, var_, tuple){\r\n    /* this routine evaluates variable member */\r\n    var info = {};\r\n    xassert(var_.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.var_ = var_;\r\n    info.tuple = tuple;\r\n    /* evaluate member, which has given n-tuple */\r\n    if (mpl_internal_eval_within_domain(mpl, info.var_.domain, info.tuple, info, mpl_internal_eval_var_func))\r\n        mpl_internal_out_of_domain(mpl, var_.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_var_func(mpl, var_){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, var_.domain);\r\n    mpl_internal_eval_member_var(mpl, var_, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_var(mpl, var_){\r\n    mpl_internal_loop_within_domain(mpl, var_.domain, var_, mpl_internal_whole_var_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *              MODEL CONSTRAINTS AND OBJECTIVES              * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_take_member_con(mpl, con, tuple){\r\n    var refer, temp = null;\r\n    /* find member in the constraint array */\r\n    var memb = mpl_internal_find_member(mpl, con.array, tuple);\r\n    if (memb != null)\r\n    {  /* member exists, so just take the reference */\r\n        refer = memb.value.con;\r\n    }\r\n    else\r\n    {  /* member is referenced for the first time and therefore does\r\n     not exist; create new elemental constraint, assign it to new\r\n     member, and add the member to the constraint array */\r\n        memb = mpl_internal_add_member(mpl, con.array, mpl_internal_copy_tuple(mpl, tuple));\r\n        refer = memb.value.con = {};\r\n        refer.i = 0;\r\n        refer.con = con;\r\n        refer.memb = memb;\r\n        /* compute linear form */\r\n        xassert(con.code != null);\r\n        refer.form = mpl_internal_eval_formula(mpl, con.code);\r\n        /* compute lower and upper bounds */\r\n        if (con.lbnd == null && con.ubnd == null)\r\n        {  /* objective has no bounds */\r\n\r\n            xassert(con.type == A_MINIMIZE || con.type == A_MAXIMIZE);\r\n            /* carry the constant term to the right-hand side */\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = refer.ubnd = - temp;\r\n        }\r\n        else if (con.lbnd != null && con.ubnd == null)\r\n        {  /* constraint a * x + b >= c * y + d is transformed to the\r\n         standard form a * x - c * y >= d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.lbnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = - temp;\r\n            refer.ubnd = 0.0;\r\n        }\r\n        else if (con.lbnd == null && con.ubnd != null)\r\n        {  /* constraint a * x + b <= c * y + d is transformed to the\r\n         standard form a * x - c * y <= d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.ubnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = 0.0;\r\n            refer.ubnd = - temp;\r\n        }\r\n        else if (con.lbnd == con.ubnd)\r\n        {  /* constraint a * x + b = c * y + d is transformed to the\r\n         standard form a * x - c * y = d - b */\r\n\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_linear_comb(mpl,\r\n                +1.0, refer.form,\r\n                -1.0, mpl_internal_eval_formula(mpl, con.lbnd));\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            refer.lbnd = refer.ubnd = - temp;\r\n        }\r\n        else\r\n        {  /* ranged constraint c <= a * x + b <= d is transformed to\r\n         the standard form c - b <= a * x <= d - b */\r\n            var temp1 = null, temp2 = null;\r\n            xassert(con.type == A_CONSTRAINT);\r\n            refer.form = mpl_internal_remove_constant(mpl, refer.form, function(v){temp = v});\r\n            xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.lbnd), function(v){temp1 = v}) == null);\r\n            xassert(mpl_internal_remove_constant(mpl, mpl_internal_eval_formula(mpl, con.ubnd), function(v){temp2 = v}) == null);\r\n            refer.lbnd = mpl_internal_fp_sub(mpl, temp1, temp);\r\n            refer.ubnd = mpl_internal_fp_sub(mpl, temp2, temp);\r\n        }\r\n        /* solution has not been obtained by the solver yet */\r\n        refer.stat = 0;\r\n        refer.prim = refer.dual = 0.0;\r\n    }\r\n    return refer;\r\n}\r\n\r\nfunction mpl_internal_eval_con_func(mpl, info)\r\n{     /* this is auxiliary routine to work within domain scope */\r\n    info.refer = mpl_internal_take_member_con(mpl, info.con, info.tuple);\r\n}\r\n\r\nfunction mpl_internal_eval_member_con(mpl, con, tuple){\r\n    /* this routine evaluates constraint member */\r\n    var info = {};\r\n    xassert(con.dim == mpl_internal_tuple_dimen(mpl, tuple));\r\n    info.con = con;\r\n    info.tuple = tuple;\r\n    /* evaluate member, which has given n-tuple */\r\n    if (mpl_internal_eval_within_domain(mpl, info.con.domain, info.tuple, info,\r\n        mpl_internal_eval_con_func))\r\n        mpl_internal_out_of_domain(mpl, con.name, info.tuple);\r\n    /* bring evaluated reference to the calling program */\r\n    return info.refer;\r\n}\r\n\r\nfunction mpl_internal_whole_con_func(mpl, con){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var tuple = mpl_internal_get_domain_tuple(mpl, con.domain);\r\n    mpl_internal_eval_member_con(mpl, con, tuple);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_whole_con(mpl, con){\r\n    mpl_internal_loop_within_domain(mpl, con.domain, con, mpl_internal_whole_con_func);\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        PSEUDO-CODE                         * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_iter_num_func(mpl, info){\r\n    /* this is auxiliary routine used to perform iterated operation\r\n     on numeric \"integrand\" within domain scope */\r\n    var temp = mpl_internal_eval_numeric(mpl, info.code.arg.loop.x);\r\n    switch (info.code.op)\r\n    {  case O_SUM:\r\n        /* summation over domain */\r\n        info.value = mpl_internal_fp_add(mpl, info.value, temp);\r\n        break;\r\n        case O_PROD:\r\n            /* multiplication over domain */\r\n            info.value = mpl_internal_fp_mul(mpl, info.value, temp);\r\n            break;\r\n        case O_MINIMUM:\r\n            /* minimum over domain */\r\n            if (info.value > temp) info.value = temp;\r\n            break;\r\n        case O_MAXIMUM:\r\n            /* maximum over domain */\r\n            if (info.value < temp) info.value = temp;\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_numeric(mpl, code){\r\n    var value, tuple, e, sym, str, temp, info;\r\n    xassert(code != null);\r\n    xassert(code.type == A_NUMERIC);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return code.value.num;\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_NUMBER:\r\n        /* take floating-point number */\r\n        value = code.arg.num;\r\n        break;\r\n        case O_MEMNUM:\r\n            /* take member of numeric parameter */\r\n        {\r\n            tuple = null;\r\n            for (e = code.arg.par.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            value = mpl_internal_eval_member_num(mpl, code.arg.par.par, tuple);\r\n        }\r\n            break;\r\n        case O_MEMVAR:\r\n            /* take computed value of elemental variable */\r\n        {\r\n            var var_;\r\n            tuple = null;\r\n            for (e = code.arg.var_.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple);\r\n            switch (code.arg.var_.suff)\r\n            {  case DOT_LB:\r\n                if (var_.var_.lbnd == null)\r\n                    value = -DBL_MAX;\r\n                else\r\n                    value = var_.lbnd;\r\n                break;\r\n                case DOT_UB:\r\n                    if (var_.var_.ubnd == null)\r\n                        value = +DBL_MAX;\r\n                    else\r\n                        value = var_.ubnd;\r\n                    break;\r\n                case DOT_STATUS:\r\n                    value = var_.stat;\r\n                    break;\r\n                case DOT_VAL:\r\n                    value = var_.prim;\r\n                    break;\r\n                case DOT_DUAL:\r\n                    value = var_.dual;\r\n                    break;\r\n                default:\r\n                    xassert(code != code);\r\n            }\r\n        }\r\n            break;\r\n        case O_MEMCON:\r\n            /* take computed value of elemental constraint */\r\n        {\r\n            var con;\r\n            tuple = null;\r\n            for (e = code.arg.con.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            con = mpl_internal_eval_member_con(mpl, code.arg.con.con, tuple);\r\n            switch (code.arg.con.suff)\r\n            {  case DOT_LB:\r\n                if (con.con.lbnd == null)\r\n                    value = -DBL_MAX;\r\n                else\r\n                    value = con.lbnd;\r\n                break;\r\n                case DOT_UB:\r\n                    if (con.con.ubnd == null)\r\n                        value = +DBL_MAX;\r\n                    else\r\n                        value = con.ubnd;\r\n                    break;\r\n                case DOT_STATUS:\r\n                    value = con.stat;\r\n                    break;\r\n                case DOT_VAL:\r\n                    value = con.prim;\r\n                    break;\r\n                case DOT_DUAL:\r\n                    value = con.dual;\r\n                    break;\r\n                default:\r\n                    xassert(code != code);\r\n            }\r\n        }\r\n            break;\r\n        case O_IRAND224:\r\n            /* pseudo-random in [0, 2^24-1] */\r\n            value = mpl_internal_fp_irand224(mpl);\r\n            break;\r\n        case O_UNIFORM01:\r\n            /* pseudo-random in [0, 1) */\r\n            value = mpl_internal_fp_uniform01(mpl);\r\n            break;\r\n        case O_NORMAL01:\r\n            /* gaussian random, mu = 0, sigma = 1 */\r\n            value = mpl_internal_fp_normal01(mpl);\r\n            break;\r\n        case O_GMTIME:\r\n            /* current calendar time */\r\n            value = mpl_internal_fn_gmtime(mpl);\r\n            break;\r\n        case O_CVTNUM:\r\n            /* conversion to numeric */\r\n        {\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                value = sym.num;\r\n            else\r\n            {  if (str2num(sym.str, function(v){value= v}))\r\n                mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, sym) + \" to floating-point number\");\r\n            }\r\n        }\r\n            break;\r\n        case O_PLUS:\r\n            /* unary plus */\r\n            value = + mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_MINUS:\r\n            /* unary minus */\r\n            value = - mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_ABS:\r\n            /* absolute value */\r\n            value = Math.abs(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_CEIL:\r\n            /* round upward (\"ceiling of x\") */\r\n            value = Math.ceil(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_FLOOR:\r\n            /* round downward (\"floor of x\") */\r\n            value = Math.floor(mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_EXP:\r\n            /* base-e exponential */\r\n            value = mpl_internal_fp_exp(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_LOG:\r\n            /* natural logarithm */\r\n            value = mpl_internal_fp_log(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_LOG10:\r\n            /* common (decimal) logarithm */\r\n            value = mpl_internal_fp_log10(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_SQRT:\r\n            /* square root */\r\n            value = mpl_internal_fp_sqrt(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_SIN:\r\n            /* trigonometric sine */\r\n            value = mpl_internal_fp_sin(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_COS:\r\n            /* trigonometric cosine */\r\n            value = mpl_internal_fp_cos(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ATAN:\r\n            /* trigonometric arctangent (one argument) */\r\n            value = mpl_internal_fp_atan(mpl, mpl_internal_eval_numeric(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ATAN2:\r\n            /* trigonometric arctangent (two arguments) */\r\n            value = mpl_internal_fp_atan2(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_ROUND:\r\n            /* round to nearest integer */\r\n            value = mpl_internal_fp_round(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0.0);\r\n            break;\r\n        case O_ROUND2:\r\n            /* round to n fractional digits */\r\n            value = mpl_internal_fp_round(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_TRUNC:\r\n            /* truncate to nearest integer */\r\n            value = mpl_internal_fp_trunc(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x), 0.0);\r\n            break;\r\n        case O_TRUNC2:\r\n            /* truncate to n fractional digits */\r\n            value = mpl_internal_fp_trunc(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_ADD:\r\n            /* addition */\r\n            value = mpl_internal_fp_add(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SUB:\r\n            /* subtraction */\r\n            value = mpl_internal_fp_sub(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_LESS:\r\n            /* non-negative subtraction */\r\n            value = mpl_internal_fp_less(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MUL:\r\n            /* multiplication */\r\n            value = mpl_internal_fp_mul(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DIV:\r\n            /* division */\r\n            value = mpl_internal_fp_div(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_IDIV:\r\n            /* quotient of exact division */\r\n            value = mpl_internal_fp_idiv(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MOD:\r\n            /* remainder of exact division */\r\n            value = mpl_internal_fp_mod(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_POWER:\r\n            /* exponentiation (raise to power) */\r\n            value = mpl_internal_fp_power(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_UNIFORM:\r\n            /* pseudo-random in [a, b) */\r\n            value = mpl_internal_fp_uniform(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_NORMAL:\r\n            /* gaussian random, given mu and sigma */\r\n            value = mpl_internal_fp_normal(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_CARD:\r\n        {\r\n            var set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = set.size;\r\n        }\r\n            break;\r\n        case O_LENGTH:\r\n        {\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                str = String(sym.num);\r\n            else\r\n                str = sym.str;\r\n            value = str.length;\r\n        }\r\n            break;\r\n        case O_STR2TIME:\r\n        {\r\n            var fmt;\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (sym.str == null)\r\n                str = String(sym.num);\r\n            else\r\n                str = sym.str;\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            if (sym.str == null)\r\n                fmt = String(sym.num);\r\n            else\r\n                fmt = sym.str;\r\n            value = mpl_internal_fn_str2time(mpl, str, fmt);\r\n        }\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = 0.0;\r\n            else\r\n                value = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_MIN:\r\n            /* minimal value (n-ary) */\r\n        {\r\n            value = +DBL_MAX;\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  temp = mpl_internal_eval_numeric(mpl, e.x);\r\n                if (value > temp) value = temp;\r\n            }\r\n        }\r\n            break;\r\n        case O_MAX:\r\n            /* maximal value (n-ary) */\r\n        {\r\n            value = -DBL_MAX;\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  temp = mpl_internal_eval_numeric(mpl, e.x);\r\n                if (value < temp) value = temp;\r\n            }\r\n        }\r\n            break;\r\n        case O_SUM:\r\n            /* summation over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 0.0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_PROD:\r\n            /* multiplication over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 1.0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_MINIMUM:\r\n            /* minimum over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = +DBL_MAX;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            if (info.value == +DBL_MAX)\r\n                mpl_internal_error(mpl, \"min{} over empty set; result undefined\");\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_MAXIMUM:\r\n            /* maximum over domain */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = -DBL_MAX;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_num_func);\r\n            if (info.value == -DBL_MAX)\r\n                mpl_internal_error(mpl, \"max{} over empty set; result undefined\");\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.num = value;\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_eval_symbolic(mpl, code){\r\n    var value, str;\r\n    xassert(code != null);\r\n    xassert(code.type == A_SYMBOLIC);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_symbol(mpl, code.value.sym);\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_STRING:\r\n        /* take character string */\r\n        value = mpl_internal_create_symbol_str(mpl, code.arg.str);\r\n        break;\r\n        case O_INDEX:\r\n            /* take dummy index */\r\n            xassert(code.arg.index.slot.value != null);\r\n            value = mpl_internal_copy_symbol(mpl, code.arg.index.slot.value);\r\n            break;\r\n        case O_MEMSYM:\r\n            /* take member of symbolic parameter */\r\n        {   var tuple;\r\n            var e;\r\n            tuple = null;\r\n            for (e = code.arg.par.list; e != null; e = e.next)\r\n                tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                    e.x));\r\n            value = mpl_internal_eval_member_sym(mpl, code.arg.par.par, tuple);\r\n        }\r\n            break;\r\n        case O_CVTSYM:\r\n            /* conversion to symbolic */\r\n            value = mpl_internal_create_symbol_num(mpl, mpl_internal_eval_numeric(mpl,\r\n                code.arg.arg.x));\r\n            break;\r\n        case O_CONCAT:\r\n            /* concatenation */\r\n            value = mpl_internal_concat_symbols(mpl,\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = mpl_internal_create_symbol_num(mpl, 0.0);\r\n            else\r\n                value = mpl_internal_eval_symbolic(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SUBSTR:\r\n        case O_SUBSTR3:\r\n        {  var pos, len;\r\n            value = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n            if (value.str == null)\r\n                str = String(value.num);\r\n            else\r\n                str = value.str;\r\n            if (code.op == O_SUBSTR)\r\n            {  pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n                if (pos != Math.floor(pos))\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \"); non-integer second argument\");\r\n                if (pos < 1 || pos > str.length + 1)\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \"); substring out of range\");\r\n            }\r\n            else\r\n            {   pos = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n                len = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n                if (pos != Math.floor(pos) || len != Math.floor(len))\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \", \" + len + \"); non-integer second and/or third argument\");\r\n                if (pos < 1 || len < 0 || pos + len > str.length + 1)\r\n                    mpl_internal_error(mpl, \"substr('...', \" + pos + \", \" + len + \"); substring out of range\");\r\n                //str[pos + len - 1] = '\\0';\r\n            }\r\n            value = mpl_internal_create_symbol_str(mpl, str.slice(pos-1, pos+len-1));\r\n        }\r\n            break;\r\n        case O_TIME2STR:\r\n        {   var num;\r\n            var sym;\r\n            var fmt; //[MAX_LENGTH+1], fmt[MAX_LENGTH+1];\r\n            num = mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            sym = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n            if (sym.str == null)\r\n                fmt = String(sym.num);\r\n            else\r\n                fmt = sym.str;\r\n            str = mpl_internal_fn_time2str(mpl, num, fmt);\r\n            value = mpl_internal_create_symbol_str(mpl, str);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.sym = mpl_internal_copy_symbol(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_log_func(mpl, info){\r\n    /* this is auxiliary routine used to perform iterated operation\r\n     on logical \"integrand\" within domain scope */\r\n    var ret = 0;\r\n    switch (info.code.op)\r\n    {  case O_FORALL:\r\n        /* conjunction over domain */\r\n        info.value &= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);\r\n        if (!info.value) ret = 1;\r\n        break;\r\n        case O_EXISTS:\r\n            /* disjunction over domain */\r\n            info.value |= mpl_internal_eval_logical(mpl, info.code.arg.loop.x);\r\n            if (info.value) ret = 1;\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_eval_logical(mpl, code){\r\n    var value, sym1, sym2, tuple, set, memb, info;\r\n    xassert(code.type == A_LOGICAL);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return code.value.bit;\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_CVTLOG:\r\n        /* conversion to logical */\r\n        value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) != 0.0);\r\n        break;\r\n        case O_NOT:\r\n            /* negation (logical \"not\") */\r\n            value = !mpl_internal_eval_logical(mpl, code.arg.arg.x);\r\n            break;\r\n        case O_LT:\r\n            /* comparison on 'less than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) <\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) < 0);\r\n            }\r\n            break;\r\n        case O_LE:\r\n            /* comparison on 'not greater than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) <=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) <= 0);\r\n            }\r\n            break;\r\n        case O_EQ:\r\n            /* comparison on 'equal to' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) ==\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) == 0);\r\n            }\r\n            break;\r\n        case O_GE:\r\n            /* comparison on 'not less than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) >=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) >= 0);\r\n            }\r\n            break;\r\n        case O_GT:\r\n            /* comparison on 'greater than' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) >\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) > 0);\r\n            }\r\n            break;\r\n        case O_NE:\r\n            /* comparison on 'not equal to' */\r\n            xassert(code.arg.arg.x != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n                value = (mpl_internal_eval_numeric(mpl, code.arg.arg.x) !=\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y));\r\n            else\r\n            {   sym1 = mpl_internal_eval_symbolic(mpl, code.arg.arg.x);\r\n                sym2 = mpl_internal_eval_symbolic(mpl, code.arg.arg.y);\r\n                value = (mpl_internal_compare_symbols(mpl, sym1, sym2) != 0);\r\n            }\r\n            break;\r\n        case O_AND:\r\n            /* conjunction (logical \"and\") */\r\n            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) &&\r\n                mpl_internal_eval_logical(mpl, code.arg.arg.y);\r\n            break;\r\n        case O_OR:\r\n            /* disjunction (logical \"or\") */\r\n            value = mpl_internal_eval_logical(mpl, code.arg.arg.x) ||\r\n                mpl_internal_eval_logical(mpl, code.arg.arg.y);\r\n            break;\r\n        case O_IN:\r\n            /* test on 'x in Y' */\r\n        {\r\n            tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n        }\r\n            break;\r\n        case O_NOTIN:\r\n            /* test on 'x not in Y' */\r\n        {\r\n            tuple = mpl_internal_eval_tuple(mpl, code.arg.arg.x);\r\n            value = !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n        }\r\n            break;\r\n        case O_WITHIN:\r\n            /* test on 'X within Y' */\r\n        {\r\n            set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = 1;\r\n            for (memb = set.head; memb != null; memb = memb.next)\r\n            {  if (!mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n            break;\r\n        case O_NOTWITHIN:\r\n            /* test on 'X not within Y' */\r\n        {\r\n            set = mpl_internal_eval_elemset(mpl, code.arg.arg.x);\r\n            value = 1;\r\n            for (memb = set.head; memb != null; memb = memb.next)\r\n            {  if (mpl_internal_is_member(mpl, code.arg.arg.y, memb.tuple))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n            break;\r\n        case O_FORALL:\r\n            /* conjunction (A-quantification) */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 1;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_log_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_EXISTS:\r\n            /* disjunction (E-quantification) */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = 0;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_log_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.bit = value;\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_eval_tuple(mpl, code){\r\n    var value;\r\n    xassert(code != null);\r\n    xassert(code.type == A_TUPLE);\r\n    xassert(code.dim > 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_tuple(mpl, code.value.tuple);\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_TUPLE:\r\n        /* make n-tuple */\r\n    {\r\n        value = null;\r\n        for (var e = code.arg.list; e != null; e = e.next)\r\n            value = mpl_internal_expand_tuple(mpl, value, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n    }\r\n        break;\r\n        case O_CVTTUP:\r\n            /* convert to 1-tuple */\r\n            value = mpl_internal_expand_tuple(mpl, null,\r\n                mpl_internal_eval_symbolic(mpl, code.arg.arg.x));\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.tuple = mpl_internal_copy_tuple(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_set_func(mpl, info)\r\n{     /* this is auxiliary routine used to perform iterated operation\r\n on n-tuple \"integrand\" within domain scope */\r\n    var tuple;\r\n    switch (info.code.op)\r\n    {  case O_SETOF:\r\n        /* compute next n-tuple and add it to the set; in this case\r\n         duplicate n-tuples are silently ignored */\r\n        tuple = mpl_internal_eval_tuple(mpl, info.code.arg.loop.x);\r\n        if (mpl_internal_find_tuple(mpl, info.value, tuple) == null)\r\n            mpl_internal_add_tuple(mpl, info.value, tuple);\r\n        break;\r\n        case O_BUILD:\r\n            /* construct next n-tuple using current values assigned to\r\n             *free* dummy indices as its components and add it to the\r\n             set; in this case duplicate n-tuples cannot appear */\r\n            mpl_internal_add_tuple(mpl, info.value, mpl_internal_get_domain_tuple(mpl,\r\n                info.code.arg.loop.domain));\r\n            break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_elemset(mpl, code){\r\n    var value, e, info;\r\n    xassert(code != null);\r\n    xassert(code.type == A_ELEMSET);\r\n    xassert(code.dim > 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_elemset(mpl, code.value.set);\r\n\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_MEMSET:\r\n        /* take member of set */\r\n    {   var tuple;\r\n        tuple = null;\r\n        for (e = code.arg.set.list; e != null; e = e.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        value = mpl_internal_copy_elemset(mpl,\r\n            mpl_internal_eval_member_set(mpl, code.arg.set.set, tuple));\r\n    }\r\n        break;\r\n        case O_MAKE:\r\n            /* make elemental set of n-tuples */\r\n        {\r\n            value = mpl_internal_create_elemset(mpl, code.dim);\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n                mpl_internal_check_then_add(mpl, value, mpl_internal_eval_tuple(mpl, e.x));\r\n        }\r\n            break;\r\n        case O_UNION:\r\n            /* union of two elemental sets */\r\n            value = mpl_internal_set_union(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DIFF:\r\n            /* difference between two elemental sets */\r\n            value = mpl_internal_set_diff(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SYMDIFF:\r\n            /* symmetric difference between two elemental sets */\r\n            value = mpl_internal_set_symdiff(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_INTER:\r\n            /* intersection of two elemental sets */\r\n            value = mpl_internal_set_inter(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_CROSS:\r\n            /* cross (Cartesian) product of two elemental sets */\r\n            value = mpl_internal_set_cross(mpl,\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_elemset(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_DOTS:\r\n            /* build \"arithmetic\" elemental set */\r\n            value = mpl_internal_create_arelset(mpl,\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                mpl_internal_eval_numeric(mpl, code.arg.arg.y),\r\n                code.arg.arg.z == null ? 1.0 : mpl_internal_eval_numeric(mpl,\r\n                    code.arg.arg.z));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_elemset(mpl, code.arg.arg.y);\r\n            else\r\n                value = mpl_internal_eval_elemset(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SETOF:\r\n            /* compute elemental set */\r\n        {   info ={};\r\n            info.code = code;\r\n            info.value = mpl_internal_create_elemset(mpl, code.dim);\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_set_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        case O_BUILD:\r\n            /* build elemental set identical to domain set */\r\n        {   info = {};\r\n            info.code = code;\r\n            info.value = mpl_internal_create_elemset(mpl, code.dim);\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_set_func);\r\n            value = info.value;\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.set = mpl_internal_copy_elemset(mpl, value);\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_null_func(mpl, info){\r\n    /* this is dummy routine used to enter the domain scope */\r\n\r\n    xassert(info == null);\r\n}\r\n\r\nfunction mpl_internal_is_member(mpl, code, tuple){\r\n    var value, e, temp, j;\r\n    xassert(code != null);\r\n    xassert(code.type == A_ELEMSET);\r\n    xassert(code.dim > 0);\r\n    xassert(tuple != null);\r\n    switch (code.op)\r\n    {  case O_MEMSET:\r\n        /* check if given n-tuple is member of elemental set, which\r\n         is assigned to member of model set */\r\n    {\r\n        var set;\r\n        /* evaluate reference to elemental set */\r\n        temp = null;\r\n        for (e = code.arg.set.list; e != null; e = e.next)\r\n            temp = mpl_internal_expand_tuple(mpl, temp, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        set = mpl_internal_eval_member_set(mpl, code.arg.set.set, temp);\r\n        /* check if the n-tuple is contained in the set array */\r\n        temp = mpl_internal_build_subtuple(mpl, tuple, set.dim);\r\n        value = (mpl_internal_find_tuple(mpl, set, temp) != null);\r\n    }\r\n        break;\r\n        case O_MAKE:\r\n            /* check if given n-tuple is member of literal set */\r\n        {\r\n            var that;\r\n            value = 0;\r\n            temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);\r\n            for (e = code.arg.list; e != null; e = e.next)\r\n            {  that = mpl_internal_eval_tuple(mpl, e.x);\r\n                value = (mpl_internal_compare_tuples(mpl, temp, that) == 0);\r\n                if (value) break;\r\n            }\r\n        }\r\n            break;\r\n        case O_UNION:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) ||\r\n                mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_DIFF:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) &&\r\n                !mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_SYMDIFF:\r\n        {   var in1 = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);\r\n            var in2 = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            value = (in1 && !in2) || (!in1 && in2);\r\n        }\r\n            break;\r\n        case O_INTER:\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple) &&\r\n                mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            break;\r\n        case O_CROSS:\r\n        {\r\n            value = mpl_internal_is_member(mpl, code.arg.arg.x, tuple);\r\n            if (value)\r\n            {  for (j = 1; j <= code.arg.arg.x.dim; j++)\r\n            {  xassert(tuple != null);\r\n                tuple = tuple.next;\r\n            }\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            }\r\n        }\r\n            break;\r\n        case O_DOTS:\r\n            /* check if given 1-tuple is member of \"arithmetic\" set */\r\n        {\r\n            var x, t0, tf, dt;\r\n            xassert(code.dim == 1);\r\n            /* compute \"parameters\" of the \"arithmetic\" set */\r\n            t0 = mpl_internal_eval_numeric(mpl, code.arg.arg.x);\r\n            tf = mpl_internal_eval_numeric(mpl, code.arg.arg.y);\r\n            if (code.arg.arg.z == null)\r\n                dt = 1.0;\r\n            else\r\n                dt = mpl_internal_eval_numeric(mpl, code.arg.arg.z);\r\n            /* make sure the parameters are correct */\r\n            mpl_internal_arelset_size(mpl, t0, tf, dt);\r\n            /* if component of 1-tuple is symbolic, not numeric, the\r\n             1-tuple cannot be member of \"arithmetic\" set */\r\n            xassert(tuple.sym != null);\r\n            if (tuple.sym.str != null)\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            /* determine numeric value of the component */\r\n            x = tuple.sym.num;\r\n            /* if the component value is out of the set range, the\r\n             1-tuple is not in the set */\r\n            if (dt > 0.0 && !(t0 <= x && x <= tf) ||\r\n                dt < 0.0 && !(tf <= x && x <= t0))\r\n            {  value = 0;\r\n                break;\r\n            }\r\n            /* estimate ordinal number of the 1-tuple in the set */\r\n            j = ((((x - t0) / dt) + 0.5)|0) + 1;\r\n            /* perform the main check */\r\n            value = (mpl_internal_arelset_member(mpl, t0, tf, dt, j) == x);\r\n        }\r\n            break;\r\n        case O_FORK:\r\n            /* check if given n-tuple is member of conditional set */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.y, tuple);\r\n            else\r\n                value = mpl_internal_is_member(mpl, code.arg.arg.z, tuple);\r\n            break;\r\n        case O_SETOF:\r\n            /* check if given n-tuple is member of computed set */\r\n            /* it is not clear how to efficiently perform the check not\r\n             computing the entire elemental set :+( */\r\n            mpl_internal_error(mpl, \"implementation restriction; in/within setof{} not allowed\");\r\n            break;\r\n        case O_BUILD:\r\n            /* check if given n-tuple is member of domain set */\r\n        {\r\n            temp = mpl_internal_build_subtuple(mpl, tuple, code.dim);\r\n            /* try to enter the domain scope; if it is successful,\r\n             the n-tuple is in the domain set */\r\n            value = (mpl_internal_eval_within_domain(mpl, code.arg.loop.domain,\r\n                temp, null, mpl_internal_null_func) == 0);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    return value;\r\n}\r\n\r\nfunction mpl_internal_iter_form_func(mpl, info)\r\n{     /* this is auxiliary routine used to perform iterated operation\r\n on linear form \"integrand\" within domain scope */\r\n    switch (info.code.op)\r\n    {  case O_SUM:\r\n        /* summation over domain */\r\n        /* the routine linear_comb needs to look through all terms\r\n         of both linear forms to reduce identical terms, so using\r\n         it here is not a good idea (for example, evaluation of\r\n         sum{i in 1..n} x[i] required quadratic time); the better\r\n         idea is to gather all terms of the integrand in one list\r\n         and reduce identical terms only once after all terms of\r\n         the resultant linear form have been evaluated */\r\n    {   var term;\r\n        var form = mpl_internal_eval_formula(mpl, info.code.arg.loop.x);\r\n        if (info.value == null)\r\n        {  xassert(info.tail == null);\r\n            info.value = form;\r\n        }\r\n        else\r\n        {  xassert(info.tail != null);\r\n            info.tail.next = form;\r\n        }\r\n        for (term = form; term != null; term = term.next)\r\n            info.tail = term;\r\n    }\r\n        break;\r\n        default:\r\n            xassert(info != info);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_eval_formula(mpl, code){\r\n    var value;\r\n    xassert(code != null);\r\n    xassert(code.type == A_FORMULA);\r\n    xassert(code.dim == 0);\r\n    /* if the operation has a side effect, invalidate and delete the\r\n     resultant value */\r\n    if (code.vflag && code.valid)\r\n    {  code.valid = 0;\r\n        mpl_internal_delete_value(mpl, code.type, code.value);\r\n    }\r\n    /* if resultant value is valid, no evaluation is needed */\r\n    if (code.valid)\r\n    {  return mpl_internal_copy_formula(mpl, code.value.form);\r\n\r\n    }\r\n    /* evaluate pseudo-code recursively */\r\n    switch (code.op)\r\n    {  case O_MEMVAR:\r\n        /* take member of variable */\r\n    {\r\n        var e;\r\n        var tuple = null;\r\n        for (e = code.arg.var_.list; e != null; e = e.next)\r\n            tuple = mpl_internal_expand_tuple(mpl, tuple, mpl_internal_eval_symbolic(mpl,\r\n                e.x));\r\n        xassert(code.arg.var_.suff == DOT_NONE);\r\n        value = mpl_internal_single_variable(mpl,\r\n            mpl_internal_eval_member_var(mpl, code.arg.var_.var_, tuple));\r\n    }\r\n        break;\r\n        case O_CVTLFM:\r\n            /* convert to linear form */\r\n            value = mpl_internal_constant_term(mpl, mpl_internal_eval_numeric(mpl,\r\n                code.arg.arg.x));\r\n            break;\r\n        case O_PLUS:\r\n            /* unary plus */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                0.0, mpl_internal_constant_term(mpl, 0.0),\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_MINUS:\r\n            /* unary minus */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                0.0, mpl_internal_constant_term(mpl, 0.0),\r\n                -1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x));\r\n            break;\r\n        case O_ADD:\r\n            /* addition */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_SUB:\r\n            /* subtraction */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                +1.0, mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                -1.0, mpl_internal_eval_formula(mpl, code.arg.arg.y));\r\n            break;\r\n        case O_MUL:\r\n            /* multiplication */\r\n            xassert(code.arg.arg.x != null);\r\n            xassert(code.arg.arg.y != null);\r\n            if (code.arg.arg.x.type == A_NUMERIC)\r\n            {  xassert(code.arg.arg.y.type == A_FORMULA);\r\n                value = mpl_internal_linear_comb(mpl,\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.x),\r\n                    mpl_internal_eval_formula(mpl, code.arg.arg.y),\r\n                    0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            }\r\n            else\r\n            {  xassert(code.arg.arg.x.type == A_FORMULA);\r\n                xassert(code.arg.arg.y.type == A_NUMERIC);\r\n                value = mpl_internal_linear_comb(mpl,\r\n                    mpl_internal_eval_numeric(mpl, code.arg.arg.y),\r\n                    mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                    0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            }\r\n            break;\r\n        case O_DIV:\r\n            /* division */\r\n            value = mpl_internal_linear_comb(mpl,\r\n                mpl_internal_fp_div(mpl, 1.0, mpl_internal_eval_numeric(mpl, code.arg.arg.y)),\r\n                mpl_internal_eval_formula(mpl, code.arg.arg.x),\r\n                0.0, mpl_internal_constant_term(mpl, 0.0));\r\n            break;\r\n        case O_FORK:\r\n            /* if-then-else */\r\n            if (mpl_internal_eval_logical(mpl, code.arg.arg.x))\r\n                value = mpl_internal_eval_formula(mpl, code.arg.arg.y);\r\n            else if (code.arg.arg.z == null)\r\n                value = mpl_internal_constant_term(mpl, 0.0);\r\n            else\r\n                value = mpl_internal_eval_formula(mpl, code.arg.arg.z);\r\n            break;\r\n        case O_SUM:\r\n            /* summation over domain */\r\n        {   var info = {};\r\n            info.code = code;\r\n            info.value = mpl_internal_constant_term(mpl, 0.0);\r\n            info.tail = null;\r\n            mpl_internal_loop_within_domain(mpl, code.arg.loop.domain, info,\r\n                mpl_internal_iter_form_func);\r\n            value = mpl_internal_reduce_terms(mpl, info.value);\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n    /* save resultant value */\r\n    xassert(!code.valid);\r\n    code.valid = 1;\r\n    code.value.form = mpl_internal_copy_formula(mpl, value);\r\n    return value;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        DATA TABLES                         * * */\r\n/**********************************************************************/\r\n\r\nvar mpl_tab_num_args = exports[\"mpl_tab_num_args\"] = function(dca){\r\n    /* returns the number of arguments */\r\n    return dca.na;\r\n};\r\n\r\nvar mpl_tab_get_arg = exports[\"mpl_tab_get_arg\"] = function(dca, k){\r\n    /* returns pointer to k-th argument */\r\n    xassert(1 <= k && k <= dca.na);\r\n    return dca.arg[k];\r\n};\r\n\r\nvar mpl_tab_get_args = exports[\"mpl_tab_get_args\"] = function(dca, k){\r\n    return dca.arg;\r\n};\r\n\r\nvar mpl_tab_num_flds = exports[\"mpl_tab_num_flds\"] = function (dca){\r\n    /* returns the number of fields */\r\n    return dca.nf;\r\n};\r\n\r\nvar mpl_tab_get_name = exports[\"mpl_tab_get_name\"] = function(dca, k)\r\n{     /* returns pointer to name of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    return dca.name[k];\r\n};\r\n\r\nvar mpl_tab_get_type = exports[\"mpl_tab_get_type\"] = function(dca, k)\r\n{     /* returns type of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    return dca.type[k];\r\n};\r\n\r\nvar mpl_tab_get_num = exports[\"mpl_tab_get_num\"] = function(dca, k){\r\n    /* returns numeric value of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == 'N');\r\n    return dca.num[k];\r\n};\r\n\r\nvar mpl_tab_get_str = exports[\"mpl_tab_get_str\"] = function(dca, k){\r\n    /* returns pointer to string value of k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == 'S');\r\n    xassert(dca.str[k] != null);\r\n    return dca.str[k];\r\n};\r\n\r\nvar mpl_tab_set_num = exports[\"mpl_tab_set_num\"] = function(dca, k, num){\r\n    /* assign numeric value to k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == '?');\r\n    dca.type[k] = 'N';\r\n    dca.num[k] = num;\r\n};\r\n\r\nvar mpl_tab_set_str = exports[\"mpl_tab_set_str\"] = function(dca, k, str){\r\n    /* assign string value to k-th field */\r\n    xassert(1 <= k && k <= dca.nf);\r\n    xassert(dca.type[k] == '?');\r\n    //xassert(str.length <= MAX_LENGTH);\r\n    xassert(dca.str[k] != null);\r\n    dca.type[k] = 'S';\r\n    dca.str[k] = str;\r\n};\r\n\r\nfunction mpl_internal_write_func(mpl, tab){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var dca = mpl.dca;\r\n    var out;\r\n    var sym;\r\n    var k;\r\n    /* evaluate field values */\r\n    k = 0;\r\n    for (out = tab.u.out.list; out != null; out = out.next)\r\n    {  k++;\r\n        switch (out.code.type)\r\n        {  case A_NUMERIC:\r\n            dca.type[k] = 'N';\r\n            dca.num[k] = mpl_internal_eval_numeric(mpl, out.code);\r\n            dca.str[k][0] = '\\0';\r\n            break;\r\n            case A_SYMBOLIC:\r\n                sym = mpl_internal_eval_symbolic(mpl, out.code);\r\n                if (sym.str == null)\r\n                {  dca.type[k] = 'N';\r\n                    dca.num[k] = sym.num;\r\n                    dca.str[k][0] = '\\0';\r\n                }\r\n                else\r\n                {  dca.type[k] = 'S';\r\n                    dca.num[k] = 0.0;\r\n                    dca.str[k] = sym.str;\r\n                }\r\n                break;\r\n            default:\r\n                xassert(out != out);\r\n        }\r\n    }\r\n    /* write record to output table */\r\n    mpl_tab_drv_write(mpl);\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_table(mpl, tab){\r\n    /* execute table statement */\r\n    var arg;\r\n    var fld;\r\n    var in_;\r\n    var out;\r\n    var dca;\r\n    var set;\r\n    var k;\r\n    var buf; // [MAX_LENGTH+1];\r\n    /* allocate table driver communication area */\r\n    xassert(mpl.dca == null);\r\n    mpl.dca = dca = {};\r\n    dca.id = 0;\r\n    dca.link = null;\r\n    dca.na = 0;\r\n    dca.arg = null;\r\n    dca.nf = 0;\r\n    dca.name = null;\r\n    dca.type = null;\r\n    dca.num = null;\r\n    dca.str = null;\r\n    /* allocate arguments */\r\n    xassert(dca.na == 0);\r\n    for (arg = tab.arg; arg != null; arg = arg.next)\r\n        dca.na++;\r\n    dca.arg = new Array(1+dca.na);\r\n    for (k = 1; k <= dca.na; k++) dca.arg[k] = null;\r\n    /* evaluate argument values */\r\n    k = 0;\r\n    for (arg = tab.arg; arg != null; arg = arg.next)\r\n    {\r\n        k++;\r\n        xassert(arg.code.type == A_SYMBOLIC);\r\n        var sym = mpl_internal_eval_symbolic(mpl, arg.code);\r\n        if (sym.str == null)\r\n            buf = String(sym.num);\r\n        else\r\n            buf = sym.str;\r\n        dca.arg[k] = buf;\r\n    }\r\n    /* perform table input/output */\r\n    switch (tab.type)    {\r\n        case A_INPUT:\r\n            /* read data from input table */\r\n            /* add the only member to the control set and assign it empty\r\n             elemental set */\r\n            set = tab.u.in_.set;\r\n            if (set != null)\r\n            {  if (set.data)\r\n                mpl_internal_error(mpl, set.name + \" already provided with data\");\r\n                xassert(set.array.head == null);\r\n                mpl_internal_add_member(mpl, set.array, null).value.set =\r\n                    mpl_internal_create_elemset(mpl, set.dimen);\r\n                set.data = 1;\r\n            }\r\n            /* check parameters specified in the input list */\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n            {  if (in_.par.data)\r\n                mpl_internal_error(mpl, in_.par.name + \" already provided with data\");\r\n                in_.par.data = 1;\r\n            }\r\n            /* allocate and initialize fields */\r\n            xassert(dca.nf == 0);\r\n            for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n                dca.nf++;\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n                dca.nf++;\r\n            dca.name = new Array(1+dca.nf);\r\n            dca.type = new Array(1+dca.nf);\r\n            dca.num = new Float64Array(1+dca.nf);\r\n            dca.str = new Array(1+dca.nf);\r\n            k = 0;\r\n            for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n            {   k++;\r\n                dca.name[k] = fld.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n            {   k++;\r\n                dca.name[k] = in_.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            /* open input table */\r\n            mpl_tab_drv_open(mpl, 'R');\r\n            /* read and process records */\r\n            for (;;)\r\n            {   var tup;\r\n                /* reset field types */\r\n                for (k = 1; k <= dca.nf; k++)\r\n                    dca.type[k] = '?';\r\n                /* read next record */\r\n                if (mpl_tab_drv_read(mpl)) break;\r\n                /* all fields must be set by the driver */\r\n                for (k = 1; k <= dca.nf; k++)\r\n                {  if (dca.type[k] == '?')\r\n                    mpl_internal_error(mpl, \"field \" + dca.name[k] + \" missing in input table\");\r\n                }\r\n                /* construct n-tuple */\r\n                tup = null;\r\n                k = 0;\r\n                for (fld = tab.u.in_.fld; fld != null; fld = fld.next)\r\n                {  k++;\r\n                    xassert(k <= dca.nf);\r\n                    switch (dca.type[k])\r\n                    {  case 'N':\r\n                        tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_num(mpl,\r\n                            dca.num[k]));\r\n                        break;\r\n                        case 'S':\r\n                            //xassert(dca.str[k].length <= MAX_LENGTH);\r\n                            tup = mpl_internal_expand_tuple(mpl, tup, mpl_internal_create_symbol_str(mpl, dca.str[k]));\r\n                            break;\r\n                        default:\r\n                            xassert(dca != dca);\r\n                    }\r\n                }\r\n                /* add n-tuple just read to the control set */\r\n                if (tab.u.in_.set != null)\r\n                    mpl_internal_check_then_add(mpl, tab.u.in_.set.array.head.value.set,\r\n                        mpl_internal_copy_tuple(mpl, tup));\r\n                /* assign values to the parameters in the input list */\r\n                for (in_ = tab.u.in_.list; in_ != null; in_ = in_.next)\r\n                {   var memb;\r\n                    k++;\r\n                    xassert(k <= dca.nf);\r\n                    /* there must be no member with the same n-tuple */\r\n                    if (mpl_internal_find_member(mpl, in_.par.array, tup) != null)\r\n                        mpl_internal_error(mpl, in_.par.name + mpl_internal_format_tuple(mpl, '[', tup) + \" already defined\");\r\n                    /* create new parameter member with given n-tuple */\r\n                    memb = mpl_internal_add_member(mpl, in_.par.array, mpl_internal_copy_tuple(mpl, tup))\r\n                    ;\r\n                    /* assign value to the parameter member */\r\n                    switch (in_.par.type)\r\n                    {  case A_NUMERIC:\r\n                        case A_INTEGER:\r\n                        case A_BINARY:\r\n                            if (dca.type[k] != 'N')\r\n                                mpl_internal_error(mpl, in_.par.name + \" requires numeric data\");\r\n                            memb.value.num = dca.num[k];\r\n                            break;\r\n                        case A_SYMBOLIC:\r\n                            switch (dca.type[k])\r\n                            {  case 'N':\r\n                                memb.value.sym = mpl_internal_create_symbol_num(mpl,\r\n                                    dca.num[k]);\r\n                                break;\r\n                                case 'S':\r\n                                    //xassert(dca.str[k].length <= MAX_LENGTH);\r\n                                    memb.value.sym = mpl_internal_create_symbol_str(mpl, dca.str[k]);\r\n                                    break;\r\n                                default:\r\n                                    xassert(dca != dca);\r\n                            }\r\n                            break;\r\n                        default:\r\n                            xassert(in_ != in_);\r\n                    }\r\n                }\r\n            }\r\n            /* close input table */\r\n            mpl.dca = null;\r\n            break;\r\n        case A_OUTPUT:\r\n            /* write data to output table */\r\n            /* allocate and initialize fields */\r\n            xassert(dca.nf == 0);\r\n            for (out = tab.u.out.list; out != null; out = out.next)\r\n                dca.nf++;\r\n            dca.name = new Array(1+dca.nf);\r\n            dca.type = new Array(1+dca.nf);\r\n            dca.num = new Float64Array(1+dca.nf);\r\n            dca.str = new Array(1+dca.nf);\r\n            k = 0;\r\n            for (out = tab.u.out.list; out != null; out = out.next)\r\n            {  k++;\r\n                dca.name[k] = out.name;\r\n                dca.type[k] = '?';\r\n                dca.num[k] = 0.0;\r\n                dca.str[k] = '';\r\n            }\r\n            /* open output table */\r\n            mpl_tab_drv_open(mpl, 'W');\r\n            /* evaluate fields and write records */\r\n            mpl_internal_loop_within_domain(mpl, tab.u.out.domain, tab, mpl_internal_write_func);\r\n            /* close output table */\r\n            mpl_tab_drv_flush(mpl);\r\n            mpl.dca = null;\r\n            break;\r\n        default:\r\n            xassert(tab != tab);\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      MODEL STATEMENTS                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_check_func(mpl, chk){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    if (!mpl_internal_eval_logical(mpl, chk.code))\r\n        mpl_internal_error(mpl, \"check\" + mpl_internal_format_tuple(mpl, '[', mpl_internal_get_domain_tuple(mpl, chk.domain)) + \" failed\");\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_check(mpl, chk){\r\n    mpl_internal_loop_within_domain(mpl, chk.domain, chk, mpl_internal_check_func);\r\n\r\n}\r\n\r\nfunction mpl_internal_display_set(mpl, set, memb){\r\n    /* display member of model set */\r\n    var s = memb.value.set;\r\n    var m;\r\n    mpl_internal_write_text(mpl, set.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + (s.head == null ? \" is empty\" : \":\"));\r\n    for (m = s.head; m != null; m = m.next)\r\n        mpl_internal_write_text(mpl, \"   \" + mpl_internal_format_tuple(mpl, '(', m.tuple));\r\n}\r\n\r\nfunction mpl_internal_display_par(mpl, par, memb){\r\n    /* display member of model parameter */\r\n    switch (par.type)\r\n    {   case A_NUMERIC:\r\n        case A_INTEGER:\r\n        case A_BINARY:\r\n            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \" = \" + memb.value.num);\r\n            break;\r\n        case A_SYMBOLIC:\r\n            mpl_internal_write_text(mpl, par.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \" = \" + mpl_internal_format_symbol(mpl, memb.value.sym));\r\n            break;\r\n        default:\r\n            xassert(par != par);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_var(mpl, var_, memb, suff){\r\n    /* display member of model variable */\r\n    if (suff == DOT_NONE || suff == DOT_VAL)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".val = \" +\r\n            memb.value.var_.prim);\r\n    else if (suff == DOT_LB)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".lb = \" +\r\n            (memb.value.var_.var_.lbnd == null ? -DBL_MAX : memb.value.var_.lbnd));\r\n    else if (suff == DOT_UB)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".ub = \" +\r\n            (memb.value.var_.var_.ubnd == null ? +DBL_MAX : memb.value.var_.ubnd));\r\n    else if (suff == DOT_STATUS)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".status = \" +\r\n            memb.value.var_.stat);\r\n    else if (suff == DOT_DUAL)\r\n        mpl_internal_write_text(mpl, var_.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".dual = \" +\r\n            memb.value.var_.dual);\r\n    else\r\n        xassert(suff != suff);\r\n}\r\n\r\nfunction mpl_internal_display_con(mpl, con, memb, suff){\r\n    /* display member of model constraint */\r\n    if (suff == DOT_NONE || suff == DOT_VAL)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".val = \" +\r\n            memb.value.con.prim);\r\n    else if (suff == DOT_LB)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".lb = \" +\r\n            (memb.value.con.con.lbnd == null ? -DBL_MAX : memb.value.con.lbnd));\r\n    else if (suff == DOT_UB)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".ub = \" +\r\n            (memb.value.con.con.ubnd == null ? +DBL_MAX : memb.value.con.ubnd));\r\n    else if (suff == DOT_STATUS)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".status = \" +\r\n            memb.value.con.stat);\r\n    else if (suff == DOT_DUAL)\r\n        mpl_internal_write_text(mpl, con.name + mpl_internal_format_tuple(mpl, '[', memb.tuple) + \".dual = \" +\r\n            memb.value.con.dual);\r\n    else\r\n        xassert(suff != suff);\r\n}\r\n\r\nfunction mpl_internal_display_memb(mpl, code){\r\n    /* display member specified by pseudo-code */\r\n    var memb = {value:{}};\r\n    var e;\r\n    xassert(code.op == O_MEMNUM || code.op == O_MEMSYM\r\n        || code.op == O_MEMSET || code.op == O_MEMVAR\r\n        || code.op == O_MEMCON);\r\n    memb.tuple = null;\r\n    for (e = code.arg.par.list || code.arg.var_.list; e != null; e = e.next)\r\n        memb.tuple = mpl_internal_expand_tuple(mpl, memb.tuple, mpl_internal_eval_symbolic(mpl,\r\n            e.x));\r\n    switch (code.op)\r\n    {  case O_MEMNUM:\r\n        memb.value.num = mpl_internal_eval_member_num(mpl, code.arg.par.par,\r\n            memb.tuple);\r\n        mpl_internal_display_par(mpl, code.arg.par.par, memb);\r\n        break;\r\n        case O_MEMSYM:\r\n            memb.value.sym = mpl_internal_eval_member_sym(mpl, code.arg.par.par,\r\n                memb.tuple);\r\n            mpl_internal_display_par(mpl, code.arg.par.par, memb);\r\n            break;\r\n        case O_MEMSET:\r\n            memb.value.set = mpl_internal_eval_member_set(mpl, code.arg.set.set,\r\n                memb.tuple);\r\n            mpl_internal_display_set(mpl, code.arg.set.set, memb);\r\n            break;\r\n        case O_MEMVAR:\r\n            memb.value.var_ = mpl_internal_eval_member_var(mpl, code.arg.var_.var_,\r\n                memb.tuple);\r\n            mpl_internal_display_var\r\n                (mpl, code.arg.var_.var_, memb, code.arg.var_.suff);\r\n            break;\r\n        case O_MEMCON:\r\n            memb.value.con = mpl_internal_eval_member_con(mpl, code.arg.con.con,\r\n                memb.tuple);\r\n            mpl_internal_display_con\r\n                (mpl, code.arg.con.con, memb, code.arg.con.suff);\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_code(mpl, code){\r\n    /* display value of expression */\r\n    switch (code.type)\r\n    {  case A_NUMERIC:\r\n        /* numeric value */\r\n    {\r\n        var num = mpl_internal_eval_numeric(mpl, code);\r\n        mpl_internal_write_text(mpl, String(num));\r\n    }\r\n        break;\r\n        case A_SYMBOLIC:\r\n            /* symbolic value */\r\n        {\r\n            var sym = mpl_internal_eval_symbolic(mpl, code);\r\n            mpl_internal_write_text(mpl, mpl_internal_format_symbol(mpl, sym));\r\n        }\r\n            break;\r\n        case A_LOGICAL:\r\n            /* logical value */\r\n        {\r\n            var bit = mpl_internal_eval_logical(mpl, code);\r\n            mpl_internal_write_text(mpl, bit ? \"true\" : \"false\");\r\n        }\r\n            break;\r\n        case A_TUPLE:\r\n            /* n-tuple */\r\n        {\r\n            var tuple = mpl_internal_eval_tuple(mpl, code);\r\n            mpl_internal_write_text(mpl, mpl_internal_format_tuple(mpl, '(', tuple));\r\n        }\r\n            break;\r\n        case A_ELEMSET:\r\n            /* elemental set */\r\n        {   var set = mpl_internal_eval_elemset(mpl, code);\r\n            if (set.head == 0)\r\n                mpl_internal_write_text(mpl, \"set is empty\");\r\n            for (var memb = set.head; memb != null; memb = memb.next)\r\n                mpl_internal_write_text(mpl, \"   \" + mpl_internal_format_tuple(mpl, '(', memb.tuple));\r\n        }\r\n            break;\r\n        case A_FORMULA:\r\n            /* linear form */\r\n        {   var term;\r\n            var form = mpl_internal_eval_formula(mpl, code);\r\n            if (form == null)\r\n                mpl_internal_write_text(mpl, \"linear form is empty\");\r\n            for (term = form; term != null; term = term.next)\r\n            {  if (term.var_ == null)\r\n                mpl_internal_write_text(mpl, \"   \" + term.coef);\r\n            else\r\n                mpl_internal_write_text(mpl, \"   \" + term.coef + \" \" + term.var_.var_.name + mpl_internal_format_tuple(mpl, '[', term.var_.memb.tuple));\r\n            }\r\n        }\r\n            break;\r\n        default:\r\n            xassert(code != code);\r\n    }\r\n}\r\n\r\nfunction mpl_internal_display_func(mpl, dpy){\r\n    var memb;\r\n    /* this is auxiliary routine to work within domain scope */\r\n    for (var entry = dpy.list; entry != null; entry = entry.next)\r\n    {  if (entry.type == A_INDEX)\r\n    {  /* dummy index */\r\n        var slot = entry.u.slot;\r\n        mpl_internal_write_text(mpl, slot.name + \" = \" + mpl_internal_format_symbol(mpl, slot.value));\r\n    }\r\n    else if (entry.type == A_SET)\r\n    {  /* model set */\r\n        var set = entry.u.set;\r\n        if (set.assign != null)\r\n        {  /* the set has assignment expression; evaluate all its\r\n         members over entire domain */\r\n            mpl_internal_eval_whole_set(mpl, set);\r\n        }\r\n        else\r\n        {  /* the set has no assignment expression; refer to its\r\n         any existing member ignoring resultant value to check\r\n         the data provided the data section */\r\n            if (set.gadget != null && set.data == 0)\r\n            {  /* initialize the set with data from a plain set */\r\n                mpl_internal_saturate_set(mpl, set);\r\n            }\r\n            if (set.array.head != null)\r\n                mpl_internal_eval_member_set(mpl, set, set.array.head.tuple);\r\n        }\r\n        /* display all members of the set array */\r\n        if (set.array.head == null)\r\n            mpl_internal_write_text(mpl, set.name + \" has empty content\");\r\n        for (memb = set.array.head; memb != null; memb =\r\n            memb.next) mpl_internal_display_set(mpl, set, memb);\r\n    }\r\n    else if (entry.type == A_PARAMETER)\r\n    {  /* model parameter */\r\n        var par = entry.u.par;\r\n        if (par.assign != null)\r\n        {  /* the parameter has an assignment expression; evaluate\r\n         all its member over entire domain */\r\n            mpl_internal_eval_whole_par(mpl, par);\r\n        }\r\n        else\r\n        {  /* the parameter has no assignment expression; refer to\r\n         its any existing member ignoring resultant value to\r\n         check the data provided in the data section */\r\n            if (par.array.head != null)\r\n            {  if (par.type != A_SYMBOLIC)\r\n                mpl_internal_eval_member_num(mpl, par, par.array.head.tuple);\r\n            else\r\n                mpl_internal_eval_member_sym(mpl, par, par.array.head.tuple);\r\n            }\r\n        }\r\n        /* display all members of the parameter array */\r\n        if (par.array.head == null)\r\n            mpl_internal_write_text(mpl, par.name + \" has empty content\");\r\n        for (memb = par.array.head; memb != null; memb =\r\n            memb.next) mpl_internal_display_par(mpl, par, memb);\r\n    }\r\n    else if (entry.type == A_VARIABLE)\r\n    {  /* model variable */\r\n        var var_ = entry.u.var_;\r\n        xassert(mpl.flag_p);\r\n        /* display all members of the variable array */\r\n        if (var_.array.head == null)\r\n            mpl_internal_write_text(mpl, var_.name + \" has empty content\");\r\n        for (memb = var_.array.head; memb != null; memb = memb.next)\r\n            mpl_internal_display_var(mpl, var_, memb, DOT_NONE);\r\n    }\r\n    else if (entry.type == A_CONSTRAINT)\r\n    {  /* model constraint */\r\n        var con = entry.u.con;\r\n        xassert(mpl.flag_p);\r\n        /* display all members of the constraint array */\r\n        if (con.array.head == null)\r\n            mpl_internal_write_text(mpl, con.name + \" has empty content\");\r\n        for (memb = con.array.head; memb != null; memb = memb.next)\r\n            mpl_internal_display_con(mpl, con, memb, DOT_NONE);\r\n    }\r\n    else if (entry.type == A_EXPRESSION)\r\n    {  /* expression */\r\n        var code = entry.u.code;\r\n        if (code.op == O_MEMNUM || code.op == O_MEMSYM ||\r\n            code.op == O_MEMSET || code.op == O_MEMVAR ||\r\n            code.op == O_MEMCON)\r\n            mpl_internal_display_memb(mpl, code);\r\n        else\r\n            mpl_internal_display_code(mpl, code);\r\n    }\r\n    else\r\n        xassert(entry != entry);\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_display(mpl, dpy){\r\n    mpl_internal_loop_within_domain(mpl, dpy.domain, dpy, mpl_internal_display_func);\r\n}\r\n\r\nfunction mpl_internal_print_char(mpl, c){\r\n    if (mpl.prt_fp == null)\r\n        mpl_internal_write_char(mpl, c);\r\n    else\r\n        mpl.prt_fp(c);\r\n}\r\n\r\nfunction mpl_internal_print_text(mpl, buf){\r\n    xassert(buf.length < OUTBUF_SIZE);\r\n    for (var c = 0; c < buf.length; c++) mpl_internal_print_char(mpl, buf[c]);\r\n}\r\n\r\nfunction mpl_internal_printf_func(mpl, prt){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var entry;\r\n    var fmt;\r\n    var from;\r\n    var c;\r\n    var value;\r\n    /* evaluate format control string */\r\n    var sym = mpl_internal_eval_symbolic(mpl, prt.fmt);\r\n    if (sym.str == null)\r\n        fmt = String(sym.num);\r\n    else\r\n        fmt = sym.str;\r\n    /* scan format control string and perform formatting output */\r\n    entry = prt.list;\r\n    for (c = 0; c < fmt.length; c++)\r\n    {  if (fmt[c] == '%')\r\n    {  /* scan format specifier */\r\n        from = c++;\r\n        if (fmt[c] == '%')\r\n        {  mpl_internal_print_char(mpl, '%');\r\n            continue;\r\n        }\r\n        if (entry == null) break;\r\n        /* scan optional flags */\r\n        while (fmt[c] == '-' || fmt[c] == '+' || fmt[c] == ' ' || fmt[c] == '#' || fmt[c] == '0') c++;\r\n        /* scan optional minimum field width */\r\n        while (isdigit(fmt[c])) c++;\r\n        /* scan optional precision */\r\n        if (fmt[c] == '.')\r\n        {  c++;\r\n            while (isdigit(fmt[c])) c++;\r\n        }\r\n        /* scan conversion specifier and perform formatting */\r\n        // save = (c+1);  *(c+1) = '\\0';\r\n        if (fmt[c] == 'd' || fmt[c] == 'i' || fmt[c] == 'e' || fmt[c] == 'E' ||\r\n            fmt[c] == 'f' || fmt[c] == 'F' || fmt[c] == 'g' || fmt[c] == 'G')\r\n        {  /* the specifier requires numeric value */\r\n            xassert(entry != null);\r\n            switch (entry.code.type)\r\n            {  case A_NUMERIC:\r\n                value = mpl_internal_eval_numeric(mpl, entry.code);\r\n                break;\r\n                case A_SYMBOLIC:\r\n                    sym = mpl_internal_eval_symbolic(mpl, entry.code);\r\n                    if (sym.str != null)\r\n                        mpl_internal_error(mpl, \"cannot convert \" + mpl_internal_format_symbol(mpl, sym) + \" to floating-point number\");\r\n                    value = sym.num;\r\n                    break;\r\n                case A_LOGICAL:\r\n                    if (mpl_internal_eval_logical(mpl, entry.code))\r\n                        value = 1.0;\r\n                    else\r\n                        value = 0.0;\r\n                    break;\r\n                default:\r\n                    xassert(entry != entry);\r\n            }\r\n            if (fmt[c] == 'd' || fmt[c] == 'i')\r\n            {  var int_max = INT_MAX;\r\n                if (!(-int_max <= value && value <= +int_max))\r\n                    mpl_internal_error(mpl, \"cannot convert \" + value + \" to integer\");\r\n                mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), Math.floor(value + 0.5)|0));\r\n            }\r\n            else\r\n                mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), value));\r\n        }\r\n        else if (fmt[c] == 's')\r\n        {  /* the specifier requires symbolic value */\r\n            switch (entry.code.type)\r\n            {   case A_NUMERIC:\r\n                value = String(mpl_internal_eval_numeric(mpl, entry.code));\r\n                break;\r\n                case A_LOGICAL:\r\n                    if (mpl_internal_eval_logical(mpl, entry.code))\r\n                        value = \"T\";\r\n                    else\r\n                        value = \"F\";\r\n                    break;\r\n                case A_SYMBOLIC:\r\n                    sym = mpl_internal_eval_symbolic(mpl, entry.code);\r\n                    if (sym.str == null)\r\n                        value = String(sym.num);\r\n                    else\r\n                        value = sym.str;\r\n                    break;\r\n                default:\r\n                    xassert(entry != entry);\r\n            }\r\n            mpl_internal_print_text(mpl, sprintf(fmt.slice(from, c+1), value));\r\n        }\r\n        else\r\n            mpl_internal_error(mpl, \"format specifier missing or invalid\");\r\n        //*(c+1) = save;\r\n        entry = entry.next;\r\n    }\r\n    else if (fmt[c] == '\\\\')\r\n    {  /* write some control character */\r\n        c++;\r\n        if (fmt[c] == 't')\r\n            mpl_internal_print_char(mpl, '\\t');\r\n        else if (fmt[c] == 'n')\r\n            mpl_internal_print_char(mpl, '\\n');\r\n        else if (fmt[c] == '\\0')\r\n        {  /* format string ends with backslash */\r\n            mpl_internal_error(mpl, \"invalid use of escape character \\\\ in format control string\");\r\n        }\r\n        else\r\n            mpl_internal_print_char(mpl, fmt[c]);\r\n    }\r\n    else\r\n    {  /* write character without formatting */\r\n        mpl_internal_print_char(mpl, fmt[c]);\r\n    }\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_printf(mpl, prt){\r\n    if (prt.fname == null)\r\n    {\r\n        mpl.prt_file = null;\r\n    }\r\n    else\r\n    {   /* evaluate file name string */\r\n        var sym = mpl_internal_eval_symbolic(mpl, prt.fname);\r\n        if (sym.str == null)\r\n            mpl.prt_file = sym.num;\r\n        else\r\n            mpl.prt_file = sym.str;\r\n    }\r\n    mpl_internal_loop_within_domain(mpl, prt.domain, prt, mpl_internal_printf_func);\r\n}\r\n\r\nfunction mpl_internal_for_func(mpl, fur){\r\n    /* this is auxiliary routine to work within domain scope */\r\n    var save = mpl.stmt;\r\n    for (var stmt = fur.list; stmt != null; stmt = stmt.next)\r\n        mpl_internal_execute_statement(mpl, stmt);\r\n    mpl.stmt = save;\r\n    return 0;\r\n}\r\n\r\nfunction mpl_internal_execute_for(mpl, fur){\r\n    mpl_internal_loop_within_domain(mpl, fur.domain, fur, mpl_internal_for_func);\r\n}\r\n\r\nfunction mpl_internal_execute_statement(mpl, stmt){\r\n    mpl.stmt = stmt;\r\n    switch (stmt.type)\r\n    {   case A_SET:\r\n        case A_PARAMETER:\r\n        case A_VARIABLE:\r\n            break;\r\n        case A_CONSTRAINT:\r\n            xprintf(\"Generating \" + stmt.u.con.name + \"...\");\r\n            mpl_internal_eval_whole_con(mpl, stmt.u.con);\r\n            break;\r\n        case A_TABLE:\r\n            switch (stmt.u.tab.type)\r\n            {  case A_INPUT:\r\n                xprintf(\"Reading \" + stmt.u.tab.name + \"...\");\r\n                break;\r\n                case A_OUTPUT:\r\n                    xprintf(\"Writing \" + stmt.u.tab.name + \"...\");\r\n                    break;\r\n                default:\r\n                    xassert(stmt != stmt);\r\n            }\r\n            mpl_internal_execute_table(mpl, stmt.u.tab);\r\n            break;\r\n        case A_SOLVE:\r\n            break;\r\n        case A_CHECK:\r\n            xprintf(\"Checking (line \" + stmt.line + \")...\");\r\n            mpl_internal_execute_check(mpl, stmt.u.chk);\r\n            break;\r\n        case A_DISPLAY:\r\n            mpl_internal_write_text(mpl, \"Display statement at line \" + stmt.line);\r\n            mpl_internal_execute_display(mpl, stmt.u.dpy);\r\n            break;\r\n        case A_PRINTF:\r\n            mpl_internal_execute_printf(mpl, stmt.u.prt);\r\n            break;\r\n        case A_FOR:\r\n            mpl_internal_execute_for(mpl, stmt.u.fur);\r\n            break;\r\n        default:\r\n            xassert(stmt != stmt);\r\n    }\r\n}\r\n\r\n/* glpmpl04.c */\r\n\r\n/**********************************************************************/\r\n/* * *              GENERATING AND POSTSOLVING MODEL              * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_alloc_content(mpl){\r\n    var stmt;\r\n    /* walk through all model statements */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  switch (stmt.type)\r\n    {  case A_SET:\r\n            /* model set */\r\n            xassert(stmt.u.set.array == null);\r\n            stmt.u.set.array = mpl_internal_create_array(mpl, A_ELEMSET,\r\n                stmt.u.set.dim);\r\n            break;\r\n        case A_PARAMETER:\r\n            /* model parameter */\r\n            xassert(stmt.u.par.array == null);\r\n            switch (stmt.u.par.type)\r\n            {  case A_NUMERIC:\r\n                case A_INTEGER:\r\n                case A_BINARY:\r\n                    stmt.u.par.array = mpl_internal_create_array(mpl, A_NUMERIC,\r\n                        stmt.u.par.dim);\r\n                    break;\r\n                case A_SYMBOLIC:\r\n                    stmt.u.par.array = mpl_internal_create_array(mpl, A_SYMBOLIC,\r\n                        stmt.u.par.dim);\r\n                    break;\r\n                default:\r\n                    xassert(stmt != stmt);\r\n            }\r\n            break;\r\n        case A_VARIABLE:\r\n            /* model variable */\r\n            xassert(stmt.u.var_.array == null);\r\n            stmt.u.var_.array = mpl_internal_create_array(mpl, A_ELEMVAR,\r\n                stmt.u.var_.dim);\r\n            break;\r\n        case A_CONSTRAINT:\r\n            /* model constraint/objective */\r\n            xassert(stmt.u.con.array == null);\r\n            stmt.u.con.array = mpl_internal_create_array(mpl, A_ELEMCON,\r\n                stmt.u.con.dim);\r\n            break;\r\n        case A_TABLE:\r\n        case A_SOLVE:\r\n        case A_CHECK:\r\n        case A_DISPLAY:\r\n        case A_PRINTF:\r\n        case A_FOR:\r\n            /* functional statements have no content array */\r\n            break;\r\n        default:\r\n            xassert(stmt != stmt);\r\n    }\r\n    }\r\n}\r\n\r\nfunction mpl_internal_generate_model(mpl){\r\n    var stmt;\r\n\r\n    xassert(!mpl.flag_p);\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {   mpl_internal_execute_statement(mpl, stmt);\r\n        if (mpl.stmt.type == A_SOLVE) break;\r\n    }\r\n    mpl.stmt = stmt;\r\n}\r\n\r\nfunction mpl_internal_build_problem(mpl){\r\n    var stmt;\r\n\r\n    var memb;\r\n    var v;\r\n    var c;\r\n    var t;\r\n    var i, j;\r\n    xassert(mpl.m == 0);\r\n    xassert(mpl.n == 0);\r\n    xassert(mpl.row == null);\r\n    xassert(mpl.col == null);\r\n    /* check that all elemental variables has zero column numbers */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n            xassert(memb.value.var_.j == 0);\r\n    }\r\n    }\r\n    /* assign row numbers to elemental constraints and objectives */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_CONSTRAINT)\r\n    {  c = stmt.u.con;\r\n        for (memb = c.array.head; memb != null; memb = memb.next)\r\n        {  xassert(memb.value.con.i == 0);\r\n            memb.value.con.i = ++mpl.m;\r\n            /* walk through linear form and mark elemental variables,\r\n             which are referenced at least once */\r\n            for (t = memb.value.con.form; t != null; t = t.next)\r\n            {  xassert(t.var_ != null);\r\n                t.var_.memb.value.var_.j = -1;\r\n            }\r\n        }\r\n    }\r\n    }\r\n    /* assign column numbers to marked elemental variables */\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n            if (memb.value.var_.j != 0) memb.value.var_.j =\r\n                ++mpl.n;\r\n    }\r\n    }\r\n    /* build list of rows */\r\n    mpl.row = new Array(1+mpl.m);\r\n    for (i = 1; i <= mpl.m; i++) mpl.row[i] = null;\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_CONSTRAINT)\r\n    {  c = stmt.u.con;\r\n        for (memb = c.array.head; memb != null; memb = memb.next)\r\n        {  i = memb.value.con.i;\r\n            xassert(1 <= i && i <= mpl.m);\r\n            xassert(mpl.row[i] == null);\r\n            mpl.row[i] = memb.value.con;\r\n        }\r\n    }\r\n    }\r\n    for (i = 1; i <= mpl.m; i++) xassert(mpl.row[i] != null);\r\n    /* build list of columns */\r\n    mpl.col = new Array(1+mpl.n);\r\n    for (j = 1; j <= mpl.n; j++) mpl.col[j] = null;\r\n    for (stmt = mpl.model; stmt != null; stmt = stmt.next)\r\n    {  if (stmt.type == A_VARIABLE)\r\n    {  v = stmt.u.var_;\r\n        for (memb = v.array.head; memb != null; memb = memb.next)\r\n        {  j = memb.value.var_.j;\r\n            if (j == 0) continue;\r\n            xassert(1 <= j && j <= mpl.n);\r\n            xassert(mpl.col[j] == null);\r\n            mpl.col[j] = memb.value.var_;\r\n        }\r\n    }\r\n    }\r\n    for (j = 1; j <= mpl.n; j++) xassert(mpl.col[j] != null);\r\n}\r\n\r\nfunction mpl_internal_postsolve_model(mpl){\r\n    var stmt;\r\n\r\n    xassert(!mpl.flag_p);\r\n    mpl.flag_p = 1;\r\n    for (stmt = mpl.stmt; stmt != null; stmt = stmt.next)\r\n        mpl_internal_execute_statement(mpl, stmt);\r\n    mpl.stmt = null;\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                        INPUT/OUTPUT                        * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_open_input(mpl, name, callback){\r\n    mpl.line = 0;\r\n    mpl.column = 0;\r\n    mpl.c = '\\n';\r\n    mpl.token = 0;\r\n    mpl.imlen = 0;\r\n    mpl.image = '';\r\n    mpl.value = 0.0;\r\n    mpl.b_token = T_EOF;\r\n    mpl.b_imlen = 0;\r\n    mpl.b_image = '';\r\n    mpl.b_value = 0.0;\r\n    mpl.f_dots = 0;\r\n    mpl.f_scan = 0;\r\n    mpl.f_token = 0;\r\n    mpl.f_imlen = 0;\r\n    mpl.f_image = '';\r\n    mpl.f_value = 0.0;\r\n    xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);\r\n    mpl.c_ptr = 0;\r\n    xassert(mpl.in_fp == null);\r\n    mpl.in_fp = callback;\r\n    mpl.in_file = name || 'input';\r\n    /* scan the very first character */\r\n    mpl_internal_get_char(mpl);\r\n    /* scan the very first token */\r\n    mpl_internal_get_token(mpl);\r\n}\r\n\r\nfunction mpl_internal_read_char(mpl){\r\n    var c;\r\n    xassert(mpl.in_fp != null);\r\n    c = mpl.in_fp();\r\n    if (c < 0)\r\n    {\r\n        c = MPL_EOF;\r\n    }\r\n    return c;\r\n}\r\n\r\nfunction mpl_internal_close_input(mpl){\r\n    xassert(mpl.in_fp != null);\r\n    mpl.in_fp = null;\r\n}\r\n\r\nfunction mpl_internal_open_output(mpl, name, callback){\r\n    xassert(mpl.out_fp == null);\r\n    if (callback == null)\r\n    {\r\n        mpl.out_fp = function(data){xprintf(data)};\r\n    }\r\n    else\r\n    {   mpl.out_fp = callback;\r\n        mpl.out_file = name;\r\n    }\r\n    mpl.out_buffer = '';\r\n}\r\n\r\nfunction mpl_internal_write_char(mpl, c){\r\n    xassert(mpl.out_fp != null);\r\n    if (c == '\\n'){\r\n        mpl.out_fp(mpl.out_buffer, mpl.prt_file);\r\n        mpl.out_buffer = '';\r\n    } else\r\n        mpl.out_buffer += c;\r\n}\r\n\r\nfunction mpl_internal_write_text(mpl, str){\r\n    xassert(mpl.out_fp != null);\r\n    mpl.out_fp(str, mpl.prt_file);\r\n}\r\n\r\nfunction mpl_internal_flush_output(mpl){\r\n    xassert(mpl.out_fp != null);\r\n    if (mpl.out_buffer.length > 0){\r\n        mpl.out_fp(mpl.out_buffer, mpl.prt_file);\r\n        mpl.out_buffer = '';\r\n    }\r\n}\r\n\r\n/**********************************************************************/\r\n/* * *                      SOLVER INTERFACE                      * * */\r\n/**********************************************************************/\r\n\r\nfunction mpl_internal_error(mpl, msg){\r\n    var error;\r\n    switch (mpl.phase)\r\n    {  case 1:\r\n        case 2:\r\n            /* translation phase */\r\n            error = new Error(mpl.in_file + \":\" + mpl.line + \": \" + msg);\r\n            error[\"line\"] = mpl.line;\r\n            error[\"column\"] = mpl.column;\r\n            mpl_internal_print_context(mpl);\r\n            break;\r\n        case 3:\r\n            /* generation/postsolve phase */\r\n            var line = (mpl.stmt == null ? 0 : mpl.stmt.line);\r\n            var column = (mpl.stmt == null ? 0 : mpl.stmt.column);\r\n            error = new Error(line + \": \" + msg);\r\n            error[\"line\"] = line;\r\n            error[\"column\"] = column;\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    mpl.phase = 4;\r\n    throw error;\r\n}\r\n\r\nfunction mpl_internal_warning(mpl, msg){\r\n    switch (mpl.phase)\r\n    {  case 1:\r\n        case 2:\r\n            /* translation phase */\r\n            xprintf(mpl.in_file + \":\" + mpl.line + \": warning: \" + msg);\r\n            break;\r\n        case 3:\r\n            /* generation/postsolve phase */\r\n            xprintf(mpl.mod_file + \":\" + (mpl.stmt == null ? 0 : mpl.stmt.line) + \": warning: \" + msg);\r\n            break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n}\r\n\r\nvar mpl_initialize = exports[\"mpl_initialize\"] = function(){\r\n    var mpl = {};\r\n    /* scanning segment */\r\n    mpl.line = 0;\r\n    mpl.column = 0;\r\n    mpl.c = 0;\r\n    mpl.token = 0;\r\n    mpl.imlen = 0;\r\n    mpl.image = '';\r\n    mpl.value = 0.0;\r\n    mpl.b_token = 0;\r\n    mpl.b_imlen = 0;\r\n    mpl.b_image = '';\r\n    mpl.b_value = 0.0;\r\n    mpl.f_dots = 0;\r\n    mpl.f_scan = 0;\r\n    mpl.f_token = 0;\r\n    mpl.f_imlen = 0;\r\n    mpl.f_image = '';\r\n    mpl.f_value = 0.0;\r\n    mpl.context = new Array(CONTEXT_SIZE);\r\n    xfillArr(mpl.context, 0, ' ', CONTEXT_SIZE);\r\n    mpl.c_ptr = 0;\r\n    mpl.flag_d = 0;\r\n    /* translating segment */\r\n    //mpl.pool = dmp_create_poolx(0);\r\n    mpl.tree = {};\r\n    mpl.model = null;\r\n    mpl.flag_x = 0;\r\n    mpl.as_within = 0;\r\n    mpl.as_in = 0;\r\n    mpl.as_binary = 0;\r\n    mpl.flag_s = 0;\r\n    /* common segment\r\n     mpl.strings = {};\r\n     mpl.symbols = {};\r\n     mpl.tuples = {};\r\n     mpl.arrays = {};\r\n     mpl.members = {};\r\n     mpl.elemvars = {};\r\n     mpl.formulae = {};\r\n     mpl.elemcons = {};*/\r\n    mpl.a_list = null;\r\n    mpl.sym_buf = '';\r\n    mpl.tup_buf = '';\r\n\r\n    /* generating/postsolving segment */\r\n    mpl.rand = rng_create_rand();\r\n    mpl.flag_p = 0;\r\n    mpl.stmt = null;\r\n    mpl.dca = null;\r\n    mpl.m = 0;\r\n    mpl.n = 0;\r\n    mpl.row = null;\r\n    mpl.col = null;\r\n    /* input/output segment */\r\n    mpl.in_fp = null;\r\n    mpl.in_file = null;\r\n    mpl.out_fp = null;\r\n    mpl.out_file = null;\r\n    mpl.prt_fp = null;\r\n    mpl.prt_file = null;\r\n    /* solver interface segment */\r\n    mpl.phase = 0;\r\n    mpl.mod_file = null;\r\n    mpl.mpl_buf = '';\r\n    return mpl;\r\n};\r\n\r\nvar mpl_read_model = exports[\"mpl_read_model\"] = function(mpl, name, callback, skip_data){\r\n\r\n    function skip(){\r\n        xprintf(mpl.line + \" line\" + (mpl.line == 1 ? \"\" : \"s\") + \" were read\");\r\n        mpl_internal_close_input(mpl);\r\n        /* return to the calling program */\r\n        return mpl.phase;\r\n    }\r\n\r\n    if (mpl.phase != 0)\r\n        xerror(\"mpl_read_model: invalid call sequence\");\r\n    if (callback == null)\r\n        xerror(\"mpl_read_model: no input specified\");\r\n    /* translate model section */\r\n    mpl.phase = 1;\r\n    xprintf(\"Reading model section from \" + name + \" ...\");\r\n    mpl_internal_open_input(mpl, name, callback);\r\n    mpl_internal_model_section(mpl);\r\n    if (mpl.model == null)\r\n        mpl_internal_error(mpl, \"empty model section not allowed\");\r\n    /* save name of the input text file containing model section for\r\n     error diagnostics during the generation phase */\r\n    mpl.mod_file = mpl.in_file;\r\n\r\n    /* allocate content arrays for all model objects */\r\n    mpl_internal_alloc_content(mpl);\r\n    /* optional data section may begin with the keyword 'data' */\r\n    if (mpl_internal_is_keyword(mpl, \"data\"))\r\n    {  if (skip_data)\r\n    {  mpl_internal_warning(mpl, \"data section ignored\");\r\n        return skip();\r\n    }\r\n        mpl.flag_d = 1;\r\n        mpl_internal_get_token(mpl /* data */);\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n        /* translate data section */\r\n        mpl.phase = 2;\r\n        xprintf(\"Reading data section from \" + name + \" ...\");\r\n        mpl_internal_data_section(mpl);\r\n    }\r\n    /* process end statement */\r\n    mpl_internal_end_statement(mpl);\r\n    return skip();\r\n};\r\n\r\nvar mpl_read_data = exports[\"mpl_read_data\"] = function(mpl, name, callback){\r\n    if (!(mpl.phase == 1 || mpl.phase == 2))\r\n        xerror(\"mpl_read_data: invalid call sequence\");\r\n    if (callback == null)\r\n        xerror(\"mpl_read_data: no input specified\");\r\n    /* process data section */\r\n    mpl.phase = 2;\r\n    xprintf(\"Reading data section from \" + name + \" ...\");\r\n    mpl.flag_d = 1;\r\n    mpl_internal_open_input(mpl, name, callback);\r\n    /* in this case the keyword 'data' is optional */\r\n    if (mpl_internal_is_literal(mpl, \"data\"))\r\n    {  mpl_internal_get_token(mpl /* data */);\r\n        if (mpl.token != T_SEMICOLON)\r\n            mpl_internal_error(mpl, \"semicolon missing where expected\");\r\n        mpl_internal_get_token(mpl /* ; */);\r\n    }\r\n    mpl_internal_data_section(mpl);\r\n    /* process end statement */\r\n    mpl_internal_end_statement(mpl);\r\n    xprintf(mpl.line + \" line\" + (mpl.line == 1 ? \"\" : \"s\") + \" were read\");\r\n    mpl_internal_close_input(mpl);\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\nvar mpl_generate = exports[\"mpl_generate\"] = function(mpl, name, callback, tablecb){\r\n    if (!(mpl.phase == 1 || mpl.phase == 2))\r\n        xerror(\"mpl_generate: invalid call sequence\");\r\n    /* generate model */\r\n    mpl.phase = 3;\r\n    mpl.tablecb = tablecb;\r\n    mpl_internal_open_output(mpl, name, callback);\r\n    mpl_internal_generate_model(mpl);\r\n    mpl_internal_flush_output(mpl);\r\n    /* build problem instance */\r\n    mpl_internal_build_problem(mpl);\r\n    /* generation phase has been finished */\r\n    xprintf(\"Model has been successfully generated\");\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\nvar mpl_get_prob_name = exports[\"mpl_get_prob_name\"] = function(mpl){\r\n    return mpl.mod_file;\r\n};\r\n\r\nvar mpl_get_num_rows = exports[\"mpl_get_num_rows\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_num_rows: invalid call sequence\");\r\n    return mpl.m;\r\n};\r\n\r\nvar mpl_get_num_cols = exports[\"mpl_get_num_cols\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_num_cols: invalid call sequence\");\r\n    return mpl.n;\r\n};\r\n\r\nvar mpl_get_row_name = exports[\"mpl_get_row_name\"] = function(mpl, i){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_name: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_name: i = \" + i + \"; row number out of range\");\r\n    var name = mpl.row[i].con.name;\r\n    var len = name.length;\r\n    xassert(len <= 255);\r\n    name += mpl_internal_format_tuple(mpl, '[', mpl.row[i].memb.tuple).slice(0, 255);\r\n    if (name.length == 255) name = name.slice(0,252) + '...';\r\n    xassert(name.length <= 255);\r\n    return name;\r\n};\r\n\r\nvar mpl_get_row_kind = exports[\"mpl_get_row_kind\"] = function(mpl, i){\r\n    var kind;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_kind: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_kind: i = \" + i + \"; row number out of range\");\r\n    switch (mpl.row[i].con.type)\r\n    {  case A_CONSTRAINT:\r\n        kind = MPL_ST; break;\r\n        case A_MINIMIZE:\r\n            kind = MPL_MIN; break;\r\n        case A_MAXIMIZE:\r\n            kind = MPL_MAX; break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar mpl_get_row_bnds = exports[\"mpl_get_row_bnds\"] = function(mpl, i, callback){\r\n    var con;\r\n    var type;\r\n    var lb, ub;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_bnds: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_bnds: i = \" + i + \"; row number out of range\");\r\n    con = mpl.row[i];\r\n    lb = (con.con.lbnd == null ? -DBL_MAX : con.lbnd);\r\n    ub = (con.con.ubnd == null ? +DBL_MAX : con.ubnd);\r\n    if (lb == -DBL_MAX && ub == +DBL_MAX){\r\n        type = MPL_FR; lb = ub = 0.0;\r\n    }\r\n    else if (ub == +DBL_MAX){\r\n        type = MPL_LO; ub = 0.0;\r\n    }\r\n    else if (lb == -DBL_MAX){\r\n        type = MPL_UP; lb = 0.0;\r\n    }\r\n    else if (con.con.lbnd != con.con.ubnd)\r\n        type = MPL_DB;\r\n    else\r\n        type = MPL_FX;\r\n    callback(lb, ub);\r\n    return type;\r\n};\r\n\r\nvar mpl_get_mat_row = exports[\"mpl_get_mat_row\"] = function(mpl, i, ndx, val){\r\n    var term;\r\n    var len = 0;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_mat_row: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_mat_row: i = \" + i + \"; row number out of range\");\r\n    for (term = mpl.row[i].form; term != null; term = term.next)\r\n    {  xassert(term.var_ != null);\r\n        len++;\r\n        xassert(len <= mpl.n);\r\n        if (ndx != null) ndx[len] = term.var_.j;\r\n        if (val != null) val[len] = term.coef;\r\n    }\r\n    return len;\r\n};\r\n\r\nvar mpl_get_row_c0 = exports[\"mpl_get_row_c0\"] = function(mpl, i){\r\n    var con;\r\n    var c0;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_row_c0: invalid call sequence\");\r\n    if (!(1 <= i && i <= mpl.m))\r\n        xerror(\"mpl_get_row_c0: i = \" + i + \"; row number out of range\");\r\n    con = mpl.row[i];\r\n    if (con.con.lbnd == null && con.con.ubnd == null)\r\n        c0 = - con.lbnd;\r\n    else\r\n        c0 = 0.0;\r\n    return c0;\r\n};\r\n\r\nvar mpl_get_col_name = exports[\"mpl_get_col_name\"] = function(mpl, j){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_name: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_name: j = \" + j + \"; column number out of range\");\r\n    var name = mpl.col[j].var_.name;\r\n    var len = name.length;\r\n    xassert(len <= 255);\r\n    name += mpl_internal_format_tuple(mpl, '[', mpl.col[j].memb.tuple);\r\n    if (name.length == 255) name = name.slice(0,252) + '...';\r\n    xassert(name.length <= 255);\r\n    return name;\r\n};\r\n\r\nvar mpl_get_col_kind = exports[\"mpl_get_col_kind\"] = function(mpl, j){\r\n    var kind;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_kind: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_kind: j = \" + j + \"; column number out of range\");\r\n    switch (mpl.col[j].var_.type)\r\n    {  case A_NUMERIC:\r\n        kind = MPL_NUM; break;\r\n        case A_INTEGER:\r\n            kind = MPL_INT; break;\r\n        case A_BINARY:\r\n            kind = MPL_BIN; break;\r\n        default:\r\n            xassert(mpl != mpl);\r\n    }\r\n    return kind;\r\n};\r\n\r\nvar mpl_get_col_bnds = exports[\"mpl_get_col_bnds\"] = function(mpl, j, callback){\r\n    var var_;\r\n    var type;\r\n    var lb, ub;\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_get_col_bnds: invalid call sequence\");\r\n    if (!(1 <= j && j <= mpl.n))\r\n        xerror(\"mpl_get_col_bnds: j = \" + j + \"; column number out of range\");\r\n    var_ = mpl.col[j];\r\n    lb = (var_.var_.lbnd == null ? -DBL_MAX : var_.lbnd);\r\n    ub = (var_.var_.ubnd == null ? +DBL_MAX : var_.ubnd);\r\n    if (lb == -DBL_MAX && ub == +DBL_MAX){\r\n        type = MPL_FR; lb = ub = 0.0;\r\n    }\r\n    else if (ub == +DBL_MAX){\r\n        type = MPL_LO; ub = 0.0;\r\n    }\r\n    else if (lb == -DBL_MAX){\r\n        type = MPL_UP; lb = 0.0;\r\n    }\r\n    else if (var_.var_.lbnd != var_.var_.ubnd)\r\n        type = MPL_DB;\r\n    else\r\n        type = MPL_FX;\r\n    callback(lb, ub);\r\n    return type;\r\n};\r\n\r\nvar mpl_has_solve_stmt = exports[\"mpl_has_solve_stmt\"] = function(mpl){\r\n    if (mpl.phase != 3)\r\n        xerror(\"mpl_has_solve_stmt: invalid call sequence\");\r\n    return mpl.flag_s;\r\n};\r\n\r\nvar mpl_put_row_soln = exports[\"mpl_put_row_soln\"] = function(mpl, i, stat, prim, dual){\r\n    /* store row (constraint/objective) solution components */\r\n    xassert(mpl.phase == 3);\r\n    xassert(1 <= i && i <= mpl.m);\r\n    mpl.row[i].stat = stat;\r\n    mpl.row[i].prim = prim;\r\n    mpl.row[i].dual = dual;\r\n};\r\n\r\nvar mpl_put_col_soln = exports[\"mpl_put_col_soln\"] = function (mpl, j, stat, prim, dual){\r\n    /* store column (variable) solution components */\r\n    xassert(mpl.phase == 3);\r\n    xassert(1 <= j && j <= mpl.n);\r\n    mpl.col[j].stat = stat;\r\n    mpl.col[j].prim = prim;\r\n    mpl.col[j].dual = dual;\r\n};\r\n\r\nvar mpl_postsolve = exports[\"mpl_postsolve\"] = function(mpl){\r\n    if (!(mpl.phase == 3 && !mpl.flag_p))\r\n        xerror(\"mpl_postsolve: invalid call sequence\");\r\n    /* perform postsolving */\r\n    mpl_internal_postsolve_model(mpl);\r\n    mpl_internal_flush_output(mpl);\r\n    /* postsolving phase has been finished */\r\n    xprintf(\"Model has been successfully processed\");\r\n    /* return to the calling program */\r\n    return mpl.phase;\r\n};\r\n\r\n/* glpmpl05.c */\r\n\r\nfunction mpl_internal_fn_gmtime(mpl){\r\n    /* obtain the current calendar time (UTC) */\r\n    return Math.round(Date.now() / 1000);\r\n}\r\n\r\nvar mpl_internal_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\r\nvar mpl_internal_moon = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n\r\nfunction mpl_internal_mulstr(v, n){\r\n    var ret = '';\r\n    while (n > 0) {\r\n        ret += v;\r\n        n--;\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction mpl_internal_error1(mpl, str, s, fmt, f, msg){\r\n    xprintf(\"Input string passed to str2time:\");\r\n    xprintf(str);\r\n    xprintf(mpl_internal_mulstr('^', s + 1));\r\n    xprintf(\"Format string passed to str2time:\\n\");\r\n    xprintf(fmt);\r\n    xprintf(mpl_internal_mulstr('^', f + 1));\r\n    mpl_internal_error(mpl, msg);\r\n}\r\n\r\nfunction mpl_internal_fn_str2time(mpl, str, fmt){\r\n    /* convert character string to the calendar time */\r\n    var j, year, month, day, hh, mm, ss, zone;\r\n    var s, f;\r\n\r\n    function err1(){mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset value incomplete or invalid\")}\r\n    function err2(){mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset value out of range\")}\r\n    function test(){\r\n        /* check a matching character in the input string */\r\n        if (str[s] != fmt[f])\r\n            mpl_internal_error1(mpl, str, s, fmt, f, \"character mismatch\");\r\n        s++;\r\n    }\r\n\r\n    year = month = day = hh = mm = ss = -1;\r\n    zone = INT_MAX;\r\n    s = 0;\r\n    for (f = 0; f < fmt.length; f++)\r\n    {  if (fmt[f] == '%')\r\n    {  f++;\r\n        if (fmt[f] == 'b' || fmt[f] == 'h')\r\n        {  /* the abbreviated month name */\r\n            var k;\r\n            var name;\r\n            if (month >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            for (month = 1; month <= 12; month++)\r\n            {  name = mpl_internal_moon[month-1];\r\n                var b = false;\r\n                for (k = 0; k <= 2; k++)\r\n                {  if (s[k].toUpperCase() != name[k].toUpperCase())\r\n                {b = true; break}\r\n                }\r\n                if (b) continue;\r\n                s += 3;\r\n                for (k = 3; name[k] != '\\0'; k++)\r\n                {  if (str[s].toUpperCase() != name[k].toUpperCase()) break;\r\n                    s++;\r\n                }\r\n                break;\r\n            }\r\n            if (month > 12)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"abbreviated month name missing or invalid\");\r\n        }\r\n        else if (fmt[f] == 'd')\r\n        {  /* the day of the month as a decimal number (01..31) */\r\n            if (day >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day missing or invalid\");\r\n            day = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                day = 10 * day + ((str[s++]) - '0');\r\n            if (!(1 <= day && day <= 31))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"day out of range\");\r\n        }\r\n        else if (fmt[f] == 'H')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         (00..23) */\r\n            if (hh >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour missing or invalid\")\r\n                ;\r\n            hh = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                hh = 10 * hh + ((str[s++]) - '0');\r\n            if (!(0 <= hh && hh <= 23))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"hour out of range\");\r\n        }\r\n        else if (fmt[f] == 'm')\r\n        {  /* the month as a decimal number (01..12) */\r\n            if (month >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month multiply specified\"\r\n                );\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month missing or invalid\"\r\n                );\r\n            month = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                month = 10 * month + ((str[s++]) - '0');\r\n            if (!(1 <= month && month <= 12))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"month out of range\");\r\n        }\r\n        else if (fmt[f] == 'M')\r\n        {  /* the minute as a decimal number (00..59) */\r\n            if (mm >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute missing or invalid\");\r\n            mm = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                mm = 10 * mm + ((str[s++]) - '0');\r\n            if (!(0 <= mm && mm <= 59))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"minute out of range\");\r\n        }\r\n        else if (fmt[f] == 'S')\r\n        {  /* the second as a decimal number (00..60) */\r\n            if (ss >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second missing or invalid\");\r\n            ss = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                ss = 10 * ss + ((str[s++]) - '0');\r\n            if (!(0 <= ss && ss <= 60))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"second out of range\");\r\n        }\r\n        else if (fmt[f] == 'y')\r\n        {  /* the year without a century as a decimal number\r\n         (00..99); the values 00 to 68 mean the years 2000 to\r\n         2068 while the values 69 to 99 mean the years 1969 to\r\n         1999 */\r\n            if (year >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year missing or invalid\")\r\n                ;\r\n            year = (str[s++]) - '0';\r\n            if ('0' <= str[s] && str[s] <= '9')\r\n                year = 10 * year + ((str[s++]) - '0');\r\n            year += (year >= 69 ? 1900 : 2000);\r\n        }\r\n        else if (fmt[f] == 'Y')\r\n        {  /* the year as a decimal number, using the Gregorian\r\n         calendar */\r\n            if (year >= 0)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year multiply specified\")\r\n                ;\r\n            while (str[s] == ' ') s++;\r\n            if (!('0' <= str[s] && str[s] <= '9'))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year missing or invalid\")\r\n                ;\r\n            year = 0;\r\n            for (j = 1; j <= 4; j++)\r\n            {  if (!('0' <= str[s] && str[s] <= '9')) break;\r\n                year = 10 * year + ((str[s++]) - '0');\r\n            }\r\n            if (!(1 <= year && year <= 4000))\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"year out of range\");\r\n        }\r\n        else if (fmt[f] == 'z')\r\n        {  /* time zone offset in the form zhhmm */\r\n            var z;\r\n            if (zone != INT_MAX)\r\n                mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset multiply specified\");\r\n            while (str[s] == ' ') s++;\r\n            if (str[s] == 'Z')\r\n            {   z = hh = mm = 0; s++;\r\n\r\n            } else {\r\n                if (str[s] == '+'){\r\n                    z = +1; s++;\r\n                }\r\n                else if (str[s] == '-'){\r\n                    z = -1; s++;\r\n                }\r\n                else\r\n                    mpl_internal_error1(mpl, str, s, fmt, f, \"time zone offset sign missing\");\r\n                hh = 0;\r\n                for (j = 1; j <= 2; j++)\r\n                {  if (!('0' <= str[s] && str[s] <= '9'))\r\n                    err1();\r\n                    hh = 10 * hh + ((str[s++]) - '0');\r\n                }\r\n                if (hh > 23)\r\n                    err2();\r\n                if (str[s] == ':')\r\n                {  s++;\r\n                    if (!('0' <= str[s] && str[s] <= '9')) err1();\r\n                }\r\n                mm = 0;\r\n                if (('0' <= str[s] && str[s] <= '9')){\r\n                    for (j = 1; j <= 2; j++)\r\n                    {  if (!('0' <= str[s] && str[s] <= '9')) err1();\r\n                        mm = 10 * mm + ((str[s++]) - '0');\r\n                    }\r\n                    if (mm > 59) err2();\r\n                }\r\n            }\r\n            zone = z * (60 * hh + mm);\r\n        }\r\n        else if (fmt[f] == '%')\r\n        {  /* literal % character */\r\n            test();\r\n        }\r\n        else\r\n            mpl_internal_error1(mpl, str, s, fmt, f, \"invalid conversion specifier\");\r\n    }\r\n    else if (fmt[f] == ' '){\r\n\r\n    }\r\n    else\r\n        test()\r\n    }\r\n    if (year < 0) year = 1970;\r\n    if (month < 0) month = 1;\r\n    if (day < 0) day = 1;\r\n    if (hh < 0) hh = 0;\r\n    if (mm < 0) mm = 0;\r\n    if (ss < 0) ss = 0;\r\n    if (zone == INT_MAX) zone = 0;\r\n    j = jday(day, month, year);\r\n    xassert(j >= 0);\r\n    return (((j - jday(1, 1, 1970)) * 24.0 + hh) * 60.0 + mm) * 60.0 + ss - 60.0 * zone;\r\n}\r\n\r\nfunction mpl_internal_error2(mpl, fmt, f, msg)\r\n{\r\n    xprintf(\"Format string passed to time2str:\");\r\n    xprintf(fmt);\r\n    xprintf(mpl_internal_mulstr('^', f));\r\n    mpl_internal_error(mpl, msg);\r\n}\r\n\r\nfunction mpl_internal_weekday(j){\r\n    /* determine weekday number (1 = Mon, ..., 7 = Sun) */\r\n    return (j + jday(1, 1, 1970)) % 7 + 1;\r\n}\r\n\r\nfunction mpl_internal_firstday(year){\r\n    /* determine the first day of the first week for a specified year\r\n     according to ISO 8601 */\r\n    var j;\r\n    /* if 1 January is Monday, Tuesday, Wednesday or Thursday, it is\r\n     in week 01; if 1 January is Friday, Saturday or Sunday, it is\r\n     in week 52 or 53 of the previous year */\r\n    j = jday(1, 1, year) - jday(1, 1, 1970);\r\n    switch (mpl_internal_weekday(j))\r\n    {  case 1: /* 1 Jan is Mon */ j += 0; break;\r\n        case 2: /* 1 Jan is Tue */ j -= 1; break;\r\n        case 3: /* 1 Jan is Wed */ j -= 2; break;\r\n        case 4: /* 1 Jan is Thu */ j -= 3; break;\r\n        case 5: /* 1 Jan is Fri */ j += 3; break;\r\n        case 6: /* 1 Jan is Sat */ j += 2; break;\r\n        case 7: /* 1 Jan is Sun */ j += 1; break;\r\n        default: xassert(j != j);\r\n    }\r\n    /* the first day of the week must be Monday */\r\n    xassert(mpl_internal_weekday(j) == 1);\r\n    return j;\r\n}\r\n\r\nfunction mpl_internal_fn_time2str(mpl, t, fmt){\r\n    /* convert the calendar time to character string */\r\n    var j, year = 0, month = 0, day = 0, hh, mm, ss, len;\r\n    var temp;\r\n    var f;\r\n    var str = '', buf;\r\n    if (!(-62135596800.0 <= t && t <= 64092211199.0))\r\n        mpl_internal_error(mpl, \"time2str(\" + t + \",...); argument out of range\");\r\n    t = Math.floor(t + 0.5);\r\n    temp = Math.abs(t) / 86400.0;\r\n    j = Math.floor(temp);\r\n    if (t < 0.0)\r\n    {  if (temp == Math.floor(temp))\r\n        j = - j;\r\n    else\r\n        j = - (j + 1);\r\n    }\r\n    xassert(jdate(j + jday(1, 1, 1970), function(d,m,y){day=d;month=m;year=y}) == 0);\r\n    ss = (t - 86400.0 * j)|0;\r\n    xassert(0 <= ss && ss < 86400);\r\n    mm = ss / 60; ss %= 60;\r\n    hh = mm / 60; mm %= 60;\r\n    len = 0;\r\n    for (f = 0; f < fmt.length; f++)\r\n    {  if (fmt[f] == '%')\r\n    {  f++;\r\n        if (fmt[f] == 'a')\r\n        {  /* the abbreviated weekday name */\r\n            buf = mpl_internal_week[mpl_internal_weekday(j)-1].slice(0,3);\r\n        }\r\n        else if (fmt[f] == 'A')\r\n        {  /* the full weekday name */\r\n            buf = mpl_internal_week[mpl_internal_weekday(j)-1];\r\n        }\r\n        else if (fmt[f] == 'b' || fmt[f] == 'h')\r\n        {  /* the abbreviated month name */\r\n            buf = mpl_internal_moon[month-1].slice(0, 3);\r\n        }\r\n        else if (fmt[f] == 'B')\r\n        {  /* the full month name */\r\n            buf = mpl_internal_moon[month-1];\r\n        }\r\n        else if (fmt[f] == 'C')\r\n        {  /* the century of the year */\r\n            buf = String(Math.floor(year / 100));\r\n        }\r\n        else if (fmt[f] == 'd')\r\n        {  /* the day of the month as a decimal number (01..31) */\r\n            buf = String(day);\r\n        }\r\n        else if (fmt[f] == 'D')\r\n        {  /* the date using the format %m/%d/%y */\r\n            buf = month + \"/\" + day + \"/\" + (year % 100);\r\n        }\r\n        else if (fmt[f] == 'e')\r\n        {  /* the day of the month like with %d, but padded with\r\n         blank (1..31) */\r\n            buf = String(day);\r\n        }\r\n        else if (fmt[f] == 'F')\r\n        {  /* the date using the format %Y-%m-%d */\r\n            sprintf(buf, year + \"-\" + month + \"-\" + day);\r\n        }\r\n        else if (fmt[f] == 'g')\r\n        {  /* the year corresponding to the ISO week number, but\r\n         without the century (range 00 through 99); this has\r\n         the same format and value as %y, except that if the\r\n         ISO week number (see %V) belongs to the previous or\r\n         next year, that year is used instead */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = year - 1;\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = year;\r\n            else\r\n                iso = year + 1;\r\n            buf = String(iso % 100);\r\n        }\r\n        else if (fmt[f] == 'G')\r\n        {  /* the year corresponding to the ISO week number; this\r\n         has the same format and value as %Y, excepth that if\r\n         the ISO week number (see %V) belongs to the previous\r\n         or next year, that year is used instead */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = year - 1;\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = year;\r\n            else\r\n                iso = year + 1;\r\n            buf = String(iso);\r\n        }\r\n        else if (fmt[f] == 'H')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         (00..23) */\r\n            buf = String(hh);\r\n        }\r\n        else if (fmt[f] == 'I')\r\n        {  /* the hour as a decimal number, using a 12-hour clock\r\n         (01..12) */\r\n            buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\r\n        }\r\n        else if (fmt[f] == 'j')\r\n        {  /* the day of the year as a decimal number (001..366) */\r\n            buf  = String(jday(day, month, year) - jday(1, 1, year) + 1);\r\n        }\r\n        else if (fmt[f] == 'k')\r\n        {  /* the hour as a decimal number, using a 24-hour clock\r\n         like %H, but padded with blank (0..23) */\r\n            buf = String(hh);\r\n        }\r\n        else if (fmt[f] == 'l')\r\n        {  /* the hour as a decimal number, using a 12-hour clock\r\n         like %I, but padded with blank (1..12) */\r\n            buf = String(hh == 0 ? 12 : hh <= 12 ? hh : hh - 12);\r\n        }\r\n        else if (fmt[f] == 'm')\r\n        {  /* the month as a decimal number (01..12) */\r\n            buf = String(month);\r\n        }\r\n        else if (fmt[f] == 'M')\r\n        {  /* the minute as a decimal number (00..59) */\r\n            buf = String(mm);\r\n        }\r\n        else if (fmt[f] == 'p')\r\n        {  /* either AM or PM, according to the given time value;\r\n         noon is treated as PM and midnight as AM */\r\n            buf = (hh <= 11 ? \"AM\" : \"PM\");\r\n        }\r\n        else if (fmt[f] == 'P')\r\n        {  /* either am or pm, according to the given time value;\r\n         noon is treated as pm and midnight as am */\r\n            buf = (hh <= 11 ? \"am\" : \"pm\");\r\n        }\r\n        else if (fmt[f] == 'r')\r\n        {  /* the calendar time using the format %I:%M:%S %p */\r\n            buf = (hh == 0 ? 12 : hh <= 12 ? hh : hh - 12) + \":\" + mm + \":\" + ss + \" \" + (hh <= 11 ? \"AM\" : \"PM\");\r\n        }\r\n        else if (fmt[f] == 'R')\r\n        {  /* the hour and minute using the format %H:%M */\r\n            buf = hh + \":\" + mm;\r\n        }\r\n        else if (fmt[f] == 'S')\r\n        {  /* the second as a decimal number (00..59) */\r\n            buf = String(ss);\r\n        }\r\n        else if (fmt[f] == 'T')\r\n        {  /* the time of day using the format %H:%M:%S */\r\n            buf = hh + \":\" + mm + \":\" + ss;\r\n        }\r\n        else if (fmt[f] == 'u')\r\n        {  /* the day of the week as a decimal number (1..7),\r\n         Monday being 1 */\r\n            buf = String(mpl_internal_weekday(j));\r\n        }\r\n        else if (fmt[f] == 'U')\r\n        {  /* the week number of the current year as a decimal\r\n         number (range 00 through 53), starting with the first\r\n         Sunday as the first day of the first week; days\r\n         preceding the first Sunday in the year are considered\r\n         to be in week 00 */\r\n            /* sun = the first Sunday of the year */\r\n            var sun = jday(1, 1, year) - jday(1, 1, 1970);\r\n            sun += (7 - mpl_internal_weekday(sun));\r\n            buf = String((j + 7 - sun) / 7);\r\n        }\r\n        else if (fmt[f] == 'V')\r\n        {  /* the ISO week number as a decimal number (range 01\r\n         through 53); ISO weeks start with Monday and end with\r\n         Sunday; week 01 of a year is the first week which has\r\n         the majority of its days in that year; week 01 of\r\n         a year can contain days from the previous year; the\r\n         week before week 01 of a year is the last week (52 or\r\n         53) of the previous year even if it contains days\r\n         from the new year */\r\n            var iso;\r\n            if (j < mpl_internal_firstday(year))\r\n                iso = j - mpl_internal_firstday(year - 1);\r\n            else if (j < mpl_internal_firstday(year + 1))\r\n                iso = j - mpl_internal_firstday(year);\r\n            else\r\n                iso = j - mpl_internal_firstday(year + 1);\r\n            buf = String(iso / 7 + 1);\r\n        }\r\n        else if (fmt[f] == 'w')\r\n        {  /* the day of the week as a decimal number (0..6),\r\n         Sunday being 0 */\r\n            buf = String(mpl_internal_weekday(j) % 7);\r\n        }\r\n        else if (fmt[f] == 'W')\r\n        {  /* the week number of the current year as a decimal\r\n         number (range 00 through 53), starting with the first\r\n         Monday as the first day of the first week; days\r\n         preceding the first Monday in the year are considered\r\n         to be in week 00 */\r\n            /* mon = the first Monday of the year */\r\n            var mon = jday(1, 1, year) - jday(1, 1, 1970);\r\n            mon += (8 - mpl_internal_weekday(mon)) % 7;\r\n            buf = String((j + 7 - mon) / 7);\r\n        }\r\n        else if (fmt[f] == 'y')\r\n        {  /* the year without a century as a decimal number\r\n         (00..99) */\r\n            buf = String(year % 100);\r\n        }\r\n        else if (fmt[f] == 'Y')\r\n        {  /* the year as a decimal number, using the Gregorian\r\n         calendar */\r\n            buf = String(year);\r\n        }\r\n        else if (fmt[f] == '%')\r\n        {  /* a literal % character */\r\n            buf = '%';\r\n        }\r\n        else\r\n            mpl_internal_error2(mpl, fmt, f, \"invalid conversion specifier\");\r\n    }\r\n    else{\r\n        buf = fmt[f];\r\n        //buf[1] = '\\0';\r\n    }\r\n/*\r\n        if (len + buf.length > MAX_LENGTH)\r\n            mpl_internal_error(mpl, \"time2str; output string length exceeds \" + MAX_LENGTH + \" charaters\");\r\n*/\r\n        str += buf;\r\n        len += buf.length;\r\n    }\r\n    return str;\r\n}\r\n\r\n/* glpmpl06.c */\r\n\r\n/*****************************************\r\n Driver API\r\n *****************************************/\r\n\r\nvar MPL_DRIVERS = {};\r\n\r\nfunction mpl_tab_drv_open(mpl, mode){\r\n    var dca = mpl.dca;\r\n    xassert(dca.id == 0);\r\n    xassert(dca.link == null);\r\n    xassert(dca.na >= 1);\r\n\r\n    var Driver = MPL_DRIVERS[dca.arg[1].toLowerCase()];\r\n    if (Driver)\r\n        dca.link = new Driver(dca, mode, mpl.tablecb);\r\n    else\r\n        mpl_internal_error(mpl, \"Invalid table driver '\" + dca.arg[1] + \"'\");\r\n    if (dca.link == null)\r\n        mpl_internal_error(mpl, \"error on opening table \" + mpl.stmt.u.tab.name);\r\n}\r\n\r\nfunction mpl_tab_drv_read(mpl){\r\n    var dca = mpl.dca;\r\n    var ret = dca.link[\"readRecord\"](dca);\r\n    if (ret > 0)\r\n        mpl_internal_error(mpl, \"error on reading data from table \" + mpl.stmt.u.tab.name);\r\n    return ret;\r\n}\r\n\r\nfunction mpl_tab_drv_write(mpl){\r\n    var dca = mpl.dca;\r\n    var ret = dca.link[\"writeRecord\"](dca);\r\n    if (ret)\r\n        mpl_internal_error(mpl, \"error on writing data to table \" + mpl.stmt.u.tab.name);\r\n}\r\n\r\nfunction mpl_tab_drv_flush(mpl){\r\n    var dca = mpl.dca;\r\n    dca.link[\"flush\"](dca);\r\n}\r\n\r\nvar mpl_tab_drv_register = exports[\"mpl_tab_drv_register\"] = function (name, driver){\r\n    MPL_DRIVERS[name.toLowerCase()] = driver;\r\n};\r\n\r\n/*****************************************\r\n    CSV Driver\r\n *****************************************/\r\n\r\nfunction CSVDriver(dca, mode, tablecb){\r\n    /* open csv data file */\r\n    /* create control structure */\r\n    this.mode = mode;\r\n    this.fname = null;\r\n    this.count = 0;\r\n    this.c = '\\n';\r\n    this.what = 0;\r\n    this.field = '';\r\n    this.nf = 0;\r\n    this.ref = [];\r\n    this.tablecb = tablecb;\r\n\r\n    this.CSV_EOF   = 0;  /* end-of-file */\r\n    this.CSV_EOR   = 1;  /* end-of-record */\r\n    this.CSV_NUM   = 2;  /* floating-point number */\r\n    this.CSV_STR   = 3;  /* character string */\r\n\r\n\r\n    /* try to open the csv data file */\r\n    if (mpl_tab_num_args(dca) < 2)\r\n        xerror(\"csv_driver: file name not specified\\n\");\r\n    this.fname = mpl_tab_get_arg(dca, 2);\r\n    var k;\r\n    if (mode == 'R')\r\n    {   /* open the file for reading */\r\n\r\n        if (tablecb){\r\n            this.data = tablecb(dca.arg, mode);\r\n            this.cursor = 0;\r\n        } else\r\n            xerror(\"csv_driver: unable to open \" + this.fname);\r\n        this.nskip = 0;\r\n        /* skip fake new-line */\r\n        this.readField();\r\n        xassert(this.what == this.CSV_EOR);\r\n        /* read field names */\r\n        xassert(this.nf == 0);\r\n        for (;;)\r\n        {  this.readField();\r\n            if (this.what == this.CSV_EOR)\r\n                break;\r\n            if (this.what != this.CSV_STR)\r\n                xerror(this.fname + \":\" + this.count + \": invalid field name\\n\");\r\n            this.nf++;\r\n            /* find corresponding field in the table statement */\r\n            for (k = mpl_tab_num_flds(dca); k >= 1; k--)\r\n            {  if (mpl_tab_get_name(dca, k) == this.field)\r\n                break;\r\n            }\r\n            this.ref[this.nf] = k;\r\n        }\r\n        /* find dummy RECNO field in the table statement */\r\n        for (k = mpl_tab_num_flds(dca); k >= 1; k--)\r\n            if (mpl_tab_get_name(dca, k) == \"RECNO\") break;\r\n        this.ref[0] = k;\r\n    }\r\n    else if (mode == 'W')\r\n    {   this.data = '';\r\n        /* write field names */\r\n        var nf = mpl_tab_num_flds(dca);\r\n        for (k = 1; k <= nf; k++)\r\n            this.data += mpl_tab_get_name(dca, k) + ((k < nf)?',':'\\n');\r\n        this.count++;\r\n    }\r\n    else\r\n        xassert(mode != mode);\r\n}\r\n\r\nCSVDriver.prototype.readField = function(){\r\n    /* read field from csv data file */\r\n    /* check for end of file */\r\n    if (this.c == XEOF)\r\n    {   this.what = this.CSV_EOF;\r\n        this.field = \"EOF\";\r\n        return;\r\n    }\r\n    /* check for end of record */\r\n    if (this.c == '\\n')\r\n    {   this.what = this.CSV_EOR;\r\n        this.field = \"EOR\";\r\n        this.readChar();\r\n        if (this.c == ',')\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\\n\");\r\n        if (this.c == '\\n')\r\n            xerror(this.fname + \":\" + this.count + \": empty record not allowed\\n\");\r\n\r\n        /* skip comment records; may appear only before the very first\r\n         record containing field names */\r\n        if (this.c == '#' && this.count == 1)\r\n        {  while (this.c == '#')\r\n        {  while (this.c != '\\n')\r\n            this.readChar();\r\n            this.readChar();\r\n            this.nskip++;\r\n        }\r\n        }\r\n\r\n        return;\r\n    }\r\n    /* skip comma before next field */\r\n    if (this.c == ',')\r\n        this.readChar();\r\n    /* read field */\r\n    if (this.c == '\\'' || this.c == '\"')\r\n    {  /* read a field enclosed in quotes */\r\n        var quote = this.c;\r\n        this.field = '';\r\n        this.what = this.CSV_STR;\r\n        /* skip opening quote */\r\n        this.readChar();\r\n        /* read field characters within quotes */\r\n        for (;;)\r\n        {  /* check for closing quote and read it */\r\n            if (this.c == quote)\r\n            {  this.readChar();\r\n                if (this.c == quote){\r\n\r\n                }\r\n                else if (this.c == ',' || this.c == '\\n')\r\n                    break;\r\n                else\r\n                    xerror(this.fname + \":\" + this.count + \": invalid field\");\r\n            }\r\n            /* add the current character to the field */\r\n            this.field += this.c;\r\n            /* read the next character */\r\n            this.readChar();\r\n        }\r\n        /* the field has been read */\r\n        if (this.field.length == 0)\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\");\r\n    }\r\n    else\r\n    {  /* read a field not enclosed in quotes */\r\n        this.field = '';\r\n        var temp;\r\n        this.what = this.CSV_NUM;\r\n        while (!(this.c == ',' || this.c == '\\n'))\r\n        {  /* quotes within the field are not allowed */\r\n            if (this.c == '\\'' || this.c == '\"')\r\n                xerror(this.fname + \":\" + this.count + \": invalid use of single or double quote within field\");\r\n            /* add the current character to the field */\r\n            this.field += this.c;\r\n            /* read the next character */\r\n            this.readChar();\r\n        }\r\n        /* the field has been read */\r\n        if (this.field.length == 0)\r\n            xerror(this.fname + \":\" + this.count + \": empty field not allowed\");\r\n        /* check the field type */\r\n        if (str2num(this.field, function(v){temp=v})) this.what = this.CSV_STR;\r\n    }\r\n};\r\n\r\nCSVDriver.prototype.readChar = function (){\r\n    /* read character from csv data file */\r\n    var c;\r\n    xassert(this.c != XEOF);\r\n    if (this.c == '\\n') this.count++;\r\n    while (true){\r\n        if (this.cursor < this.data.length)\r\n            c = this.data[this.cursor++];\r\n        else\r\n            c = XEOF;\r\n        if (c == '\\r')\r\n            continue;\r\n        else if (c == '\\n'){\r\n\r\n        }\r\n        else if (iscntrl(c))\r\n        {   xerror(this.fname +\":\" + this.count +\": invalid control character \" + c);\r\n        }\r\n        break;\r\n    }\r\n    this.c = c;\r\n};\r\n\r\nCSVDriver.prototype[\"readRecord\"] = function(dca){\r\n    /* read next record from csv data file */\r\n    var k, ret = 0;\r\n    xassert(this.mode == 'R');\r\n\r\n    /* read dummy RECNO field */\r\n    if (this.ref[0] > 0)\r\n        mpl_tab_set_num(dca, this.ref[0], this.count-this.nskip-1);\r\n    /* read fields */\r\n    for (k = 1; k <= this.nf; k++)\r\n    {  this.readField();\r\n        if (this.what == this.CSV_EOF)\r\n        {  /* end-of-file reached */\r\n            xassert(k == 1);\r\n            return XEOF;\r\n        }\r\n        else if (this.what == this.CSV_EOR)\r\n        {  /* end-of-record reached */\r\n            var lack = this.nf - k + 1;\r\n            if (lack == 1)\r\n                xerror(this.fname + \":\" + this.count + \": one field missing\");\r\n            else\r\n                xerror(this.fname + \":\" + this.count + \": \" + lack + \" fields missing\");\r\n        }\r\n        else if (this.what == this.CSV_NUM)\r\n        {  /* floating-point number */\r\n            if (this.ref[k] > 0)\r\n            {   var num = 0;\r\n                xassert(str2num(this.field, function(v){num=v}) == 0);\r\n                mpl_tab_set_num(dca, this.ref[k], num);\r\n            }\r\n        }\r\n        else if (this.what == this.CSV_STR)\r\n        {  /* character string */\r\n            if (this.ref[k] > 0)\r\n                mpl_tab_set_str(dca, this.ref[k], this.field);\r\n        }\r\n        else\r\n            xassert(this != this);\r\n    }\r\n    /* now there must be NL */\r\n    this.readField();\r\n    xassert(this.what != this.CSV_EOF);\r\n    if (this.what != this.CSV_EOR)\r\n        xerror(this.fname + \":\" + this.count + \": too many fields\");\r\n    return ret;\r\n};\r\n\r\nCSVDriver.prototype[\"writeRecord\"] = function(dca){\r\n    /* write next record to csv data file */\r\n    var k, nf, ret = 0;\r\n    var c, n;\r\n    xassert(this.mode == 'W');\r\n    nf = mpl_tab_num_flds(dca);\r\n    for (k = 1; k <= nf; k++)\r\n    {  switch (mpl_tab_get_type(dca, k))\r\n    {  case 'N':\r\n            this.data += mpl_tab_get_num(dca, k);\r\n            break;\r\n        case 'S':\r\n            this.data += '\"';\r\n            for (c = mpl_tab_get_str(dca, k), n = 0; c.length > n; n++){\r\n                if (c[n] == '\"')\r\n                    this.data += '\"\"';\r\n                else\r\n                    this.data += c[n];\r\n            }\r\n            this.data += '\"';\r\n            break;\r\n        default:\r\n            xassert(dca != dca);\r\n    }\r\n        this.data += (k < nf)?',':'\\n';\r\n    }\r\n    this.count++;\r\n    return ret;\r\n};\r\n\r\nCSVDriver.prototype[\"flush\"] = function(dca){\r\n    this.tablecb(dca.arg, this.mode, this.data);\r\n};\r\n\r\nmpl_tab_drv_register(\"CSV\", CSVDriver);\r\n\r\n/*****************************************\r\n JSON Driver\r\n *****************************************/\r\n\r\nfunction JSONDriver(dca, mode, tablecb){\r\n    this.mode = mode;\r\n    this.fname = null;\r\n\r\n    if (mpl_tab_num_args(dca) < 2)\r\n        xerror(\"json driver: file name not specified\");\r\n    this.fname = mpl_tab_get_arg(dca, 2);\r\n    var k;\r\n    if (mode == 'R')\r\n    {\r\n        this.ref = {};\r\n        if (tablecb){\r\n            this.data = tablecb(dca.arg, mode);\r\n            if (typeof this.data == 'string')\r\n                this.data = JSON.parse(this.data);\r\n            this.cursor = 1;\r\n        } else\r\n            xerror(\"json driver: unable to open \" + this.fname);\r\n\r\n        for (var i = 0, meta = this.data[0]; i < meta.length; i++)\r\n            this.ref[meta[i]] = i;\r\n    }\r\n    else if (mode == 'W')\r\n    {   this.tablecb = tablecb;\r\n        var names = [];\r\n        this.data = [names];\r\n        var nf = mpl_tab_num_flds(dca);\r\n        for (k = 1; k <= nf; k++)\r\n            names.push(mpl_tab_get_name(dca, k));\r\n    }\r\n    else\r\n        xassert(mode != mode);\r\n}\r\n\r\nJSONDriver.prototype[\"writeRecord\"] = function(dca){\r\n    var k;\r\n    xassert(this.mode == 'W');\r\n    var nf = mpl_tab_num_flds(dca);\r\n    var line = [];\r\n    for (k = 1; k <= nf; k++){\r\n        switch (mpl_tab_get_type(dca, k)){\r\n            case 'N':\r\n                line.push(mpl_tab_get_num(dca, k));\r\n                break;\r\n            case 'S':\r\n                line.push(mpl_tab_get_str(dca, k));\r\n                break;\r\n            default:\r\n                xassert(dca != dca);\r\n        }\r\n    }\r\n    this.data.push(line);\r\n    return 0;\r\n};\r\n\r\nJSONDriver.prototype[\"readRecord\"] = function(dca){\r\n    /* read next record from csv data file */\r\n    var ret = 0;\r\n    xassert(this.mode == 'R');\r\n\r\n    /* read fields */\r\n    var line = this.data[this.cursor++];\r\n    if (line == null) return XEOF;\r\n\r\n    for (var k = 1; k <= mpl_tab_num_flds(dca); k++){\r\n        var index = this.ref[mpl_tab_get_name(dca, k)];\r\n        if (index != null){\r\n            var value = line[index];\r\n            switch (typeof value){\r\n                case 'number':\r\n                    mpl_tab_set_num(dca, k, value);\r\n                    break;\r\n                case 'boolean':\r\n                    mpl_tab_set_num(dca, k, Number(value));\r\n                    break;\r\n                case 'string':\r\n                    mpl_tab_set_str(dca, k, value);\r\n                    break;\r\n                default:\r\n                    xerror('Unexpected data type ' + value + \" in \" + this.fname);\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n};\r\n\r\nJSONDriver.prototype[\"flush\"] = function(dca){\r\n    this.tablecb(dca.arg, this.mode, this.data);\r\n};\r\n\r\nmpl_tab_drv_register(\"JSON\", JSONDriver);function npp_error(){\r\n\r\n}\r\n\r\n\r\nfunction npp_create_wksp(){\r\n    /* create LP/MIP preprocessor workspace */\r\n    var npp = {};\r\n    npp.orig_dir = 0;\r\n    npp.orig_m = npp.orig_n = npp.orig_nnz = 0;\r\n    npp.name = npp.obj = null;\r\n    npp.c0 = 0.0;\r\n    npp.nrows = npp.ncols = 0;\r\n    npp.r_head = npp.r_tail = null;\r\n    npp.c_head = npp.c_tail = null;\r\n    npp.top = null;\r\n    npp.m = npp.n = npp.nnz = 0;\r\n    npp.row_ref = npp.col_ref = null;\r\n    npp.sol = npp.scaling = 0;\r\n    npp.p_stat = npp.d_stat = npp.t_stat = npp.i_stat = 0;\r\n    npp.r_stat = null;\r\n    /*npp.r_prim =*/ npp.r_pi = null;\r\n    npp.c_stat = null;\r\n    npp.c_value = /*npp.c_dual =*/ null;\r\n    return npp;\r\n}\r\n\r\nfunction npp_insert_row(npp, row, where){\r\n    /* insert row to the row list */\r\n    if (where == 0)\r\n    {  /* insert row to the beginning of the row list */\r\n        row.prev = null;\r\n        row.next = npp.r_head;\r\n        if (row.next == null)\r\n            npp.r_tail = row;\r\n        else\r\n            row.next.prev = row;\r\n        npp.r_head = row;\r\n    }\r\n    else\r\n    {  /* insert row to the end of the row list */\r\n        row.prev = npp.r_tail;\r\n        row.next = null;\r\n        if (row.prev == null)\r\n            npp.r_head = row;\r\n        else\r\n            row.prev.next = row;\r\n        npp.r_tail = row;\r\n    }\r\n}\r\n\r\nfunction npp_remove_row(npp, row){\r\n    /* remove row from the row list */\r\n    if (row.prev == null)\r\n        npp.r_head = row.next;\r\n    else\r\n        row.prev.next = row.next;\r\n    if (row.next == null)\r\n        npp.r_tail = row.prev;\r\n    else\r\n        row.next.prev = row.prev;\r\n}\r\n\r\nfunction npp_activate_row(npp, row){\r\n    /* make row active */\r\n    if (!row.temp)\r\n    {  row.temp = 1;\r\n        /* move the row to the beginning of the row list */\r\n        npp_remove_row(npp, row);\r\n        npp_insert_row(npp, row, 0);\r\n    }\r\n}\r\n\r\nfunction npp_deactivate_row(npp, row){\r\n    /* make row inactive */\r\n    if (row.temp)\r\n    {  row.temp = 0;\r\n        /* move the row to the end of the row list */\r\n        npp_remove_row(npp, row);\r\n        npp_insert_row(npp, row, 1);\r\n    }\r\n}\r\n\r\nfunction npp_insert_col(npp, col, where){\r\n    /* insert column to the column list */\r\n    if (where == 0)\r\n    {  /* insert column to the beginning of the column list */\r\n        col.prev = null;\r\n        col.next = npp.c_head;\r\n        if (col.next == null)\r\n            npp.c_tail = col;\r\n        else\r\n            col.next.prev = col;\r\n        npp.c_head = col;\r\n    }\r\n    else\r\n    {  /* insert column to the end of the column list */\r\n        col.prev = npp.c_tail;\r\n        col.next = null;\r\n        if (col.prev == null)\r\n            npp.c_head = col;\r\n        else\r\n            col.prev.next = col;\r\n        npp.c_tail = col;\r\n    }\r\n}\r\n\r\nfunction npp_remove_col(npp, col){\r\n    /* remove column from the column list */\r\n    if (col.prev == null)\r\n        npp.c_head = col.next;\r\n    else\r\n        col.prev.next = col.next;\r\n    if (col.next == null)\r\n        npp.c_tail = col.prev;\r\n    else\r\n        col.next.prev = col.prev;\r\n}\r\n\r\nfunction npp_activate_col(npp, col){\r\n    /* make column active */\r\n    if (!col.temp)\r\n    {  col.temp = 1;\r\n        /* move the column to the beginning of the column list */\r\n        npp_remove_col(npp, col);\r\n        npp_insert_col(npp, col, 0);\r\n    }\r\n}\r\n\r\nfunction npp_deactivate_col(npp, col){\r\n    /* make column inactive */\r\n    if (col.temp)\r\n    {  col.temp = 0;\r\n        /* move the column to the end of the column list */\r\n        npp_remove_col(npp, col);\r\n        npp_insert_col(npp, col, 1);\r\n    }\r\n}\r\n\r\nfunction npp_add_row(npp){\r\n    /* add new row to the current problem */\r\n    var row = {};\r\n    row.i = ++(npp.nrows);\r\n    row.name = null;\r\n    row.lb = -DBL_MAX;\r\n    row.ub = +DBL_MAX;\r\n    row.ptr = null;\r\n    row.temp = 0;\r\n    npp_insert_row(npp, row, 1);\r\n    return row;\r\n}\r\n\r\nfunction npp_add_col(npp){\r\n    /* add new column to the current problem */\r\n    var col = {};\r\n    col.j = ++(npp.ncols);\r\n    col.name = null;\r\n    col.is_int = 0;\r\n    col.lb = col.ub = col.coef = 0.0;\r\n    col.ptr = null;\r\n    col.temp = 0;\r\n    col.ll = {};\r\n    col.uu = {};\r\n    npp_insert_col(npp, col, 1);\r\n    return col;\r\n}\r\n\r\nfunction npp_add_aij(row, col, val){\r\n    /* add new element to the constraint matrix */\r\n    var aij = {};\r\n    aij.row = row;\r\n    aij.col = col;\r\n    aij.val = val;\r\n    aij.r_prev = null;\r\n    aij.r_next = row.ptr;\r\n    aij.c_prev = null;\r\n    aij.c_next = col.ptr;\r\n    if (aij.r_next != null)\r\n        aij.r_next.r_prev = aij;\r\n    if (aij.c_next != null)\r\n        aij.c_next.c_prev = aij;\r\n    row.ptr = col.ptr = aij;\r\n    return aij;\r\n}\r\n\r\nfunction npp_row_nnz(row){\r\n    /* count number of non-zero coefficients in row */\r\n    var nnz = 0;\r\n    for (var aij = row.ptr; aij != null; aij = aij.r_next)\r\n        nnz++;\r\n    return nnz;\r\n}\r\n\r\nfunction npp_col_nnz(col){\r\n    /* count number of non-zero coefficients in column */\r\n    var nnz = 0;\r\n    for (var aij = col.ptr; aij != null; aij = aij.c_next)\r\n        nnz++;\r\n    return nnz;\r\n}\r\n\r\nfunction npp_push_tse(npp, func){\r\n    /* push new entry to the transformation stack */\r\n    var tse;\r\n    tse = {};\r\n    tse.func = func;\r\n    tse.info = {};\r\n    tse.link = npp.top;\r\n    npp.top = tse;\r\n    return tse.info;\r\n}\r\n\r\nfunction npp_erase_row(row){\r\n    /* erase row content to make it empty */\r\n    var aij;\r\n    while (row.ptr != null)\r\n    {  aij = row.ptr;\r\n        row.ptr = aij.r_next;\r\n        if (aij.c_prev == null)\r\n            aij.col.ptr = aij.c_next;\r\n        else\r\n            aij.c_prev.c_next = aij.c_next;\r\n        if (aij.c_next != null)\r\n            aij.c_next.c_prev = aij.c_prev;\r\n    }\r\n}\r\n\r\nfunction npp_del_row(npp, row){\r\n    /* remove row from the current problem */\r\n    npp_erase_row(row);\r\n    npp_remove_row(npp, row);\r\n}\r\n\r\nfunction npp_del_col(npp, col){\r\n    /* remove column from the current problem */\r\n    var aij;\r\n    while (col.ptr != null)\r\n    {  aij = col.ptr;\r\n        col.ptr = aij.c_next;\r\n        if (aij.r_prev == null)\r\n            aij.row.ptr = aij.r_next;\r\n        else\r\n            aij.r_prev.r_next = aij.r_next;\r\n        if (aij.r_next != null)\r\n            aij.r_next.r_prev = aij.r_prev;\r\n    }\r\n    npp_remove_col(npp, col);\r\n}\r\n\r\nfunction npp_del_aij(aij){\r\n    /* remove element from the constraint matrix */\r\n    if (aij.r_prev == null)\r\n        aij.row.ptr = aij.r_next;\r\n    else\r\n        aij.r_prev.r_next = aij.r_next;\r\n    if (aij.r_next != null)\r\n        aij.r_next.r_prev = aij.r_prev;\r\n    if (aij.c_prev == null)\r\n        aij.col.ptr = aij.c_next;\r\n    else\r\n        aij.c_prev.c_next = aij.c_next;\r\n    if (aij.c_next != null)\r\n        aij.c_next.c_prev = aij.c_prev;\r\n}\r\n\r\nfunction npp_load_prob(npp, orig, names, sol, scaling){\r\n    /* load original problem into the preprocessor workspace */\r\n    var m = orig.m;\r\n    var n = orig.n;\r\n    var link;\r\n    var i, j;\r\n    var dir;\r\n    xassert(names == GLP_OFF || names == GLP_ON);\r\n    xassert(sol == GLP_SOL || sol == GLP_IPT || sol == GLP_MIP);\r\n    xassert(scaling == GLP_OFF || scaling == GLP_ON);\r\n    if (sol == GLP_MIP) xassert(!scaling);\r\n    npp.orig_dir = orig.dir;\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    npp.orig_m = m;\r\n    npp.orig_n = n;\r\n    npp.orig_nnz = orig.nnz;\r\n    if (names && orig.name != null)\r\n        npp.name = orig.name;\r\n    if (names && orig.obj != null)\r\n        npp.obj = orig.obj;\r\n    npp.c0 = dir * orig.c0;\r\n    /* load rows */\r\n    link = new Array(1+m);\r\n    for (i = 1; i <= m; i++)\r\n    {  var rrr = orig.row[i];\r\n        var row;\r\n        link[i] = row = npp_add_row(npp);\r\n        xassert(row.i == i);\r\n        if (names && rrr.name != null)\r\n            row.name = rrr.name;\r\n        if (!scaling)\r\n        {  if (rrr.type == GLP_FR){\r\n            row.lb = -DBL_MAX; row.ub = +DBL_MAX;\r\n        }\r\n        else if (rrr.type == GLP_LO){\r\n            row.lb = rrr.lb; row.ub = +DBL_MAX;\r\n        }\r\n        else if (rrr.type == GLP_UP){\r\n            row.lb = -DBL_MAX; row.ub = rrr.ub;\r\n        }\r\n        else if (rrr.type == GLP_DB){\r\n            row.lb = rrr.lb; row.ub = rrr.ub;\r\n        }\r\n        else if (rrr.type == GLP_FX)\r\n            row.lb = row.ub = rrr.lb;\r\n        else\r\n            xassert(rrr != rrr);\r\n        }\r\n        else\r\n        {  var rii = rrr.rii;\r\n            if (rrr.type == GLP_FR){\r\n                row.lb = -DBL_MAX; row.ub = +DBL_MAX;\r\n            }\r\n            else if (rrr.type == GLP_LO){\r\n                row.lb = rrr.lb * rii; row.ub = +DBL_MAX;\r\n            }\r\n            else if (rrr.type == GLP_UP){\r\n                row.lb = -DBL_MAX; row.ub = rrr.ub * rii;\r\n            }\r\n            else if (rrr.type == GLP_DB){\r\n                row.lb = rrr.lb * rii; row.ub = rrr.ub * rii;\r\n            }\r\n            else if (rrr.type == GLP_FX)\r\n                row.lb = row.ub = rrr.lb * rii;\r\n            else\r\n                xassert(rrr != rrr);\r\n        }\r\n    }\r\n    /* load columns and constraint coefficients */\r\n    for (j = 1; j <= n; j++)\r\n    {  var ccc = orig.col[j];\r\n        var aaa;\r\n        var col;\r\n        col = npp_add_col(npp);\r\n        xassert(col.j == j);\r\n        if (names && ccc.name != null)\r\n            col.name =  ccc.name;\r\n        if (sol == GLP_MIP)\r\n            col.is_int = Number(ccc.kind == GLP_IV);\r\n        if (!scaling){\r\n            if (ccc.type == GLP_FR){\r\n                col.lb = -DBL_MAX; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_LO){\r\n                col.lb = ccc.lb; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_UP){\r\n                col.lb = -DBL_MAX; col.ub = ccc.ub;\r\n            }\r\n            else if (ccc.type == GLP_DB){\r\n                col.lb = ccc.lb; col.ub = ccc.ub;\r\n            }\r\n            else if (ccc.type == GLP_FX)\r\n                col.lb = col.ub = ccc.lb;\r\n            else\r\n                xassert(ccc != ccc);\r\n            col.coef = dir * ccc.coef;\r\n            for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_add_aij(link[aaa.row.i], col, aaa.val);\r\n        }\r\n        else\r\n        {  var sjj = ccc.sjj;\r\n            if (ccc.type == GLP_FR){\r\n                col.lb = -DBL_MAX; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_LO){\r\n                col.lb = ccc.lb / sjj; col.ub = +DBL_MAX;\r\n            }\r\n            else if (ccc.type == GLP_UP){\r\n                col.lb = -DBL_MAX; col.ub = ccc.ub / sjj;\r\n            }\r\n            else if (ccc.type == GLP_DB){\r\n                col.lb = ccc.lb / sjj; col.ub = ccc.ub / sjj;\r\n            }\r\n            else if (ccc.type == GLP_FX)\r\n                col.lb = col.ub = ccc.lb / sjj;\r\n            else\r\n                xassert(ccc != ccc);\r\n            col.coef = dir * ccc.coef * sjj;\r\n            for (aaa = ccc.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_add_aij(link[aaa.row.i], col,\r\n                    aaa.row.rii * aaa.val * sjj);\r\n        }\r\n    }\r\n    /* keep solution indicator and scaling option */\r\n    npp.sol = sol;\r\n    npp.scaling = scaling;\r\n}\r\n\r\nfunction npp_build_prob(npp, prob){\r\n    /* build resultant (preprocessed) problem */\r\n    var row;\r\n    var col;\r\n    var aij;\r\n    var i, j, type, len, ind;\r\n    var dir, val;\r\n    glp_erase_prob(prob);\r\n    glp_set_prob_name(prob, npp.name);\r\n    glp_set_obj_name(prob, npp.obj);\r\n    glp_set_obj_dir(prob, npp.orig_dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    glp_set_obj_coef(prob, 0, dir * npp.c0);\r\n    /* build rows */\r\n    for (row = npp.r_head; row != null; row = row.next)\r\n    {  row.temp = i = glp_add_rows(prob, 1);\r\n        glp_set_row_name(prob, i, row.name);\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (row.ub == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (row.lb == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (row.lb != row.ub)\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_row_bnds(prob, i, type, row.lb, row.ub);\r\n    }\r\n    /* build columns and the constraint matrix */\r\n    ind = new Int32Array(1+prob.m);\r\n    val = new Float64Array(1+prob.m);\r\n    for (col = npp.c_head; col != null; col = col.next)\r\n    {  j = glp_add_cols(prob, 1);\r\n        glp_set_col_name(prob, j, col.name);\r\n        glp_set_col_kind(prob, j, col.is_int ? GLP_IV : GLP_CV);\r\n        if (col.lb == -DBL_MAX && col.ub == +DBL_MAX)\r\n            type = GLP_FR;\r\n        else if (col.ub == +DBL_MAX)\r\n            type = GLP_LO;\r\n        else if (col.lb == -DBL_MAX)\r\n            type = GLP_UP;\r\n        else if (col.lb != col.ub)\r\n            type = GLP_DB;\r\n        else\r\n            type = GLP_FX;\r\n        glp_set_col_bnds(prob, j, type, col.lb, col.ub);\r\n        glp_set_obj_coef(prob, j, dir * col.coef);\r\n        len = 0;\r\n        for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n        {  len++;\r\n            ind[len] = aij.row.temp;\r\n            val[len] = aij.val;\r\n        }\r\n        glp_set_mat_col(prob, j, len, ind, val);\r\n    }\r\n    /* resultant problem has been built */\r\n    npp.m = prob.m;\r\n    npp.n = prob.n;\r\n    npp.nnz = prob.nnz;\r\n    npp.row_ref = new Int32Array(1+npp.m);\r\n    npp.col_ref = new Int32Array(1+npp.n);\r\n    for (row = npp.r_head, i = 0; row != null; row = row.next)\r\n        npp.row_ref[++i] = row.i;\r\n    for (col = npp.c_head, j = 0; col != null; col = col.next)\r\n        npp.col_ref[++j] = col.j;\r\n    /* transformed problem segment is no longer needed */\r\n    npp.name = npp.obj = null;\r\n    npp.c0 = 0.0;\r\n    npp.r_head = npp.r_tail = null;\r\n    npp.c_head = npp.c_tail = null;\r\n}\r\n\r\nfunction npp_postprocess(npp, prob){\r\n    /* postprocess solution from the resultant problem */\r\n    var row;\r\n    var col;\r\n    var tse;\r\n    var i, j, k;\r\n    var dir;\r\n    xassert(npp.orig_dir == prob.dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    xassert(npp.m == prob.m);\r\n    xassert(npp.n == prob.n);\r\n    xassert(npp.nnz == prob.nnz);\r\n    /* copy solution status */\r\n    if (npp.sol == GLP_SOL)\r\n    {  npp.p_stat = prob.pbs_stat;\r\n        npp.d_stat = prob.dbs_stat;\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n        npp.t_stat = prob.ipt_stat;\r\n    else if (npp.sol == GLP_MIP)\r\n        npp.i_stat = prob.mip_stat;\r\n    else\r\n        xassert(npp != npp);\r\n    /* allocate solution arrays */\r\n    if (npp.sol == GLP_SOL)\r\n    {  if (npp.r_stat == null)\r\n        npp.r_stat = new Int8Array(1+npp.nrows);\r\n        for (i = 1; i <= npp.nrows; i++)\r\n            npp.r_stat[i] = 0;\r\n        if (npp.c_stat == null)\r\n            npp.c_stat = new Int8Array(1+npp.ncols);\r\n        for (j = 1; j <= npp.ncols; j++)\r\n            npp.c_stat[j] = 0;\r\n    }\r\n    if (npp.c_value == null)\r\n        npp.c_value = new Float64Array(1+npp.ncols);\r\n    for (j = 1; j <= npp.ncols; j++)\r\n        npp.c_value[j] = DBL_MAX;\r\n    if (npp.sol != GLP_MIP)\r\n    {  if (npp.r_pi == null)\r\n        npp.r_pi = new Float64Array(1+npp.nrows);\r\n        for (i = 1; i <= npp.nrows; i++)\r\n            npp.r_pi[i] = DBL_MAX;\r\n    }\r\n    /* copy solution components from the resultant problem */\r\n    if (npp.sol == GLP_SOL)\r\n    {  for (i = 1; i <= npp.m; i++)\r\n    {  row = prob.row[i];\r\n        k = npp.row_ref[i];\r\n        npp.r_stat[k] = row.stat;\r\n        /*npp.r_prim[k] = row.prim;*/\r\n        npp.r_pi[k] = dir * row.dual;\r\n    }\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_stat[k] = col.stat;\r\n            npp.c_value[k] = col.prim;\r\n            /*npp.c_dual[k] = dir * col.dual;*/\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n    {  for (i = 1; i <= npp.m; i++)\r\n    {  row = prob.row[i];\r\n        k = npp.row_ref[i];\r\n        /*npp.r_prim[k] = row.pval;*/\r\n        npp.r_pi[k] = dir * row.dval;\r\n    }\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_value[k] = col.pval;\r\n            /*npp.c_dual[k] = dir * col.dval;*/\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_MIP)\r\n    {\r\n        for (j = 1; j <= npp.n; j++)\r\n        {  col = prob.col[j];\r\n            k = npp.col_ref[j];\r\n            npp.c_value[k] = col.mipx;\r\n        }\r\n    }\r\n    else\r\n        xassert(npp != npp);\r\n    /* perform postprocessing to construct solution to the original\r\n     problem */\r\n    for (tse = npp.top; tse != null; tse = tse.link)\r\n    {  xassert(tse.func != null);\r\n        xassert(tse.func(npp, tse.info) == 0);\r\n    }\r\n}\r\n\r\nfunction npp_unload_sol(npp, orig){\r\n    /* store solution to the original problem */\r\n    var row;\r\n    var col;\r\n    var i, j;\r\n    var dir;\r\n    var aij, temp;\r\n    xassert(npp.orig_dir == orig.dir);\r\n    if (npp.orig_dir == GLP_MIN)\r\n        dir = +1.0;\r\n    else if (npp.orig_dir == GLP_MAX)\r\n        dir = -1.0;\r\n    else\r\n        xassert(npp != npp);\r\n    xassert(npp.orig_m == orig.m);\r\n    xassert(npp.orig_n == orig.n);\r\n    xassert(npp.orig_nnz == orig.nnz);\r\n    if (npp.sol == GLP_SOL)\r\n    {  /* store basic solution */\r\n        orig.valid = 0;\r\n        orig.pbs_stat = npp.p_stat;\r\n        orig.dbs_stat = npp.d_stat;\r\n        orig.obj_val = orig.c0;\r\n        orig.some = 0;\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            row.stat = npp.r_stat[i];\r\n            if (!npp.scaling)\r\n            {  /*row.prim = npp.r_prim[i];*/\r\n                row.dual = dir * npp.r_pi[i];\r\n            }\r\n            else\r\n            {  /*row.prim = npp.r_prim[i] / row.rii;*/\r\n                row.dual = dir * npp.r_pi[i] * row.rii;\r\n            }\r\n            if (row.stat == GLP_BS)\r\n                row.dual = 0.0;\r\n            else if (row.stat == GLP_NL)\r\n            {  xassert(row.type == GLP_LO || row.type == GLP_DB);\r\n                row.prim = row.lb;\r\n            }\r\n            else if (row.stat == GLP_NU)\r\n            {  xassert(row.type == GLP_UP || row.type == GLP_DB);\r\n                row.prim = row.ub;\r\n            }\r\n            else if (row.stat == GLP_NF)\r\n            {  xassert(row.type == GLP_FR);\r\n                row.prim = 0.0;\r\n            }\r\n            else if (row.stat == GLP_NS)\r\n            {  xassert(row.type == GLP_FX);\r\n                row.prim = row.lb;\r\n            }\r\n            else\r\n                xassert(row != row);\r\n        }\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            col.stat = npp.c_stat[j];\r\n            if (!npp.scaling)\r\n            {  col.prim = npp.c_value[j];\r\n                /*col.dual = dir * npp.c_dual[j];*/\r\n            }\r\n            else\r\n            {  col.prim = npp.c_value[j] * col.sjj;\r\n                /*col.dual = dir * npp.c_dual[j] / col.sjj;*/\r\n            }\r\n            if (col.stat == GLP_BS)\r\n                col.dual = 0.0;\r\n            else if (col.stat == GLP_NL)\r\n            {  xassert(col.type == GLP_LO || col.type == GLP_DB);\r\n                col.prim = col.lb;\r\n            }\r\n            else if (col.stat == GLP_NU)\r\n            {  xassert(col.type == GLP_UP || col.type == GLP_DB);\r\n                col.prim = col.ub;\r\n            }\r\n            else if (col.stat == GLP_NF)\r\n            {  xassert(col.type == GLP_FR);\r\n                col.prim = 0.0;\r\n            }\r\n            else if (col.stat == GLP_NS)\r\n            {  xassert(col.type == GLP_FX);\r\n                col.prim = col.lb;\r\n            }\r\n            else\r\n                xassert(col != col);\r\n            orig.obj_val += col.coef * col.prim;\r\n        }\r\n        /* compute primal values of inactive rows */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            if (row.stat == GLP_BS)\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.prim;\r\n                row.prim = temp;\r\n            }\r\n        }\r\n        /* compute reduced costs of active columns */\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {\r\n                temp = col.coef;\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    temp -= aij.val * aij.row.dual;\r\n                col.dual = temp;\r\n            }\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_IPT)\r\n    {  /* store interior-point solution */\r\n        orig.ipt_stat = npp.t_stat;\r\n        orig.ipt_obj = orig.c0;\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            if (!npp.scaling)\r\n            {  /*row.pval = npp.r_prim[i];*/\r\n                row.dval = dir * npp.r_pi[i];\r\n            }\r\n            else\r\n            {  /*row.pval = npp.r_prim[i] / row.rii;*/\r\n                row.dval = dir * npp.r_pi[i] * row.rii;\r\n            }\r\n        }\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            if (!npp.scaling)\r\n            {  col.pval = npp.c_value[j];\r\n                /*col.dval = dir * npp.c_dual[j];*/\r\n            }\r\n            else\r\n            {  col.pval = npp.c_value[j] * col.sjj;\r\n                /*col.dval = dir * npp.c_dual[j] / col.sjj;*/\r\n            }\r\n            orig.ipt_obj += col.coef * col.pval;\r\n        }\r\n        /* compute row primal values */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.pval;\r\n                row.pval = temp;\r\n            }\r\n        }\r\n        /* compute column dual values */\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            {\r\n                temp = col.coef;\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    temp -= aij.val * aij.row.dval;\r\n                col.dval = temp;\r\n            }\r\n        }\r\n    }\r\n    else if (npp.sol == GLP_MIP)\r\n    {  /* store MIP solution */\r\n        xassert(!npp.scaling);\r\n        orig.mip_stat = npp.i_stat;\r\n        orig.mip_obj = orig.c0;\r\n        for (j = 1; j <= orig.n; j++)\r\n        {  col = orig.col[j];\r\n            col.mipx = npp.c_value[j];\r\n            if (col.kind == GLP_IV)\r\n                xassert(col.mipx == Math.floor(col.mipx));\r\n            orig.mip_obj += col.coef * col.mipx;\r\n        }\r\n        /* compute row primal values */\r\n        for (i = 1; i <= orig.m; i++)\r\n        {  row = orig.row[i];\r\n            {\r\n                temp = 0.0;\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    temp += aij.val * aij.col.mipx;\r\n                row.mipx = temp;\r\n            }\r\n        }\r\n    }\r\n    else\r\n        xassert(npp != npp);\r\n}\r\n\r\n\r\nfunction npp_free_row(npp, p){\r\n    /* process free (unbounded) row */\r\n    var info;\r\n    /* the row must be free */\r\n    xassert(p.lb == -DBL_MAX && p.ub == +DBL_MAX);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover free (unbounded) row */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            if (npp.sol != GLP_MIP)\r\n                npp.r_pi[info.p] = 0.0;\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n}\r\n\r\nfunction npp_geq_row(npp, p){\r\n    /* process row of 'not less than' type */\r\n    var info;\r\n    var s;\r\n    /* the row must have lower bound */\r\n    xassert(p.lb != -DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* create column for surplus variable */\r\n    s = npp_add_col(npp);\r\n    s.lb = 0.0;\r\n    s.ub = (p.ub == +DBL_MAX ? +DBL_MAX : p.ub - p.lb);\r\n    /* and add it to the transformed problem */\r\n    npp_add_aij(p, s, -1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function rcv_geq_row(npp, info){\r\n            /* recover row of 'not less than' type */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL ||\r\n                npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else if (npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.s = s.j;\r\n    /* replace the row by equality constraint */\r\n    p.ub = p.lb;\r\n}\r\n\r\nfunction npp_leq_row(npp, p){\r\n    /* process row of 'not greater than' type */\r\n    var info;\r\n    var s;\r\n    /* the row must have upper bound */\r\n    xassert(p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* create column for slack variable */\r\n    s = npp_add_col(npp);\r\n    s.lb = 0.0;\r\n    s.ub = (p.lb == -DBL_MAX ? +DBL_MAX : p.ub - p.lb);\r\n    /* and add it to the transformed problem */\r\n    npp_add_aij(p, s, +1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row of 'not greater than' type */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL ||\r\n                npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            else if (npp.c_stat[info.s] == GLP_NU)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.s = s.j;\r\n    /* replace the row by equality constraint */\r\n    p.lb = p.ub;\r\n}\r\n\r\nfunction npp_free_col(npp, q){\r\n    /* process free (unbounded) column */\r\n    var info;\r\n    var s;\r\n    var aij;\r\n    /* the column must be free */\r\n    xassert(q.lb == -DBL_MAX && q.ub == +DBL_MAX);\r\n    /* variable x[q] becomes s' */\r\n    q.lb = 0.0; q.ub = +DBL_MAX;\r\n    /* create variable s'' */\r\n    s = npp_add_col(npp);\r\n    s.is_int = q.is_int;\r\n    s.lb = 0.0; s.ub = +DBL_MAX;\r\n    /* duplicate objective coefficient */\r\n    s.coef = -q.coef;\r\n    /* duplicate column of the constraint matrix */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n        npp_add_aij(aij.row, s, -aij.val);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover free (unbounded) column */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NF;\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return -1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] -= npp.c_value[info.s];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = s.j;\r\n}\r\n\r\nfunction npp_lbnd_col(npp, q){\r\n    /* process column with (non-zero) lower bound */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must have non-zero lower bound */\r\n    xassert(q.lb != 0.0);\r\n    xassert(q.lb != -DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with (non-zero) lower bound */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS ||\r\n                npp.c_stat[info.q] == GLP_NL ||\r\n                npp.c_stat[info.q] == GLP_NU)\r\n                npp.c_stat[info.q] = npp.c_stat[info.q];\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] = info.bnd + npp.c_value[info.q];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.bnd = q.lb;\r\n    /* substitute x[q] into objective row */\r\n    npp.c0 += q.coef * q.lb;\r\n    /* substitute x[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.lb;\r\n        }\r\n    }\r\n    /* column x[q] becomes column s */\r\n    if (q.ub != +DBL_MAX)\r\n        q.ub -= q.lb;\r\n    q.lb = 0.0;\r\n}\r\n\r\nfunction npp_ubnd_col(npp, q){\r\n    /* process column with upper bound */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must have upper bound */\r\n    xassert(q.ub != +DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with upper bound */\r\n            if (npp.sol == GLP_BS)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NU;\r\n            else if (npp.c_stat[info.q] == GLP_NU)\r\n                npp.c_stat[info.q] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            /* compute value of x[q] with formula (2) */\r\n            npp.c_value[info.q] = info.bnd - npp.c_value[info.q];\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.bnd = q.ub;\r\n    /* substitute x[q] into objective row */\r\n    npp.c0 += q.coef * q.ub;\r\n    q.coef = -q.coef;\r\n    /* substitute x[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.ub);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.ub;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.ub;\r\n        }\r\n        aij.val = -aij.val;\r\n    }\r\n    /* column x[q] becomes column s */\r\n    if (q.lb != -DBL_MAX)\r\n        q.ub -= q.lb;\r\n    else\r\n        q.ub = +DBL_MAX;\r\n    q.lb = 0.0;\r\n}\r\n\r\nfunction npp_dbnd_col(npp, q){\r\n    /* process non-negative column with upper bound */\r\n    var info;\r\n    var p;\r\n    var s;\r\n    /* the column must be non-negative with upper bound */\r\n    xassert(q.lb == 0.0);\r\n    xassert(q.ub > 0.0);\r\n    xassert(q.ub != +DBL_MAX);\r\n    /* create variable s */\r\n    s = npp_add_col(npp);\r\n    s.is_int = q.is_int;\r\n    s.lb = 0.0; s.ub = +DBL_MAX;\r\n    /* create equality constraint (2) */\r\n    p = npp_add_row(npp);\r\n    p.lb = p.ub = q.ub;\r\n    npp_add_aij(p, q, +1.0);\r\n    npp_add_aij(p, s, +1.0);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover non-negative column with upper bound */\r\n            if (npp.sol == GLP_BS)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n            {  if (npp.c_stat[info.s] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NU;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else if (npp.c_stat[info.q] == GLP_NL)\r\n            {  if (npp.c_stat[info.s] == GLP_BS ||\r\n                npp.c_stat[info.s] == GLP_NL)\r\n                npp.c_stat[info.q] = GLP_NL;\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = s.j;\r\n    /* remove upper bound of x[q] */\r\n    q.ub = +DBL_MAX;\r\n}\r\n\r\nfunction npp_fixed_col(npp, q){\r\n    /* process fixed column */\r\n    var info;\r\n    var i;\r\n    var aij;\r\n    /* the column must be fixed */\r\n    xassert(q.lb == q.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover fixed column */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.c_stat[info.q] = GLP_NS;\r\n            npp.c_value[info.q] = info.s;\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.s = q.lb;\r\n    /* substitute x[q] = s[q] into objective row */\r\n    npp.c0 += q.coef * q.lb;\r\n    /* substitute x[q] = s[q] into constraint rows */\r\n    for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  i = aij.row;\r\n        if (i.lb == i.ub)\r\n            i.ub = (i.lb -= aij.val * q.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= aij.val * q.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= aij.val * q.lb;\r\n        }\r\n    }\r\n    /* remove the column from the problem */\r\n    npp_del_col(npp, q);\r\n}\r\n\r\nfunction npp_make_equality(npp, p){\r\n    /* process row with almost identical bounds */\r\n    var info;\r\n    var b, eps, nint;\r\n    /* the row must be double-sided inequality */\r\n    xassert(p.lb != -DBL_MAX);\r\n    xassert(p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* check row bounds */\r\n    eps = 1e-9 + 1e-12 * Math.abs(p.lb);\r\n    if (p.ub - p.lb > eps) return 0;\r\n    /* row bounds are very close to each other */\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row with almost identical bounds */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  if (npp.r_pi[info.p] >= 0.0)\r\n                npp.r_stat[info.p] = GLP_NL;\r\n            else\r\n                npp.r_stat[info.p] = GLP_NU;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    /* compute right-hand side */\r\n    b = 0.5 * (p.ub + p.lb);\r\n    nint = Math.floor(b + 0.5);\r\n    if (Math.abs(b - nint) <= eps) b = nint;\r\n    /* replace row p by almost equivalent equality constraint */\r\n    p.lb = p.ub = b;\r\n    return 1;\r\n}\r\n\r\nfunction npp_make_fixed(npp, q){\r\n    /* process column with almost identical bounds */\r\n    var info;\r\n    var aij;\r\n    var lfe;\r\n    var s, eps, nint;\r\n    /* the column must be double-bounded */\r\n    xassert(q.lb != -DBL_MAX);\r\n    xassert(q.ub != +DBL_MAX);\r\n    xassert(q.lb < q.ub);\r\n    /* check column bounds */\r\n    eps = 1e-9 + 1e-12 * Math.abs(q.lb);\r\n    if (q.ub - q.lb > eps) return 0;\r\n    /* column bounds are very close to each other */\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column with almost identical bounds */\r\n            var lfe;\r\n            var lambda;\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.c_stat[info.q] == GLP_BS)\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            else if (npp.c_stat[info.q] == GLP_NS)\r\n            {  /* compute multiplier for column q with formula (6) */\r\n                lambda = info.c;\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                    lambda -= lfe.val * npp.r_pi[lfe.ref];\r\n                /* assign status to non-basic column */\r\n                if (lambda >= 0.0)\r\n                    npp.c_stat[info.q] = GLP_NL;\r\n                else\r\n                    npp.c_stat[info.q] = GLP_NU;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q] (needed for basic solution\r\n     only) */\r\n    if (npp.sol == GLP_SOL)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {   lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* compute column fixed value */\r\n    s = 0.5 * (q.ub + q.lb);\r\n    nint = Math.floor(s + 0.5);\r\n    if (Math.abs(s - nint) <= eps) s = nint;\r\n    /* make column q fixed */\r\n    q.lb = q.ub = s;\r\n    return 1;\r\n}\r\n\r\nfunction npp_empty_row(npp, p){\r\n    /* process empty row */\r\n    var eps = 1e-3;\r\n    /* the row must be empty */\r\n    xassert(p.ptr == null);\r\n    /* check primal feasibility */\r\n    if (p.lb > +eps || p.ub < -eps)\r\n        return 1;\r\n    /* replace the row by equivalent free (unbounded) row */\r\n    p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n    /* and process it */\r\n    npp_free_row(npp, p);\r\n    return 0;\r\n}\r\n\r\nfunction npp_empty_col(npp, q){\r\n    /* process empty column */\r\n    var info;\r\n    var eps = 1e-3;\r\n    /* the column must be empty */\r\n    xassert(q.ptr == null);\r\n    /* check dual feasibility */\r\n    if (q.coef > +eps && q.lb == -DBL_MAX)\r\n        return 1;\r\n    if (q.coef < -eps && q.ub == +DBL_MAX)\r\n        return 1;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover empty column */\r\n            if (npp.sol == GLP_SOL)\r\n                npp.c_stat[info.q] = info.stat;\r\n            return 0;\r\n        }\r\n    );\r\n    info.q = q.j;\r\n    /* fix the column */\r\n\r\n    function lo(){  \r\n        /* column with lower bound */\r\n        info.stat = GLP_NL;\r\n        q.ub = q.lb;\r\n    }\r\n\r\n    function up(){\r\n        /* column with upper bound */\r\n        info.stat = GLP_NU;\r\n        q.lb = q.ub;\r\n    }\r\n    \r\n    if (q.lb == -DBL_MAX && q.ub == +DBL_MAX)\r\n    {  /* free column */\r\n        info.stat = GLP_NF;\r\n        q.lb = q.ub = 0.0;\r\n    }\r\n    else if (q.ub == +DBL_MAX)\r\n        lo();   \r\n    else if (q.lb == -DBL_MAX)\r\n        up();\r\n    else if (q.lb != q.ub)\r\n    {  /* double-bounded column */\r\n        if (q.coef >= +DBL_EPSILON) \r\n            lo();\r\n        else if (q.coef <= -DBL_EPSILON) \r\n            up();\r\n        else if (Math.abs(q.lb) <= Math.abs(q.ub)) \r\n            lo();\r\n        else \r\n            up();\r\n    }\r\n    else\r\n    {  /* fixed column */\r\n        info.stat = GLP_NS;\r\n    }\r\n    /* process fixed column */\r\n    npp_fixed_col(npp, q);\r\n    return 0;\r\n}\r\n\r\nfunction npp_implied_value(npp, q, s){\r\n    /* process implied column value */\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* check integrality */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(s + 0.5);\r\n        if (Math.abs(s - nint) <= 1e-5)\r\n            s = nint;\r\n        else\r\n            return 2;\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.lb));\r\n        if (s < q.lb - eps) return 1;\r\n        /* if s[q] is close to l[q], fix column at its lower bound\r\n         rather than at the implied value */\r\n        if (s < q.lb + 1e-3 * eps)\r\n        {  q.ub = q.lb;\r\n            return 0;\r\n        }\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.ub));\r\n        if (s > q.ub + eps) return 1;\r\n        /* if s[q] is close to u[q], fix column at its upper bound\r\n         rather than at the implied value */\r\n        if (s > q.ub - 1e-3 * eps)\r\n        {  q.lb = q.ub;\r\n            return 0;\r\n        }\r\n    }\r\n    /* fix column at the implied value */\r\n    q.lb = q.ub = s;\r\n    return 0;\r\n}\r\n\r\nfunction npp_eq_singlet(npp, p){\r\n    /* process row singleton (equality constraint) */\r\n    var info;\r\n    var q;\r\n    var aij;\r\n    var lfe;\r\n    var ret;\r\n    var s;\r\n    /* the row must be singleton equality constraint */\r\n    xassert(p.lb == p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next == null);\r\n    /* compute and process implied column value */\r\n    aij = p.ptr;\r\n    q = aij.col;\r\n    s = p.lb / aij.val;\r\n    ret = npp_implied_value(npp, q, s);\r\n    xassert(0 <= ret && ret <= 2);\r\n    if (ret != 0) return ret;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row singleton (equality constraint) */\r\n            var lfe;\r\n            var temp;\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* column q must be already recovered as GLP_NS */\r\n                if (npp.c_stat[info.q] != GLP_NS)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                npp.r_stat[info.p] = GLP_NS;\r\n                npp.c_stat[info.q] = GLP_BS;\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute multiplier for row p with formula (3) */\r\n                temp = info.c;\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                    temp -= lfe.val * npp.r_pi[lfe.ref];\r\n                npp.r_pi[info.p] = temp / info.apq;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = aij.val;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q], i != p (not needed for MIP\r\n     solution) */\r\n    if (npp.sol != GLP_MIP)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  if (aij.row == p) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n    return 0;\r\n}\r\n\r\nfunction npp_implied_lower(npp, q, l){\r\n    /* process implied column lower bound */\r\n    var ret;\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* implied lower bound must be finite */\r\n    xassert(l != -DBL_MAX);\r\n    /* if column is integral, round up l'[q] */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(l + 0.5);\r\n        if (Math.abs(l - nint) <= 1e-5)\r\n            l = nint;\r\n        else\r\n            l = Math.ceil(l);\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-3 : 1e-3 + 1e-6 * Math.abs(q.lb));\r\n        if (l < q.lb + eps)\r\n        {  ret = 0; /* redundant */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.ub));\r\n        if (l > q.ub + eps)\r\n        {  ret = 4; /* infeasible */\r\n            return ret;\r\n        }\r\n        /* if l'[q] is close to u[q], fix column at its upper bound */\r\n        if (l > q.ub - 1e-3 * eps)\r\n        {  q.lb = q.ub;\r\n            ret = 3; /* fixed */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if column lower bound changes significantly */\r\n    if (q.lb == -DBL_MAX)\r\n        ret = 2; /* significantly */\r\n    else if (q.is_int && l > q.lb + 0.5)\r\n        ret = 2; /* significantly */\r\n    else if (l > q.lb + 0.30 * (1.0 + Math.abs(q.lb)))\r\n        ret = 2; /* significantly */\r\n    else\r\n        ret = 1; /* not significantly */\r\n    /* set new column lower bound */\r\n    q.lb = l;\r\n    return ret;\r\n}\r\n\r\nfunction npp_implied_upper(npp, q, u){\r\n    var ret;\r\n    var eps, nint;\r\n    xassert(npp == npp);\r\n    /* column must not be fixed */\r\n    xassert(q.lb < q.ub);\r\n    /* implied upper bound must be finite */\r\n    xassert(u != +DBL_MAX);\r\n    /* if column is integral, round down u'[q] */\r\n    if (q.is_int)\r\n    {  nint = Math.floor(u + 0.5);\r\n        if (Math.abs(u - nint) <= 1e-5)\r\n            u = nint;\r\n        else\r\n            u = Math.floor(u);\r\n    }\r\n    /* check current column upper bound */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-3 : 1e-3 + 1e-6 * Math.abs(q.ub));\r\n        if (u > q.ub - eps)\r\n        {  ret = 0; /* redundant */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check current column lower bound */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = (q.is_int ? 1e-5 : 1e-5 + 1e-8 * Math.abs(q.lb));\r\n        if (u < q.lb - eps)\r\n        {  ret = 4; /* infeasible */\r\n            return ret;\r\n        }\r\n        /* if u'[q] is close to l[q], fix column at its lower bound */\r\n        if (u < q.lb + 1e-3 * eps)\r\n        {  q.ub = q.lb;\r\n            ret = 3; /* fixed */\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if column upper bound changes significantly */\r\n    if (q.ub == +DBL_MAX)\r\n        ret = 2; /* significantly */\r\n    else if (q.is_int && u < q.ub - 0.5)\r\n        ret = 2; /* significantly */\r\n    else if (u < q.ub - 0.30 * (1.0 + Math.abs(q.ub)))\r\n        ret = 2; /* significantly */\r\n    else\r\n        ret = 1; /* not significantly */\r\n    /* set new column upper bound */\r\n    q.ub = u;\r\n    return ret;\r\n}\r\n\r\nfunction npp_ineq_singlet(npp, p){\r\n    /* process row singleton (inequality constraint) */\r\n    var info;\r\n    var q;\r\n    var apq, aij;\r\n    var lfe;\r\n    var lb_changed, ub_changed;\r\n    var ll, uu;\r\n    /* the row must be singleton inequality constraint */\r\n    xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next == null);\r\n    /* compute implied column bounds */\r\n    apq = p.ptr;\r\n    q = apq.col;\r\n    xassert(q.lb < q.ub);\r\n    if (apq.val > 0.0)\r\n    {  ll = (p.lb == -DBL_MAX ? -DBL_MAX : p.lb / apq.val);\r\n        uu = (p.ub == +DBL_MAX ? +DBL_MAX : p.ub / apq.val);\r\n    }\r\n    else\r\n    {  ll = (p.ub == +DBL_MAX ? -DBL_MAX : p.ub / apq.val);\r\n        uu = (p.lb == -DBL_MAX ? +DBL_MAX : p.lb / apq.val);\r\n    }\r\n    /* process implied column lower bound */\r\n    if (ll == -DBL_MAX)\r\n        lb_changed = 0;\r\n    else\r\n    {  lb_changed = npp_implied_lower(npp, q, ll);\r\n        xassert(0 <= lb_changed && lb_changed <= 4);\r\n        if (lb_changed == 4) return 4; /* infeasible */\r\n    }\r\n    /* process implied column upper bound */\r\n    if (uu == +DBL_MAX)\r\n        ub_changed = 0;\r\n    else if (lb_changed == 3)\r\n    {  /* column was fixed on its upper bound due to l'[q] = u[q] */\r\n        /* note that L[p] < U[p], so l'[q] = u[q] < u'[q] */\r\n        ub_changed = 0;\r\n    }\r\n    else\r\n    {  ub_changed = npp_implied_upper(npp, q, uu);\r\n        xassert(0 <= ub_changed && ub_changed <= 4);\r\n        if (ub_changed == 4) return 4; /* infeasible */\r\n    }\r\n    /* if neither lower nor upper column bound was changed, the row\r\n     is originally redundant and can be replaced by free row */\r\n    if (!lb_changed && !ub_changed)\r\n    {  p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n        npp_free_row(npp, p);\r\n        return 0;\r\n    }\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row singleton (inequality constraint) */\r\n            var lfe;\r\n            var lambda;\r\n            if (npp.sol == GLP_MIP) return 0;\r\n            /* compute lambda~[q] in solution to the transformed problem\r\n             with formula (8) */\r\n            lambda = info.c;\r\n            for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                lambda -= lfe.val * npp.r_pi[lfe.ref];\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* recover basic solution */\r\n\r\n                function nl(){  /* column q is non-basic with lower bound active */\r\n                    if (info.lb_changed)\r\n                    {  /* it is implied bound, so actually row p is active\r\n                     while column q is basic */\r\n                        npp.r_stat[info.p] =\r\n                            (info.apq > 0.0 ? GLP_NL : GLP_NU);\r\n                        npp.c_stat[info.q] = GLP_BS;\r\n                        npp.r_pi[info.p] = lambda / info.apq;\r\n                    }\r\n                    else\r\n                    {  /* it is original bound, so row p is inactive */\r\n                        npp.r_stat[info.p] = GLP_BS;\r\n                        npp.r_pi[info.p] = 0.0;\r\n                    }\r\n                    return 0;\r\n                }\r\n\r\n                function nu(){\r\n                    /* column q is non-basic with upper bound active */\r\n                    if (info.ub_changed)\r\n                    {  /* it is implied bound, so actually row p is active\r\n                     while column q is basic */\r\n                        npp.r_stat[info.p] =\r\n                            (info.apq > 0.0 ? GLP_NU : GLP_NL);\r\n                        npp.c_stat[info.q] = GLP_BS;\r\n                        npp.r_pi[info.p] = lambda / info.apq;\r\n                    }\r\n                    else\r\n                    {  /* it is original bound, so row p is inactive */\r\n                        npp.r_stat[info.p] = GLP_BS;\r\n                        npp.r_pi[info.p] = 0.0;\r\n                    }\r\n                    return 0;\r\n                }\r\n\r\n\r\n                if (npp.c_stat[info.q] == GLP_BS)\r\n                {  /* column q is basic, so row p is inactive */\r\n                    npp.r_stat[info.p] = GLP_BS;\r\n                    npp.r_pi[info.p] = 0.0;\r\n                }\r\n                else if (npp.c_stat[info.q] == GLP_NL)\r\n                    nl();\r\n                else if (npp.c_stat[info.q] == GLP_NU)\r\n                    nu();\r\n                else if (npp.c_stat[info.q] == GLP_NS)\r\n                {  /* column q is non-basic and fixed; note, however, that in\r\n                 in the original problem it is non-fixed */\r\n                    if (lambda > +1e-7)\r\n                    {  if (info.apq > 0.0 && info.lb != -DBL_MAX ||\r\n                        info.apq < 0.0 && info.ub != +DBL_MAX ||\r\n                        !info.lb_changed)\r\n                    {  /* either corresponding bound of row p exists or\r\n                     column q remains non-basic with its original lower\r\n                     bound active */\r\n                        npp.c_stat[info.q] = GLP_NL;\r\n                        return nl();\r\n                    }\r\n                    }\r\n                    if (lambda < -1e-7)\r\n                    {  if (info.apq > 0.0 && info.ub != +DBL_MAX ||\r\n                        info.apq < 0.0 && info.lb != -DBL_MAX ||\r\n                        !info.ub_changed)\r\n                    {  /* either corresponding bound of row p exists or\r\n                     column q remains non-basic with its original upper\r\n                     bound active */\r\n                        npp.c_stat[info.q] = GLP_NU;\r\n                        return nu();\r\n                    }\r\n                    }\r\n                    /* either lambda~[q] is close to zero, or corresponding\r\n                     bound of row p does not exist, because lambda~[q] has\r\n                     wrong sign due to round-off errors; in the latter case\r\n                     lambda~[q] is also assumed to be close to zero; so, we\r\n                     can make row p active on its existing bound and column q\r\n                     basic; pi[p] will have wrong sign, but it also will be\r\n                     close to zero (rarus casus of dual degeneracy) */\r\n                    if (info.lb != -DBL_MAX && info.ub == +DBL_MAX)\r\n                    {  /* row lower bound exists, but upper bound doesn't */\r\n                        npp.r_stat[info.p] = GLP_NL;\r\n                    }\r\n                    else if (info.lb == -DBL_MAX && info.ub != +DBL_MAX)\r\n                    {  /* row upper bound exists, but lower bound doesn't */\r\n                        npp.r_stat[info.p] = GLP_NU;\r\n                    }\r\n                    else if (info.lb != -DBL_MAX && info.ub != +DBL_MAX)\r\n                    {  /* both row lower and upper bounds exist */\r\n                        /* to choose proper active row bound we should not use\r\n                         lambda~[q], because its value being close to zero is\r\n                         unreliable; so we choose that bound which provides\r\n                         primal feasibility for original constraint (1) */\r\n                        if (info.apq * npp.c_value[info.q] <=\r\n                            0.5 * (info.lb + info.ub))\r\n                            npp.r_stat[info.p] = GLP_NL;\r\n                        else\r\n                            npp.r_stat[info.p] = GLP_NU;\r\n                    }\r\n                    else\r\n                    {  npp_error();\r\n                        return 1;\r\n                    }\r\n                    npp.c_stat[info.q] = GLP_BS;\r\n                    npp.r_pi[info.p] = lambda / info.apq;\r\n                }\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n            }\r\n\r\n            if (npp.sol == GLP_IPT)\r\n            {  /* recover interior-point solution */\r\n                if (lambda > +DBL_EPSILON && info.lb_changed ||\r\n                    lambda < -DBL_EPSILON && info.ub_changed)\r\n                {  /* actually row p has corresponding active bound */\r\n                    npp.r_pi[info.p] = lambda / info.apq;\r\n                }\r\n                else\r\n                {  /* either bounds of column q are both inactive or its\r\n                 original bound is active */\r\n                    npp.r_pi[info.p] = 0.0;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = apq.val;\r\n    info.c = q.coef;\r\n    info.lb = p.lb;\r\n    info.ub = p.ub;\r\n    info.lb_changed = lb_changed;\r\n    info.ub_changed = ub_changed;\r\n    info.ptr = null;\r\n    /* save column coefficients a[i,q], i != p (not needed for MIP\r\n     solution) */\r\n    if (npp.sol != GLP_MIP)\r\n    {  for (aij = q.ptr; aij != null; aij = aij.c_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.row.i;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n    }\r\n    }\r\n    /* remove the row from the problem */\r\n    npp_del_row(npp, p);\r\n    return lb_changed >= ub_changed ? lb_changed : ub_changed;\r\n}\r\n\r\nfunction npp_implied_slack(npp, q){\r\n    /* process column singleton (implied slack variable) */\r\n    var info;\r\n    var p;\r\n    var aij;\r\n    var lfe;\r\n    /* the column must be non-integral non-fixed singleton */\r\n    xassert(!q.is_int);\r\n    xassert(q.lb < q.ub);\r\n    xassert(q.ptr != null && q.ptr.c_next == null);\r\n    /* corresponding row must be equality constraint */\r\n    aij = q.ptr;\r\n    p = aij.row;\r\n    xassert(p.lb == p.ub);\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column singleton (implied slack variable) */\r\n            var temp;\r\n            var lfe;\r\n            if (npp.sol == GLP_SOL)\r\n            {  /* assign statuses to row p and column q */\r\n                if (npp.r_stat[info.p] == GLP_BS ||\r\n                    npp.r_stat[info.p] == GLP_NF)\r\n                    npp.c_stat[info.q] = npp.r_stat[info.p];\r\n                else if (npp.r_stat[info.p] == GLP_NL)\r\n                    npp.c_stat[info.q] =\r\n                        (info.apq > 0.0 ? GLP_NU : GLP_NL);\r\n                else if (npp.r_stat[info.p] == GLP_NU)\r\n                    npp.c_stat[info.q] =\r\n                        (info.apq > 0.0 ? GLP_NL : GLP_NU);\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                npp.r_stat[info.p] = GLP_NS;\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute multiplier for row p */\r\n                npp.r_pi[info.p] += info.c / info.apq;\r\n            }\r\n            /* compute value of column q */\r\n            temp = info.b;\r\n            for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                temp -= lfe.val * npp.c_value[lfe.ref];\r\n            npp.c_value[info.q] = temp / info.apq;\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.q = q.j;\r\n    info.apq = aij.val;\r\n    info.b = p.lb;\r\n    info.c = q.coef;\r\n    info.ptr = null;\r\n    /* save row coefficients a[p,j], j != q, and substitute x[q]\r\n     into the objective row */\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.col == q) continue; /* skip a[p,q] */\r\n        lfe = {};\r\n        lfe.ref = aij.col.j;\r\n        lfe.val = aij.val;\r\n        lfe.next = info.ptr;\r\n        info.ptr = lfe;\r\n        aij.col.coef -= info.c * (aij.val / info.apq);\r\n    }\r\n    npp.c0 += info.c * (info.b / info.apq);\r\n    /* compute new row bounds */\r\n    if (info.apq > 0.0)\r\n    {  p.lb = (q.ub == +DBL_MAX ?\r\n        -DBL_MAX : info.b - info.apq * q.ub);\r\n        p.ub = (q.lb == -DBL_MAX ?\r\n            +DBL_MAX : info.b - info.apq * q.lb);\r\n    }\r\n    else\r\n    {  p.lb = (q.lb == -DBL_MAX ?\r\n        -DBL_MAX : info.b - info.apq * q.lb);\r\n        p.ub = (q.ub == +DBL_MAX ?\r\n            +DBL_MAX : info.b - info.apq * q.ub);\r\n    }\r\n    /* remove the column from the problem */\r\n    npp_del_col(npp, q);\r\n}\r\n\r\nfunction npp_implied_free(npp, q){\r\n    /* process column singleton (implied free variable) */\r\n    var info;\r\n    var p;\r\n    var apq, aij;\r\n    var alfa, beta, l, u, pi, eps;\r\n    /* the column must be non-fixed singleton */\r\n    xassert(q.lb < q.ub);\r\n    xassert(q.ptr != null && q.ptr.c_next == null);\r\n    /* corresponding row must be inequality constraint */\r\n    apq = q.ptr;\r\n    p = apq.row;\r\n    xassert(p.lb != -DBL_MAX || p.ub != +DBL_MAX);\r\n    xassert(p.lb < p.ub);\r\n    /* compute alfa */\r\n    alfa = p.lb;\r\n    if (alfa != -DBL_MAX)\r\n    {  for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        if (aij.val > 0.0)\r\n        {  if (aij.col.ub == +DBL_MAX)\r\n        {  alfa = -DBL_MAX;\r\n            break;\r\n        }\r\n            alfa -= aij.val * aij.col.ub;\r\n        }\r\n        else /* < 0.0 */\r\n        {  if (aij.col.lb == -DBL_MAX)\r\n        {  alfa = -DBL_MAX;\r\n            break;\r\n        }\r\n            alfa -= aij.val * aij.col.lb;\r\n        }\r\n    }\r\n    }\r\n    /* compute beta */\r\n    beta = p.ub;\r\n    if (beta != +DBL_MAX)\r\n    {  for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij == apq) continue; /* skip a[p,q] */\r\n        if (aij.val > 0.0)\r\n        {  if (aij.col.lb == -DBL_MAX)\r\n        {  beta = +DBL_MAX;\r\n            break;\r\n        }\r\n            beta -= aij.val * aij.col.lb;\r\n        }\r\n        else /* < 0.0 */\r\n        {  if (aij.col.ub == +DBL_MAX)\r\n        {  beta = +DBL_MAX;\r\n            break;\r\n        }\r\n            beta -= aij.val * aij.col.ub;\r\n        }\r\n    }\r\n    }\r\n    /* compute implied column lower bound l'[q] */\r\n    if (apq.val > 0.0)\r\n        l = (alfa == -DBL_MAX ? -DBL_MAX : alfa / apq.val);\r\n    else /* < 0.0 */\r\n        l = (beta == +DBL_MAX ? -DBL_MAX : beta / apq.val);\r\n    /* compute implied column upper bound u'[q] */\r\n    if (apq.val > 0.0)\r\n        u = (beta == +DBL_MAX ? +DBL_MAX : beta / apq.val);\r\n    else\r\n        u = (alfa == -DBL_MAX ? +DBL_MAX : alfa / apq.val);\r\n    /* check if column lower bound l[q] can be active */\r\n    if (q.lb != -DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(q.lb);\r\n        if (l < q.lb - eps) return 1; /* yes, it can */\r\n    }\r\n    /* check if column upper bound u[q] can be active */\r\n    if (q.ub != +DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(q.ub);\r\n        if (u > q.ub + eps) return 1; /* yes, it can */\r\n    }\r\n    /* okay; make column q free (unbounded) */\r\n    q.lb = -DBL_MAX; q.ub = +DBL_MAX;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover column singleton (implied free variable) */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] == GLP_BS)\r\n                npp.r_stat[info.p] = GLP_BS;\r\n            else if (npp.r_stat[info.p] == GLP_NS)\r\n            {  xassert(info.stat == GLP_NL || info.stat == GLP_NU);\r\n                npp.r_stat[info.p] = info.stat;\r\n            }\r\n            else\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.stat = -1;\r\n    /* compute row multiplier pi[p] */\r\n    pi = q.coef / apq.val;\r\n    /* check dual feasibility for row p */\r\n\r\n    function nl(){\r\n        info.stat = GLP_NL;\r\n        p.ub = p.lb;\r\n    }\r\n\r\n    function nu(){\r\n        info.stat = GLP_NU;\r\n        p.lb = p.ub;\r\n    }\r\n\r\n    if (pi > +DBL_EPSILON)\r\n    {  /* lower bound L[p] must be active */\r\n        if (p.lb != -DBL_MAX)\r\n            nl();\r\n        else\r\n        {  if (pi > +1e-5) return 2; /* dual infeasibility */\r\n            /* take a chance on U[p] */\r\n            xassert(p.ub != +DBL_MAX);\r\n            nu();\r\n        }\r\n    }\r\n    else if (pi < -DBL_EPSILON)\r\n    {  /* upper bound U[p] must be active */\r\n        if (p.ub != +DBL_MAX)\r\n            nu();\r\n        else\r\n        {  if (pi < -1e-5) return 2; /* dual infeasibility */\r\n            /* take a chance on L[p] */\r\n            xassert(p.lb != -DBL_MAX);\r\n            nl();\r\n        }\r\n    }\r\n    else\r\n    {  /* any bound (either L[p] or U[p]) can be made active  */\r\n        if (p.ub == +DBL_MAX)\r\n        {  xassert(p.lb != -DBL_MAX);\r\n           nl();\r\n        }\r\n        else if (p.lb == -DBL_MAX)\r\n        {  xassert(p.ub != +DBL_MAX);\r\n            nu();\r\n        } else {\r\n            if (Math.abs(p.lb) <= Math.abs(p.ub)) nl(); else nu();\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction npp_eq_doublet(npp, p){\r\n    /* process row doubleton (equality constraint) */\r\n    var info;\r\n    var i;\r\n    var q, r;\r\n    var apq, apr, aiq, air, next;\r\n    var lfe;\r\n    var gamma;\r\n    /* the row must be doubleton equality constraint */\r\n    xassert(p.lb == p.ub);\r\n    xassert(p.ptr != null && p.ptr.r_next != null &&\r\n        p.ptr.r_next.r_next == null);\r\n    /* choose column to be eliminated */\r\n    {  var a1, a2;\r\n        a1 = p.ptr; a2 = a1.r_next;\r\n        if (Math.abs(a2.val) < 0.001 * Math.abs(a1.val))\r\n        {  /* only first column can be eliminated, because second one\r\n         has too small constraint coefficient */\r\n            apq = a1; apr = a2;\r\n        }\r\n        else if (Math.abs(a1.val) < 0.001 * Math.abs(a2.val))\r\n        {  /* only second column can be eliminated, because first one\r\n         has too small constraint coefficient */\r\n            apq = a2; apr = a1;\r\n        }\r\n        else\r\n        {  /* both columns are appropriate; choose that one which is\r\n         shorter to minimize fill-in */\r\n            if (npp_col_nnz(a1.col) <= npp_col_nnz(a2.col))\r\n            {  /* first column is shorter */\r\n                apq = a1; apr = a2;\r\n            }\r\n            else\r\n            {  /* second column is shorter */\r\n                apq = a2; apr = a1;\r\n            }\r\n        }\r\n    }\r\n    /* now columns q and r have been chosen */\r\n    q = apq.col; r = apr.col;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover row doubleton (equality constraint) */\r\n            var lfe;\r\n            var gamma, temp;\r\n            /* we assume that processing row p is followed by processing\r\n             column q as singleton of type \"implied slack variable\", in\r\n             which case row p must always be active equality constraint */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] != GLP_NS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n            }\r\n            if (npp.sol != GLP_MIP)\r\n            {  /* compute value of multiplier for row p; see (14) */\r\n                temp = npp.r_pi[info.p];\r\n                for (lfe = info.ptr; lfe != null; lfe = lfe.next)\r\n                {  gamma = lfe.val / info.apq; /* a[i,q] / a[p,q] */\r\n                    temp -= gamma * npp.r_pi[lfe.ref];\r\n                }\r\n                npp.r_pi[info.p] = temp;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    info.apq = apq.val;\r\n    info.ptr = null;\r\n    /* transform each row i (i != p), where a[i,q] != 0, to eliminate\r\n     column q */\r\n    for (aiq = q.ptr; aiq != null; aiq = next)\r\n    {  next = aiq.c_next;\r\n        if (aiq == apq) continue; /* skip row p */\r\n        i = aiq.row; /* row i to be transformed */\r\n        /* save constraint coefficient a[i,q] */\r\n        if (npp.sol != GLP_MIP)\r\n        {  lfe = {};\r\n            lfe.ref = i.i;\r\n            lfe.val = aiq.val;\r\n            lfe.next = info.ptr;\r\n            info.ptr = lfe;\r\n        }\r\n        /* find coefficient a[i,r] in row i */\r\n        for (air = i.ptr; air != null; air = air.r_next)\r\n            if (air.col == r) break;\r\n        /* if a[i,r] does not exist, create a[i,r] = 0 */\r\n        if (air == null)\r\n            air = npp_add_aij(i, r, 0.0);\r\n        /* compute gamma[i] = a[i,q] / a[p,q] */\r\n        gamma = aiq.val / apq.val;\r\n        /* (row i) := (row i) - gamma[i] * (row p); see (3)-(6) */\r\n        /* new a[i,q] is exact zero due to elimnation; remove it from\r\n         row i */\r\n        npp_del_aij(aiq);\r\n        /* compute new a[i,r] */\r\n        air.val -= gamma * apr.val;\r\n        /* if new a[i,r] is close to zero due to numeric cancelation,\r\n         remove it from row i */\r\n        if (Math.abs(air.val) <= 1e-10)\r\n            npp_del_aij(air);\r\n        /* compute new lower and upper bounds of row i */\r\n        if (i.lb == i.ub)\r\n            i.lb = i.ub = (i.lb - gamma * p.lb);\r\n        else\r\n        {  if (i.lb != -DBL_MAX)\r\n            i.lb -= gamma * p.lb;\r\n            if (i.ub != +DBL_MAX)\r\n                i.ub -= gamma * p.lb;\r\n        }\r\n    }\r\n    return q;\r\n}\r\n\r\nfunction npp_forcing_row(npp, p, at){\r\n    /* process forcing row */\r\n    var info;\r\n    var col = null;\r\n    var j;\r\n    var apj, aij;\r\n    var lfe;\r\n    var big;\r\n    xassert(at == 0 || at == 1);\r\n    /* determine maximal magnitude of the row coefficients */\r\n    big = 1.0;\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n        if (big < Math.abs(apj.val)) big = Math.abs(apj.val);\r\n    /* if there are too small coefficients in the row, transformation\r\n     should not be applied */\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n        if (Math.abs(apj.val) < 1e-7 * big) return 1;\r\n    /* create transformation stack entry */\r\n    info = npp_push_tse(npp,\r\n        function (npp, info){\r\n            /* recover forcing row */\r\n            var col, piv;\r\n            var lfe;\r\n            var d, big, temp;\r\n            if (npp.sol == GLP_MIP) return 0;\r\n            /* initially solution to the original problem is the same as\r\n             to the transformed problem, where row p is inactive constraint\r\n             with pi[p] = 0, and all columns are non-basic */\r\n            if (npp.sol == GLP_SOL)\r\n            {  if (npp.r_stat[info.p] != GLP_BS)\r\n            {  npp_error();\r\n                return 1;\r\n            }\r\n                for (col = info.ptr; col != null; col = col.next)\r\n                {  if (npp.c_stat[col.j] != GLP_NS)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                    npp.c_stat[col.j] = col.stat; /* original status */\r\n                }\r\n            }\r\n            /* compute reduced costs d[j] for all columns with formula (10)\r\n             and store them in col.c instead objective coefficients */\r\n            for (col = info.ptr; col != null; col = col.next)\r\n            {  d = col.c;\r\n                for (lfe = col.ptr; lfe != null; lfe = lfe.next)\r\n                    d -= lfe.val * npp.r_pi[lfe.ref];\r\n                col.c = d;\r\n            }\r\n            /* consider columns j, whose multipliers lambda[j] has wrong\r\n             sign in solution to the transformed problem (where lambda[j] =\r\n             d[j]), and choose column q, whose multipler lambda[q] reaches\r\n             zero last on changing row multiplier pi[p]; see (14) */\r\n            piv = null; big = 0.0;\r\n            for (col = info.ptr; col != null; col = col.next)\r\n            {  d = col.c; /* d[j] */\r\n                temp = Math.abs(d / col.a);\r\n                if (col.stat == GLP_NL)\r\n                {  /* column j has active lower bound */\r\n                    if (d < 0.0 && big < temp){\r\n                        piv = col; big = temp;\r\n                    }\r\n                }\r\n                else if (col.stat == GLP_NU)\r\n                {  /* column j has active upper bound */\r\n                    if (d > 0.0 && big < temp){\r\n                        piv = col; big = temp;\r\n                    }\r\n                }\r\n                else\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n            }\r\n            /* if column q does not exist, no correction is needed */\r\n            if (piv != null)\r\n            {  /* correct solution; row p becomes active constraint while\r\n             column q becomes basic */\r\n                if (npp.sol == GLP_SOL)\r\n                {  npp.r_stat[info.p] = info.stat;\r\n                    npp.c_stat[piv.j] = GLP_BS;\r\n                }\r\n                /* assign new value to row multiplier pi[p] = d[p] / a[p,q] */\r\n                npp.r_pi[info.p] = piv.c / piv.a;\r\n            }\r\n            return 0;\r\n        }\r\n    );\r\n    info.p = p.i;\r\n    if (p.lb == p.ub)\r\n    {  /* equality constraint */\r\n        info.stat = GLP_NS;\r\n    }\r\n    else if (at == 0)\r\n    {  /* inequality constraint; case L[p] = U'[p] */\r\n        info.stat = GLP_NL;\r\n        xassert(p.lb != -DBL_MAX);\r\n    }\r\n    else /* at == 1 */\r\n    {  /* inequality constraint; case U[p] = L'[p] */\r\n        info.stat = GLP_NU;\r\n        xassert(p.ub != +DBL_MAX);\r\n    }\r\n    info.ptr = null;\r\n    /* scan the forcing row, fix columns at corresponding bounds, and\r\n     save column information (the latter is not needed for MIP) */\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n    {  /* column j has non-zero coefficient in the forcing row */\r\n        j = apj.col;\r\n        /* it must be non-fixed */\r\n        xassert(j.lb < j.ub);\r\n        /* allocate stack entry to save column information */\r\n        if (npp.sol != GLP_MIP)\r\n        {  col = {};\r\n            col.j = j.j;\r\n            col.stat = -1; /* will be set below */\r\n            col.a = apj.val;\r\n            col.c = j.coef;\r\n            col.ptr = null;\r\n            col.next = info.ptr;\r\n            info.ptr = col;\r\n        }\r\n        /* fix column j */\r\n        if (at == 0 && apj.val < 0.0 || at != 0 && apj.val > 0.0)\r\n        {  /* at its lower bound */\r\n            if (npp.sol != GLP_MIP)\r\n                col.stat = GLP_NL;\r\n            xassert(j.lb != -DBL_MAX);\r\n            j.ub = j.lb;\r\n        }\r\n        else\r\n        {  /* at its upper bound */\r\n            if (npp.sol != GLP_MIP)\r\n                col.stat = GLP_NU;\r\n            xassert(j.ub != +DBL_MAX);\r\n            j.lb = j.ub;\r\n        }\r\n        /* save column coefficients a[i,j], i != p */\r\n        if (npp.sol != GLP_MIP)\r\n        {  for (aij = j.ptr; aij != null; aij = aij.c_next)\r\n        {  if (aij == apj) continue; /* skip a[p,j] */\r\n            lfe = {};\r\n            lfe.ref = aij.row.i;\r\n            lfe.val = aij.val;\r\n            lfe.next = col.ptr;\r\n            col.ptr = lfe;\r\n        }\r\n        }\r\n    }\r\n    /* make the row free (unbounded) */\r\n    p.lb = -DBL_MAX; p.ub = +DBL_MAX;\r\n    return 0;\r\n}\r\n\r\nfunction npp_analyze_row(npp, p){\r\n    /* perform general row analysis */\r\n    var aij;\r\n    var ret = 0x00;\r\n    var l, u, eps;\r\n    xassert(npp == npp);\r\n    /* compute implied lower bound L'[p]; see (3) */\r\n    l = 0.0;\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.val > 0.0)\r\n    {  if (aij.col.lb == -DBL_MAX)\r\n    {  l = -DBL_MAX;\r\n        break;\r\n    }\r\n        l += aij.val * aij.col.lb;\r\n    }\r\n    else /* aij.val < 0.0 */\r\n    {  if (aij.col.ub == +DBL_MAX)\r\n    {  l = -DBL_MAX;\r\n        break;\r\n    }\r\n        l += aij.val * aij.col.ub;\r\n    }\r\n    }\r\n    /* compute implied upper bound U'[p]; see (4) */\r\n    u = 0.0;\r\n    for (aij = p.ptr; aij != null; aij = aij.r_next)\r\n    {  if (aij.val > 0.0)\r\n    {  if (aij.col.ub == +DBL_MAX)\r\n    {  u = +DBL_MAX;\r\n        break;\r\n    }\r\n        u += aij.val * aij.col.ub;\r\n    }\r\n    else /* aij.val < 0.0 */\r\n    {  if (aij.col.lb == -DBL_MAX)\r\n    {  u = +DBL_MAX;\r\n        break;\r\n    }\r\n        u += aij.val * aij.col.lb;\r\n    }\r\n    }\r\n    /* column bounds are assumed correct, so L'[p] <= U'[p] */\r\n    /* check if row lower bound is consistent */\r\n    if (p.lb != -DBL_MAX)\r\n    {  eps = 1e-3 + 1e-6 * Math.abs(p.lb);\r\n        if (p.lb - eps > u)\r\n        {  ret = 0x33;\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if row upper bound is consistent */\r\n    if (p.ub != +DBL_MAX)\r\n    {  eps = 1e-3 + 1e-6 * Math.abs(p.ub);\r\n        if (p.ub + eps < l)\r\n        {  ret = 0x33;\r\n            return ret;\r\n        }\r\n    }\r\n    /* check if row lower bound can be active/forcing */\r\n    if (p.lb != -DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(p.lb);\r\n        if (p.lb - eps > l)\r\n        {  if (p.lb + eps <= u)\r\n            ret |= 0x01;\r\n        else\r\n            ret |= 0x02;\r\n        }\r\n    }\r\n    /* check if row upper bound can be active/forcing */\r\n    if (p.ub != +DBL_MAX)\r\n    {  eps = 1e-9 + 1e-12 * Math.abs(p.ub);\r\n        if (p.ub + eps < u)\r\n        {  /* check if the upper bound is forcing */\r\n            if (p.ub - eps >= l)\r\n                ret |= 0x10;\r\n            else\r\n                ret |= 0x20;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction npp_inactive_bound(npp, p, which){\r\n    /* remove row lower/upper inactive bound */\r\n    var info;\r\n    if (npp.sol == GLP_SOL)\r\n    {  /* create transformation stack entry */\r\n        info = npp_push_tse(npp,\r\n            function (npp, info){\r\n                /* recover row status */\r\n                if (npp.sol != GLP_SOL)\r\n                {  npp_error();\r\n                    return 1;\r\n                }\r\n                if (npp.r_stat[info.p] == GLP_BS)\r\n                    npp.r_stat[info.p] = GLP_BS;\r\n                else\r\n                    npp.r_stat[info.p] = info.stat;\r\n                return 0;\r\n            }\r\n        );\r\n        info.p = p.i;\r\n        if (p.ub == +DBL_MAX)\r\n            info.stat = GLP_NL;\r\n        else if (p.lb == -DBL_MAX)\r\n            info.stat = GLP_NU;\r\n        else if (p.lb != p.ub)\r\n            info.stat = (which == 0 ? GLP_NU : GLP_NL);\r\n        else\r\n            info.stat = GLP_NS;\r\n    }\r\n    /* remove row inactive bound */\r\n    if (which == 0)\r\n    {  xassert(p.lb != -DBL_MAX);\r\n        p.lb = -DBL_MAX;\r\n    }\r\n    else if (which == 1)\r\n    {  xassert(p.ub != +DBL_MAX);\r\n        p.ub = +DBL_MAX;\r\n    }\r\n    else\r\n        xassert(which != which);\r\n}\r\n\r\nfunction npp_implied_bounds(npp, p){\r\n    var apj, apk;\r\n    var big, eps, temp;\r\n    var skip = false;\r\n    xassert(npp == npp);\r\n    /* initialize implied bounds for all variables and determine\r\n     maximal magnitude of row coefficients a[p,j] */\r\n    big = 1.0;\r\n    for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n    {  apj.col.ll.ll = -DBL_MAX; apj.col.uu.uu = +DBL_MAX;\r\n        if (big < Math.abs(apj.val)) big = Math.abs(apj.val);\r\n    }\r\n    eps = 1e-6 * big;\r\n    /* process row lower bound (assuming that it can be active) */\r\n    if (p.lb != -DBL_MAX){\r\n        apk = null;\r\n\r\n        for (apj = p.ptr; apj != null; apj = apj.r_next){\r\n            if (apj.val > 0.0 && apj.col.ub == +DBL_MAX || apj.val < 0.0 && apj.col.lb == -DBL_MAX){\r\n                if (apk == null)\r\n                    apk = apj;\r\n                else {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!skip){\r\n            /* if a[p,k] = null then |J'| = 0 else J' = { k } */\r\n            temp = p.lb;\r\n            for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n            {  if (apj == apk){\r\n                /* skip a[p,k] */\r\n            }\r\n            else if (apj.val > 0.0)\r\n                temp -= apj.val * apj.col.ub;\r\n            else /* apj.val < 0.0 */\r\n                temp -= apj.val * apj.col.lb;\r\n            }\r\n            /* compute column implied bounds */\r\n            if (apk == null)\r\n            {  /* temp = L[p] - U'[p] */\r\n                for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n                {  if (apj.val >= +eps)\r\n                {  /* l'[j] := u[j] + (L[p] - U'[p]) / a[p,j] */\r\n                    apj.col.ll.ll = apj.col.ub + temp / apj.val;\r\n                }\r\n                else if (apj.val <= -eps)\r\n                {  /* u'[j] := l[j] + (L[p] - U'[p]) / a[p,j] */\r\n                    apj.col.uu.uu = apj.col.lb + temp / apj.val;\r\n                }\r\n                }\r\n            }\r\n            else\r\n            {  /* temp = L[p,k] */\r\n                if (apk.val >= +eps)\r\n                {  /* l'[k] := L[p,k] / a[p,k] */\r\n                    apk.col.ll.ll = temp / apk.val;\r\n                }\r\n                else if (apk.val <= -eps)\r\n                {  /* u'[k] := L[p,k] / a[p,k] */\r\n                    apk.col.uu.uu = temp / apk.val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    skip = false;\r\n    /* process row upper bound (assuming that it can be active) */\r\n    if (p.ub != +DBL_MAX)\r\n    {  apk = null;\r\n        for (apj = p.ptr; apj != null; apj = apj.r_next){\r\n            if (apj.val > 0.0 && apj.col.lb == -DBL_MAX || apj.val < 0.0 && apj.col.ub == +DBL_MAX){\r\n                if (apk == null)\r\n                    apk = apj;\r\n                else {\r\n                    skip = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!skip){\r\n            /* if a[p,k] = null then |J''| = 0 else J'' = { k } */\r\n            temp = p.ub;\r\n            for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n            {  if (apj == apk){\r\n                /* skip a[p,k] */\r\n            }\r\n            else if (apj.val > 0.0)\r\n                temp -= apj.val * apj.col.lb;\r\n            else /* apj.val < 0.0 */\r\n                temp -= apj.val * apj.col.ub;\r\n            }\r\n            /* compute column implied bounds */\r\n            if (apk == null)\r\n            {  /* temp = U[p] - L'[p] */\r\n                for (apj = p.ptr; apj != null; apj = apj.r_next)\r\n                {  if (apj.val >= +eps)\r\n                {  /* u'[j] := l[j] + (U[p] - L'[p]) / a[p,j] */\r\n                    apj.col.uu.uu = apj.col.lb + temp / apj.val;\r\n                }\r\n                else if (apj.val <= -eps)\r\n                {  /* l'[j] := u[j] + (U[p] - L'[p]) / a[p,j] */\r\n                    apj.col.ll.ll = apj.col.ub + temp / apj.val;\r\n                }\r\n                }\r\n            }\r\n            else\r\n            {  /* temp = U[p,k] */\r\n                if (apk.val >= +eps)\r\n                {  /* u'[k] := U[p,k] / a[p,k] */\r\n                    apk.col.uu.uu = temp / apk.val;\r\n                }\r\n                else if (apk.val <= -eps)\r\n                {  /* l'[k] := U[p,k] / a[p,k] */\r\n                    apk.col.ll.ll = temp / apk.val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nfunction npp_binarize_prob(npp){\r\n    /* binarize MIP problem */\r\n    var info;\r\n    var row;\r\n    var col, bin;\r\n    var aij;\r\n    var u, n, k, temp, nfails, nvars, nbins, nrows;\r\n    /* new variables will be added to the end of the column list, so\r\n     we go from the end to beginning of the column list */\r\n    nfails = nvars = nbins = nrows = 0;\r\n    for (col = npp.c_tail; col != null; col = col.prev)\r\n    {  /* skip continuous variable */\r\n        if (!col.is_int) continue;\r\n        /* skip fixed variable */\r\n        if (col.lb == col.ub) continue;\r\n        /* skip binary variable */\r\n        if (col.lb == 0.0 && col.ub == 1.0) continue;\r\n        /* check if the transformation is applicable */\r\n        if (col.lb < -1e6 || col.ub > +1e6 ||\r\n            col.ub - col.lb > 4095.0)\r\n        {  /* unfortunately, not */\r\n            nfails++;\r\n            continue;\r\n        }\r\n        /* process integer non-binary variable x[q] */\r\n        nvars++;\r\n        /* make x[q] non-negative, if its lower bound is non-zero */\r\n        if (col.lb != 0.0)\r\n            npp_lbnd_col(npp, col);\r\n        /* now 0 <= x[q] <= u[q] */\r\n        xassert(col.lb == 0.0);\r\n        u = col.ub|0;\r\n        xassert(col.ub == u);\r\n        /* if x[q] is binary, further processing is not needed */\r\n        if (u == 1) continue;\r\n        /* determine smallest n such that u <= 2^n - 1 (thus, n is the\r\n         number of binary variables needed) */\r\n        n = 2; temp = 4;\r\n        while (u >= temp){\r\n            n++; temp += temp;\r\n        }\r\n        nbins += n;\r\n        /* create transformation stack entry */\r\n        info = npp_push_tse(npp,\r\n            function (npp, info)\r\n            {     /* recovery binarized variable */\r\n                var k, temp;\r\n                /* compute value of x[q]; see formula (3) */\r\n                var sum = npp.c_value[info.q];\r\n                for (k = 1, temp = 2; k < info.n; k++, temp += temp)\r\n                    sum += temp * npp.c_value[info.j + (k-1)];\r\n                npp.c_value[info.q] = sum;\r\n                return 0;\r\n            }\r\n        );\r\n        info.q = col.j;\r\n        info.j = 0; /* will be set below */\r\n        info.n = n;\r\n        /* if u < 2^n - 1, we need one additional row for (4) */\r\n        if (u < temp - 1)\r\n        {  row = npp_add_row(npp); nrows++;\r\n            row.lb = -DBL_MAX; row.ub = u;\r\n        }\r\n        else\r\n            row = null;\r\n        /* in the transformed problem variable x[q] becomes binary\r\n         variable x[0], so its objective and constraint coefficients\r\n         are not changed */\r\n        col.ub = 1.0;\r\n        /* include x[0] into constraint (4) */\r\n        if (row != null)\r\n            npp_add_aij(row, col, 1.0);\r\n        /* add other binary variables x[1], ..., x[n-1] */\r\n        for (k = 1, temp = 2; k < n; k++, temp += temp)\r\n        {  /* add new binary variable x[k] */\r\n            bin = npp_add_col(npp);\r\n            bin.is_int = 1;\r\n            bin.lb = 0.0; bin.ub = 1.0;\r\n            bin.coef = temp * col.coef;\r\n            /* store column reference number for x[1] */\r\n            if (info.j == 0)\r\n                info.j = bin.j;\r\n            else\r\n                xassert(info.j + (k-1) == bin.j);\r\n            /* duplicate constraint coefficients for x[k]; this also\r\n             automatically includes x[k] into constraint (4) */\r\n            for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                npp_add_aij(aij.row, bin, temp * aij.val);\r\n        }\r\n    }\r\n    if (nvars > 0)\r\n        xprintf(nvars + \" integer variable(s) were replaced by \" + nbins + \" binary ones\");\r\n    if (nrows > 0)\r\n        xprintf(nrows + \" row(s) were added due to binarization\");\r\n    if (nfails > 0)\r\n        xprintf(\"Binarization failed for \" + nfails + \" integer variable(s)\");\r\n    return nfails;\r\n}\r\n\r\nfunction copy_form(row, s){\r\n    /* copy linear form */\r\n    var aij;\r\n    var ptr, e;\r\n    ptr = null;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  e = {};\r\n        e.aj = s * aij.val;\r\n        e.xj = aij.col;\r\n        e.next = ptr;\r\n        ptr = e;\r\n    }\r\n    return ptr;\r\n}\r\n\r\nfunction npp_is_packing(npp, row){\r\n    /* test if constraint is packing inequality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (!(row.lb == -DBL_MAX && row.ub != +DBL_MAX))\r\n        return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.ub != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction hidden_packing(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] <= b;\r\n 0 - specified row is NOT hidden packing inequality;\r\n 1 - specified row is packing inequality;\r\n 2 - specified row is hidden packing inequality. */\r\n    var e, ej, ek;\r\n    var neg;\r\n    var eps;\r\n    xassert(npp == npp);\r\n    /* a[j] must be non-zero, x[j] must be binary, for all j in J */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  xassert(e.aj != 0.0);\r\n        xassert(e.xj.is_int);\r\n        xassert(e.xj.lb == 0.0 && e.xj.ub == 1.0);\r\n    }\r\n    /* check if the specified inequality constraint already has the\r\n     form of packing inequality */\r\n    neg = 0; /* neg is |Jn| */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj == +1.0){\r\n        \r\n    }\r\n    else if (e.aj == -1.0)\r\n        neg++;\r\n    else\r\n        break;\r\n    }\r\n    if (e == null)\r\n    {  /* all coefficients a[j] are +1 or -1; check rhs b */\r\n        if (b == (1 - neg))\r\n        {  /* it is packing inequality; no processing is needed */\r\n            return 1;\r\n        }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\r\n     positive; the result is a~[j] = |a[j]| and new rhs b */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0) b -= e.aj;\r\n    /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\r\n    /* if a[j] > b, skip processing--this case must not appear */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (Math.abs(e.aj) > b) return 0;\r\n    /* now 0 < a[j] <= b for all j in J */\r\n    /* find two minimal coefficients a[j] and a[k], j != k */\r\n    ej = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (ej == null || Math.abs(ej.aj) > Math.abs(e.aj)) ej = e;\r\n    xassert(ej != null);\r\n    ek = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e != ej)\r\n            if (ek == null || Math.abs(ek.aj) > Math.abs(e.aj)) ek = e;\r\n    xassert(ek != null);\r\n    /* the specified constraint is equivalent to packing inequality\r\n     iff a[j] + a[k] > b + eps */\r\n    eps = 1e-3 + 1e-6 * Math.abs(b);\r\n    if (Math.abs(ej.aj) + Math.abs(ek.aj) <= b + eps) return 0;\r\n    /* perform back substitution x~[j] = 1 - x[j] and construct the\r\n     final equivalent packing inequality in generalized format */\r\n    b = 1.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n        e.aj = +1.0;\r\n    else /* e.aj < 0.0 */{\r\n        e.aj = -1.0; b -= 1.0\r\n    }\r\n    }\r\n    callback(b);\r\n    return 2;\r\n}\r\n\r\nfunction npp_hidden_packing(npp, row){\r\n    /* identify hidden packing inequality */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, ret, count = 0;\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.ub;\r\n    }\r\n    else\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.lb;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] <= b\" */\r\n        ret = hidden_packing(npp, ptr, b, function(v){b=v});\r\n        xassert(0 <= ret && ret <= 2);\r\n        if (kase == 1 && ret == 1 || ret == 2)\r\n        {  /* the original inequality has been identified as hidden\r\n         packing inequality */\r\n            count++;\r\n            if (GLP_DEBUG){\r\n                xprintf(\"Original constraint:\");\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    xprintf(\" \" + aij.val + \" x\" + aij.col.j);\r\n                if (row.lb != -DBL_MAX) xprintf(\", >= \" + row.lb);\r\n                if (row.ub != +DBL_MAX) xprintf(\", <= \" + row.ub);\r\n                xprintf(\"\");\r\n                xprintf(\"Equivalent packing inequality:\");\r\n                for (e = ptr; e != null; e = e.next)\r\n                    xprintf(\" \" + (e.aj > 0.0 ? \"+\" : \"-\") + \"x\" + e.xj.j);\r\n                xprintf(\", <= \" + b + \"\");\r\n            }\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                else\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = -DBL_MAX; row.ub = b;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing lower bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_implied_packing(row, which, var_, set_){\r\n    var ptr, e, i, k;\r\n    var len = 0;\r\n    var b, eps;\r\n    /* build inequality (3) */\r\n    if (which == 0)\r\n    {  ptr = copy_form(row, -1.0);\r\n        xassert(row.lb != -DBL_MAX);\r\n        b = - row.lb;\r\n    }\r\n    else if (which == 1)\r\n    {  ptr = copy_form(row, +1.0);\r\n        xassert(row.ub != +DBL_MAX);\r\n        b = + row.ub;\r\n    }\r\n    /* remove non-binary variables to build relaxed inequality (5);\r\n     compute its right-hand side b~ with formula (6) */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (!(e.xj.is_int && e.xj.lb == 0.0 && e.xj.ub == 1.0))\r\n    {  /* x[j] is non-binary variable */\r\n        if (e.aj > 0.0)\r\n        {  if (e.xj.lb == -DBL_MAX) return len;\r\n            b -= e.aj * e.xj.lb;\r\n        }\r\n        else /* e.aj < 0.0 */\r\n        {  if (e.xj.ub == +DBL_MAX) return len;\r\n            b -= e.aj * e.xj.ub;\r\n        }\r\n        /* a[j] = 0 means that variable x[j] is removed */\r\n        e.aj = 0.0;\r\n    }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] to build knapsack inequality (8);\r\n     compute its right-hand side beta with formula (11) */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0.0) b -= e.aj;\r\n    /* if beta is close to zero, the knapsack inequality is either\r\n     infeasible or forcing inequality; this must never happen, so\r\n     we skip further analysis */\r\n    if (b < 1e-3) return len;\r\n    /* build set P as well as sets Jp and Jn, and determine x[k] as\r\n     explained above in comments to the routine */\r\n    eps = 1e-3 + 1e-6 * b;\r\n    i = k = null;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  /* note that alfa[j] = |a[j]| */\r\n        if (Math.abs(e.aj) > 0.5 * (b + eps))\r\n        {  /* alfa[j] > (b + eps) / 2; include x[j] in set P, i.e. in\r\n         set Jp or Jn */\r\n            var_[++len] = e.xj;\r\n            set_[len] = (e.aj > 0.0 ? 0 : 1);\r\n            /* alfa[i] = min alfa[j] over all j included in set P */\r\n            if (i == null || Math.abs(i.aj) > Math.abs(e.aj)) i = e;\r\n        }\r\n        else if (Math.abs(e.aj) >= 1e-3)\r\n        {  /* alfa[k] = max alfa[j] over all j not included in set P;\r\n         we skip coefficient a[j] if it is close to zero to avoid\r\n         numerically unreliable results */\r\n            if (k == null || Math.abs(k.aj) < Math.abs(e.aj)) k = e;\r\n        }\r\n    }\r\n    /* if alfa[k] satisfies to condition (13) for all j in P, include\r\n     x[k] in P */\r\n    if (i != null && k != null && Math.abs(i.aj) + Math.abs(k.aj) > b + eps)\r\n    {  var_[++len] = k.xj;\r\n        set_[len] = (k.aj > 0.0 ? 0 : 1);\r\n    }\r\n    /* trivial packing inequality being redundant must never appear,\r\n     so we just ignore it */\r\n    if (len < 2) len = 0;\r\n    return len;\r\n\r\n}\r\n\r\nfunction npp_is_covering(npp, row){\r\n    /* test if constraint is covering inequality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (!(row.lb != -DBL_MAX && row.ub == +DBL_MAX))\r\n        return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.lb != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction hidden_covering(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] >= b;\r\n 0 - specified row is NOT hidden covering inequality;\r\n 1 - specified row is covering inequality;\r\n 2 - specified row is hidden covering inequality. */\r\n    var e;\r\n    var neg;\r\n    var eps;\r\n    xassert(npp == npp);\r\n    /* a[j] must be non-zero, x[j] must be binary, for all j in J */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  xassert(e.aj != 0.0);\r\n        xassert(e.xj.is_int);\r\n        xassert(e.xj.lb == 0.0 && e.xj.ub == 1.0);\r\n    }\r\n    /* check if the specified inequality constraint already has the\r\n     form of covering inequality */\r\n    neg = 0; /* neg is |Jn| */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj == +1.0){\r\n\r\n    }\r\n    else if (e.aj == -1.0)\r\n        neg++;\r\n    else\r\n        break;\r\n    }\r\n    if (e == null)\r\n    {  /* all coefficients a[j] are +1 or -1; check rhs b */\r\n        if (b == (1 - neg))\r\n        {  /* it is covering inequality; no processing is needed */\r\n            return 1;\r\n        }\r\n    }\r\n    /* substitute x[j] = 1 - x~[j] for all j in Jn to make all a[j]\r\n     positive; the result is a~[j] = |a[j]| and new rhs b */\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (e.aj < 0) b -= e.aj;\r\n    /* now a[j] > 0 for all j in J (actually |a[j]| are used) */\r\n    /* if b <= 0, skip processing--this case must not appear */\r\n    if (b < 1e-3) return 0;\r\n    /* now a[j] > 0 for all j in J, and b > 0 */\r\n    /* the specified constraint is equivalent to covering inequality\r\n     iff a[j] >= b for all j in J */\r\n    eps = 1e-9 + 1e-12 * Math.abs(b);\r\n    for (e = ptr; e != null; e = e.next)\r\n        if (Math.abs(e.aj) < b - eps) return 0;\r\n    /* perform back substitution x~[j] = 1 - x[j] and construct the\r\n     final equivalent covering inequality in generalized format */\r\n    b = 1.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n        e.aj = +1.0;\r\n    else /* e.aj < 0.0 */{\r\n        e.aj = -1.0; b -= 1.0;\r\n    }\r\n    }\r\n    callback(b);\r\n    return 2;\r\n}\r\n\r\nfunction npp_hidden_covering(npp, row){\r\n    /* identify hidden covering inequality */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, ret, count = 0;\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.lb;\r\n    }\r\n    else\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.ub;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] >= b\" */\r\n        ret = hidden_covering(npp, ptr, b, function(v){b=v});\r\n        xassert(0 <= ret && ret <= 2);\r\n        if (kase == 1 && ret == 1 || ret == 2)\r\n        {  /* the original inequality has been identified as hidden\r\n         covering inequality */\r\n            count++;\r\n            if (GLP_DEBUG){\r\n                xprintf(\"Original constraint:\");\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    xprintf(\" \" + aij.val + \" x\" + aij.col.j);\r\n                if (row.lb != -DBL_MAX) xprintf(\", >= \" + row.lb);\r\n                if (row.ub != +DBL_MAX) xprintf(\", <= \" + row.ub);\r\n                xprintf(\"\");\r\n                xprintf(\"Equivalent covering inequality:\");\r\n                for (e = ptr; e != null; e = e.next)\r\n                    xprintf(\" \" + (e.aj > 0.0 ? \"+\" : \"-\") + \"x\" + e.xj.j);\r\n                xprintf(\", >= \" + b + \"\");\r\n            }\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                else\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = b; row.ub = +DBL_MAX;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing upper bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_is_partitioning(npp, row){\r\n    /* test if constraint is partitioning equality */\r\n    var col;\r\n    var aij;\r\n    var b;\r\n    xassert(npp == npp);\r\n    if (row.lb != row.ub) return 0;\r\n    b = 1;\r\n    for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n    {  col = aij.col;\r\n        if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n            return 0;\r\n        if (aij.val == +1.0){\r\n\r\n        }\r\n        else if (aij.val == -1.0)\r\n            b--;\r\n        else\r\n            return 0;\r\n    }\r\n    if (row.lb != b) return 0;\r\n    return 1;\r\n}\r\n\r\nfunction reduce_ineq_coef(npp, ptr, b, callback)\r\n{     /* process inequality constraint: sum a[j] x[j] >= b */\r\n    /* returns: the number of coefficients reduced */\r\n    var e;\r\n    var count = 0;\r\n    var h, inf_t, new_a;\r\n    xassert(npp == npp);\r\n    /* compute h; see (15) */\r\n    h = 0.0;\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  if (e.aj > 0.0)\r\n    {  if (e.xj.lb == -DBL_MAX) return count;\r\n        h += e.aj * e.xj.lb;\r\n    }\r\n    else /* e.aj < 0.0 */\r\n    {  if (e.xj.ub == +DBL_MAX) return count;\r\n        h += e.aj * e.xj.ub;\r\n    }\r\n    }\r\n    /* perform reduction of coefficients at binary variables */\r\n    for (e = ptr; e != null; e = e.next)\r\n    {  /* skip non-binary variable */\r\n        if (!(e.xj.is_int && e.xj.lb == 0.0 && e.xj.ub == 1.0))\r\n            continue;\r\n        if (e.aj > 0.0)\r\n        {  /* compute inf t[k]; see (14) */\r\n            inf_t = h;\r\n            if (b - e.aj < inf_t && inf_t < b)\r\n            {  /* compute reduced coefficient a'[k]; see (7) */\r\n                new_a = b - inf_t;\r\n                if (new_a >= +1e-3 &&\r\n                    e.aj - new_a >= 0.01 * (1.0 + e.aj))\r\n                {  /* accept a'[k] */\r\n                    if (GLP_DEBUG){xprintf(\"+\")}\r\n                    e.aj = new_a;\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n        else /* e.aj < 0.0 */\r\n        {  /* compute inf t[k]; see (14) */\r\n            inf_t = h - e.aj;\r\n            if (b < inf_t && inf_t < b - e.aj)\r\n            {  /* compute reduced coefficient a'[k]; see (11) */\r\n                new_a = e.aj + (inf_t - b);\r\n                if (new_a <= -1e-3 &&\r\n                    new_a - e.aj >= 0.01 * (1.0 - e.aj))\r\n                {  /* accept a'[k] */\r\n                    if (GLP_DEBUG){xprintf(\"-\")}\r\n                    e.aj = new_a;\r\n                    /* update h; see (17) */\r\n                    h += (inf_t - b);\r\n                    /* compute b'; see (9) */\r\n                    b = inf_t;\r\n                    count++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    callback(b);\r\n    return count\r\n}\r\n\r\nfunction npp_reduce_ineq_coef(npp, row){\r\n    /* reduce inequality constraint coefficients */\r\n    var copy;\r\n    var aij;\r\n    var ptr, e;\r\n    var kase, count = new Array(2);\r\n    var b;\r\n    /* the row must be inequality constraint */\r\n    xassert(row.lb < row.ub);\r\n    count[0] = count[1] = 0;\r\n    for (kase = 0; kase <= 1; kase++)\r\n    {  if (kase == 0)\r\n    {  /* process row lower bound */\r\n        if (row.lb == -DBL_MAX) continue;\r\n        if (GLP_DEBUG){xprintf(\"L\")}\r\n        ptr = copy_form(row, +1.0);\r\n        b = + row.lb;\r\n    }\r\n    else\r\n    {  /* process row upper bound */\r\n        if (row.ub == +DBL_MAX) continue;\r\n        if (GLP_DEBUG){xprintf(\"U\")}\r\n        ptr = copy_form(row, -1.0);\r\n        b = - row.ub;\r\n    }\r\n        /* now the inequality has the form \"sum a[j] x[j] >= b\" */\r\n        count[kase] = reduce_ineq_coef(npp, ptr, b, function(v){b=v});\r\n        if (count[kase] > 0)\r\n        {  /* the original inequality has been replaced by equivalent\r\n         one with coefficients reduced */\r\n            if (row.lb == -DBL_MAX || row.ub == +DBL_MAX)\r\n            {  /* the original row is single-sided inequality; no copy\r\n             is needed */\r\n                copy = null;\r\n            }\r\n            else\r\n            {  /* the original row is double-sided inequality; we need\r\n             to create its copy for other bound before replacing it\r\n             with the equivalent inequality */\r\n                if (GLP_DEBUG){xprintf(\"*\")}\r\n                copy = npp_add_row(npp);\r\n                if (kase == 0)\r\n                {  /* the copy is for upper bound */\r\n                    copy.lb = -DBL_MAX; copy.ub = row.ub;\r\n                }\r\n                else\r\n                {  /* the copy is for lower bound */\r\n                    copy.lb = row.lb; copy.ub = +DBL_MAX;\r\n                }\r\n                /* copy original row coefficients */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_add_aij(copy, aij.col, aij.val);\r\n            }\r\n            /* replace the original inequality by equivalent one */\r\n            npp_erase_row(row);\r\n            row.lb = b; row.ub = +DBL_MAX;\r\n            for (e = ptr; e != null; e = e.next)\r\n                npp_add_aij(row, e.xj, e.aj);\r\n            /* continue processing upper bound for the copy */\r\n            if (copy != null) row = copy;\r\n        }\r\n    }\r\n    return count[0] + count[1];\r\n}\r\n\r\n\r\nfunction npp_clean_prob(npp){\r\n    /* perform initial LP/MIP processing */\r\n    var row, next_row;\r\n    var col, next_col;\r\n    var ret;\r\n    xassert(npp == npp);\r\n    /* process rows which originally are free */\r\n    for (row = npp.r_head; row != null; row = next_row)\r\n    {  next_row = row.next;\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n        {  /* process free row */\r\n            if (GLP_DEBUG){xprintf(\"1\")}\r\n            npp_free_row(npp, row);\r\n            /* row was deleted */\r\n        }\r\n    }\r\n    /* process rows which originally are double-sided inequalities */\r\n    for (row = npp.r_head; row != null; row = next_row)\r\n    {  next_row = row.next;\r\n        if (row.lb != -DBL_MAX && row.ub != +DBL_MAX &&\r\n            row.lb < row.ub)\r\n        {  ret = npp_make_equality(npp, row);\r\n            if (ret == 0){\r\n\r\n            } else\r\n            if (ret == 1)\r\n            {  /* row was replaced by equality constraint */\r\n                if (GLP_DEBUG){xprintf(\"2\")}\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    /* process columns which are originally fixed */\r\n    for (col = npp.c_head; col != null; col = next_col)\r\n    {  next_col = col.next;\r\n        if (col.lb == col.ub)\r\n        {  /* process fixed column */\r\n            if (GLP_DEBUG){xprintf(\"3\")}\r\n            npp_fixed_col(npp, col);\r\n            /* column was deleted */\r\n        }\r\n    }\r\n    /* process columns which are originally double-bounded */\r\n    for (col = npp.c_head; col != null; col = next_col)\r\n    {  next_col = col.next;\r\n        if (col.lb != -DBL_MAX && col.ub != +DBL_MAX &&\r\n            col.lb < col.ub)\r\n        {  ret = npp_make_fixed(npp, col);\r\n            if (ret == 0){\r\n\r\n            }\r\n            else if (ret == 1)\r\n            {  /* column was replaced by fixed column; process it */\r\n                if (GLP_DEBUG){xprintf(\"4\")}\r\n                npp_fixed_col(npp, col);\r\n                /* column was deleted */\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction npp_process_row(npp, row, hard){\r\n    /* perform basic row processing */\r\n    var col;\r\n    var aij, next_aij, aaa;\r\n    var ret;\r\n    /* row must not be free */\r\n    xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));\r\n    /* start processing row */\r\n    if (row.ptr == null)\r\n    {  /* empty row */\r\n        ret = npp_empty_row(npp, row);\r\n        if (ret == 0)\r\n        {  /* row was deleted */\r\n            if (GLP_DEBUG){xprintf(\"A\")}\r\n            return 0;\r\n        }\r\n        else if (ret == 1)\r\n        {  /* primal infeasibility */\r\n            return GLP_ENOPFS;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n    }\r\n    if (row.ptr.r_next == null)\r\n    {  /* row singleton */\r\n        col = row.ptr.col;\r\n        if (row.lb == row.ub)\r\n        {  /* equality constraint */\r\n            ret = npp_eq_singlet(npp, row);\r\n            if (ret == 0)\r\n            {  /* column was fixed, row was deleted */\r\n                if (GLP_DEBUG){xprintf(\"B\")}\r\n                /* activate rows affected by column */\r\n                for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                    npp_activate_row(npp, aij.row);\r\n                /* process fixed column */\r\n                npp_fixed_col(npp, col);\r\n                /* column was deleted */\r\n                return 0;\r\n            }\r\n            else if (ret == 1 || ret == 2)\r\n            {  /* primal/integer infeasibility */\r\n                return GLP_ENOPFS;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n        else\r\n        {  /* inequality constraint */\r\n            ret = npp_ineq_singlet(npp, row);\r\n            if (0 <= ret && ret <= 3)\r\n            {  /* row was deleted */\r\n                if (GLP_DEBUG){xprintf(\"C\")}\r\n                /* activate column, since its length was changed due to\r\n                 row deletion */\r\n                npp_activate_col(npp, col);\r\n                if (ret >= 2)\r\n                {  /* column bounds changed significantly or column was\r\n                 fixed */\r\n                    /* activate rows affected by column */\r\n                    for (aij = col.ptr; aij != null; aij = aij.c_next)\r\n                        npp_activate_row(npp, aij.row);\r\n                }\r\n                if (ret == 3)\r\n                {  /* column was fixed; process it */\r\n                    if (GLP_DEBUG){xprintf(\"D\")}\r\n                    npp_fixed_col(npp, col);\r\n                    /* column was deleted */\r\n                }\r\n                return 0;\r\n            }\r\n            else if (ret == 4)\r\n            {  /* primal infeasibility */\r\n                return GLP_ENOPFS;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    /* general row analysis */\r\n    ret = npp_analyze_row(npp, row);\r\n    xassert(0x00 <= ret && ret <= 0xFF);\r\n    if (ret == 0x33)\r\n    {  /* row bounds are inconsistent with column bounds */\r\n        return GLP_ENOPFS;\r\n    }\r\n    if ((ret & 0x0F) == 0x00)\r\n    {  /* row lower bound does not exist or redundant */\r\n        if (row.lb != -DBL_MAX)\r\n        {  /* remove redundant row lower bound */\r\n            if (GLP_DEBUG){xprintf(\"F\")}\r\n            npp_inactive_bound(npp, row, 0);\r\n        }\r\n    }\r\n    else if ((ret & 0x0F) == 0x01)\r\n    {  /* row lower bound can be active */\r\n        /* see below */\r\n    }\r\n    else if ((ret & 0x0F) == 0x02)\r\n    {  /* row lower bound is a forcing bound */\r\n        if (GLP_DEBUG){xprintf(\"G\")}\r\n        /* process forcing row */\r\n        if (npp_forcing_row(npp, row, 0) == 0)\r\n            return fixup();\r\n    }\r\n    else\r\n        xassert(ret != ret);\r\n    if ((ret & 0xF0) == 0x00)\r\n    {  /* row upper bound does not exist or redundant */\r\n        if (row.ub != +DBL_MAX)\r\n        {  /* remove redundant row upper bound */\r\n            if (GLP_DEBUG){xprintf(\"I\")}\r\n            npp_inactive_bound(npp, row, 1);\r\n        }\r\n    }\r\n    else if ((ret & 0xF0) == 0x10)\r\n    {  /* row upper bound can be active */\r\n        /* see below */\r\n    }\r\n    else if ((ret & 0xF0) == 0x20)\r\n    {  /* row upper bound is a forcing bound */\r\n        if (GLP_DEBUG) {xprintf(\"J\")}\r\n        /* process forcing row */\r\n        if (npp_forcing_row(npp, row, 1) == 0) return fixup();\r\n    }\r\n    else\r\n        xassert(ret != ret);\r\n    if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n    {  /* row became free due to redundant bounds removal */\r\n        if (GLP_DEBUG) {xprintf(\"K\")}\r\n        /* activate its columns, since their length will change due\r\n         to row deletion */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n            npp_activate_col(npp, aij.col);\r\n        /* process free row */\r\n        npp_free_row(npp, row);\r\n        /* row was deleted */\r\n        return 0;\r\n    }\r\n    /* row lower and/or upper bounds can be active */\r\n    if (npp.sol == GLP_MIP && hard)\r\n    {  /* improve current column bounds (optional) */\r\n        if (npp_improve_bounds(npp, row, 1) < 0)\r\n            return GLP_ENOPFS;\r\n    }\r\n    function fixup()   {  /* columns were fixed, row was made free */\r\n        for (aij = row.ptr; aij != null; aij = next_aij)\r\n        {  /* process column fixed by forcing row */\r\n            if (GLP_DEBUG){xprintf(\"H\")}\r\n            col = aij.col;\r\n            next_aij = aij.r_next;\r\n            /* activate rows affected by column */\r\n            for (aaa = col.ptr; aaa != null; aaa = aaa.c_next)\r\n                npp_activate_row(npp, aaa.row);\r\n            /* process fixed column */\r\n            npp_fixed_col(npp, col);\r\n            /* column was deleted */\r\n        }\r\n        /* process free row (which now is empty due to deletion of\r\n         all its columns) */\r\n        npp_free_row(npp, row);\r\n        /* row was deleted */\r\n        return 0;\r\n    }\r\n    return 0;\r\n}\r\n\r\nfunction npp_improve_bounds(npp, row, flag){\r\n    /* improve current column bounds */\r\n    var col;\r\n    var aij, next_aij, aaa;\r\n    var kase, ret, count = 0;\r\n    var lb, ub;\r\n    xassert(npp.sol == GLP_MIP);\r\n    /* row must not be free */\r\n    xassert(!(row.lb == -DBL_MAX && row.ub == +DBL_MAX));\r\n    /* determine implied column bounds */\r\n    npp_implied_bounds(npp, row);\r\n    /* and use these bounds to strengthen current column bounds */\r\n    for (aij = row.ptr; aij != null; aij = next_aij)\r\n    {  col = aij.col;\r\n        next_aij = aij.r_next;\r\n        for (kase = 0; kase <= 1; kase++)\r\n        {  /* save current column bounds */\r\n            lb = col.lb; ub = col.ub;\r\n            if (kase == 0)\r\n            {  /* process implied column lower bound */\r\n                if (col.ll.ll == -DBL_MAX) continue;\r\n                ret = npp_implied_lower(npp, col, col.ll.ll);\r\n            }\r\n            else\r\n            {  /* process implied column upper bound */\r\n                if (col.uu.uu == +DBL_MAX) continue;\r\n                ret = npp_implied_upper(npp, col, col.uu.uu);\r\n            }\r\n            if (ret == 0 || ret == 1)\r\n            {  /* current column bounds did not change or changed, but\r\n             not significantly; restore current column bounds */\r\n                col.lb = lb; col.ub = ub;\r\n            }\r\n            else if (ret == 2 || ret == 3)\r\n            {  /* current column bounds changed significantly or column\r\n             was fixed */\r\n                if (GLP_DEBUG){xprintf(\"L\")}\r\n                count++;\r\n                /* activate other rows affected by column, if required */\r\n                if (flag)\r\n                {  for (aaa = col.ptr; aaa != null; aaa = aaa.c_next)\r\n                {  if (aaa.row != row)\r\n                    npp_activate_row(npp, aaa.row);\r\n                }\r\n                }\r\n                if (ret == 3)\r\n                {  /* process fixed column */\r\n                    if (GLP_DEBUG){xprintf(\"M\")}\r\n                    npp_fixed_col(npp, col);\r\n                    /* column was deleted */\r\n                    break; /* for kase */\r\n                }\r\n            }\r\n            else if (ret == 4)\r\n            {  /* primal/integer infeasibility */\r\n                return -1;\r\n            }\r\n            else\r\n                xassert(ret != ret);\r\n        }\r\n    }\r\n    return count;\r\n}\r\n\r\nfunction npp_process_col(npp, col)\r\n{     /* perform basic column processing */\r\n    var row;\r\n    var aij;\r\n    var ret;\r\n    /* column must not be fixed */\r\n    xassert(col.lb < col.ub);\r\n    /* start processing column */\r\n    if (col.ptr == null)\r\n    {  /* empty column */\r\n        ret = npp_empty_col(npp, col);\r\n        if (ret == 0)\r\n        {  /* column was fixed and deleted */\r\n            if (GLP_DEBUG){xprintf(\"N\")}\r\n            return 0;\r\n        }\r\n        else if (ret == 1)\r\n        {  /* dual infeasibility */\r\n            return GLP_ENODFS;\r\n        }\r\n        else\r\n            xassert(ret != ret);\r\n    }\r\n    if (col.ptr.c_next == null)\r\n    {  /* column singleton */\r\n        row = col.ptr.row;\r\n\r\n\r\n        function slack(){  /* implied slack variable */\r\n            if (GLP_DEBUG) {xprintf(\"O\")}\r\n            npp_implied_slack(npp, col);\r\n            /* column was deleted */\r\n            if (row.lb == -DBL_MAX && row.ub == +DBL_MAX)\r\n            {  /* row became free due to implied slack variable */\r\n                if (GLP_DEBUG){xprintf(\"P\")}\r\n                /* activate columns affected by row */\r\n                for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n                    npp_activate_col(npp, aij.col);\r\n                /* process free row */\r\n                npp_free_row(npp, row);\r\n                /* row was deleted */\r\n            }\r\n            else\r\n            {  /* row became inequality constraint; activate it\r\n             since its length changed due to column deletion */\r\n                npp_activate_row(npp, row);\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        if (row.lb == row.ub)\r\n        {  /* equality constraint */\r\n            if (!col.is_int)\r\n                return slack();\r\n        }\r\n        else\r\n        {  /* inequality constraint */\r\n            if (!col.is_int)\r\n            {  ret = npp_implied_free(npp, col);\r\n                if (ret == 0)\r\n                {  /* implied free variable */\r\n                    if (GLP_DEBUG){xprintf(\"Q\")}\r\n                    /* column bounds were removed, row was replaced by\r\n                     equality constraint */\r\n                    return slack();\r\n                }\r\n                else if (ret == 1)\r\n                {  /* column is not implied free variable, because its\r\n                 lower and/or upper bounds can be active */\r\n                }\r\n                else if (ret == 2)\r\n                {  /* dual infeasibility */\r\n                    return GLP_ENODFS;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /* column still exists */\r\n    return 0;\r\n}\r\n\r\nfunction npp_process_prob(npp, hard){\r\n    /* perform basic LP/MIP processing */\r\n    var row;\r\n    var col;\r\n    var processing, ret;\r\n    /* perform initial LP/MIP processing */\r\n    npp_clean_prob(npp);\r\n    /* activate all remaining rows and columns */\r\n    for (row = npp.r_head; row != null; row = row.next)\r\n        row.temp = 1;\r\n    for (col = npp.c_head; col != null; col = col.next)\r\n        col.temp = 1;\r\n    /* main processing loop */\r\n    processing = 1;\r\n    while (processing)\r\n    {  processing = 0;\r\n        /* process all active rows */\r\n        for (;;)\r\n        {  row = npp.r_head;\r\n            if (row == null || !row.temp) break;\r\n            npp_deactivate_row(npp, row);\r\n            ret = npp_process_row(npp, row, hard);\r\n            if (ret != 0) return done();\r\n            processing = 1;\r\n        }\r\n        /* process all active columns */\r\n        for (;;)\r\n        {  col = npp.c_head;\r\n            if (col == null || !col.temp) break;\r\n            npp_deactivate_col(npp, col);\r\n            ret = npp_process_col(npp, col);\r\n            if (ret != 0) return done();\r\n            processing = 1;\r\n        }\r\n    }\r\n    if (npp.sol == GLP_MIP && !hard)\r\n    {  /* improve current column bounds (optional) */\r\n        for (row = npp.r_head; row != null; row = row.next)\r\n        {  if (npp_improve_bounds(npp, row, 0) < 0)\r\n        {  ret = GLP_ENOPFS;\r\n            return done();\r\n        }\r\n        }\r\n    }\r\n    /* all seems ok */\r\n    ret = 0;\r\n    function done(){\r\n        xassert(ret == 0 || ret == GLP_ENOPFS || ret == GLP_ENODFS);\r\n        if (GLP_DEBUG){xprintf(\"\")}\r\n        return ret;\r\n    }\r\n    return done();\r\n}\r\n\r\nfunction npp_simplex(npp, parm){\r\n    /* process LP prior to applying primal/dual simplex method */\r\n    xassert(npp.sol == GLP_SOL);\r\n    xassert(parm == parm);\r\n    return npp_process_prob(npp, 0);\r\n}\r\n\r\nfunction npp_integer(npp, parm){\r\n    /* process MIP prior to applying branch-and-bound method */\r\n    var row, prev_row;\r\n    var col;\r\n    var aij;\r\n    var count, ret;\r\n    xassert(npp.sol == GLP_MIP);\r\n    xassert(parm == parm);\r\n    /*==============================================================*/\r\n    /* perform basic MIP processing */\r\n    ret = npp_process_prob(npp, 1);\r\n    if (ret != 0) return ret;\r\n    /*==============================================================*/\r\n    /* binarize problem, if required */\r\n    if (parm.binarize)\r\n        npp_binarize_prob(npp);\r\n    /*==============================================================*/\r\n    /* identify hidden packing inequalities */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip free row */\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) continue;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        /* skip row having less than two variables */\r\n        if (row.ptr == null || row.ptr.r_next == null) continue;\r\n        /* skip row having non-binary variables */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  col = aij.col;\r\n            if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n                break;\r\n        }\r\n        if (aij != null) continue;\r\n        count += npp_hidden_packing(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" hidden packing inequaliti(es) were detected\");\r\n    /*==============================================================*/\r\n    /* identify hidden covering inequalities */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip free row */\r\n        if (row.lb == -DBL_MAX && row.ub == +DBL_MAX) continue;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        /* skip row having less than three variables */\r\n        if (row.ptr == null || row.ptr.r_next == null ||\r\n            row.ptr.r_next.r_next == null) continue;\r\n        /* skip row having non-binary variables */\r\n        for (aij = row.ptr; aij != null; aij = aij.r_next)\r\n        {  col = aij.col;\r\n            if (!(col.is_int && col.lb == 0.0 && col.ub == 1.0))\r\n                break;\r\n        }\r\n        if (aij != null) continue;\r\n        count += npp_hidden_covering(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" hidden covering inequaliti(es) were detected\");\r\n    /*==============================================================*/\r\n    /* reduce inequality constraint coefficients */\r\n    count = 0;\r\n    /* new rows will be added to the end of the row list, so we go\r\n     from the end to beginning of the row list */\r\n    for (row = npp.r_tail; row != null; row = prev_row)\r\n    {  prev_row = row.prev;\r\n        /* skip equality constraint */\r\n        if (row.lb == row.ub) continue;\r\n        count += npp_reduce_ineq_coef(npp, row);\r\n    }\r\n    if (count > 0)\r\n        xprintf(count + \" constraint coefficient(s) were reduced\");\r\n    /*==============================================================*/\r\n    //if (GLP_DEBUG){routine(npp)}\r\n    /*==============================================================*/\r\n    /* all seems ok */\r\n    ret = 0;\r\n    return ret;\r\n}\r\n\r\n\r\nfunction mod_diff(x, y) {return (x - y) & 0x7FFFFFFF}\r\n/* difference modulo 2^31 */\r\n\r\nfunction flip_cycle(rand){\r\n/* this is an auxiliary routine to do 55 more steps of the basic\r\n recurrence, at high speed, and to reset fptr */\r\n    var ii, jj;\r\n    for (ii = 1, jj = 32; jj <= 55; ii++, jj++)\r\n        rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);\r\n    for (jj = 1; ii <= 55; ii++, jj++)\r\n        rand.A[ii] = mod_diff(rand.A[ii], rand.A[jj]);\r\n    rand.fptr = 54;\r\n    return rand.A[55];\r\n}\r\n\r\nfunction rng_create_rand(){\r\n    var rand = {};\r\n    var i;\r\n    rand.A = new Array(56);\r\n    rand.A[0] = -1;\r\n    for (i = 1; i <= 55; i++) rand.A[i] = 0;\r\n    (rand.fptr) = 0;\r\n    rng_init_rand(rand, 1);\r\n    return rand;\r\n}\r\n\r\nfunction rng_init_rand(rand, seed){\r\n    var i;\r\n    var prev = seed, next = 1;\r\n    seed = prev = mod_diff(prev, 0);\r\n    rand.A[55] = prev;\r\n    for (i = 21; i; i = (i + 21) % 55)\r\n    {  rand.A[i] = next;\r\n        next = mod_diff(prev, next);\r\n        if (seed & 1)\r\n            seed = 0x40000000 + (seed >> 1);\r\n        else\r\n            seed >>= 1;\r\n        next = mod_diff(next, seed);\r\n        prev = rand.A[i];\r\n    }\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n    flip_cycle(rand);\r\n}\r\n\r\nfunction rng_next_rand(rand){\r\n    return rand.A[rand.fptr] >= 0 ? rand.A[rand.fptr--] : flip_cycle(rand);\r\n}\r\n\r\nfunction rng_unif_rand(rand, m){\r\n    var two_to_the_31 = 0x80000000;\r\n    var t = two_to_the_31 - (two_to_the_31 % m);\r\n    var r;\r\n    xassert(m > 0);\r\n    do { r = rng_next_rand(rand); } while (t <= r);\r\n    return r % m;\r\n}\r\n\r\nfunction rng_unif_01(rand){\r\n    var x = rng_next_rand(rand) / 2147483647.0;\r\n    xassert(0.0 <= x && x <= 1.0);\r\n    return x;\r\n}\r\n\r\nfunction rng_uniform(rand, a, b){\r\n    if (a >= b)\r\n        xerror(\"rng_uniform: a = \" + a + \", b = \" + b + \"; invalid range\");\r\n    var x = rng_unif_01(rand);\r\n    x = a * (1.0 - x) + b * x;\r\n    xassert(a <= x && x <= b);\r\n    return x;\r\n}\r\n\r\nvar\r\n    SCF_TBG     = 1,  /* Bartels-Golub elimination */\r\n    SCF_TGR     = 2;  /* Givens plane rotation */\r\n\r\n/* return codes: */\r\nvar\r\n    SCF_ESING    = 1,  /* singular matrix */\r\n    SCF_ELIMIT   = 2;  /* update limit reached */\r\n\r\nvar _GLPSCF_DEBUG = 0;\r\n\r\nvar SCF_EPS = 1e-10;\r\n\r\nfunction scf_create_it(n_max){\r\n    if (_GLPSCF_DEBUG){\r\n        xprintf(\"scf_create_it: warning: debug mode enabled\");\r\n    }\r\n    if (!(1 <= n_max && n_max <= 32767))\r\n        xerror(\"scf_create_it: n_max = \" + n_max + \"; invalid parameter\");\r\n    var scf = {};\r\n    scf.n_max = n_max;\r\n    scf.n = 0;\r\n    scf.f = new Float64Array(1 + n_max * n_max);\r\n    scf.u = new Float64Array(1 + n_max * (n_max + 1) / 2);\r\n    scf.p = new Int32Array(1 + n_max);\r\n    scf.t_opt = SCF_TBG;\r\n    scf.rank = 0;\r\n    if (_GLPSCF_DEBUG)\r\n        scf.c = new Float64Array(1 + n_max * n_max);\r\n    else\r\n        scf.c = null;\r\n    scf.w = new Float64Array(1 + n_max);\r\n    return scf;\r\n}\r\n\r\nfunction f_loc(scf, i, j){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(1 <= j && j <= n);\r\n    return (i - 1) * n_max + j;\r\n}\r\n\r\nfunction u_loc(scf, i, j){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    xassert(1 <= i && i <= n);\r\n    xassert(i <= j && j <= n);\r\n    return (i - 1) * n_max + j - i * (i - 1) / 2;\r\n}\r\n\r\nfunction bg_transform(scf, k, un){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var j, k1, kj, kk, n1, nj;\r\n    var t;\r\n    xassert(1 <= k && k <= n);\r\n    /* main elimination loop */\r\n    for (; k < n; k++)\r\n    {  /* determine location of U[k,k] */\r\n        kk = u_loc(scf, k, k);\r\n        /* determine location of F[k,1] */\r\n        k1 = f_loc(scf, k, 1);\r\n        /* determine location of F[n,1] */\r\n        n1 = f_loc(scf, n, 1);\r\n        /* if |U[k,k]| < |U[n,k]|, interchange k-th and n-th rows to\r\n         provide |U[k,k]| >= |U[n,k]| */\r\n        if (Math.abs(u[kk]) < Math.abs(un[k]))\r\n        {  /* interchange k-th and n-th rows of matrix U */\r\n            for (j = k, kj = kk; j <= n; j++, kj++){\r\n                t = u[kj]; u[kj] = un[j]; un[j] = t;\r\n            }\r\n            /* interchange k-th and n-th rows of matrix F to keep the\r\n             main equality F * C = U * P */\r\n            for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++){\r\n                t = f[kj]; f[kj] = f[nj]; f[nj] = t;\r\n            }\r\n        }\r\n        /* now |U[k,k]| >= |U[n,k]| */\r\n        /* if U[k,k] is too small in the magnitude, replace U[k,k] and\r\n         U[n,k] by exact zero */\r\n        if (Math.abs(u[kk]) < SCF_EPS) u[kk] = un[k] = 0.0;\r\n        /* if U[n,k] is already zero, elimination is not needed */\r\n        if (un[k] == 0.0) continue;\r\n        /* compute gaussian multiplier t = U[n,k] / U[k,k] */\r\n        t = un[k] / u[kk];\r\n        /* apply gaussian elimination to nullify U[n,k] */\r\n        /* (n-th row of U) := (n-th row of U) - t * (k-th row of U) */\r\n        for (j = k+1, kj = kk+1; j <= n; j++, kj++)\r\n            un[j] -= t * u[kj];\r\n        /* (n-th row of F) := (n-th row of F) - t * (k-th row of F)\r\n         to keep the main equality F * C = U * P */\r\n        for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)\r\n            f[nj] -= t * f[kj];\r\n    }\r\n    /* if U[n,n] is too small in the magnitude, replace it by exact\r\n     zero */\r\n    if (Math.abs(un[n]) < SCF_EPS) un[n] = 0.0;\r\n    /* store U[n,n] in a proper location */\r\n    u[u_loc(scf, n, n)] = un[n];\r\n}\r\n\r\nfunction givens(a, b, callback){\r\n    var t, c, s;\r\n    if (b == 0.0){\r\n        c = 1.0; s = 0.0;\r\n    }\r\n    else if (Math.abs(a) <= Math.abs(b)){\r\n        t = - a / b; s = 1.0 / Math.sqrt(1.0 + t * t); c = s * t;\r\n    }\r\n    else{\r\n        t = - b / a; c = 1.0 / Math.sqrt(1.0 + t * t); s = c * t;\r\n    }\r\n    callback(c, s);\r\n}\r\n\r\nfunction gr_transform(scf, k, un){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var j, k1, kj, kk, n1, nj;\r\n    xassert(1 <= k && k <= n);\r\n    /* main elimination loop */\r\n    for (; k < n; k++)\r\n    {  /* determine location of U[k,k] */\r\n        kk = u_loc(scf, k, k);\r\n        /* determine location of F[k,1] */\r\n        k1 = f_loc(scf, k, 1);\r\n        /* determine location of F[n,1] */\r\n        n1 = f_loc(scf, n, 1);\r\n        /* if both U[k,k] and U[n,k] are too small in the magnitude,\r\n         replace them by exact zero */\r\n        if (Math.abs(u[kk]) < SCF_EPS && Math.abs(un[k]) < SCF_EPS)\r\n            u[kk] = un[k] = 0.0;\r\n        /* if U[n,k] is already zero, elimination is not needed */\r\n        if (un[k] == 0.0) continue;\r\n        /* compute the parameters of Givens plane rotation */\r\n        givens(u[kk], un[k],\r\n            function(c, s){\r\n                /* apply Givens rotation to k-th and n-th rows of matrix U */\r\n                for (j = k, kj = kk; j <= n; j++, kj++)\r\n                {  var ukj = u[kj], unj = un[j];\r\n                    u[kj] = c * ukj - s * unj;\r\n                    un[j] = s * ukj + c * unj;\r\n                }\r\n                /* apply Givens rotation to k-th and n-th rows of matrix F\r\n                 to keep the main equality F * C = U * P */\r\n                for (j = 1, kj = k1, nj = n1; j <= n; j++, kj++, nj++)\r\n                {  var fkj = f[kj], fnj = f[nj];\r\n                    f[kj] = c * fkj - s * fnj;\r\n                    f[nj] = s * fkj + c * fnj;\r\n                }\r\n            }\r\n        );\r\n    }\r\n    /* if U[n,n] is too small in the magnitude, replace it by exact\r\n     zero */\r\n    if (Math.abs(un[n]) < SCF_EPS) un[n] = 0.0;\r\n    /* store U[n,n] in a proper location */\r\n    u[u_loc(scf, n, n)] = un[n];\r\n}\r\n\r\nfunction transform(scf, k, un){\r\n    switch (scf.t_opt){\r\n        case SCF_TBG:\r\n            bg_transform(scf, k, un);\r\n            break;\r\n        case SCF_TGR:\r\n            gr_transform(scf, k, un);\r\n            break;\r\n        default:\r\n            xassert(scf != scf);\r\n    }\r\n}\r\n\r\nfunction estimate_rank(scf){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    var u = scf.u;\r\n    var i, ii, inc, rank = 0;\r\n    for (i = 1, ii = u_loc(scf, i, i), inc = n_max; i <= n; i++, ii += inc, inc--)\r\n        if (u[ii] != 0.0) rank++;\r\n    return rank;\r\n}\r\n\r\nif (_GLPSCF_DEBUG){\r\n\r\n    function check_error(scf, func){\r\n        var n = scf.n;\r\n        var f = scf.f;\r\n        var u = scf.u;\r\n        var p = scf.p;\r\n        var c = scf.c;\r\n        var i, j, k;\r\n        var d, dmax = 0.0, s, t;\r\n        xassert(c != null);\r\n        for (i = 1; i <= n; i++)\r\n        {  for (j = 1; j <= n; j++)\r\n        {  /* compute element (i,j) of product F * C */\r\n            s = 0.0;\r\n            for (k = 1; k <= n; k++)\r\n                s += f[f_loc(scf, i, k)] * c[f_loc(scf, k, j)];\r\n            /* compute element (i,j) of product U * P */\r\n            k = p[j];\r\n            t = (i <= k ? u[u_loc(scf, i, k)] : 0.0);\r\n            /* compute the maximal relative error */\r\n            d = Math.abs(s - t) / (1.0 + Math.abs(t));\r\n            if (dmax < d) dmax = d;\r\n        }\r\n        }\r\n        if (dmax > 1e-8)\r\n            xprintf(func + \": dmax = \" + dmax + \"; relative error too large\");\r\n    }\r\n}\r\n\r\nfunction scf_update_exp(scf, x, idx, y, idy, z){\r\n    var n_max = scf.n_max;\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    if (_GLPSCF_DEBUG){var c = scf.c}\r\n    var un = scf.w;\r\n    var i, ij, in_, j, k, nj, ret = 0;\r\n    var t;\r\n    /* check if the factorization can be expanded */\r\n    if (n == n_max)\r\n    {  /* there is not enough room */\r\n        ret = SCF_ELIMIT;\r\n        return ret;\r\n    }\r\n    /* increase the order of the factorization */\r\n    scf.n = ++n;\r\n    /* fill new zero column of matrix F */\r\n    for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)\r\n    f[in_] = 0.0;\r\n    /* fill new zero row of matrix F */\r\n    for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)\r\n        f[nj] = 0.0;\r\n    /* fill new unity diagonal element of matrix F */\r\n    f[f_loc(scf, n, n)] = 1.0;\r\n    /* compute new column of matrix U, which is (old F) * x */\r\n    for (i = 1; i < n; i++)\r\n    {  /* u[i,n] := (i-th row of old F) * x */\r\n        t = 0.0;\r\n        for (j = 1, ij = f_loc(scf, i, 1); j < n; j++, ij++)\r\n            t += f[ij] * x[j+idx];\r\n        u[u_loc(scf, i, n)] = t;\r\n    }\r\n    /* compute new (spiked) row of matrix U, which is (old P) * y */\r\n    for (j = 1; j < n; j++) un[j] = y[p[j]+idy];\r\n    /* store new diagonal element of matrix U, which is z */\r\n    un[n] = z;\r\n    /* expand matrix P */\r\n    p[n] = n;\r\n    if (_GLPSCF_DEBUG){\r\n        /* expand matrix C */\r\n        /* fill its new column, which is x */\r\n        for (i = 1, in_ = f_loc(scf, i, n); i < n; i++, in_ += n_max)\r\n            c[in_] = x[i+idx];\r\n        /* fill its new row, which is y */\r\n        for (j = 1, nj = f_loc(scf, n, j); j < n; j++, nj++)\r\n            c[nj] = y[j+idy];\r\n        /* fill its new diagonal element, which is z */\r\n        c[f_loc(scf, n, n)] = z;\r\n    }\r\n    /* restore upper triangular structure of matrix U */\r\n    for (k = 1; k < n; k++)\r\n        if (un[k] != 0.0) break;\r\n    transform(scf, k, un);\r\n    /* estimate the rank of matrices C and U */\r\n    scf.rank = estimate_rank(scf);\r\n    if (scf.rank != n) ret = SCF_ESING;\r\n    if (_GLPSCF_DEBUG){\r\n        /* check that the factorization is accurate enough */\r\n        check_error(scf, \"scf_update_exp\");\r\n    }\r\n    return ret;\r\n}\r\n\r\nfunction solve(scf, x, idx){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    var y = scf.w;\r\n    var i, j, ij;\r\n    var t;\r\n    /* y := F * b */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* y[i] = (i-th row of F) * b */\r\n        t = 0.0;\r\n        for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)\r\n            t += f[ij] * x[j+idx];\r\n        y[i] = t;\r\n    }\r\n    /* y := inv(U) * y */\r\n    for (i = n; i >= 1; i--)\r\n    {  t = y[i];\r\n        for (j = n, ij = u_loc(scf, i, n); j > i; j--, ij--)\r\n            t -= u[ij] * y[j];\r\n        y[i] = t / u[ij];\r\n    }\r\n    /* x := P' * y */\r\n    for (i = 1; i <= n; i++) x[p[i]+idx] = y[i];\r\n}\r\n\r\nfunction tsolve(scf, x, idx){\r\n    var n = scf.n;\r\n    var f = scf.f;\r\n    var u = scf.u;\r\n    var p = scf.p;\r\n    var y = scf.w;\r\n    var i, j, ij;\r\n    var t;\r\n    /* y := P * b */\r\n    for (i = 1; i <= n; i++) y[i] = x[p[i]+idx];\r\n    /* y := inv(U') * y */\r\n    for (i = 1; i <= n; i++)\r\n    {  /* compute y[i] */\r\n        ij = u_loc(scf, i, i);\r\n        t = (y[i] /= u[ij]);\r\n        /* substitute y[i] in other equations */\r\n        for (j = i+1, ij++; j <= n; j++, ij++)\r\n            y[j] -= u[ij] * t;\r\n    }\r\n    /* x := F' * y (computed as linear combination of rows of F) */\r\n    for (j = 1; j <= n; j++) x[j+idx] = 0.0;\r\n    for (i = 1; i <= n; i++)\r\n    {  t = y[i]; /* coefficient of linear combination */\r\n        for (j = 1, ij = f_loc(scf, i, 1); j <= n; j++, ij++)\r\n            x[j+idx] += f[ij] * t;\r\n    }\r\n}\r\n\r\nfunction scf_solve_it(scf, tr, x, idx){\r\n    if (scf.rank < scf.n)\r\n        xerror(\"scf_solve_it: singular matrix\");\r\n    if (!tr)\r\n        solve(scf, x, idx);\r\n    else\r\n        tsolve(scf, x, idx);\r\n}\r\n\r\nfunction scf_reset_it(scf){\r\n    /* reset factorization for empty matrix C */\r\n    scf.n = scf.rank = 0;\r\n}\r\n\r\nvar glp_scale_prob = exports[\"glp_scale_prob\"] = function(lp, flags){\r\n    function min_row_aij(lp, i, scaled){\r\n        var aij;\r\n        var min_aij, temp;\r\n        xassert(1 <= i && i <= lp.m);\r\n        min_aij = 1.0;\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.r_prev == null || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_row_aij(lp, i, scaled){\r\n        var aij;\r\n        var max_aij, temp;\r\n        xassert(1 <= i && i <= lp.m);\r\n        max_aij = 1.0;\r\n        for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.r_prev == null || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function min_col_aij(lp, j, scaled){\r\n        var aij;\r\n        var min_aij, temp;\r\n        xassert(1 <= j && j <= lp.n);\r\n        min_aij = 1.0;\r\n        for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.c_prev == null || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_col_aij(lp, j, scaled){\r\n        var aij;\r\n        var max_aij, temp;\r\n        xassert(1 <= j && j <= lp.n);\r\n        max_aij = 1.0;\r\n        for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n        {  temp = Math.abs(aij.val);\r\n            if (scaled) temp *= (aij.row.rii * aij.col.sjj);\r\n            if (aij.c_prev == null || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function min_mat_aij(lp, scaled){\r\n        var i;\r\n        var min_aij, temp;\r\n        min_aij = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = min_row_aij(lp, i, scaled);\r\n            if (i == 1 || min_aij > temp)\r\n                min_aij = temp;\r\n        }\r\n        return min_aij;\r\n    }\r\n\r\n    function max_mat_aij(lp, scaled){\r\n        var i;\r\n        var max_aij, temp;\r\n        max_aij = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = max_row_aij(lp, i, scaled);\r\n            if (i == 1 || max_aij < temp)\r\n                max_aij = temp;\r\n        }\r\n        return max_aij;\r\n    }\r\n\r\n    function eq_scaling(lp, flag){\r\n        var i, j, pass;\r\n        var temp;\r\n        xassert(flag == 0 || flag == 1);\r\n        for (pass = 0; pass <= 1; pass++)\r\n        {  if (pass == flag)\r\n        {  /* scale rows */\r\n            for (i = 1; i <= lp.m; i++)\r\n            {  temp = max_row_aij(lp, i, 1);\r\n                glp_set_rii(lp, i, glp_get_rii(lp, i) / temp);\r\n            }\r\n        }\r\n        else\r\n        {  /* scale columns */\r\n            for (j = 1; j <= lp.n; j++)\r\n            {  temp = max_col_aij(lp, j, 1);\r\n                glp_set_sjj(lp, j, glp_get_sjj(lp, j) / temp);\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    function gm_scaling(lp, flag){\r\n        var i, j, pass;\r\n        var temp;\r\n        xassert(flag == 0 || flag == 1);\r\n        for (pass = 0; pass <= 1; pass++)\r\n        {  if (pass == flag)\r\n        {  /* scale rows */\r\n            for (i = 1; i <= lp.m; i++)\r\n            {  temp = min_row_aij(lp, i, 1) * max_row_aij(lp, i, 1);\r\n                glp_set_rii(lp, i, glp_get_rii(lp, i) / Math.sqrt(temp));\r\n            }\r\n        }\r\n        else\r\n        {  /* scale columns */\r\n            for (j = 1; j <= lp.n; j++)\r\n            {  temp = min_col_aij(lp, j, 1) * max_col_aij(lp, j, 1);\r\n                glp_set_sjj(lp, j, glp_get_sjj(lp, j) / Math.sqrt(temp));\r\n            }\r\n        }\r\n        }\r\n    }\r\n\r\n    function max_row_ratio(lp){\r\n        var i;\r\n        var ratio, temp;\r\n        ratio = 1.0;\r\n        for (i = 1; i <= lp.m; i++)\r\n        {  temp = max_row_aij(lp, i, 1) / min_row_aij(lp, i, 1);\r\n            if (i == 1 || ratio < temp) ratio = temp;\r\n        }\r\n        return ratio;\r\n    }\r\n\r\n    function max_col_ratio(lp){\r\n        var j;\r\n        var ratio, temp;\r\n        ratio = 1.0;\r\n        for (j = 1; j <= lp.n; j++)\r\n        {  temp = max_col_aij(lp, j, 1) / min_col_aij(lp, j, 1);\r\n            if (j == 1 || ratio < temp) ratio = temp;\r\n        }\r\n        return ratio;\r\n    }\r\n\r\n    function gm_iterate(lp, it_max, tau){\r\n        var k, flag;\r\n        var ratio = 0.0, r_old;\r\n        /* if the scaling \"quality\" for rows is better than for columns,\r\n         the rows are scaled first; otherwise, the columns are scaled\r\n         first */\r\n        flag = (max_row_ratio(lp) > max_col_ratio(lp));\r\n        for (k = 1; k <= it_max; k++)\r\n        {  /* save the scaling \"quality\" from previous iteration */\r\n            r_old = ratio;\r\n            /* determine the current scaling \"quality\" */\r\n            ratio = max_mat_aij(lp, 1) / min_mat_aij(lp, 1);\r\n            /* if improvement is not enough, terminate scaling */\r\n            if (k > 1 && ratio > tau * r_old) break;\r\n            /* otherwise, perform another iteration */\r\n            gm_scaling(lp, flag);\r\n        }\r\n    }\r\n\r\n    function scale_prob(lp, flags){\r\n\r\n        function fmt(a, b, c, d){\r\n            return a + \": min|aij| = \" + b + \"  max|aij| = \" + c + \"  ratio = \" + d + \"\"\r\n        }\r\n\r\n        var min_aij, max_aij, ratio;\r\n        xprintf(\"Scaling...\");\r\n        /* cancel the current scaling effect */\r\n        glp_unscale_prob(lp);\r\n        /* report original scaling \"quality\" */\r\n        min_aij = min_mat_aij(lp, 1);\r\n        max_aij = max_mat_aij(lp, 1);\r\n        ratio = max_aij / min_aij;\r\n        xprintf(fmt(\" A\", min_aij, max_aij, ratio));\r\n        /* check if the problem is well scaled */\r\n        if (min_aij >= 0.10 && max_aij <= 10.0)\r\n        {  xprintf(\"Problem data seem to be well scaled\");\r\n            /* skip scaling, if required */\r\n            if (flags & GLP_SF_SKIP) return;\r\n        }\r\n        /* perform iterative geometric mean scaling, if required */\r\n        if (flags & GLP_SF_GM)\r\n        {  gm_iterate(lp, 15, 0.90);\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"GM\", min_aij, max_aij, ratio));\r\n        }\r\n        /* perform equilibration scaling, if required */\r\n        if (flags & GLP_SF_EQ)\r\n        {  eq_scaling(lp, max_row_ratio(lp) > max_col_ratio(lp));\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"EQ\", min_aij, max_aij, ratio));\r\n        }\r\n        /* round scale factors to nearest power of two, if required */\r\n        if (flags & GLP_SF_2N)\r\n        {  var i, j;\r\n            for (i = 1; i <= lp.m; i++)\r\n                glp_set_rii(lp, i, round2n(glp_get_rii(lp, i)));\r\n            for (j = 1; j <= lp.n; j++)\r\n                glp_set_sjj(lp, j, round2n(glp_get_sjj(lp, j)));\r\n            min_aij = min_mat_aij(lp, 1);\r\n            max_aij = max_mat_aij(lp, 1);\r\n            ratio = max_aij / min_aij;\r\n            xprintf(fmt(\"2N\", min_aij, max_aij, ratio));\r\n        }\r\n    }\r\n\r\n\r\n    if (flags & ~(GLP_SF_GM | GLP_SF_EQ | GLP_SF_2N | GLP_SF_SKIP | GLP_SF_AUTO))\r\n        xerror(\"glp_scale_prob: flags = \" + flags + \"; invalid scaling options\");\r\n    if (flags & GLP_SF_AUTO)\r\n        flags = (GLP_SF_GM | GLP_SF_EQ | GLP_SF_SKIP);\r\n    scale_prob(lp, flags);\r\n};\r\n\r\nfunction spx_primal(lp, parm){\r\n\r\n    var kappa = 0.10;\r\n\r\n    function alloc_csa(lp){\r\n        var m = lp.m;\r\n        var n = lp.n;\r\n        var nnz = lp.nnz;\r\n        var csa = {};\r\n        xassert(m > 0 && n > 0);\r\n        csa.m = m;\r\n        csa.n = n;\r\n        csa.type = new Int8Array(1+m+n);\r\n        csa.lb = new Float64Array(1+m+n);\r\n        csa.ub = new Float64Array(1+m+n);\r\n        csa.coef = new Float64Array(1+m+n);\r\n        csa.obj = new Float64Array(1+n);\r\n        csa.A_ptr = new Int32Array(1+n+1);\r\n        csa.A_ind = new Int32Array(1+nnz);\r\n        csa.A_val = new Float64Array(1+nnz);\r\n        csa.head = new Int32Array(1+m+n);\r\n        csa.stat = new Int8Array(1+n);\r\n        csa.N_ptr = new Int32Array(1+m+1);\r\n        csa.N_len = new Int32Array(1+m);\r\n        csa.N_ind = null; /* will be allocated later */\r\n        csa.N_val = null; /* will be allocated later */\r\n        csa.bbar = new Float64Array(1+m);\r\n        csa.cbar = new Float64Array(1+n);\r\n        csa.refsp = new Int8Array(1+m+n);\r\n        csa.gamma = new Float64Array(1+n);\r\n        csa.tcol_ind = new Int32Array(1+m);\r\n        csa.tcol_vec = new Float64Array(1+m);\r\n        csa.trow_ind = new Int32Array(1+n);\r\n        csa.trow_vec = new Float64Array(1+n);\r\n        csa.work1 = new Float64Array(1+m);\r\n        csa.work2 = new Float64Array(1+m);\r\n        csa.work3 = new Float64Array(1+m);\r\n        csa.work4 = new Float64Array(1+m);\r\n        return csa;\r\n    }\r\n\r\n    function init_csa(csa, lp){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var obj = csa.obj;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, j, k, loc;\r\n        var cmax;\r\n        var row, col;\r\n        /* auxiliary variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            type[i] = row.type;\r\n            lb[i] = row.lb * row.rii;\r\n            ub[i] = row.ub * row.rii;\r\n            coef[i] = 0.0;\r\n        }\r\n        /* structural variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            type[m+j] = col.type;\r\n            lb[m+j] = col.lb / col.sjj;\r\n            ub[m+j] = col.ub / col.sjj;\r\n            coef[m+j] = col.coef * col.sjj;\r\n        }\r\n        /* original objective function */\r\n        obj[0] = lp.c0;\r\n        xcopyArr(obj, 1, coef, m+1, n);\r\n        /* factor used to scale original objective coefficients */\r\n        cmax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            if (cmax < Math.abs(obj[j])) cmax = Math.abs(obj[j]);\r\n        if (cmax == 0.0) cmax = 1.0;\r\n        switch (lp.dir)\r\n        {  case GLP_MIN:\r\n            csa.zeta = + 1.0 / cmax;\r\n            break;\r\n            case GLP_MAX:\r\n                csa.zeta = - 1.0 / cmax;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        if (Math.abs(csa.zeta) < 1.0) csa.zeta *= 1000.0;\r\n        /* matrix A (by columns) */\r\n        loc = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {   A_ptr[j] = loc;\r\n            for (var aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n            {  A_ind[loc] = aij.row.i;\r\n                A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        A_ptr[n+1] = loc;\r\n        xassert(loc == lp.nnz+1);\r\n        /* basis header */\r\n        xassert(lp.valid);\r\n        xcopyArr(head, 1, lp.head, 1, m);\r\n        k = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            if (row.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = i;\r\n                stat[k] = row.stat;\r\n            }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = m + j;\r\n                stat[k] = col.stat;\r\n            }\r\n        }\r\n        xassert(k == n);\r\n        /* factorization of matrix B */\r\n        csa.valid = 1; lp.valid = 0;\r\n        csa.bfd = lp.bfd; lp.bfd = null;\r\n        /* matrix N (by rows) */\r\n        alloc_N(csa);\r\n        build_N(csa);\r\n        /* working parameters */\r\n        csa.phase = 0;\r\n        csa.tm_beg = xtime();\r\n        csa.it_beg = csa.it_cnt = lp.it_cnt;\r\n        csa.it_dpy = -1;\r\n        /* reference space and steepest edge coefficients */\r\n        csa.refct = 0;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (j = 1; j <= n; j++) gamma[j] = 1.0;\r\n    }\r\n\r\n    function inv_col(csa, i, ind, val){\r\n        /* this auxiliary routine returns row indices and numeric values\r\n         of non-zero elements of i-th column of the basis matrix */\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var k, len, ptr, t;\r\n        if(GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n        k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (k <= m)\r\n        {  /* B[i] is k-th column of submatrix I */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n            ptr = A_ptr[k-m];\r\n            len = A_ptr[k-m+1] - ptr;\r\n            xcopyArr(ind, 1, A_ind, ptr, len);\r\n            xcopyArr(val, 1, A_val, ptr, len);\r\n            for (t = 1; t <= len; t++) val[t] = - val[t];\r\n        }\r\n        return len;\r\n    }\r\n\r\n    function invert_B(csa){\r\n        var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function update_B(csa, i, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var val, ret;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= i && i <= m);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* new i-th column of B is k-th column of I */\r\n            var ind = new Array(1+1);\r\n            val = new Array(1+1);\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);\r\n        }\r\n        else\r\n        {  /* new i-th column of B is (k-m)-th column of (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            val = csa.work1;\r\n            var beg, end, ptr, len;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            len = 0;\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                val[++len] = - A_val[ptr];\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg-1, val);\r\n        }\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function error_ftran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector:\r\n         r = h - B * x = h - B[1] * x[1] - ... - B[m] * x[m],\r\n         where B[1], ..., B[m] are columns of matrix B */\r\n        xcopyArr(r, 1, h, 1, m);\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                r[k] -= temp;\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    r[A_ind[ptr]] += A_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    function refine_ftran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B * x */\r\n        error_ftran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B) * r */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function error_btran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector r = b - B'* x */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* r[i] := b[i] - (i-th column of B)'* x */\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            temp = h[i];\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                temp -= x[k];\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += A_val[ptr] * x[A_ind[ptr]];\r\n            }\r\n            r[i] = temp;\r\n        }\r\n    }\r\n\r\n    function refine_btran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B'* x */\r\n        error_btran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B') * r */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function alloc_N(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var i, j, beg, end, ptr;\r\n        /* determine number of non-zeros in each row of the augmented\r\n         constraint matrix (I|-A) */\r\n        for (i = 1; i <= m; i++)\r\n            N_len[i] = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {  beg = A_ptr[j];\r\n            end = A_ptr[j+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                N_len[A_ind[ptr]]++;\r\n        }\r\n        /* determine maximal row lengths of matrix N and set its row\r\n         pointers */\r\n        N_ptr[1] = 1;\r\n        for (i = 1; i <= m; i++)\r\n        {  /* row of matrix N cannot have more than n non-zeros */\r\n            if (N_len[i] > n) N_len[i] = n;\r\n            N_ptr[i+1] = N_ptr[i] + N_len[i];\r\n        }\r\n        /* now maximal number of non-zeros in matrix N is known */\r\n        csa.N_ind = new Int32Array(N_ptr[m+1]);\r\n        csa.N_val = new Float64Array(N_ptr[m+1]);\r\n    }\r\n\r\n    function add_N_col(csa, j, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var pos;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= j && j <= n);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            pos = N_ptr[k] + (N_len[k]++);\r\n            if (GLP_DEBUG){xassert(pos < N_ptr[k+1])}\r\n            N_ind[pos] = j;\r\n            N_val[pos] = 1.0;\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var i, beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  i = A_ind[ptr]; /* row number */\r\n                pos = N_ptr[i] + (N_len[i]++);\r\n                if (GLP_DEBUG){xassert(pos < N_ptr[i+1])}\r\n                N_ind[pos] = j;\r\n                N_val[pos] = - A_val[ptr];\r\n            }\r\n        }\r\n    }\r\n\r\n    function del_N_col(csa, j, k){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var pos, head, tail;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= j && j <= n);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            /* find element in k-th row of N */\r\n            head = N_ptr[k];\r\n            for (pos = head; N_ind[pos] != j; pos++){} /* nop */\r\n            /* and remove it from the row list */\r\n            tail = head + (--N_len[k]);\r\n            if (GLP_DEBUG){xassert(pos <= tail)}\r\n            N_ind[pos] = N_ind[tail];\r\n            N_val[pos] = N_val[tail];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var i, beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  i = A_ind[ptr]; /* row number */\r\n                /* find element in i-th row of N */\r\n                head = N_ptr[i];\r\n                for (pos = head; N_ind[pos] != j; pos++){} /* nop */\r\n                /* and remove it from the row list */\r\n                tail = head + (--N_len[i]);\r\n                if (GLP_DEBUG){xassert(pos <= tail)}\r\n                N_ind[pos] = N_ind[tail];\r\n                N_val[pos] = N_val[tail];\r\n            }\r\n        }\r\n    }\r\n\r\n    function build_N(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var N_len = csa.N_len;\r\n        var j, k;\r\n        /* N := empty matrix */\r\n        xfillArr(N_len, 1, 0, m);\r\n        /* go through non-basic columns of matrix (I|-A) */\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] != GLP_NS)\r\n        {  /* xN[j] is non-fixed; add j-th column to matrix N which is\r\n         k-th column of matrix (I|-A) */\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            add_N_col(csa, j, k);\r\n        }\r\n        }\r\n    }\r\n\r\n    function get_xN(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var k;\r\n        var xN;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        switch (stat[j])\r\n        {  case GLP_NL:\r\n            /* x[k] is on its lower bound */\r\n            xN = lb[k]; break;\r\n            case GLP_NU:\r\n                /* x[k] is on its upper bound */\r\n                xN = ub[k]; break;\r\n            case GLP_NF:\r\n                /* x[k] is free non-basic variable */\r\n                xN = 0.0; break;\r\n            case GLP_NS:\r\n                /* x[k] is fixed non-basic variable */\r\n                xN = lb[k]; break;\r\n            default:\r\n                xassert(stat != stat);\r\n        }\r\n        return xN;\r\n    }\r\n\r\n    function eval_beta(csa, beta){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var h = csa.work2;\r\n        var i, j, k, beg, end, ptr;\r\n        var xN;\r\n        /* compute the right-hand side vector:\r\n         h := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n],\r\n         where N[1], ..., N[n] are columns of matrix N */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine current value of xN[j] */\r\n            xN = get_xN(csa, j);\r\n            if (xN == 0.0) continue;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] -= xN;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] += xN * A_val[ptr];\r\n            }\r\n        }\r\n        /* solve system B * beta = h */\r\n        xcopyArr(beta, 1, h, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, beta);\r\n        /* and refine the solution */\r\n        refine_ftran(csa, h, beta);\r\n    }\r\n\r\n    function eval_pi(csa, pi){\r\n        var m = csa.m;\r\n        var c = csa.coef;\r\n        var head = csa.head;\r\n        var cB = csa.work2;\r\n        var i;\r\n        /* construct the right-hand side vector cB */\r\n        for (i = 1; i <= m; i++)\r\n            cB[i] = c[head[i]];\r\n        /* solve system B'* pi = cB */\r\n        xcopyArr(pi, 1, cB, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, pi);\r\n        /* and refine the solution */\r\n        refine_btran(csa, cB, pi);\r\n    }\r\n\r\n    function eval_cost(csa, pi, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var k;\r\n        var dj;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        dj = coef[k];\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            dj -= pi[k];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                dj += A_val[ptr] * pi[A_ind[ptr]];\r\n        }\r\n        return dj;\r\n    }\r\n\r\n    function eval_bbar(csa)\r\n    {\r\n        eval_beta(csa, csa.bbar);\r\n    }\r\n\r\n    function eval_cbar(csa){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var head = csa.head}\r\n        var cbar = csa.cbar;\r\n        var pi = csa.work3;\r\n        var j;\r\n        if(GLP_DEBUG){var k}\r\n        /* compute simplex multipliers */\r\n        eval_pi(csa, pi);\r\n        /* compute and store reduced costs */\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                k = head[m+j]; /* x[k] = xN[j] */\r\n                xassert(1 <= k && k <= m+n);\r\n            }\r\n            cbar[j] = eval_cost(csa, pi, j);\r\n        }\r\n    }\r\n\r\n    function reset_refsp(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var j, k;\r\n        xassert(csa.refct == 0);\r\n        csa.refct = 1000;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            refsp[k] = 1;\r\n            gamma[j] = 1.0;\r\n        }\r\n    }\r\n\r\n    function eval_gamma(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var alfa = csa.work3;\r\n        var h = csa.work3;\r\n        var i, k;\r\n        var gamma;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[j] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * alfa = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, alfa);\r\n        /* compute gamma */\r\n        gamma = (refsp[k] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i];\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (refsp[k]) gamma += alfa[i] * alfa[i];\r\n        }\r\n        return gamma;\r\n    }\r\n\r\n    function chuzc(csa, tol_dj){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var gamma = csa.gamma;\r\n        var j, q;\r\n        var dj, best, temp;\r\n        /* nothing is chosen so far */\r\n        q = 0; best = 0.0;\r\n        /* look through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  dj = cbar[j];\r\n            switch (stat[j])\r\n            {  case GLP_NL:\r\n                /* xN[j] can increase */\r\n                if (dj >= - tol_dj) continue;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[j] can decrease */\r\n                    if (dj <= + tol_dj) continue;\r\n                    break;\r\n                case GLP_NF:\r\n                    /* xN[j] can change in any direction */\r\n                    if (- tol_dj <= dj && dj <= + tol_dj) continue;\r\n                    break;\r\n                case GLP_NS:\r\n                    /* xN[j] cannot change at all */\r\n                    continue;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n            /* xN[j] is eligible non-basic variable; choose one which has\r\n             largest weighted reduced cost */\r\n            if (GLP_DEBUG){xassert(gamma[j] > 0.0)}\r\n            temp = (dj * dj) / gamma[j];\r\n            if (best < temp){\r\n                q = j;\r\n                best = temp;\r\n            }\r\n        }\r\n        /* store the index of non-basic variable xN[q] chosen */\r\n        csa.q = q;\r\n    }\r\n\r\n    function eval_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.tcol_vec;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * tcol = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function refine_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.work3;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* refine solution of B * tcol = h */\r\n        refine_ftran(csa, h, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function sort_tcol(csa, tol_piv){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, num, pos;\r\n        var big, eps, temp;\r\n        /* compute infinity (maximum) norm of the column */\r\n        big = 0.0;\r\n        for (pos = 1; pos <= nnz; pos++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                i = tcol_ind[pos];\r\n                xassert(1 <= i && i <= m);\r\n            }\r\n            temp = Math.abs(tcol_vec[tcol_ind[pos]]);\r\n            if (big < temp) big = temp;\r\n        }\r\n        csa.tcol_max = big;\r\n        /* determine absolute pivot tolerance */\r\n        eps = tol_piv * (1.0 + 0.01 * big);\r\n        /* move significant column components to front of the list */\r\n        for (num = 0; num < nnz; )\r\n        {  i = tcol_ind[nnz];\r\n            if (Math.abs(tcol_vec[i]) < eps)\r\n                nnz--;\r\n            else\r\n            {  num++;\r\n                tcol_ind[nnz] = tcol_ind[num];\r\n                tcol_ind[num] = i;\r\n            }\r\n        }\r\n        csa.tcol_num = num;\r\n    }\r\n\r\n    function chuzr(csa, rtol){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var tcol_num = csa.tcol_num;\r\n        var i, i_stat, k, p, p_stat, pos;\r\n        var alfa, big, delta, s, t, teta, tmax;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* s := - sign(d[q]), where d[q] is reduced cost of xN[q] */\r\n        if (GLP_DEBUG){xassert(cbar[q] != 0.0)}\r\n        s = (cbar[q] > 0.0 ? -1.0 : +1.0);\r\n        /*** FIRST PASS ***/\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (type[k] == GLP_DB)\r\n        {  /* xN[q] has both lower and upper bounds */\r\n            p = -1; p_stat = 0; teta = ub[k] - lb[k]; big = 1.0;\r\n        }\r\n        else\r\n        {  /* xN[q] has no opposite bound */\r\n            p = 0; p_stat = 0; teta = DBL_MAX; big = 0.0;\r\n        }\r\n        /* walk through significant elements of the pivot column */\r\n        for (pos = 1; pos <= tcol_num; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            alfa = s * tcol_vec[i];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* xB[i] = ... + alfa * xN[q] + ..., and due to s we need to\r\n             consider the only case when xN[q] is increasing */\r\n            if (alfa > 0.0)\r\n            {  /* xB[i] is increasing */\r\n                if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(lb[k]));\r\n                    t = ((lb[k] + delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an upper bound */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(ub[k]));\r\n                    t = ((ub[k] + delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* xB[i] is decreasing */\r\n                if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(ub[k]));\r\n                    t = ((ub[k] - delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an lower bound */\r\n                    delta = rtol * (1.0 + kappa * Math.abs(lb[k]));\r\n                    t = ((lb[k] - delta) - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* t is a change of xN[q], on which xB[i] reaches its bound\r\n             (possibly relaxed); since the basic solution is assumed to\r\n             be primal feasible (or pseudo feasible on phase I), t has\r\n             to be non-negative by definition; however, it may happen\r\n             that xB[i] slightly (i.e. within a tolerance) violates its\r\n             bound, that leads to negative t; in the latter case, if\r\n             xB[i] is chosen, negative t means that xN[q] changes in\r\n             wrong direction; if pivot alfa[i,q] is close to zero, even\r\n             small bound violation of xB[i] may lead to a large change\r\n             of xN[q] in wrong direction; let, for example, xB[i] >= 0\r\n             and in the current basis its value be -5e-9; let also xN[q]\r\n             be on its zero bound and should increase; from the ratio\r\n             test rule it follows that the pivot alfa[i,q] < 0; however,\r\n             if alfa[i,q] is, say, -1e-9, the change of xN[q] in wrong\r\n             direction is 5e-9 / (-1e-9) = -5, and using it for updating\r\n             values of other basic variables will give absolutely wrong\r\n             results; therefore, if t is negative, we should replace it\r\n             by exact zero assuming that xB[i] is exactly on its bound,\r\n             and the violation appears due to round-off errors */\r\n            if (t < 0.0) t = 0.0;\r\n            /* apply minimal ratio test */\r\n            if (teta > t || teta == t && big < Math.abs(alfa)){\r\n                p = i; p_stat = i_stat; teta = t; big = Math.abs(alfa);\r\n            }\r\n\r\n        }\r\n        /* the second pass is skipped in the following cases: */\r\n        /* if the standard ratio test is used */\r\n        if (rtol == 0.0) return done();\r\n        /* if xN[q] reaches its opposite bound or if no basic variable\r\n         has been chosen on the first pass */\r\n        if (p <= 0) return done();\r\n        /* if xB[p] is a blocking variable, i.e. if it prevents xN[q]\r\n         from any change */\r\n        if (teta == 0.0) return done();\r\n        /*** SECOND PASS ***/\r\n        /* here tmax is a maximal change of xN[q], on which the solution\r\n         remains primal feasible (or pseudo feasible on phase I) within\r\n         a tolerance */\r\n        tmax = teta;\r\n        /* nothing is chosen so far */\r\n        p = 0; p_stat = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot column */\r\n        for (pos = 1; pos <= tcol_num; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            alfa = s * tcol_vec[i];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* xB[i] = ... + alfa * xN[q] + ..., and due to s we need to\r\n             consider the only case when xN[q] is increasing */\r\n            if (alfa > 0.0)\r\n            {  /* xB[i] is increasing */\r\n                if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    t = (lb[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an upper bound */\r\n                    t = (ub[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* xB[i] is decreasing */\r\n                if (phase == 1 && coef[k] > 0.0)\r\n                {  /* xB[i] violates its upper bound, which plays the role\r\n                 of an lower bound on phase I */\r\n                    t = (ub[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NU;\r\n                }\r\n                else if (phase == 1 && coef[k] < 0.0)\r\n                {  /* xB[i] violates its lower bound, which plays the role\r\n                 of an upper bound on phase I */\r\n                    continue;\r\n                }\r\n                else if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* xB[i] is within its bounds and has an lower bound */\r\n                    t = (lb[k] - bbar[i]) / alfa;\r\n                    i_stat = GLP_NL;\r\n                }\r\n                else\r\n                {  /* xB[i] is within its bounds and has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* (see comments for the first pass) */\r\n            if (t < 0.0) t = 0.0;\r\n            /* t is a change of xN[q], on which xB[i] reaches its bound;\r\n             if t <= tmax, all basic variables can violate their bounds\r\n             only within relaxation tolerance delta; we can use this\r\n             freedom and choose basic variable having largest influence\r\n             coefficient to avoid possible numeric instability */\r\n            if (t <= tmax && big < Math.abs(alfa)){\r\n                p = i; p_stat = i_stat; teta = t; big = Math.abs(alfa);\r\n            }\r\n        }\r\n        /* something must be chosen on the second pass */\r\n        xassert(p != 0);\r\n\r\n        function done(){\r\n            /* store the index and status of basic variable xB[p] chosen */\r\n            csa.p = p;\r\n            if (p > 0 && type[head[p]] == GLP_FX)\r\n                csa.p_stat = GLP_NS;\r\n            else\r\n                csa.p_stat = p_stat;\r\n            /* store corresponding change of non-basic variable xN[q] */\r\n            if (GLP_DEBUG){xassert(teta >= 0.0)}\r\n            csa.teta = s * teta;\r\n        }\r\n        done();\r\n    }\r\n\r\n    function eval_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector rho[p] */\r\n        for (i = 1; i <= m; i++)\r\n            rho[i] = 0.0;\r\n        rho[p] = 1.0;\r\n        /* solve system B'* rho = rho[p] */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, rho);\r\n    }\r\n\r\n    function refine_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var e = csa.work3;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* refine solution of B'* rho = e[p] */\r\n        refine_btran(csa, e, rho);\r\n    }\r\n\r\n    function eval_trow(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var stat = csa.stat}\r\n        var N_ptr = csa.N_ptr;\r\n        var N_len = csa.N_len;\r\n        var N_ind = csa.N_ind;\r\n        var N_val = csa.N_val;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var i, j, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* clear the pivot row */\r\n        for (j = 1; j <= n; j++)\r\n            trow_vec[j] = 0.0;\r\n        /* compute the pivot row as a linear combination of rows of the\r\n         matrix N: trow = - rho[1] * N'[1] - ... - rho[m] * N'[m] */\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = rho[i];\r\n            if (temp == 0.0) continue;\r\n            /* trow := trow - rho[i] * N'[i] */\r\n            beg = N_ptr[i];\r\n            end = beg + N_len[i];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {\r\n                if (GLP_DEBUG){\r\n                    j = N_ind[ptr];\r\n                    xassert(1 <= j && j <= n);\r\n                    xassert(stat[j] != GLP_NS);\r\n                }\r\n                trow_vec[N_ind[ptr]] -= temp * N_val[ptr];\r\n            }\r\n        }\r\n        /* construct sparse pattern of the pivot row */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (trow_vec[j] != 0.0)\r\n            trow_ind[++nnz] = j;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function update_bbar(csa){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var bbar = csa.bbar;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var p = csa.p;\r\n        var teta = csa.teta;\r\n        var i, pos;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= q && q <= n);\r\n            xassert(p < 0 || 1 <= p && p <= m);\r\n        }\r\n        /* if xN[q] leaves the basis, compute its value in the adjacent\r\n         basis, where it will replace xB[p] */\r\n        if (p > 0)\r\n            bbar[p] = get_xN(csa, q) + teta;\r\n        /* update values of other basic variables (except xB[p], because\r\n         it will be replaced by xN[q]) */\r\n        if (teta == 0.0) return;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            /* skip xB[p] */\r\n            if (i == p) continue;\r\n            /* (change of xB[i]) = alfa[i,q] * (change of xN[q]) */\r\n            bbar[i] += tcol_vec[i] * teta;\r\n        }\r\n    }\r\n\r\n    function reeval_cost(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, pos;\r\n        var dq;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        dq = coef[head[m+q]];\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            dq += coef[head[i]] * tcol_vec[i];\r\n        }\r\n        return dq;\r\n    }\r\n\r\n    function update_cbar(csa){\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var cbar = csa.cbar;\r\n        var q = csa.q;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, pos;\r\n        var new_dq;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* compute reduced cost of xB[p] in the adjacent basis, where it\r\n         will replace xN[q] */\r\n        if (GLP_DEBUG){xassert(trow_vec[q] != 0.0)}\r\n        new_dq = (cbar[q] /= trow_vec[q]);\r\n        /* update reduced costs of other non-basic variables (except\r\n         xN[q], because it will be replaced by xB[p]) */\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            /* skip xN[q] */\r\n            if (j == q) continue;\r\n            cbar[j] -= trow_vec[j] * new_dq;\r\n        }\r\n    }\r\n\r\n    function update_gamma(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var p = csa.p;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var u = csa.work3;\r\n        var i, j, k, pos, beg, end, ptr;\r\n        var gamma_q, delta_q, pivot, s, t, t1, t2;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* the basis changes, so decrease the count */\r\n        xassert(csa.refct > 0);\r\n        csa.refct--;\r\n        /* recompute gamma[q] for the current basis more accurately and\r\n         compute auxiliary vector u */\r\n        gamma_q = delta_q = (refsp[head[m+q]] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++) u[i] = 0.0;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (refsp[head[i]])\r\n            {  u[i] = t = tcol_vec[i];\r\n                gamma_q += t * t;\r\n            }\r\n            else\r\n                u[i] = 0.0;\r\n        }\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, u);\r\n        /* update gamma[k] for other non-basic variables (except fixed\r\n         variables and xN[q], because it will be replaced by xB[p]) */\r\n        pivot = trow_vec[q];\r\n        if (GLP_DEBUG){xassert(pivot != 0.0)}\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            /* skip xN[q] */\r\n            if (j == q) continue;\r\n            /* compute t */\r\n            t = trow_vec[j] / pivot;\r\n            /* compute inner product s = N'[j] * u */\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (k <= m)\r\n                s = u[k];\r\n            else\r\n            {  s = 0.0;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    s -= A_val[ptr] * u[A_ind[ptr]];\r\n            }\r\n            /* compute gamma[k] for the adjacent basis */\r\n            t1 = gamma[j] + t * t * gamma_q + 2.0 * t * s;\r\n            t2 = (refsp[k] ? 1.0 : 0.0) + delta_q * t * t;\r\n            gamma[j] = (t1 >= t2 ? t1 : t2);\r\n            if (gamma[j] < DBL_EPSILON) gamma[j] = DBL_EPSILON;\r\n        }\r\n        /* compute gamma[q] for the adjacent basis */\r\n        if (type[head[p]] == GLP_FX)\r\n            gamma[q] = 1.0;\r\n        else\r\n        {  gamma[q] = gamma_q / (pivot * pivot);\r\n            if (gamma[q] < DBL_EPSILON) gamma[q] = DBL_EPSILON;\r\n        }\r\n    }\r\n\r\n    function err_in_bbar(csa){\r\n        var m = csa.m;\r\n        var bbar = csa.bbar;\r\n        var i;\r\n        var e, emax, beta;\r\n        beta = new Float64Array(1+m);\r\n        eval_beta(csa, beta);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  e = Math.abs(beta[i] - bbar[i]) / (1.0 + Math.abs(beta[i]));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_cbar(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        var e, emax, cost, pi;\r\n        pi = new Float64Array(1+m);\r\n        eval_pi(csa, pi);\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS) continue;\r\n            cost = eval_cost(csa, pi, j);\r\n            e = Math.abs(cost - cbar[j]) / (1.0 + Math.abs(cost));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_gamma(csa){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var gamma = csa.gamma;\r\n        var j;\r\n        var e, emax, temp;\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS)\r\n        {  xassert(gamma[j] == 1.0);\r\n            continue;\r\n        }\r\n            temp = eval_gamma(csa, j);\r\n            e = Math.abs(temp - gamma[j]) / (1.0 + Math.abs(temp));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function change_basis(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var type = csa.type;\r\n        }\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var q = csa.q;\r\n        var p = csa.p;\r\n        var p_stat = csa.p_stat;\r\n        var k;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        if (p < 0)\r\n        {  /* xN[q] goes to its opposite bound */\r\n            if (GLP_DEBUG){\r\n                k = head[m+q]; /* x[k] = xN[q] */\r\n                xassert(1 <= k && k <= m+n);\r\n                xassert(type[k] == GLP_DB);\r\n            }\r\n            switch (stat[q])\r\n            {  case GLP_NL:\r\n                /* xN[q] increases */\r\n                stat[q] = GLP_NU;\r\n                break;\r\n                case GLP_NU:\r\n                    /* xN[q] decreases */\r\n                    stat[q] = GLP_NL;\r\n                    break;\r\n                default:\r\n                    xassert(stat != stat);\r\n            }\r\n        }\r\n        else\r\n        {  /* xB[p] leaves the basis, xN[q] enters the basis */\r\n            if (GLP_DEBUG){\r\n                xassert(1 <= p && p <= m);\r\n                k = head[p]; /* x[k] = xB[p] */\r\n                switch (p_stat)\r\n                {  case GLP_NL:\r\n                    /* xB[p] goes to its lower bound */\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB);\r\n                    break;\r\n                    case GLP_NU:\r\n                        /* xB[p] goes to its upper bound */\r\n                        xassert(type[k] == GLP_UP || type[k] == GLP_DB);\r\n                        break;\r\n                    case GLP_NS:\r\n                        /* xB[p] goes to its fixed value */\r\n                        xassert(type[k] == GLP_NS);\r\n                        break;\r\n                    default:\r\n                        xassert(p_stat != p_stat);\r\n                }\r\n            }\r\n            /* xB[p] <. xN[q] */\r\n            k = head[p];\r\n            head[p] = head[m+q];\r\n            head[m+q] = k;\r\n            stat[q] = p_stat;\r\n        }\r\n    }\r\n\r\n    function set_aux_obj(csa, tol_bnd){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k, cnt = 0;\r\n        var eps;\r\n        /* use a bit more restrictive tolerance */\r\n        tol_bnd *= 0.90;\r\n        /* clear all objective coefficients */\r\n        for (k = 1; k <= m+n; k++)\r\n            coef[k] = 0.0;\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has lower bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps)\r\n                {  /* and violates it */\r\n                    coef[k] = -1.0;\r\n                    cnt++;\r\n                }\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has upper bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps)\r\n                {  /* and violates it */\r\n                    coef[k] = +1.0;\r\n                    cnt++;\r\n                }\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n\r\n    function set_orig_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var coef = csa.coef;\r\n        var obj = csa.obj;\r\n        var zeta = csa.zeta;\r\n        var i, j;\r\n        for (i = 1; i <= m; i++)\r\n            coef[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            coef[m+j] = zeta * obj[j];\r\n    }\r\n\r\n    function check_stab(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var i, k;\r\n        var eps;\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (phase == 1 && coef[k] < 0.0)\r\n            {  /* x[k] must not be greater than its lower bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] > lb[k] + eps) return 1;\r\n            }\r\n            else if (phase == 1 && coef[k] > 0.0)\r\n            {  /* x[k] must not be less than its upper bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] < ub[k] - eps) return 1;\r\n            }\r\n            else\r\n            {  /* either phase = 1 and coef[k] = 0, or phase = 2 */\r\n                if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* x[k] must not be less than its lower bound */\r\n                    eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                    if (bbar[i] < lb[k] - eps) return 1;\r\n                }\r\n                if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                    type[k] == GLP_FX)\r\n                {  /* x[k] must not be greater then its upper bound */\r\n                    eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                    if (bbar[i] > ub[k] + eps) return 1;\r\n                }\r\n            }\r\n        }\r\n        /* basic solution is primal feasible within a tolerance */\r\n        return 0;\r\n    }\r\n\r\n    function check_feas(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var type = csa.type;\r\n        }\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k;\r\n        var eps;\r\n        xassert(csa.phase == 1);\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (coef[k] < 0.0)\r\n            {  /* check if x[k] still violates its lower bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps) return 1;\r\n            }\r\n            else if (coef[k] > 0.0)\r\n            {  /* check if x[k] still violates its upper bound */\r\n                if (GLP_DEBUG){\r\n                    xassert(type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                        type[k] == GLP_FX);\r\n                }\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps) return 1;\r\n            }\r\n        }\r\n        /* basic solution is primal feasible within a tolerance */\r\n        return 0;\r\n    }\r\n\r\n    function eval_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var obj = csa.obj;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, j, k;\r\n        var sum;\r\n        sum = obj[0];\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k > m)\r\n                sum += obj[k-m] * bbar[i];\r\n        }\r\n        /* walk through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k > m)\r\n                sum += obj[k-m] * get_xN(csa, j);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function display(csa, parm, spec){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var phase = csa.phase;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, k, cnt;\r\n        var sum;\r\n        if (parm.msg_lev < GLP_MSG_ON) return;\r\n        if (parm.out_dly > 0 &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)\r\n            return;\r\n        if (csa.it_cnt == csa.it_dpy) return;\r\n        if (!spec && csa.it_cnt % parm.out_frq != 0) return;\r\n        /* compute the sum of primal infeasibilities and determine the\r\n         number of basic fixed variables */\r\n        sum = 0.0; cnt = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has lower bound */\r\n                if (bbar[i] < lb[k])\r\n                    sum += (lb[k] - bbar[i]);\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* x[k] has upper bound */\r\n                if (bbar[i] > ub[k])\r\n                    sum += (bbar[i] - ub[k]);\r\n            }\r\n            if (type[k] == GLP_FX) cnt++;\r\n        }\r\n        xprintf((phase == 1 ? ' ' : '*') + csa.it_cnt + \": obj = \" + eval_obj(csa) + \"  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        csa.it_dpy = csa.it_cnt;\r\n    }\r\n\r\n    function store_sol(csa, lp, p_stat, d_stat, ray){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var zeta = csa.zeta;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, k;\r\n        var row, col;\r\n        if (GLP_DEBUG){\r\n            xassert(lp.m == m);\r\n            xassert(lp.n == n);\r\n\r\n            /* basis factorization */\r\n            xassert(!lp.valid && lp.bfd == null);\r\n            xassert(csa.valid && csa.bfd != null);\r\n        }\r\n        lp.valid = 1; csa.valid = 0;\r\n        lp.bfd = csa.bfd; csa.bfd = null;\r\n        xcopyArr(lp.head, 1, head, 1, m);\r\n        /* basic solution status */\r\n        lp.pbs_stat = p_stat;\r\n        lp.dbs_stat = d_stat;\r\n        /* objective function value */\r\n        lp.obj_val = eval_obj(csa);\r\n        /* simplex iteration count */\r\n        lp.it_cnt = csa.it_cnt;\r\n        /* unbounded ray */\r\n        lp.some = ray;\r\n        /* basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = GLP_BS;\r\n                row.bind = i;\r\n                row.prim = bbar[i] / row.rii;\r\n                row.dual = 0.0;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = GLP_BS;\r\n                col.bind = i;\r\n                col.prim = bbar[i] * col.sjj;\r\n                col.dual = 0.0;\r\n            }\r\n        }\r\n        /* non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = stat[j];\r\n                row.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    row.prim = row.lb; break;\r\n                    case GLP_NU:\r\n                        row.prim = row.ub; break;\r\n                    case GLP_NF:\r\n                        row.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        row.prim = row.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                row.dual = (cbar[j] * row.rii) / zeta;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = stat[j];\r\n                col.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    col.prim = col.lb; break;\r\n                    case GLP_NU:\r\n                        col.prim = col.ub; break;\r\n                    case GLP_NF:\r\n                        col.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        col.prim = col.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                col.dual = (cbar[j] / col.sjj) / zeta;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    var csa;\r\n    var binv_st = 2;\r\n    /* status of basis matrix factorization:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var bbar_st = 0;\r\n    /* status of primal values of basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var cbar_st = 0;\r\n    /* status of reduced costs of non-basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var rigorous = 0;\r\n    /* rigorous mode flag; this flag is used to enable iterative\r\n     refinement on computing pivot rows and columns of the simplex\r\n     table */\r\n    var check = 0;\r\n    var p_stat, d_stat, ret;\r\n    /* allocate and initialize the common storage area */\r\n    csa = alloc_csa(lp);\r\n    init_csa(csa, lp);\r\n    if (parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"Objective scale factor = \" + csa.zeta + \"\");\r\n    while (true){\r\n        /* main loop starts here */\r\n        /* compute factorization of the basis matrix */\r\n        if (binv_st == 0)\r\n        {  ret = invert_B(csa);\r\n            if (ret != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            {  xprintf(\"Error: unable to factorize the basis matrix (\" + ret + \")\");\r\n                xprintf(\"Sorry, basis recovery procedure not implemented yet\");\r\n            }\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                return ret;\r\n            }\r\n            csa.valid = 1;\r\n            binv_st = 1; /* just computed */\r\n            /* invalidate basic solution components */\r\n            bbar_st = cbar_st = 0;\r\n        }\r\n        /* compute primal values of basic variables */\r\n        if (bbar_st == 0)\r\n        {  eval_bbar(csa);\r\n            bbar_st = 1; /* just computed */\r\n            /* determine the search phase, if not determined yet */\r\n            if (csa.phase == 0)\r\n            {  if (set_aux_obj(csa, parm.tol_bnd) > 0)\r\n            {  /* current basic solution is primal infeasible */\r\n                /* start to minimize the sum of infeasibilities */\r\n                csa.phase = 1;\r\n            }\r\n            else\r\n            {  /* current basic solution is primal feasible */\r\n                /* start to minimize the original objective function */\r\n                set_orig_obj(csa);\r\n                csa.phase = 2;\r\n            }\r\n                xassert(check_stab(csa, parm.tol_bnd) == 0);\r\n                /* working objective coefficients have been changed, so\r\n                 invalidate reduced costs */\r\n                cbar_st = 0;\r\n                display(csa, parm, 1);\r\n            }\r\n            /* make sure that the current basic solution remains primal\r\n             feasible (or pseudo feasible on phase I) */\r\n            if (check_stab(csa, parm.tol_bnd))\r\n            {  /* there are excessive bound violations due to round-off\r\n             errors */\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Warning: numerical instability (primal simplex, phase \" + (csa.phase == 1 ? \"I\" : \"II\") + \")\");\r\n                /* restart the search */\r\n                csa.phase = 0;\r\n                binv_st = 0;\r\n                rigorous = 5;\r\n                continue;\r\n            }\r\n        }\r\n        xassert(csa.phase == 1 || csa.phase == 2);\r\n        /* on phase I we do not need to wait until the current basic\r\n         solution becomes dual feasible; it is sufficient to make sure\r\n         that no basic variable violates its bounds */\r\n        if (csa.phase == 1 && !check_feas(csa, parm.tol_bnd))\r\n        {  /* the current basis is primal feasible; switch to phase II */\r\n            csa.phase = 2;\r\n            set_orig_obj(csa);\r\n            cbar_st = 0;\r\n            display(csa, parm, 1);\r\n        }\r\n        /* compute reduced costs of non-basic variables */\r\n        if (cbar_st == 0)\r\n        {  eval_cbar(csa);\r\n            cbar_st = 1; /* just computed */\r\n        }\r\n        /* redefine the reference space, if required */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct == 0) reset_refsp(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* at this point the basis factorization and all basic solution\r\n         components are valid */\r\n        xassert(binv_st && bbar_st && cbar_st);\r\n        /* check accuracy of current basic solution components (only for\r\n         debugging) */\r\n        if (check)\r\n        {  var e_bbar = err_in_bbar(csa);\r\n            var e_cbar = err_in_cbar(csa);\r\n            var e_gamma =\r\n                (parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0.0);\r\n            xprintf(\"e_bbar = \" + e_bbar + \"; e_cbar = \" + e_cbar + \"; e_gamma = \" + e_gamma + \"\");\r\n            xassert(e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3);\r\n        }\r\n        /* check if the iteration limit has been exhausted */\r\n        if (parm.it_lim < INT_MAX &&\r\n            csa.it_cnt - csa.it_beg >= parm.it_lim)\r\n        {  if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (csa.phase == 2 && cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                p_stat = GLP_INFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                break;\r\n                case 2:\r\n                    p_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            chuzc(csa, parm.tol_dj);\r\n            d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = GLP_EITLIM;\r\n            return ret;\r\n        }\r\n        /* check if the time limit has been exhausted */\r\n        if (parm.tm_lim < INT_MAX &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim)\r\n        {  if (bbar_st != 1 || csa.phase == 2 && cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (csa.phase == 2 && cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                p_stat = GLP_INFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                break;\r\n                case 2:\r\n                    p_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            chuzc(csa, parm.tol_dj);\r\n            d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = GLP_ETMLIM;\r\n            return ret;\r\n        }\r\n        /* display the search progress */\r\n        display(csa, parm, 0);\r\n        /* choose non-basic variable xN[q] */\r\n        chuzc(csa, parm.tol_dj);\r\n        if (csa.q == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n                p_stat = GLP_NOFEAS;\r\n                set_orig_obj(csa);\r\n                eval_cbar(csa);\r\n                chuzc(csa, parm.tol_dj);\r\n                d_stat = (csa.q == 0 ? GLP_FEAS : GLP_INFEAS);\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n                    p_stat = d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n        /* compute pivot column of the simplex table */\r\n        eval_tcol(csa);\r\n        if (rigorous) refine_tcol(csa);\r\n        sort_tcol(csa, parm.tol_piv);\r\n        /* check accuracy of the reduced cost of xN[q] */\r\n        {  var d1 = csa.cbar[csa.q]; /* less accurate */\r\n            var d2 = reeval_cost(csa);  /* more accurate */\r\n            xassert(d1 != 0.0);\r\n            if (Math.abs(d1 - d2) > 1e-5 * (1.0 + Math.abs(d2)) ||\r\n                !(d1 < 0.0 && d2 < 0.0 || d1 > 0.0 && d2 > 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"d1 = \" + d1 + \"; d2 = \" + d2 + \"\");\r\n                if (cbar_st != 1 || !rigorous)\r\n                {  if (cbar_st != 1) cbar_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n            /* replace cbar[q] by more accurate value keeping its sign */\r\n            if (d1 > 0.0)\r\n                csa.cbar[csa.q] = (d2 > 0.0 ? d2 : +DBL_EPSILON);\r\n            else\r\n                csa.cbar[csa.q] = (d2 < 0.0 ? d2 : -DBL_EPSILON);\r\n        }\r\n        /* choose basic variable xB[p] */\r\n        switch (parm.r_test)\r\n        {  case GLP_RT_STD:\r\n            chuzr(csa, 0.0);\r\n            break;\r\n            case GLP_RT_HAR:\r\n                chuzr(csa, 0.30 * parm.tol_bnd);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        if (csa.p == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1 || !rigorous)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            rigorous = 1;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Error: unable to choose basic variable on phase I\");\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"PROBLEM HAS UNBOUNDED SOLUTION\");\r\n                    store_sol(csa, lp, GLP_FEAS, GLP_NOFEAS,\r\n                        csa.head[csa.m+csa.q]);\r\n                    ret = 0;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            return ret;\r\n        }\r\n        /* check if the pivot element is acceptable */\r\n        if (csa.p > 0)\r\n        {  var piv = csa.tcol_vec[csa.p];\r\n            var eps = 1e-5 * (1.0 + 0.01 * csa.tcol_max);\r\n            if (Math.abs(piv) < eps)\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv = \" + piv + \"; eps = \" + eps + \"\");\r\n                if (!rigorous)\r\n                {  rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        /* now xN[q] and xB[p] have been chosen anyhow */\r\n        /* compute pivot row of the simplex table */\r\n        if (csa.p > 0)\r\n        {  var rho = csa.work4;\r\n            eval_rho(csa, rho);\r\n            if (rigorous) refine_rho(csa, rho);\r\n            eval_trow(csa, rho);\r\n        }\r\n        /* accuracy check based on the pivot element */\r\n        if (csa.p > 0)\r\n        {  var piv1 = csa.tcol_vec[csa.p]; /* more accurate */\r\n            var piv2 = csa.trow_vec[csa.q]; /* less accurate */\r\n            xassert(piv1 != 0.0);\r\n            if (Math.abs(piv1 - piv2) > 1e-8 * (1.0 + Math.abs(piv1)) ||\r\n                !(piv1 > 0.0 && piv2 > 0.0 || piv1 < 0.0 && piv2 < 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv1 = \" + piv1 + \"; piv2 = \" + piv2 + \"\");\r\n                if (binv_st != 1 || !rigorous)\r\n                {  if (binv_st != 1) binv_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n                /* use more accurate version in the pivot row */\r\n                if (csa.trow_vec[csa.q] == 0.0)\r\n                {  csa.trow_nnz++;\r\n                    xassert(csa.trow_nnz <= csa.n);\r\n                    csa.trow_ind[csa.trow_nnz] = csa.q;\r\n                }\r\n                csa.trow_vec[csa.q] = piv1;\r\n            }\r\n        }\r\n        /* update primal values of basic variables */\r\n        update_bbar(csa);\r\n        bbar_st = 2; /* updated */\r\n        /* update reduced costs of non-basic variables */\r\n        if (csa.p > 0)\r\n        {  update_cbar(csa);\r\n            cbar_st = 2; /* updated */\r\n            /* on phase I objective coefficient of xB[p] in the adjacent\r\n             basis becomes zero */\r\n            if (csa.phase == 1)\r\n            {  var k = csa.head[csa.p]; /* x[k] = xB[p] . xN[q] */\r\n                csa.cbar[csa.q] -= csa.coef[k];\r\n                csa.coef[k] = 0.0;\r\n            }\r\n        }\r\n        /* update steepest edge coefficients */\r\n        if (csa.p > 0)\r\n        {  switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n                break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct > 0) update_gamma(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        }\r\n        /* update factorization of the basis matrix */\r\n        if (csa.p > 0)\r\n        {  ret = update_B(csa, csa.p, csa.head[csa.m+csa.q]);\r\n            if (ret == 0)\r\n                binv_st = 2; /* updated */\r\n            else\r\n            {  csa.valid = 0;\r\n                binv_st = 0; /* invalid */\r\n            }\r\n        }\r\n        /* update matrix N */\r\n        if (csa.p > 0)\r\n        {  del_N_col(csa, csa.q, csa.head[csa.m+csa.q]);\r\n            if (csa.type[csa.head[csa.p]] != GLP_FX)\r\n                add_N_col(csa, csa.q, csa.head[csa.p]);\r\n        }\r\n        /* change the basis header */\r\n        change_basis(csa);\r\n        /* iteration complete */\r\n        csa.it_cnt++;\r\n        if (rigorous > 0) rigorous--;\r\n        continue;\r\n    }\r\n\r\n    /* return to the calling program */\r\n    //return ret;\r\n}\r\n\r\nfunction spx_dual(lp, parm){\r\n\r\n    var kappa = 0.10;\r\n\r\n    function alloc_csa(lp){\r\n        var m = lp.m;\r\n        var n = lp.n;\r\n        var nnz = lp.nnz;\r\n        var csa = {};\r\n        xassert(m > 0 && n > 0);\r\n        csa.m = m;\r\n        csa.n = n;\r\n        csa.type = new Int8Array(1+m+n);\r\n        csa.lb = new Float64Array(1+m+n);\r\n        csa.ub = new Float64Array(1+m+n);\r\n        csa.coef = new Float64Array(1+m+n);\r\n        csa.orig_type = new Int8Array(1+m+n);\r\n        csa.orig_lb = new Float64Array(1+m+n);\r\n        csa.orig_ub = new Float64Array(1+m+n);\r\n        csa.obj = new Float64Array(1+n);\r\n        csa.A_ptr = new Int32Array(1+n+1);\r\n        csa.A_ind = new Int32Array(1+nnz);\r\n        csa.A_val = new Float64Array(1+nnz);\r\n        csa.AT_ptr = new Int32Array(1+m+1);\r\n        csa.AT_ind = new Int32Array(1+nnz);\r\n        csa.AT_val = new Float64Array(1+nnz);\r\n        csa.head = new Int32Array(1+m+n);\r\n        csa.bind = new Int32Array(1+m+n);\r\n        csa.stat = new Int8Array(1+n);\r\n        csa.bbar = new Float64Array(1+m);\r\n        csa.cbar = new Float64Array(1+n);\r\n        csa.refsp = new Int8Array(1+m+n);\r\n        csa.gamma = new Float64Array(1+m);\r\n        csa.trow_ind = new Int32Array(1+n);\r\n        csa.trow_vec = new Float64Array(1+n);\r\n        csa.tcol_ind = new Int32Array(1+m);\r\n        csa.tcol_vec = new Float64Array(1+m);\r\n        csa.work1 = new Float64Array(1+m);\r\n        csa.work2 = new Float64Array(1+m);\r\n        csa.work3 = new Float64Array(1+m);\r\n        csa.work4 = new Float64Array(1+m);\r\n        return csa;\r\n    }\r\n\r\n    this[\"chrome_workaround_1\"] = function(csa, lp){\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var n = csa.n;\r\n        var aij, loc, j;\r\n        /* matrix A (by columns) */\r\n        loc = 1;\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            A_ptr[j] = loc;\r\n            for (aij = lp.col[j].ptr; aij != null; aij = aij.c_next)\r\n            {  A_ind[loc] = aij.row.i;\r\n                A_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        A_ptr[n+1] = loc;\r\n        xassert(loc-1 == lp.nnz);\r\n    };\r\n\r\n    this[\"chrome_workaround_2\"] = function(csa, lp){\r\n        var loc, i, aij;\r\n        var AT_ptr = csa.AT_ptr;\r\n        var AT_ind = csa.AT_ind;\r\n        var AT_val = csa.AT_val;\r\n        var m = csa.m;\r\n\r\n        /* matrix A (by rows) */\r\n        loc = 1;\r\n        for (i = 1; i <= m; i++)\r\n        {\r\n            AT_ptr[i] = loc;\r\n            for (aij = lp.row[i].ptr; aij != null; aij = aij.r_next)\r\n            {  AT_ind[loc] = aij.col.j;\r\n                AT_val[loc] = aij.row.rii * aij.val * aij.col.sjj;\r\n                loc++;\r\n            }\r\n        }\r\n        AT_ptr[m+1] = loc;\r\n        xassert(loc-1 == lp.nnz);\r\n\r\n    };\r\n\r\n    function init_csa(csa, lp){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var coef = csa.coef;\r\n        var orig_type = csa.orig_type;\r\n        var orig_lb = csa.orig_lb;\r\n        var orig_ub = csa.orig_ub;\r\n        var obj = csa.obj;\r\n\r\n        var head = csa.head;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, j, k, loc;\r\n        var cmax, aij, row, col;\r\n        /* auxiliary variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            type[i] = row.type;\r\n            lb[i] = row.lb * row.rii;\r\n            ub[i] = row.ub * row.rii;\r\n            coef[i] = 0.0;\r\n        }\r\n        /* structural variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            type[m+j] = col.type;\r\n            lb[m+j] = col.lb / col.sjj;\r\n            ub[m+j] = col.ub / col.sjj;\r\n            coef[m+j] = col.coef * col.sjj;\r\n        }\r\n        /* original bounds of variables */\r\n        xcopyArr(orig_type, 1, type, 1, m+n);\r\n        xcopyArr(orig_lb, 1, lb, 1, m+n);\r\n        xcopyArr(orig_ub, 1, ub, 1, m+n);\r\n        /* original objective function */\r\n        obj[0] = lp.c0;\r\n        xcopyArr(obj, 1, coef, m+1, n);\r\n        /* factor used to scale original objective coefficients */\r\n        cmax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n            if (cmax < Math.abs(obj[j])) cmax = Math.abs(obj[j]);\r\n        if (cmax == 0.0) cmax = 1.0;\r\n        switch (lp.dir)\r\n        {  case GLP_MIN:\r\n            csa.zeta = + 1.0 / cmax;\r\n            break;\r\n            case GLP_MAX:\r\n                csa.zeta = - 1.0 / cmax;\r\n                break;\r\n            default:\r\n                xassert(lp != lp);\r\n        }\r\n        if (Math.abs(csa.zeta) < 1.0) csa.zeta *= 1000.0;\r\n        /* scale working objective coefficients */\r\n        for (j = 1; j <= n; j++) coef[m+j] *= csa.zeta;\r\n\r\n        chrome_workaround_1(csa, lp);\r\n        chrome_workaround_2(csa, lp);\r\n\r\n        /* basis header */\r\n        xassert(lp.valid);\r\n        xcopyArr(head, 1, lp.head, 1, m);\r\n        k = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  row = lp.row[i];\r\n            if (row.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = i;\r\n                stat[k] = row.stat;\r\n            }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {  col = lp.col[j];\r\n            if (col.stat != GLP_BS)\r\n            {  k++;\r\n                xassert(k <= n);\r\n                head[m+k] = m + j;\r\n                stat[k] = col.stat;\r\n            }\r\n        }\r\n        xassert(k == n);\r\n        for (k = 1; k <= m+n; k++)\r\n            bind[head[k]] = k;\r\n        /* factorization of matrix B */\r\n        csa.valid = 1; lp.valid = 0;\r\n        csa.bfd = lp.bfd; lp.bfd = null;\r\n        /* working parameters */\r\n        csa.phase = 0;\r\n        csa.tm_beg = xtime();\r\n        csa.it_beg = csa.it_cnt = lp.it_cnt;\r\n        csa.it_dpy = -1;\r\n        /* reference space and steepest edge coefficients */\r\n        csa.refct = 0;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (i = 1; i <= m; i++) gamma[i] = 1.0;\r\n    }\r\n\r\n    function inv_col(csa, i, ind, val){\r\n        /* this auxiliary routine returns row indices and numeric values\r\n         of non-zero elements of i-th column of the basis matrix */\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var k, len, ptr, t;\r\n        if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n        k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        if (k <= m)\r\n        {  /* B[i] is k-th column of submatrix I */\r\n            len = 1;\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n        }\r\n        else\r\n        {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n            ptr = A_ptr[k-m];\r\n            len = A_ptr[k-m+1] - ptr;\r\n            xcopyArr(ind, 1, A_ind, ptr, len);\r\n            xcopyArr(val, 1, A_val, ptr, len);\r\n            for (t = 1; t <= len; t++) val[t] = - val[t];\r\n        }\r\n        return len;\r\n    }\r\n\r\n    function invert_B(csa){\r\n        var ret = bfd_factorize(csa.bfd, csa.m, null, inv_col, csa);\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function update_B(csa, i, k)\r\n    {   var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var ret, val;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= i && i <= m);\r\n            xassert(1 <= k && k <= m+n);\r\n        }\r\n        if (k <= m)\r\n        {  /* new i-th column of B is k-th column of I */\r\n            var ind = new Array(1+1);\r\n            val = new Array(1+1);\r\n            ind[1] = k;\r\n            val[1] = 1.0;\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, 1, ind, 0, val);\r\n        }\r\n        else\r\n        {  /* new i-th column of B is (k-m)-th column of (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            val = csa.work1;\r\n            var beg, end, ptr, len;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            len = 0;\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                val[++len] = - A_val[ptr];\r\n            xassert(csa.valid);\r\n            ret = bfd_update_it(csa.bfd, i, 0, len, A_ind, beg-1, val);\r\n        }\r\n        csa.valid = (ret == 0);\r\n        return ret;\r\n    }\r\n\r\n    function error_ftran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector:\r\n         r = h - B * x = h - B[1] * x[1] - ... - B[m] * x[m],\r\n         where B[1], ..., B[m] are columns of matrix B */\r\n        xcopyArr(r, 1, h, 1, m);\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = x[i];\r\n            if (temp == 0.0) continue;\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                r[k] -= temp;\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    r[A_ind[ptr]] += A_val[ptr] * temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    function refine_ftran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B * x */\r\n        error_ftran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B) * r */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function error_btran(csa, h, x, r){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var i, k, beg, end, ptr;\r\n        var temp;\r\n        /* compute the residual vector r = b - B'* x */\r\n        for (i = 1; i <= m; i++)\r\n        {  /* r[i] := b[i] - (i-th column of B)'* x */\r\n            k = head[i]; /* B[i] is k-th column of (I|-A) */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            temp = h[i];\r\n            if (k <= m)\r\n            {  /* B[i] is k-th column of submatrix I */\r\n                temp -= x[k];\r\n            }\r\n            else\r\n            {  /* B[i] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += A_val[ptr] * x[A_ind[ptr]];\r\n            }\r\n            r[i] = temp;\r\n        }\r\n    }\r\n\r\n    function refine_btran(csa, h, x){\r\n        var m = csa.m;\r\n        var r = csa.work1;\r\n        var d = csa.work1;\r\n        var i;\r\n        /* compute the residual vector r = h - B'* x */\r\n        error_btran(csa, h, x, r);\r\n        /* compute the correction vector d = inv(B') * r */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, d);\r\n        /* refine the solution vector (new x) = (old x) + d */\r\n        for (i = 1; i <= m; i++) x[i] += d[i];\r\n    }\r\n\r\n    function get_xN(csa, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var k;\r\n        var xN;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        switch (stat[j])\r\n        {  case GLP_NL:\r\n            /* x[k] is on its lower bound */\r\n            xN = lb[k]; break;\r\n            case GLP_NU:\r\n                /* x[k] is on its upper bound */\r\n                xN = ub[k]; break;\r\n            case GLP_NF:\r\n                /* x[k] is free non-basic variable */\r\n                xN = 0.0; break;\r\n            case GLP_NS:\r\n                /* x[k] is fixed non-basic variable */\r\n                xN = lb[k]; break;\r\n            default:\r\n                xassert(stat != stat);\r\n        }\r\n        return xN;\r\n    }\r\n\r\n    function eval_beta(csa, beta){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var h = csa.work2;\r\n        var i, j, k, beg, end, ptr;\r\n        var xN;\r\n        /* compute the right-hand side vector:\r\n         h := - N * xN = - N[1] * xN[1] - ... - N[n] * xN[n],\r\n         where N[1], ..., N[n] are columns of matrix N */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {   k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine current value of xN[j] */\r\n            xN = get_xN(csa, j);\r\n            if (xN == 0.0) continue;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] -= xN;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] += xN * A_val[ptr];\r\n            }\r\n        }\r\n        /* solve system B * beta = h */\r\n        xcopyArr(beta, 1, h, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, beta);\r\n        /* and refine the solution */\r\n        refine_ftran(csa, h, beta);\r\n    }\r\n\r\n    function eval_pi(csa, pi){\r\n        var m = csa.m;\r\n        var c = csa.coef;\r\n        var head = csa.head;\r\n        var cB = csa.work2;\r\n        var i;\r\n        /* construct the right-hand side vector cB */\r\n        for (i = 1; i <= m; i++)\r\n            cB[i] = c[head[i]];\r\n        /* solve system B'* pi = cB */\r\n        xcopyArr(pi, 1, cB, 1, m);\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, pi);\r\n        /* and refine the solution */\r\n        refine_btran(csa, cB, pi);\r\n    }\r\n\r\n    function eval_cost(csa, pi, j){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var coef = csa.coef;\r\n        var head = csa.head;\r\n        var k;\r\n        var dj;\r\n        if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n        k = head[m+j]; /* x[k] = xN[j] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        dj = coef[k];\r\n        if (k <= m)\r\n        {  /* N[j] is k-th column of submatrix I */\r\n            dj -= pi[k];\r\n        }\r\n        else\r\n        {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                dj += A_val[ptr] * pi[A_ind[ptr]];\r\n        }\r\n        return dj;\r\n    }\r\n\r\n    function eval_bbar(csa){\r\n        eval_beta(csa, csa.bbar);\r\n    }\r\n\r\n    function eval_cbar(csa){\r\n        if (GLP_DEBUG){var m = csa.m}\r\n        var n = csa.n;\r\n        if (GLP_DEBUG){var head = csa.head}\r\n        var cbar = csa.cbar;\r\n        var pi = csa.work3;\r\n        var j;\r\n        if (GLP_DEBUG){var k}\r\n        /* compute simplex multipliers */\r\n        eval_pi(csa, pi);\r\n        /* compute and store reduced costs */\r\n        for (j = 1; j <= n; j++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                k = head[m+j]; /* x[k] = xN[j] */\r\n                xassert(1 <= k && k <= m+n);\r\n            }\r\n            cbar[j] = eval_cost(csa, pi, j);\r\n        }\r\n    }\r\n\r\n    function reset_refsp(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var i, k;\r\n        xassert(csa.refct == 0);\r\n        csa.refct = 1000;\r\n        xfillArr(refsp, 1, 0, m+n);\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            refsp[k] = 1;\r\n            gamma[i] = 1.0;\r\n        }\r\n    }\r\n\r\n    function eval_gamma(csa, gamma){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var alfa = csa.work3;\r\n        var h = csa.work3;\r\n        var i, j, k;\r\n        /* gamma[i] := eta[i] (or 1, if xB[i] is free) */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            if (type[k] == GLP_FR)\r\n                gamma[i] = 1.0;\r\n            else\r\n                gamma[i] = (refsp[k] ? 1.0 : 0.0);\r\n        }\r\n        /* compute columns of the current simplex table */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* skip column, if xN[j] is not in C */\r\n            if (!refsp[k]) continue;\r\n            if (GLP_DEBUG){\r\n                /* set C must not contain fixed variables */\r\n                xassert(type[k] != GLP_FX);\r\n            }\r\n            /* construct the right-hand side vector h = - N[j] */\r\n            for (i = 1; i <= m; i++)\r\n                h[i] = 0.0;\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                h[k] = -1.0;\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                var A_ptr = csa.A_ptr;\r\n                var A_ind = csa.A_ind;\r\n                var A_val = csa.A_val;\r\n                var beg, end, ptr;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    h[A_ind[ptr]] = A_val[ptr];\r\n            }\r\n            /* solve system B * alfa = h */\r\n            xassert(csa.valid);\r\n            bfd_ftran(csa.bfd, alfa);\r\n            /* gamma[i] := gamma[i] + alfa[i,j]^2 */\r\n            for (i = 1; i <= m; i++)\r\n            {  k = head[i]; /* x[k] = xB[i] */\r\n                if (type[k] != GLP_FR)\r\n                    gamma[i] += alfa[i] * alfa[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function chuzr(csa, tol_bnd){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var gamma = csa.gamma;\r\n        var i, k, p;\r\n        var delta, best, eps, ri, temp;\r\n        /* nothing is chosen so far */\r\n        p = 0; delta = 0.0; best = 0.0;\r\n        /* look through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* determine bound violation ri[i] */\r\n            ri = 0.0;\r\n            if (type[k] == GLP_LO || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* xB[i] has lower bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(lb[k]));\r\n                if (bbar[i] < lb[k] - eps)\r\n                {  /* and significantly violates it */\r\n                    ri = lb[k] - bbar[i];\r\n                }\r\n            }\r\n            if (type[k] == GLP_UP || type[k] == GLP_DB ||\r\n                type[k] == GLP_FX)\r\n            {  /* xB[i] has upper bound */\r\n                eps = tol_bnd * (1.0 + kappa * Math.abs(ub[k]));\r\n                if (bbar[i] > ub[k] + eps)\r\n                {  /* and significantly violates it */\r\n                    ri = ub[k] - bbar[i];\r\n                }\r\n            }\r\n            /* if xB[i] is not eligible, skip it */\r\n            if (ri == 0.0) continue;\r\n            /* xB[i] is eligible basic variable; choose one with largest\r\n             weighted bound violation */\r\n            if (GLP_DEBUG){xassert(gamma[i] >= 0.0)}\r\n            temp = gamma[i];\r\n            if (temp < DBL_EPSILON) temp = DBL_EPSILON;\r\n            temp = (ri * ri) / temp;\r\n            if (best < temp){\r\n                p = i; delta = ri; best = temp;\r\n            }\r\n        }\r\n        /* store the index of basic variable xB[p] chosen and its change\r\n         in the adjacent basis */\r\n        csa.p = p;\r\n        csa.delta = delta;\r\n    }\r\n\r\n    function eval_rho(csa, e){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* solve system B'* rho = e[p] */\r\n        xassert(csa.valid);\r\n        bfd_btran(csa.bfd, rho);\r\n    }\r\n\r\n    function refine_rho(csa, rho){\r\n        var m = csa.m;\r\n        var p = csa.p;\r\n        var e = csa.work3;\r\n        var i;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* construct the right-hand side vector e[p] */\r\n        for (i = 1; i <= m; i++)\r\n            e[i] = 0.0;\r\n        e[p] = 1.0;\r\n        /* refine solution of B'* rho = e[p] */\r\n        refine_btran(csa, e, rho);\r\n    }\r\n\r\n    function eval_trow1(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var A_ptr = csa.A_ptr;\r\n        var A_ind = csa.A_ind;\r\n        var A_val = csa.A_val;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, k, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* compute the pivot row as inner products of columns of the\r\n         matrix N and vector rho: trow[j] = - rho * N[j] */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS)\r\n        {  /* xN[j] is fixed */\r\n            trow_vec[j] = 0.0;\r\n            continue;\r\n        }\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (k <= m)\r\n            {  /* N[j] is k-th column of submatrix I */\r\n                temp = - rho[k];\r\n            }\r\n            else\r\n            {  /* N[j] is (k-m)-th column of submatrix (-A) */\r\n                beg = A_ptr[k-m]; end = A_ptr[k-m+1];\r\n                temp = 0.0;\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    temp += rho[A_ind[ptr]] * A_val[ptr];\r\n            }\r\n            if (temp != 0.0)\r\n                trow_ind[++nnz] = j;\r\n            trow_vec[j] = temp;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function eval_trow2(csa, rho){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var AT_ptr = csa.AT_ptr;\r\n        var AT_ind = csa.AT_ind;\r\n        var AT_val = csa.AT_val;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var i, j, beg, end, ptr, nnz;\r\n        var temp;\r\n        /* clear the pivot row */\r\n        for (j = 1; j <= n; j++)\r\n            trow_vec[j] = 0.0;\r\n        /* compute the pivot row as a linear combination of rows of the\r\n         matrix N: trow = - rho[1] * N'[1] - ... - rho[m] * N'[m] */\r\n        for (i = 1; i <= m; i++)\r\n        {  temp = rho[i];\r\n            if (temp == 0.0) continue;\r\n            /* trow := trow - rho[i] * N'[i] */\r\n            j = bind[i] - m; /* x[i] = xN[j] */\r\n            if (j >= 1 && stat[j] != GLP_NS)\r\n                trow_vec[j] -= temp;\r\n            beg = AT_ptr[i]; end = AT_ptr[i+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n            {  j = bind[m + AT_ind[ptr]] - m; /* x[k] = xN[j] */\r\n                if (j >= 1 && stat[j] != GLP_NS)\r\n                    trow_vec[j] += temp * AT_val[ptr];\r\n            }\r\n        }\r\n        /* construct sparse pattern of the pivot row */\r\n        nnz = 0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (trow_vec[j] != 0.0)\r\n            trow_ind[++nnz] = j;\r\n        }\r\n        csa.trow_nnz = nnz;\r\n    }\r\n\r\n    function eval_trow(csa, rho){\r\n        var m = csa.m;\r\n        var i, nnz;\r\n        var dens;\r\n        /* determine the density of the vector rho */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n            if (rho[i] != 0.0) nnz++;\r\n        dens = nnz / m;\r\n        if (dens >= 0.20)\r\n        {  /* rho is relatively dense */\r\n            eval_trow1(csa, rho);\r\n        }\r\n        else\r\n        {  /* rho is relatively sparse */\r\n            eval_trow2(csa, rho);\r\n        }\r\n    }\r\n\r\n    function sort_trow(csa, tol_piv){\r\n        if (GLP_DEBUG){\r\n            var n = csa.n;\r\n            var stat = csa.stat;\r\n        }\r\n        var nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var j, num, pos;\r\n        var big, eps, temp;\r\n        /* compute infinity (maximum) norm of the row */\r\n        big = 0.0;\r\n        for (pos = 1; pos <= nnz; pos++)\r\n        {\r\n            if (GLP_DEBUG){\r\n                j = trow_ind[pos];\r\n                xassert(1 <= j && j <= n);\r\n                xassert(stat[j] != GLP_NS);\r\n            }\r\n            temp = Math.abs(trow_vec[trow_ind[pos]]);\r\n            if (big < temp) big = temp;\r\n        }\r\n        csa.trow_max = big;\r\n        /* determine absolute pivot tolerance */\r\n        eps = tol_piv * (1.0 + 0.01 * big);\r\n        /* move significant row components to the front of the list */\r\n        for (num = 0; num < nnz; )\r\n        {  j = trow_ind[nnz];\r\n            if (Math.abs(trow_vec[j]) < eps)\r\n                nnz--;\r\n            else\r\n            {  num++;\r\n                trow_ind[nnz] = trow_ind[num];\r\n                trow_ind[num] = j;\r\n            }\r\n        }\r\n        csa.trow_num = num;\r\n    }\r\n\r\n    function chuzc(csa, rtol){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        if (GLP_DEBUG){\r\n            var p = csa.p;\r\n        }\r\n        var delta = csa.delta;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var trow_num = csa.trow_num;\r\n        var j, pos, q;\r\n        var alfa, big, s, t, teta, tmax;\r\n        if (GLP_DEBUG){xassert(1 <= p && p <= m)}\r\n        /* delta > 0 means that xB[p] violates its lower bound and goes\r\n         to it in the adjacent basis, so lambdaB[p] is increasing from\r\n         its lower zero bound;\r\n         delta < 0 means that xB[p] violates its upper bound and goes\r\n         to it in the adjacent basis, so lambdaB[p] is decreasing from\r\n         its upper zero bound */\r\n        if (GLP_DEBUG){xassert(delta != 0.0)}\r\n        /* s := sign(delta) */\r\n        s = (delta > 0.0 ? +1.0 : -1.0);\r\n        /*** FIRST PASS ***/\r\n        /* nothing is chosen so far */\r\n        q = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot row */\r\n        for (pos = 1; pos <= trow_num; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            alfa = s * trow_vec[j];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* lambdaN[j] = ... - alfa * lambdaB[p] - ..., and due to s we\r\n             need to consider only increasing lambdaB[p] */\r\n            if (alfa > 0.0)\r\n            {  /* lambdaN[j] is decreasing */\r\n                if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero lower bound */\r\n                    t = (cbar[j] + rtol) / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* lambdaN[j] is increasing */\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero upper bound */\r\n                    t = (cbar[j] - rtol) / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* t is a change of lambdaB[p], on which lambdaN[j] reaches\r\n             its zero bound (possibly relaxed); since the basic solution\r\n             is assumed to be dual feasible, t has to be non-negative by\r\n             definition; however, it may happen that lambdaN[j] slightly\r\n             (i.e. within a tolerance) violates its zero bound, that\r\n             leads to negative t; in the latter case, if xN[j] is chosen,\r\n             negative t means that lambdaB[p] changes in wrong direction\r\n             that may cause wrong results on updating reduced costs;\r\n             thus, if t is negative, we should replace it by exact zero\r\n             assuming that lambdaN[j] is exactly on its zero bound, and\r\n             violation appears due to round-off errors */\r\n            if (t < 0.0) t = 0.0;\r\n            /* apply minimal ratio test */\r\n            if (teta > t || teta == t && big < Math.abs(alfa)){\r\n                q = j; teta = t; big = Math.abs(alfa);\r\n            }\r\n\r\n        }\r\n        /* the second pass is skipped in the following cases: */\r\n        /* if the standard ratio test is used */\r\n        if (rtol == 0.0) return done();\r\n        /* if no non-basic variable has been chosen on the first pass */\r\n        if (q == 0) return done();\r\n        /* if lambdaN[q] prevents lambdaB[p] from any change */\r\n        if (teta == 0.0) return done();\r\n        /*** SECOND PASS ***/\r\n        /* here tmax is a maximal change of lambdaB[p], on which the\r\n         solution remains dual feasible within a tolerance */\r\n        tmax = teta;\r\n        /* nothing is chosen so far */\r\n        q = 0; teta = DBL_MAX; big = 0.0;\r\n        /* walk through significant elements of the pivot row */\r\n        for (pos = 1; pos <= trow_num; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            alfa = s * trow_vec[j];\r\n            if (GLP_DEBUG){xassert(alfa != 0.0)}\r\n            /* lambdaN[j] = ... - alfa * lambdaB[p] - ..., and due to s we\r\n             need to consider only increasing lambdaB[p] */\r\n            if (alfa > 0.0)\r\n            {  /* lambdaN[j] is decreasing */\r\n                if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero lower bound */\r\n                    t = cbar[j] / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no lower bound */\r\n                    continue;\r\n                }\r\n            }\r\n            else\r\n            {  /* lambdaN[j] is increasing */\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                {  /* lambdaN[j] has zero upper bound */\r\n                    t = cbar[j] / alfa;\r\n                }\r\n                else\r\n                {  /* lambdaN[j] has no upper bound */\r\n                    continue;\r\n                }\r\n            }\r\n            /* (see comments for the first pass) */\r\n            if (t < 0.0) t = 0.0;\r\n            /* t is a change of lambdaB[p], on which lambdaN[j] reaches\r\n             its zero (lower or upper) bound; if t <= tmax, all reduced\r\n             costs can violate their zero bounds only within relaxation\r\n             tolerance rtol, so we can choose non-basic variable having\r\n             largest influence coefficient to avoid possible numerical\r\n             instability */\r\n            if (t <= tmax && big < Math.abs(alfa)){\r\n                q = j; teta = t; big = Math.abs(alfa);\r\n            }\r\n        }\r\n        /* something must be chosen on the second pass */\r\n        xassert(q != 0);\r\n\r\n        function done(){\r\n            /* store the index of non-basic variable xN[q] chosen */\r\n            csa.q = q;\r\n            /* store reduced cost of xN[q] in the adjacent basis */\r\n            csa.new_dq = s * teta;\r\n        }\r\n        done();\r\n    }\r\n\r\n    function eval_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.tcol_vec;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* solve system B * tcol = h */\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function refine_tcol(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var head = csa.head;\r\n        var q = csa.q;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var h = csa.work3;\r\n        var i, k, nnz;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        k = head[m+q]; /* x[k] = xN[q] */\r\n        if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n        /* construct the right-hand side vector h = - N[q] */\r\n        for (i = 1; i <= m; i++)\r\n            h[i] = 0.0;\r\n        if (k <= m)\r\n        {  /* N[q] is k-th column of submatrix I */\r\n            h[k] = -1.0;\r\n        }\r\n        else\r\n        {  /* N[q] is (k-m)-th column of submatrix (-A) */\r\n            var A_ptr = csa.A_ptr;\r\n            var A_ind = csa.A_ind;\r\n            var A_val = csa.A_val;\r\n            var beg, end, ptr;\r\n            beg = A_ptr[k-m];\r\n            end = A_ptr[k-m+1];\r\n            for (ptr = beg; ptr < end; ptr++)\r\n                h[A_ind[ptr]] = A_val[ptr];\r\n        }\r\n        /* refine solution of B * tcol = h */\r\n        refine_ftran(csa, h, tcol_vec);\r\n        /* construct sparse pattern of the pivot column */\r\n        nnz = 0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (tcol_vec[i] != 0.0)\r\n            tcol_ind[++nnz] = i;\r\n        }\r\n        csa.tcol_nnz = nnz;\r\n    }\r\n\r\n    function update_cbar(csa){\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var cbar = csa.cbar;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var q = csa.q;\r\n        var new_dq = csa.new_dq;\r\n        var j, pos;\r\n        if (GLP_DEBUG){xassert(1 <= q && q <= n)}\r\n        /* set new reduced cost of xN[q] */\r\n        cbar[q] = new_dq;\r\n        /* update reduced costs of other non-basic variables */\r\n        if (new_dq == 0.0) return;\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {  j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            if (j != q)\r\n                cbar[j] -= trow_vec[j] * new_dq;\r\n        }\r\n    }\r\n\r\n    function update_bbar(csa){\r\n        if (GLP_DEBUG){\r\n            var m = csa.m;\r\n            var n = csa.n;\r\n        }\r\n        var bbar = csa.bbar;\r\n        var p = csa.p;\r\n        var delta = csa.delta;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var i, pos;\r\n        var teta;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n            /* determine the change of xN[q] in the adjacent basis */\r\n            xassert(tcol_vec[p] != 0.0);\r\n        }\r\n        teta = delta / tcol_vec[p];\r\n        /* set new primal value of xN[q] */\r\n        bbar[p] = get_xN(csa, q) + teta;\r\n        /* update primal values of other basic variables */\r\n        if (teta == 0.0) return;\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {  i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            if (i != p)\r\n                bbar[i] += tcol_vec[i] * teta;\r\n        }\r\n    }\r\n\r\n    function update_gamma(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var refsp = csa.refsp;\r\n        var gamma = csa.gamma;\r\n        var p = csa.p;\r\n        var trow_nnz = csa.trow_nnz;\r\n        var trow_ind = csa.trow_ind;\r\n        var trow_vec = csa.trow_vec;\r\n        var q = csa.q;\r\n        var tcol_nnz = csa.tcol_nnz;\r\n        var tcol_ind = csa.tcol_ind;\r\n        var tcol_vec = csa.tcol_vec;\r\n        var u = csa.work3;\r\n        var i, j, k,pos;\r\n        var gamma_p, eta_p, pivot, t, t1, t2;\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* the basis changes, so decrease the count */\r\n        xassert(csa.refct > 0);\r\n        csa.refct--;\r\n        /* recompute gamma[p] for the current basis more accurately and\r\n         compute auxiliary vector u */\r\n        if (GLP_DEBUG){xassert(type[head[p]] != GLP_FR)}\r\n        gamma_p = eta_p = (refsp[head[p]] ? 1.0 : 0.0);\r\n        for (i = 1; i <= m; i++) u[i] = 0.0;\r\n        for (pos = 1; pos <= trow_nnz; pos++)\r\n        {   j = trow_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= j && j <= n)}\r\n            k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG){\r\n                xassert(1 <= k && k <= m+n);\r\n                xassert(type[k] != GLP_FX);\r\n            }\r\n            if (!refsp[k]) continue;\r\n            t = trow_vec[j];\r\n            gamma_p += t * t;\r\n            /* u := u + N[j] * delta[j] * trow[j] */\r\n            if (k <= m)\r\n            {  /* N[k] = k-j stolbec submatrix I */\r\n                u[k] += t;\r\n            }\r\n            else\r\n            {  /* N[k] = k-m-k stolbec (-A) */\r\n                var A_ptr = csa.A_ptr;\r\n                var A_ind = csa.A_ind;\r\n                var A_val = csa.A_val;\r\n                var beg, end, ptr;\r\n                beg = A_ptr[k-m];\r\n                end = A_ptr[k-m+1];\r\n                for (ptr = beg; ptr < end; ptr++)\r\n                    u[A_ind[ptr]] -= t * A_val[ptr];\r\n            }\r\n        }\r\n        xassert(csa.valid);\r\n        bfd_ftran(csa.bfd, u);\r\n        /* update gamma[i] for other basic variables (except xB[p] and\r\n         free variables) */\r\n        pivot = tcol_vec[p];\r\n        if (GLP_DEBUG){xassert(pivot != 0.0)}\r\n        for (pos = 1; pos <= tcol_nnz; pos++)\r\n        {   i = tcol_ind[pos];\r\n            if (GLP_DEBUG){xassert(1 <= i && i <= m)}\r\n            k = head[i];\r\n            if (GLP_DEBUG){xassert(1 <= k && k <= m+n)}\r\n            /* skip xB[p] */\r\n            if (i == p) continue;\r\n            /* skip free basic variable */\r\n            if (type[head[i]] == GLP_FR)\r\n            {\r\n                if (GLP_DEBUG){xassert(gamma[i] == 1.0)}\r\n                continue;\r\n            }\r\n            /* compute gamma[i] for the adjacent basis */\r\n            t = tcol_vec[i] / pivot;\r\n            t1 = gamma[i] + t * t * gamma_p + 2.0 * t * u[i];\r\n            t2 = (refsp[k] ? 1.0 : 0.0) + eta_p * t * t;\r\n            gamma[i] = (t1 >= t2 ? t1 : t2);\r\n            /* (though gamma[i] can be exact zero, because the reference\r\n             space does not include non-basic fixed variables) */\r\n            if (gamma[i] < DBL_EPSILON) gamma[i] = DBL_EPSILON;\r\n        }\r\n        /* compute gamma[p] for the adjacent basis */\r\n        if (type[head[m+q]] == GLP_FR)\r\n            gamma[p] = 1.0;\r\n        else\r\n        {  gamma[p] = gamma_p / (pivot * pivot);\r\n            if (gamma[p] < DBL_EPSILON) gamma[p] = DBL_EPSILON;\r\n        }\r\n        /* if xB[p], which becomes xN[q] in the adjacent basis, is fixed\r\n         and belongs to the reference space, remove it from there, and\r\n         change all gamma's appropriately */\r\n        k = head[p];\r\n        if (type[k] == GLP_FX && refsp[k])\r\n        {  refsp[k] = 0;\r\n            for (pos = 1; pos <= tcol_nnz; pos++)\r\n            {  i = tcol_ind[pos];\r\n                if (i == p)\r\n                {  if (type[head[m+q]] == GLP_FR) continue;\r\n                    t = 1.0 / tcol_vec[p];\r\n                }\r\n                else\r\n                {  if (type[head[i]] == GLP_FR) continue;\r\n                    t = tcol_vec[i] / tcol_vec[p];\r\n                }\r\n                gamma[i] -= t * t;\r\n                if (gamma[i] < DBL_EPSILON) gamma[i] = DBL_EPSILON;\r\n            }\r\n        }\r\n    }\r\n\r\n    function err_in_bbar(csa){\r\n        var m = csa.m;\r\n        var bbar = csa.bbar;\r\n        var i;\r\n        var e, emax;\r\n        var beta = new Float64Array(1+m);\r\n        eval_beta(csa, beta);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  e = Math.abs(beta[i] - bbar[i]) / (1.0 + Math.abs(beta[i]));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    /***********************************************************************\r\n     *  err_in_cbar - compute maximal relative error in dual solution\r\n     *\r\n     *  This routine returns maximal relative error:\r\n     *\r\n     *     max |cost[j] - cbar[j]| / (1 + |cost[j]|),\r\n     *\r\n     *  where cost and cbar are, respectively, directly computed and the\r\n     *  current (updated) reduced costs of non-basic non-fixed variables.\r\n     *\r\n     *  NOTE: The routine is intended only for debugginig purposes. */\r\n\r\n    function err_in_cbar(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        var e, emax, cost;\r\n        var pi = new Float64Array(1+m);\r\n        eval_pi(csa, pi);\r\n        emax = 0.0;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (stat[j] == GLP_NS) continue;\r\n            cost = eval_cost(csa, pi, j);\r\n            e = Math.abs(cost - cbar[j]) / (1.0 + Math.abs(cost));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function err_in_gamma(csa){\r\n        var m = csa.m;\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var gamma = csa.gamma;\r\n        var exact = csa.work4;\r\n        var i;\r\n        var e, emax, temp;\r\n        eval_gamma(csa, exact);\r\n        emax = 0.0;\r\n        for (i = 1; i <= m; i++)\r\n        {  if (type[head[i]] == GLP_FR)\r\n        {  xassert(gamma[i] == 1.0);\r\n            xassert(exact[i] == 1.0);\r\n            continue;\r\n        }\r\n            temp = exact[i];\r\n            e = Math.abs(temp - gamma[i]) / (1.0 + Math.abs(temp));\r\n            if (emax < e) emax = e;\r\n        }\r\n        return emax;\r\n    }\r\n\r\n    function change_basis(csa){\r\n        var m = csa.m;\r\n        if (GLP_DEBUG){var n = csa.n}\r\n        var type = csa.type;\r\n        var head = csa.head;\r\n        var bind = csa.bind;\r\n        var stat = csa.stat;\r\n        var p = csa.p;\r\n        var delta = csa.delta;\r\n        var q = csa.q;\r\n        var k;\r\n        /* xB[p] leaves the basis, xN[q] enters the basis */\r\n        if (GLP_DEBUG){\r\n            xassert(1 <= p && p <= m);\r\n            xassert(1 <= q && q <= n);\r\n        }\r\n        /* xB[p] <. xN[q] */\r\n        k = head[p]; head[p] = head[m+q]; head[m+q] = k;\r\n        bind[head[p]] = p; bind[head[m+q]] = m + q;\r\n        if (type[k] == GLP_FX)\r\n            stat[q] = GLP_NS;\r\n        else if (delta > 0.0)\r\n        {\r\n            if (GLP_DEBUG){\r\n                xassert(type[k] == GLP_LO || type[k] == GLP_DB)\r\n            }\r\n\r\n            stat[q] = GLP_NL;\r\n        }\r\n        else /* delta < 0.0 */\r\n        {\r\n            if (GLP_DEBUG)\r\n                xassert(type[k] == GLP_UP || type[k] == GLP_DB);\r\n            stat[q] = GLP_NU;\r\n        }\r\n    }\r\n\r\n    function check_feas(csa, tol_dj){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (cbar[j] < - tol_dj)\r\n                if (orig_type[k] == GLP_LO || orig_type[k] == GLP_FR)\r\n                    return 1;\r\n            if (cbar[j] > + tol_dj)\r\n                if (orig_type[k] == GLP_UP || orig_type[k] == GLP_FR)\r\n                    return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function set_aux_bnds(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        for (k = 1; k <= m+n; k++)\r\n        {  switch (orig_type[k])\r\n        {  case GLP_FR:\r\n                /* to force free variables to enter the basis */\r\n                type[k] = GLP_DB; lb[k] = -1e3; ub[k] = +1e3;\r\n                break;\r\n            case GLP_LO:\r\n                type[k] = GLP_DB; lb[k] = 0.0; ub[k] = +1.0;\r\n                break;\r\n            case GLP_UP:\r\n                type[k] = GLP_DB; lb[k] = -1.0; ub[k] = 0.0;\r\n                break;\r\n            case GLP_DB:\r\n            case GLP_FX:\r\n                type[k] = GLP_FX; lb[k] = ub[k] = 0.0;\r\n                break;\r\n            default:\r\n                xassert(orig_type != orig_type);\r\n        }\r\n        }\r\n        for (j = 1; j <= n; j++)\r\n        {   k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (type[k] == GLP_FX)\r\n                stat[j] = GLP_NS;\r\n            else if (cbar[j] >= 0.0)\r\n                stat[j] = GLP_NL;\r\n            else\r\n                stat[j] = GLP_NU;\r\n        }\r\n    }\r\n\r\n    function set_orig_bnds(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var type = csa.type;\r\n        var lb = csa.lb;\r\n        var ub = csa.ub;\r\n        var orig_type = csa.orig_type;\r\n        var orig_lb = csa.orig_lb;\r\n        var orig_ub = csa.orig_ub;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j, k;\r\n        xcopyArr(type, 1, orig_type, 1, m+n);\r\n        xcopyArr(lb, 1, orig_lb, 1, m+n);\r\n        xcopyArr(ub, 1, orig_ub, 1, m+n);\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            switch (type[k])\r\n            {  case GLP_FR:\r\n                stat[j] = GLP_NF;\r\n                break;\r\n                case GLP_LO:\r\n                    stat[j] = GLP_NL;\r\n                    break;\r\n                case GLP_UP:\r\n                    stat[j] = GLP_NU;\r\n                    break;\r\n                case GLP_DB:\r\n                    if (cbar[j] >= +DBL_EPSILON)\r\n                        stat[j] = GLP_NL;\r\n                    else if (cbar[j] <= -DBL_EPSILON)\r\n                        stat[j] = GLP_NU;\r\n                    else if (Math.abs(lb[k]) <= Math.abs(ub[k]))\r\n                        stat[j] = GLP_NL;\r\n                    else\r\n                        stat[j] = GLP_NU;\r\n                    break;\r\n                case GLP_FX:\r\n                    stat[j] = GLP_NS;\r\n                    break;\r\n                default:\r\n                    xassert(type != type);\r\n            }\r\n        }\r\n    }\r\n\r\n    function check_stab(csa, tol_dj){\r\n        var n = csa.n;\r\n        var stat = csa.stat;\r\n        var cbar = csa.cbar;\r\n        var j;\r\n        for (j = 1; j <= n; j++)\r\n        {  if (cbar[j] < - tol_dj)\r\n            if (stat[j] == GLP_NL || stat[j] == GLP_NF) return 1;\r\n            if (cbar[j] > + tol_dj)\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF) return 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function eval_obj(csa){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var obj = csa.obj;\r\n        var head = csa.head;\r\n        var bbar = csa.bbar;\r\n        var i, j, k;\r\n        var sum;\r\n        sum = obj[0];\r\n        /* walk through the list of basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k > m)\r\n                sum += obj[k-m] * bbar[i];\r\n        }\r\n        /* walk through the list of non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k > m)\r\n                sum += obj[k-m] * get_xN(csa, j);\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function display(csa, parm, spec){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var coef = csa.coef;\r\n        var orig_type = csa.orig_type;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var phase = csa.phase;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, cnt;\r\n        var sum;\r\n        if (parm.msg_lev < GLP_MSG_ON) return;\r\n        if (parm.out_dly > 0 &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) < parm.out_dly)\r\n            return;\r\n        if (csa.it_cnt == csa.it_dpy) return;\r\n        if (!spec && csa.it_cnt % parm.out_frq != 0) return;\r\n        /* compute the sum of dual infeasibilities */\r\n        sum = 0.0;\r\n        if (phase == 1)\r\n        {  for (i = 1; i <= m; i++)\r\n            sum -= coef[head[i]] * bbar[i];\r\n            for (j = 1; j <= n; j++)\r\n                sum -= coef[head[m+j]] * get_xN(csa, j);\r\n        }\r\n        else\r\n        {  for (j = 1; j <= n; j++)\r\n        {  if (cbar[j] < 0.0)\r\n            if (stat[j] == GLP_NL || stat[j] == GLP_NF)\r\n                sum -= cbar[j];\r\n            if (cbar[j] > 0.0)\r\n                if (stat[j] == GLP_NU || stat[j] == GLP_NF)\r\n                    sum += cbar[j];\r\n        }\r\n        }\r\n        /* determine the number of basic fixed variables */\r\n        cnt = 0;\r\n        for (i = 1; i <= m; i++)\r\n            if (orig_type[head[i]] == GLP_FX) cnt++;\r\n        if (csa.phase == 1)\r\n            xprintf(\" \" + csa.it_cnt + \":  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        else\r\n            xprintf(\"|\" + csa.it_cnt + \": obj = \" + eval_obj(csa) + \"  infeas = \" + sum + \" (\" + cnt + \")\");\r\n        csa.it_dpy = csa.it_cnt;\r\n    }\r\n\r\n    function store_sol(csa, lp, p_stat, d_stat, ray){\r\n        var m = csa.m;\r\n        var n = csa.n;\r\n        var zeta = csa.zeta;\r\n        var head = csa.head;\r\n        var stat = csa.stat;\r\n        var bbar = csa.bbar;\r\n        var cbar = csa.cbar;\r\n        var i, j, k;\r\n        var col, row;\r\n        if (GLP_DEBUG){\r\n            xassert(lp.m == m);\r\n            xassert(lp.n == n);\r\n            /* basis factorization */\r\n            xassert(!lp.valid && lp.bfd == null);\r\n            xassert(csa.valid && csa.bfd != null);\r\n        }\r\n        lp.valid = 1; csa.valid = 0;\r\n        lp.bfd = csa.bfd; csa.bfd = null;\r\n        xcopyArr(lp.head, 1, head, 1, m);\r\n        /* basic solution status */\r\n        lp.pbs_stat = p_stat;\r\n        lp.dbs_stat = d_stat;\r\n        /* objective function value */\r\n        lp.obj_val = eval_obj(csa);\r\n        /* simplex iteration count */\r\n        lp.it_cnt = csa.it_cnt;\r\n        /* unbounded ray */\r\n        lp.some = ray;\r\n        /* basic variables */\r\n        for (i = 1; i <= m; i++)\r\n        {  k = head[i]; /* x[k] = xB[i] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = GLP_BS;\r\n                row.bind = i;\r\n                row.prim = bbar[i] / row.rii;\r\n                row.dual = 0.0;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = GLP_BS;\r\n                col.bind = i;\r\n                col.prim = bbar[i] * col.sjj;\r\n                col.dual = 0.0;\r\n            }\r\n        }\r\n        /* non-basic variables */\r\n        for (j = 1; j <= n; j++)\r\n        {  k = head[m+j]; /* x[k] = xN[j] */\r\n            if (GLP_DEBUG)\r\n                xassert(1 <= k && k <= m+n);\r\n            if (k <= m)\r\n            {   row = lp.row[k];\r\n                row.stat = stat[j];\r\n                row.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    row.prim = row.lb; break;\r\n                    case GLP_NU:\r\n                        row.prim = row.ub; break;\r\n                    case GLP_NF:\r\n                        row.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        row.prim = row.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                row.dual = (cbar[j] * row.rii) / zeta;\r\n            }\r\n            else\r\n            {   col = lp.col[k-m];\r\n                col.stat = stat[j];\r\n                col.bind = 0;\r\n                switch (stat[j])\r\n                {  case GLP_NL:\r\n                    col.prim = col.lb; break;\r\n                    case GLP_NU:\r\n                        col.prim = col.ub; break;\r\n                    case GLP_NF:\r\n                        col.prim = 0.0; break;\r\n                    case GLP_NS:\r\n                        col.prim = col.lb; break;\r\n                    default:\r\n                        xassert(stat != stat);\r\n                }\r\n                col.dual = (cbar[j] / col.sjj) / zeta;\r\n            }\r\n        }\r\n    }\r\n\r\n    var csa;\r\n    var binv_st = 2;\r\n    /* status of basis matrix factorization:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var bbar_st = 0;\r\n    /* status of primal values of basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var cbar_st = 0;\r\n    /* status of reduced costs of non-basic variables:\r\n     0 - invalid; 1 - just computed; 2 - updated */\r\n    var rigorous = 0;\r\n    /* rigorous mode flag; this flag is used to enable iterative\r\n     refinement on computing pivot rows and columns of the simplex\r\n     table */\r\n    var check = 0;\r\n    var p_stat, d_stat, ret;\r\n    /* allocate and initialize the common storage area */\r\n    csa = alloc_csa(lp);\r\n    init_csa(csa, lp);\r\n    if (parm.msg_lev >= GLP_MSG_DBG)\r\n        xprintf(\"Objective scale factor = \" + csa.zeta + \"\");\r\n\r\n    while (true){\r\n        /* main loop starts here */\r\n        /* compute factorization of the basis matrix */\r\n        if (binv_st == 0)\r\n        {  ret = invert_B(csa);\r\n            if (ret != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n            {  xprintf(\"Error: unable to factorize the basis matrix (\" + ret + \")\");\r\n                xprintf(\"Sorry, basis recovery procedure not implemented yet\");\r\n            }\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                return ret;\r\n            }\r\n            csa.valid = 1;\r\n            binv_st = 1; /* just computed */\r\n            /* invalidate basic solution components */\r\n            bbar_st = cbar_st = 0;\r\n        }\r\n        /* compute reduced costs of non-basic variables */\r\n        if (cbar_st == 0)\r\n        {  eval_cbar(csa);\r\n            cbar_st = 1; /* just computed */\r\n            /* determine the search phase, if not determined yet */\r\n            if (csa.phase == 0)\r\n            {  if (check_feas(csa, 0.90 * parm.tol_dj) != 0)\r\n            {  /* current basic solution is dual infeasible */\r\n                /* start searching for dual feasible solution */\r\n                csa.phase = 1;\r\n                set_aux_bnds(csa);\r\n            }\r\n            else\r\n            {  /* current basic solution is dual feasible */\r\n                /* start searching for optimal solution */\r\n                csa.phase = 2;\r\n                set_orig_bnds(csa);\r\n            }\r\n                xassert(check_stab(csa, parm.tol_dj) == 0);\r\n                /* some non-basic double-bounded variables might become\r\n                 fixed (on phase I) or vice versa (on phase II) */\r\n                csa.refct = 0;\r\n                /* bounds of non-basic variables have been changed, so\r\n                 invalidate primal values */\r\n                bbar_st = 0;\r\n            }\r\n            /* make sure that the current basic solution remains dual\r\n             feasible */\r\n            if (check_stab(csa, parm.tol_dj) != 0)\r\n            {  if (parm.msg_lev >= GLP_MSG_ERR)\r\n                xprintf(\"Warning: numerical instability (dual simplex, phase \" + (csa.phase == 1 ? \"I\" : \"II\") + \")\");\r\n                if (parm.meth == GLP_DUALP)\r\n                {  store_sol(csa, lp, GLP_UNDEF, GLP_UNDEF, 0);\r\n                    ret = GLP_EFAIL;\r\n                    return ret;\r\n                }\r\n                /* restart the search */\r\n                csa.phase = 0;\r\n                binv_st = 0;\r\n                rigorous = 5;\r\n                continue;\r\n            }\r\n        }\r\n        xassert(csa.phase == 1 || csa.phase == 2);\r\n        /* on phase I we do not need to wait until the current basic\r\n         solution becomes primal feasible; it is sufficient to make\r\n         sure that all reduced costs have correct signs */\r\n        if (csa.phase == 1 && check_feas(csa, parm.tol_dj) == 0)\r\n        {  /* the current basis is dual feasible; switch to phase II */\r\n            display(csa, parm, 1);\r\n            csa.phase = 2;\r\n            if (cbar_st != 1)\r\n            {  eval_cbar(csa);\r\n                cbar_st = 1;\r\n            }\r\n            set_orig_bnds(csa);\r\n            csa.refct = 0;\r\n            bbar_st = 0;\r\n        }\r\n        /* compute primal values of basic variables */\r\n        if (bbar_st == 0)\r\n        {  eval_bbar(csa);\r\n            if (csa.phase == 2)\r\n                csa.bbar[0] = eval_obj(csa);\r\n            bbar_st = 1; /* just computed */\r\n        }\r\n        /* redefine the reference space, if required */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct == 0) reset_refsp(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* at this point the basis factorization and all basic solution\r\n         components are valid */\r\n        xassert(binv_st && bbar_st && cbar_st);\r\n        /* check accuracy of current basic solution components (only for\r\n         debugging) */\r\n        if (check)\r\n        {  var e_bbar = err_in_bbar(csa);\r\n            var e_cbar = err_in_cbar(csa);\r\n            var e_gamma =\r\n                (parm.pricing == GLP_PT_PSE ? err_in_gamma(csa) : 0.0);\r\n            xprintf(\"e_bbar = \" + e_bbar + \"; e_cbar = \" + e_cbar + \"; e_gamma = \" + e_gamma + \"\");\r\n            xassert(e_bbar <= 1e-5 && e_cbar <= 1e-5 && e_gamma <= 1e-3);\r\n        }\r\n        /* if the objective has to be maximized, check if it has reached\r\n         its lower limit */\r\n        if (csa.phase == 2 && csa.zeta < 0.0 &&\r\n            parm.obj_ll > -DBL_MAX && csa.bbar[0] <= parm.obj_ll)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OBJECTIVE LOWER LIMIT REACHED; SEARCH TERMINATED\"\r\n                );\r\n            store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);\r\n            ret = GLP_EOBJLL;\r\n            return ret;\r\n        }\r\n        /* if the objective has to be minimized, check if it has reached\r\n         its upper limit */\r\n        if (csa.phase == 2 && csa.zeta > 0.0 &&\r\n            parm.obj_ul < +DBL_MAX && csa.bbar[0] >= parm.obj_ul)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"OBJECTIVE UPPER LIMIT REACHED; SEARCH TERMINATED\"\r\n                );\r\n            store_sol(csa, lp, GLP_INFEAS, GLP_FEAS, 0);\r\n            ret = GLP_EOBJUL;\r\n            return ret;\r\n        }\r\n        /* check if the iteration limit has been exhausted */\r\n        if (parm.it_lim < INT_MAX &&\r\n            csa.it_cnt - csa.it_beg >= parm.it_lim)\r\n        {  if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1)\r\n        {  if (csa.phase == 2 && bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"ITERATION LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                d_stat = GLP_INFEAS;\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                break;\r\n                case 2:\r\n                    d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, GLP_INFEAS, d_stat, 0);\r\n            ret = GLP_EITLIM;\r\n            return ret;\r\n        }\r\n        /* check if the time limit has been exhausted */\r\n        if (parm.tm_lim < INT_MAX &&\r\n            1000.0 * xdifftime(xtime(), csa.tm_beg) >= parm.tm_lim)\r\n        {  if (csa.phase == 2 && bbar_st != 1 || cbar_st != 1)\r\n        {  if (csa.phase == 2 && bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            if (parm.msg_lev >= GLP_MSG_ALL)\r\n                xprintf(\"TIME LIMIT EXCEEDED; SEARCH TERMINATED\");\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                d_stat = GLP_INFEAS;\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                break;\r\n                case 2:\r\n                    d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, GLP_INFEAS, d_stat, 0);\r\n            ret = GLP_ETMLIM;\r\n            return ret;\r\n        }\r\n        /* display the search progress */\r\n        display(csa, parm, 0);\r\n        /* choose basic variable xB[p] */\r\n        chuzr(csa, parm.tol_bnd);\r\n        if (csa.p == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ALL)\r\n                    xprintf(\"PROBLEM HAS NO DUAL FEASIBLE SOLUTION\");\r\n                set_orig_bnds(csa);\r\n                eval_bbar(csa);\r\n                p_stat = GLP_INFEAS; d_stat = GLP_NOFEAS;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"OPTIMAL SOLUTION FOUND\");\r\n                    p_stat = d_stat = GLP_FEAS;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            store_sol(csa, lp, p_stat, d_stat, 0);\r\n            ret = 0;\r\n            return ret;\r\n        }\r\n        /* compute pivot row of the simplex table */\r\n        {  var rho = csa.work4;\r\n            eval_rho(csa, rho);\r\n            if (rigorous) refine_rho(csa, rho);\r\n            eval_trow(csa, rho);\r\n            sort_trow(csa, parm.tol_bnd);\r\n        }\r\n        /* choose non-basic variable xN[q] */\r\n        switch (parm.r_test)\r\n        {  case GLP_RT_STD:\r\n            chuzc(csa, 0.0);\r\n            break;\r\n            case GLP_RT_HAR:\r\n                chuzc(csa, 0.30 * parm.tol_dj);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        if (csa.q == 0)\r\n        {  if (bbar_st != 1 || cbar_st != 1 || !rigorous)\r\n        {  if (bbar_st != 1) bbar_st = 0;\r\n            if (cbar_st != 1) cbar_st = 0;\r\n            rigorous = 1;\r\n            continue;\r\n        }\r\n            display(csa, parm, 1);\r\n            switch (csa.phase)\r\n            {  case 1:\r\n                if (parm.msg_lev >= GLP_MSG_ERR)\r\n                    xprintf(\"Error: unable to choose basic variable on phase I\");\r\n                xassert(!lp.valid && lp.bfd == null);\r\n                lp.bfd = csa.bfd; csa.bfd = null;\r\n                lp.pbs_stat = lp.dbs_stat = GLP_UNDEF;\r\n                lp.obj_val = 0.0;\r\n                lp.it_cnt = csa.it_cnt;\r\n                lp.some = 0;\r\n                ret = GLP_EFAIL;\r\n                break;\r\n                case 2:\r\n                    if (parm.msg_lev >= GLP_MSG_ALL)\r\n                        xprintf(\"PROBLEM HAS NO FEASIBLE SOLUTION\");\r\n                    store_sol(csa, lp, GLP_NOFEAS, GLP_FEAS,\r\n                        csa.head[csa.p]);\r\n                    ret = 0;\r\n                    break;\r\n                default:\r\n                    xassert(csa != csa);\r\n            }\r\n            return ret;\r\n        }\r\n        /* check if the pivot element is acceptable */\r\n        {  var piv = csa.trow_vec[csa.q];\r\n            var eps = 1e-5 * (1.0 + 0.01 * csa.trow_max);\r\n            if (Math.abs(piv) < eps)\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv = \" + piv + \"; eps = \" + eps + \"\");\r\n                if (!rigorous)\r\n                {  rigorous = 5;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        /* now xN[q] and xB[p] have been chosen anyhow */\r\n        /* compute pivot column of the simplex table */\r\n        eval_tcol(csa);\r\n        if (rigorous) refine_tcol(csa);\r\n        /* accuracy check based on the pivot element */\r\n        {  var piv1 = csa.tcol_vec[csa.p]; /* more accurate */\r\n            var piv2 = csa.trow_vec[csa.q]; /* less accurate */\r\n            xassert(piv1 != 0.0);\r\n            if (Math.abs(piv1 - piv2) > 1e-8 * (1.0 + Math.abs(piv1)) ||\r\n                !(piv1 > 0.0 && piv2 > 0.0 || piv1 < 0.0 && piv2 < 0.0))\r\n            {  if (parm.msg_lev >= GLP_MSG_DBG)\r\n                xprintf(\"piv1 = \" + piv1 + \"; piv2 = \" + piv2 + \"\");\r\n                if (binv_st != 1 || !rigorous)\r\n                {  if (binv_st != 1) binv_st = 0;\r\n                    rigorous = 5;\r\n                    continue;\r\n                }\r\n                /* (not a good idea; should be revised later) */\r\n                if (csa.tcol_vec[csa.p] == 0.0)\r\n                {  csa.tcol_nnz++;\r\n                    xassert(csa.tcol_nnz <= csa.m);\r\n                    csa.tcol_ind[csa.tcol_nnz] = csa.p;\r\n                }\r\n                csa.tcol_vec[csa.p] = piv2;\r\n            }\r\n        }\r\n        /* update primal values of basic variables */\r\n        update_bbar(csa);\r\n        if (csa.phase == 2)\r\n            csa.bbar[0] += (csa.cbar[csa.q] / csa.zeta) *\r\n                (csa.delta / csa.tcol_vec[csa.p]);\r\n        bbar_st = 2; /* updated */\r\n        /* update reduced costs of non-basic variables */\r\n        update_cbar(csa);\r\n        cbar_st = 2; /* updated */\r\n        /* update steepest edge coefficients */\r\n        switch (parm.pricing)\r\n        {  case GLP_PT_STD:\r\n            break;\r\n            case GLP_PT_PSE:\r\n                if (csa.refct > 0) update_gamma(csa);\r\n                break;\r\n            default:\r\n                xassert(parm != parm);\r\n        }\r\n        /* update factorization of the basis matrix */\r\n        ret = update_B(csa, csa.p, csa.head[csa.m+csa.q]);\r\n        if (ret == 0)\r\n            binv_st = 2; /* updated */\r\n        else\r\n        {  csa.valid = 0;\r\n            binv_st = 0; /* invalid */\r\n        }\r\n        /* change the basis header */\r\n        change_basis(csa);\r\n        /* iteration complete */\r\n        csa.it_cnt++;\r\n        if (rigorous > 0) rigorous--;\r\n    }\r\n}\r\n\r\n}(typeof exports === 'object' && exports || this));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/glpk.js/dist/glpk.js\n// module id = 4\n// module chunks = 0","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime-module.js\n// module id = 5\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof global.process === \"object\" && global.process.domain) {\n      invoke = global.process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}